<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MYND — Your Mind, Visualized</title>
    <meta name="theme-color" content="#0a0a0f">
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* ═══════════════════════════════════════════════════════════
           THEME SYSTEM - 6 Modern Themes
           ═══════════════════════════════════════════════════════════ */
        :root {
            /* Base/Shared Variables */
            --font-display: 'Space Grotesk', sans-serif;
            --font-body: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            
            --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px; 
            --space-5: 20px; --space-6: 24px; --space-7: 32px; --space-8: 40px;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            
            --duration-instant: 100ms;
            --duration-fast: 200ms;
            --duration-normal: 350ms;
            --duration-slow: 500ms;
            --duration-slower: 800ms;
            
            --z-bg: 0;
            --z-canvas: 1;
            --z-ui: 100;
            --z-dropdown: 150;
            --z-overlay: 200;
            --z-spotlight: 250;
            --z-modal: 300;
            --z-toast: 400;
            
            /* Default to Sandstone theme */
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --glass-blur: 20px;
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
            --shadow-glow: 0 0 24px var(--accent-glow);
            
            /* AI/Brainstorm button colors */
            --purple: #8B5CF6;
            --pink: #EC4899;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 1: SANDSTONE - Natural/Professional (Default)
           Inspired by: Milk, Light Stone, Desert Clay, Graphite
           ═══════════════════════════════════════════════════════════ */
        [data-theme="sandstone"] {
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 2: CORAL - Ultra-flat Cartoon/Pastel
           Inspired by: Clean white UI, soft pastels, no shadows
           ═══════════════════════════════════════════════════════════ */
        [data-theme="coral"] {
            --bg-deep: #FAFAFA;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F5F5F5;
            --bg-tertiary: #EEEEEE;
            --bg-elevated: #E8E8E8;
            --text-primary: #1A1A1A;
            --text-secondary: #666666;
            --text-muted: #999999;
            --accent: #E87D7D;
            --accent-light: #F09999;
            --accent-glow: rgba(232, 125, 125, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.04);
            --glass-blur: 0px;
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: none;
            --shadow-md: none;
            --shadow-lg: none;
            --shadow-glow: none;
        }
        
        /* Minimal theme specific - remove all visual noise */
        [data-theme="coral"] .brand,
        [data-theme="coral"] .icon-btn,
        [data-theme="coral"] #side-panel,
        [data-theme="coral"] #info-panel,
        [data-theme="coral"] .modal-content,
        [data-theme="coral"] #theme-picker,
        [data-theme="coral"] #menu-dropdown {
            box-shadow: none !important;
            border: 1px solid #E0E0E0 !important;
        }
        
        [data-theme="coral"] .brand-logo {
            background: var(--accent) !important;
            box-shadow: none !important;
        }
        
        /* Coral theme mobile - ensure all accents are pink */
        @media (max-width: 768px) {
            [data-theme="coral"] .sheet-voice-btn,
            [data-theme="coral"] .chat-voice-btn,
            [data-theme="coral"] .sheet-quick-btn.voice-btn,
            [data-theme="coral"] #sheet-voice-btn,
            [data-theme="coral"] #chat-voice-btn,
            [data-theme="coral"] #sheet-quick-voice {
                background: linear-gradient(135deg, #E87D7D, #F09999) !important;
                border-color: var(--accent) !important;
                color: white !important;
                box-shadow: 0 4px 15px rgba(232, 125, 125, 0.4) !important;
            }
            
            [data-theme="coral"] .sheet-quick-btn.voice-btn.recording {
                box-shadow: 0 4px 20px rgba(232, 125, 125, 0.6) !important;
            }
            
            [data-theme="coral"] .sheet-voice-btn svg,
            [data-theme="coral"] .chat-voice-btn svg,
            [data-theme="coral"] .sheet-quick-btn.voice-btn svg {
                stroke: white !important;
            }
            
            [data-theme="coral"] .chat-input-container,
            [data-theme="coral"] .sheet-input-container,
            [data-theme="coral"] .sheet-text-input {
                border-color: var(--accent) !important;
            }
            
            [data-theme="coral"] .chat-input-container:focus-within,
            [data-theme="coral"] .sheet-text-input:focus {
                border-color: var(--accent) !important;
                box-shadow: 0 0 0 2px rgba(232, 125, 125, 0.2) !important;
            }
            
            [data-theme="coral"] .sheet-send-btn:not(:disabled),
            [data-theme="coral"] .chat-send-btn:not(:disabled) {
                background: var(--accent) !important;
                color: white !important;
            }
            
            [data-theme="coral"] .mobile-pill-user {
                background: var(--accent) !important;
            }
            
            [data-theme="coral"] .mobile-header-menu,
            [data-theme="coral"] .mobile-header-pill {
                border-color: rgba(232, 125, 125, 0.3) !important;
            }
            
            [data-theme="coral"] #mobile-bottom-sheet {
                border-color: rgba(232, 125, 125, 0.2) !important;
            }
            
            [data-theme="coral"] .sheet-map-toggle.active {
                background: var(--accent) !important;
                border-color: var(--accent) !important;
            }
            
            /* Teal chat button should also be pink in Coral */
            [data-theme="coral"] .sheet-quick-btn.teal,
            [data-theme="coral"] .sheet-quick-btn.teal svg {
                color: var(--accent) !important;
                stroke: var(--accent) !important;
            }
            
            /* Orange memo button should be pink in Coral */
            [data-theme="coral"] .sheet-quick-btn.orange,
            [data-theme="coral"] .sheet-quick-btn.orange svg {
                color: var(--accent) !important;
                stroke: var(--accent) !important;
            }
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 3: EMBER - Warm Light
           Inspired by: Burnt orange to cream gradient on warm white
           ═══════════════════════════════════════════════════════════ */
        [data-theme="ember"] {
            --bg-deep: #FAF6F0;
            --bg-primary: #FDF9F4;
            --bg-secondary: #F5F0E8;
            --bg-tertiary: #EDE6DC;
            --bg-elevated: #E5DCD0;
            --text-primary: #2A2420;
            --text-secondary: #5A5048;
            --text-muted: #8A8078;
            --accent: #E87830;
            --accent-light: #F49848;
            --accent-glow: rgba(232, 120, 48, 0.3);
            --glass-bg: rgba(253, 249, 244, 0.95);
            --glass-border: rgba(42, 36, 32, 0.08);
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: 0 2px 8px rgba(42, 36, 32, 0.06);
            --shadow-md: 0 4px 20px rgba(42, 36, 32, 0.08);
            --shadow-lg: 0 8px 40px rgba(42, 36, 32, 0.1);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 4: FROST - Glassmorphism Light
           Inspired by: Frosted glass panels, soft backgrounds
           ═══════════════════════════════════════════════════════════ */
        [data-theme="frost"] {
            --bg-deep: #E8ECF0;
            --bg-primary: #F0F4F8;
            --bg-secondary: #E4E8EC;
            --bg-tertiary: #D8DDE4;
            --bg-elevated: #CCD4DC;
            --text-primary: #1A2030;
            --text-secondary: #4A5568;
            --text-muted: #718096;
            --accent: #5B8DEF;
            --accent-light: #7DA8F5;
            --accent-glow: rgba(91, 141, 239, 0.3);
            --glass-bg: rgba(255, 255, 255, 0.6);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-blur: 24px;
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.08);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.1);
        }
        
        /* Frost theme glassmorphism enhancements */
        [data-theme="frost"] .brand,
        [data-theme="frost"] .icon-btn,
        [data-theme="frost"] #side-panel,
        [data-theme="frost"] #info-panel,
        [data-theme="frost"] .modal-content,
        [data-theme="frost"] #theme-picker,
        [data-theme="frost"] #menu-dropdown,
        [data-theme="frost"] .spotlight-container,
        [data-theme="frost"] #quick-capture {
            background: rgba(255, 255, 255, 0.55) !important;
            backdrop-filter: blur(24px) saturate(180%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(180%) !important;
            border: 1px solid rgba(255, 255, 255, 0.5) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 5: OBSIDIAN - Glassmorphism Dark
           Inspired by: Dark translucent panels, deep purple accents
           ═══════════════════════════════════════════════════════════ */
        [data-theme="obsidian"] {
            --bg-deep: #0A0A0C;
            --bg-primary: #101014;
            --bg-secondary: #18181C;
            --bg-tertiary: #222228;
            --bg-elevated: #2C2C34;
            --text-primary: #F0F2F5;
            --text-secondary: #A0A8B8;
            --text-muted: #687080;
            --accent: #8B5CF6;
            --accent-light: #A78BFA;
            --accent-glow: rgba(139, 92, 246, 0.35);
            --glass-bg: rgba(16, 16, 20, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-blur: 24px;
            --nebula-1: rgba(139, 92, 246, 0.08);
            --nebula-2: rgba(167, 139, 250, 0.06);
            --nebula-3: rgba(196, 181, 253, 0.04);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.4);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.5);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.6);
        }
        
        /* Obsidian theme glassmorphism enhancements */
        [data-theme="obsidian"] .brand,
        [data-theme="obsidian"] .icon-btn,
        [data-theme="obsidian"] #side-panel,
        [data-theme="obsidian"] #info-panel,
        [data-theme="obsidian"] .modal-content,
        [data-theme="obsidian"] #theme-picker,
        [data-theme="obsidian"] #menu-dropdown,
        [data-theme="obsidian"] .spotlight-container,
        [data-theme="obsidian"] #quick-capture {
            background: rgba(16, 16, 20, 0.7) !important;
            backdrop-filter: blur(24px) saturate(150%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(150%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           BASE STYLES
           ═══════════════════════════════════════════════════════════ */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        
        html { 
            font-size: 16px; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body { 
            font-family: var(--font-body); 
            background: var(--bg-deep); 
            color: var(--text-primary); 
            overflow: hidden; 
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        button { font-family: inherit; cursor: pointer; border: none; background: none; color: inherit; }
        input, textarea { font-family: inherit; border: none; background: none; color: inherit; }
        
        /* Selection */
        ::selection { background: var(--accent); color: white; }

        /* ═══════════════════════════════════════════════════════════
           AMBIENT BACKGROUND - Living, Breathing Space
           ═══════════════════════════════════════════════════════════ */
        #ambient-bg {
            position: fixed;
            inset: 0;
            z-index: var(--z-bg);
            overflow: hidden;
            background: var(--bg-deep);
        }
        
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.5; /* Static opacity instead of animation */
            /* Animation disabled for performance */
            /* animation: nebulaFloat 20s ease-in-out infinite, nebulaFade 3s ease-out forwards; */
        }
        
        .nebula-1 {
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--nebula-1) 0%, transparent 70%);
            top: -10%; left: 10%;
            animation-delay: 0s;
        }
        
        .nebula-2 {
            width: 500px; height: 500px;
            background: radial-gradient(circle, var(--nebula-2) 0%, transparent 70%);
            bottom: -5%; right: 5%;
            animation-delay: -7s;
        }
        
        .nebula-3 {
            width: 700px; height: 700px;
            background: radial-gradient(circle, var(--nebula-3) 0%, transparent 70%);
            top: 30%; left: 50%;
            transform: translateX(-50%);
            animation-delay: -14s;
        }
        
        @keyframes nebulaFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(30px, -20px) scale(1.05); }
            50% { transform: translate(-20px, 30px) scale(0.95); }
            75% { transform: translate(-30px, -10px) scale(1.02); }
        }
        
        @keyframes nebulaFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particle container - handled by Three.js */
        #particle-bg {
            position: fixed;
            inset: 0;
            z-index: calc(var(--z-bg) + 1);
            pointer-events: none;
        }

        /* ═══════════════════════════════════════════════════════════
           CANVAS & 3D SCENE
           ═══════════════════════════════════════════════════════════ */
        #canvas-container { 
            position: fixed; 
            inset: 0; 
            z-index: var(--z-canvas); 
            touch-action: none;
        }

        /* ═══════════════════════════════════════════════════════════
           FOCUS MODE - Spotlight Effect
           ═══════════════════════════════════════════════════════════ */
        #focus-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-overlay);
            background: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
            pointer-events: none;
            transition: all var(--duration-slow) var(--ease-smooth);
        }
        
        #focus-overlay.active {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
        }
        
        .focus-spotlight {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-normal);
        }

        /* ═══════════════════════════════════════════════════════════
           HEADER & BRANDING
           ═══════════════════════════════════════════════════════════ */
        #header { 
            position: fixed; 
            top: var(--space-5); 
            left: var(--space-5); 
            z-index: var(--z-ui);
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }
        
        .brand { 
            display: flex; 
            align-items: center; 
            gap: var(--space-3); 
            padding: var(--space-3) var(--space-4);
            background: var(--glass-bg); 
            backdrop-filter: blur(var(--glass-blur)); 
            border: 1px solid var(--glass-border);
            border-radius: 16px; 
            box-shadow: var(--shadow-md);
            transition: all var(--duration-fast);
        }
        
        .brand:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .brand-logo { 
            width: 40px; 
            height: 40px; 
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px; 
            display: grid; 
            place-items: center; 
            font-family: var(--font-display);
            font-weight: 700; 
            font-size: 18px; 
            color: white;
            box-shadow: var(--shadow-glow);
        }
        
        .brand-text h1 { 
            font-family: var(--font-display); 
            font-size: 18px; 
            font-weight: 700; 
            letter-spacing: 1px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .brand-text p { 
            font-family: var(--font-mono); 
            font-size: 9px; 
            color: var(--text-muted); 
            letter-spacing: 2px; 
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════
           TOP CONTROLS
           ═══════════════════════════════════════════════════════════ */
        #top-controls {
            position: fixed;
            top: var(--space-5);
            right: var(--space-5);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-2);
            align-items: center;
        }
        
        .icon-btn {
            width: 44px;
            height: 44px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }
        
        .icon-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .icon-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* Goal button special styling */
        .icon-btn.goal-btn {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(167, 139, 250, 0.9));
            border-color: rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }

        .icon-btn.goal-btn:hover {
            background: linear-gradient(135deg, rgba(124, 79, 224, 0.95), rgba(155, 122, 240, 0.95));
            box-shadow: 0 6px 24px rgba(139, 92, 246, 0.5);
            color: white;
        }

        /* ═══════════════════════════════════════════════════════════
           MOBILE HEADER
           New simplified header for mobile devices
           ═══════════════════════════════════════════════════════════ */
        #mobile-header {
            display: none; /* Hidden on desktop */
        }
        
        #mobile-zoom-slider {
            display: none; /* Hidden on desktop */
        }

        #mobile-floating-actions {
            display: none; /* Hidden on desktop */
        }

        @media (max-width: 768px) {
            /* Mobile Header - column layout with brand above search bar */
            #mobile-header {
                display: flex;
                flex-direction: column;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: var(--z-ui);
                padding: env(safe-area-inset-top, 8px) var(--space-4) 0;
                pointer-events: none;
            }

            #mobile-header > * {
                pointer-events: auto;
            }

            /* Top: Small centered brand */
            .mobile-header-brand {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 4px;
                padding: 6px 0 8px;
                cursor: pointer;
            }

            .mobile-brand-logo {
                width: 14px;
                height: 14px;
                background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
                border-radius: 3px;
                display: grid;
                place-items: center;
                font-family: var(--font-display);
                font-weight: 700;
                font-size: 8px;
                color: white;
            }

            .mobile-brand-text {
                font-family: var(--font-display);
                font-size: 11px;
                font-weight: 700;
                letter-spacing: 1.5px;
                color: var(--text-primary);
                opacity: 0.9;
            }

            /* Search bar - unified pill with frosted glass */
            .mobile-search-bar {
                display: flex;
                align-items: center;
                height: 48px;
                background: rgba(22, 22, 30, 0.85);
                backdrop-filter: blur(40px) saturate(180%);
                -webkit-backdrop-filter: blur(40px) saturate(180%);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 24px;
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.04);
                overflow: hidden;
            }

            /* Left: Menu button as circle */
            .mobile-search-menu {
                width: 40px;
                height: 40px;
                margin: 4px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.08);
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--text-secondary);
                cursor: pointer;
                transition: all var(--duration-fast);
                flex-shrink: 0;
            }

            .mobile-search-menu:active {
                transform: scale(0.95);
                background: var(--bg-elevated);
            }

            .mobile-search-menu svg {
                width: 18px;
                height: 18px;
                stroke-width: 2;
            }

            /* Center: Search input */
            .mobile-search-input {
                flex: 1;
                height: 100%;
                background: transparent;
                border: none;
                outline: none;
                font-family: var(--font-body);
                font-size: 15px;
                color: var(--text-primary);
                padding: 0 12px;
            }

            .mobile-search-input::placeholder {
                color: var(--text-muted);
            }

            /* Right: User avatar as circle */
            .mobile-search-user {
                position: relative;
                width: 40px;
                height: 40px;
                margin: 4px;
                border-radius: 50%;
                background: var(--accent);
                border: none;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all var(--duration-fast);
                flex-shrink: 0;
            }

            .mobile-search-user:active {
                transform: scale(0.95);
            }

            .mobile-user-avatar {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
            }

            .mobile-user-avatar svg {
                width: 20px;
                height: 20px;
                stroke-width: 2;
            }

            .mobile-sync-indicator {
                position: absolute;
                bottom: 2px;
                right: 2px;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                background: var(--text-muted);
                border: 2px solid var(--bg-primary);
            }

            .mobile-sync-indicator.synced {
                background: #22c55e;
            }

            /* Floating action buttons - centered below avatar */
            #mobile-floating-actions {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                position: fixed;
                right: calc(var(--space-4) + 2px);
                top: calc(env(safe-area-inset-top, 8px) + 90px);
                z-index: var(--z-ui);
            }

            .mobile-fab {
                width: 44px;
                height: 44px;
                border-radius: 50%;
                background: rgba(22, 22, 30, 0.85);
                backdrop-filter: blur(40px) saturate(180%);
                -webkit-backdrop-filter: blur(40px) saturate(180%);
                border: 1px solid rgba(255, 255, 255, 0.08);
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.04);
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--text-secondary);
                cursor: pointer;
                transition: all var(--duration-fast);
            }

            .mobile-fab:active {
                transform: scale(0.95);
                background: var(--bg-elevated);
            }

            /* Goal FAB button - special styling */
            .mobile-fab.goal-fab {
                background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(167, 139, 250, 0.9));
                border-color: rgba(255, 255, 255, 0.2);
                color: white;
                box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
            }

            .mobile-fab.goal-fab:active {
                background: linear-gradient(135deg, rgba(124, 79, 224, 0.95), rgba(155, 122, 240, 0.95));
            }

            .mobile-fab:disabled {
                opacity: 0.3;
                cursor: not-allowed;
            }

            .mobile-fab:disabled:active {
                transform: none;
            }

            .mobile-fab svg {
                width: 20px;
                height: 20px;
                stroke-width: 2;
            }

            /* Light theme overrides - shadows at bottom of elements */
            [data-theme="sandstone"] .mobile-search-bar,
            [data-theme="coral"] .mobile-search-bar,
            [data-theme="ember"] .mobile-search-bar,
            [data-theme="frost"] .mobile-search-bar {
                background: rgba(255, 255, 255, 0.85);
                border-color: rgba(0, 0, 0, 0.06);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            }

            [data-theme="sandstone"] .mobile-search-menu,
            [data-theme="coral"] .mobile-search-menu,
            [data-theme="ember"] .mobile-search-menu,
            [data-theme="frost"] .mobile-search-menu {
                background: rgba(0, 0, 0, 0.05);
            }

            [data-theme="sandstone"] .mobile-fab,
            [data-theme="coral"] .mobile-fab,
            [data-theme="ember"] .mobile-fab,
            [data-theme="frost"] .mobile-fab {
                background: rgba(255, 255, 255, 0.85);
                border-color: rgba(0, 0, 0, 0.06);
                box-shadow: 0 6px 24px rgba(0, 0, 0, 0.12);
            }

            [data-theme="sandstone"] #mobile-bottom-sheet,
            [data-theme="coral"] #mobile-bottom-sheet,
            [data-theme="ember"] #mobile-bottom-sheet,
            [data-theme="frost"] #mobile-bottom-sheet {
                background: rgba(255, 255, 255, 0.88);
                border-color: rgba(0, 0, 0, 0.06);
                box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.12);
            }

            /* Hide desktop header elements on mobile */
            #header {
                display: none !important;
            }
            
            #top-controls {
                display: none !important;
            }
            
            /* Reposition dropdowns for mobile header */
            #menu-dropdown {
                top: calc(env(safe-area-inset-top, 8px) + 86px);
                left: var(--space-4);
                right: auto;
                min-width: 150px;
                max-width: 170px;
                z-index: 350; /* Above sheet (z-modal is 300) */
            }

            #menu-dropdown .menu-item {
                padding: var(--space-2) var(--space-3);
                font-size: 15px;
                gap: var(--space-2);
            }

            #menu-dropdown .menu-item svg {
                width: 18px;
                height: 18px;
            }

            #theme-picker {
                top: calc(env(safe-area-inset-top, 8px) + 86px);
                right: var(--space-4);
                z-index: 350; /* Above sheet (z-modal is 300) */
            }

            #user-dropdown {
                position: fixed;
                top: calc(env(safe-area-inset-top, 8px) + 86px);
                right: var(--space-4);
                width: calc(100vw - 32px);
                max-width: 300px;
                z-index: 350; /* Above sheet (z-modal is 300) */
            }
            
            /* Mobile Zoom Slider - minimal scrollbar style */
            #mobile-zoom-slider {
                display: block;
                position: fixed;
                right: 0;
                top: calc(env(safe-area-inset-top, 8px) + 190px);
                bottom: 180px;
                width: 24px;
                z-index: 100;
                opacity: 0;
                transition: opacity 0.3s;
                touch-action: none;
            }
            
            #mobile-zoom-slider.visible {
                opacity: 1;
            }
            
            #mobile-zoom-slider .zoom-thumb {
                position: absolute;
                right: 4px;
                width: 4px;
                height: 50px;
                background: var(--text-muted);
                border-radius: 2px;
                transition: background 0.15s, width 0.15s, right 0.15s;
            }
            
            /* Larger invisible touch target */
            #mobile-zoom-slider .zoom-thumb::before {
                content: '';
                position: absolute;
                top: -10px;
                left: -16px;
                right: -8px;
                bottom: -10px;
            }
            
            #mobile-zoom-slider.dragging .zoom-thumb,
            #mobile-zoom-slider .zoom-thumb:active {
                width: 6px;
                right: 3px;
                background: var(--text-secondary);
            }
        }

        /* ═══════════════════════════════════════════════════════════
           SPOTLIGHT SEARCH (Cmd+K)
           ═══════════════════════════════════════════════════════════ */
        #spotlight-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-spotlight);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: start center;
            padding-top: 15vh;
        }
        
        #spotlight-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast) var(--ease-out);
        }
        
        .spotlight-container {
            width: min(580px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-lg), 0 0 60px rgba(0, 0, 0, 0.3);
            animation: spotlightIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes spotlightIn {
            from { opacity: 0; transform: scale(0.95) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .spotlight-input-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-5);
            border-bottom: 1px solid var(--glass-border);
        }
        
        .spotlight-input-wrapper svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
            flex-shrink: 0;
        }
        
        #spotlight-input {
            flex: 1;
            font-size: 18px;
            font-weight: 500;
            background: transparent;
            outline: none;
        }
        
        #spotlight-input::placeholder {
            color: var(--text-muted);
        }
        
        .spotlight-hint {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        
        .spotlight-results {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .spotlight-section {
            padding: var(--space-2) var(--space-4);
        }
        
        .spotlight-section-title {
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: var(--space-2) 0;
        }
        
        .spotlight-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .spotlight-item:hover,
        .spotlight-item.selected {
            background: var(--bg-elevated);
        }
        
        .spotlight-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .spotlight-item-content {
            flex: 1;
            min-width: 0;
        }
        
        .spotlight-item-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .spotlight-item-subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .spotlight-item-shortcut {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-1);
        }
        
        .spotlight-item-shortcut kbd {
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }
        
        .spotlight-empty {
            padding: var(--space-8);
            text-align: center;
            color: var(--text-muted);
        }
        
        .spotlight-footer {
            padding: var(--space-3) var(--space-5);
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: var(--space-5);
            justify-content: center;
        }
        
        .spotlight-footer-hint {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .spotlight-footer-hint kbd {
            font-family: var(--font-mono);
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           QUICK CAPTURE BAR
           ═══════════════════════════════════════════════════════════ */
        #quick-capture {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .quick-capture-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            outline: none;
            transition: all var(--duration-fast);
        }
        
        .quick-capture-wrapper:focus-within {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #quick-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            font-size: 15px;
            background: transparent;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            color: var(--text-primary);
            transition: opacity 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        #quick-input:focus {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }
        
        #quick-input::placeholder {
            color: var(--text-muted);
            transition: opacity 0.3s ease;
        }
        
        .quick-btn {
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
        }
        
        .quick-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .quick-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .quick-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .quick-btn.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .quick-btn.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* ═══════════════════════════════════════════════════════════
           TOOLBAR TOGGLE - Mobile Only
           ═══════════════════════════════════════════════════════════ */
        #toolbar-toggle {
            display: none;
            position: fixed;
            bottom: 12px;
            right: 12px;
            width: 48px;
            height: 48px;
            border-radius: 14px;
            background: var(--accent);
            border: none;
            color: white;
            font-size: 22px;
            z-index: 1001;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            align-items: center;
            justify-content: center;
        }

        /* ═══════════════════════════════════════════════════════════
           SIDE PANEL - Controls
           ═══════════════════════════════════════════════════════════ */
        #side-panel {
            position: fixed;
            top: 50%;
            right: var(--space-3);
            transform: translateY(-50%);
            z-index: var(--z-ui);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: var(--shadow-md);
            transition: right 0.35s var(--ease-out);
        }
        
        /* Slide side panel when chat is open */
        body.chat-open #side-panel {
            right: 412px;
        }
        
        /* Hide quick capture when chat is open */
        body.chat-open #quick-capture {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(20px);
        }
        
        .side-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-2) var(--space-3);
            border-radius: 10px;
            color: var(--text-secondary);
            transition: all var(--duration-fast);
            cursor: pointer;
        }
        
        .side-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .side-btn.active {
            background: var(--accent);
            color: white;
        }
        
        /* Hide toolbar close button on desktop - only show on mobile */
        .toolbar-close {
            display: none;
        }
        
        /* AI Feature icons - subtle color accents */
        .side-btn.ai-feature {
            position: relative;
        }
        
        #btn-voice svg {
            stroke: #fb923c;
        }
        #btn-voice:hover {
            background: rgba(251, 146, 60, 0.15);
            color: #fb923c;
        }
        
        #btn-chat svg {
            stroke: #2dd4bf;
        }
        #btn-chat:hover {
            background: rgba(45, 212, 191, 0.15);
            color: #2dd4bf;
        }
        
        #btn-neural svg {
            stroke: #a78bfa;
        }
        #btn-neural:hover {
            background: rgba(167, 139, 250, 0.15);
            color: #a78bfa;
        }
        
        #btn-voice.active {
            animation: pulse-recording 1s ease-in-out infinite;
            background: var(--accent);
            color: white;
        }
        #btn-voice.active svg,
        #btn-voice.recording svg,
        #btn-voice.processing svg {
            stroke: white;
        }
        
        #btn-voice.recording {
            background: #fb923c;
            color: white;
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        #btn-voice.processing {
            background: #2dd4bf;
            color: white;
        }
        
        #btn-voice.speaking {
            background: #3b82f6;
            color: white;
            animation: speakingPulse 1.2s ease-in-out infinite;
        }
        
        @keyframes speakingPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        
        @keyframes pulse-recording {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 var(--accent-glow); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px 5px var(--accent-glow); }
        }
        
        @keyframes voicePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 131, 84, 0.5); }
            50% { box-shadow: 0 0 0 12px rgba(239, 131, 84, 0); }
        }
        
        /* Voice Indicator Modal */
        #voice-backdrop {
            position: fixed;
            inset: 0;
            z-index: 449;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(2px);
            display: none;
        }
        #voice-backdrop.active { display: block; }
        
        #voice-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 450;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-4);
            text-align: center;
            display: none;
            min-width: 200px;
            max-width: 240px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        #voice-indicator.active {
            display: block;
            animation: fadeIn 0.15s ease-out;
        }
        
        .voice-icon {
            margin-bottom: var(--space-2);
            color: #fb923c;
        }
        .voice-icon svg {
            width: 32px;
            height: 32px;
        }
        .voice-icon.recording svg { animation: voiceIconPulse 1s ease-in-out infinite; }
        .voice-icon.processing { color: #2dd4bf; }
        .voice-icon.speaking { color: #3b82f6; animation: voiceIconPulse 1s ease-in-out infinite; }
        @keyframes voiceIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .voice-status {
            font-family: var(--font-display);
            font-size: 13px;
            font-weight: 600;
            margin-bottom: var(--space-1);
        }
        
        .voice-transcript {
            font-size: 12px;
            color: var(--text-secondary);
            min-height: 28px;
            padding: var(--space-2);
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: var(--space-2);
            max-height: 60px;
            overflow-y: auto;
        }
        
        .voice-hint {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: var(--space-2);
        }
        
        .voice-cancel {
            margin-top: var(--space-3);
            padding: 6px 14px;
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            font-size: 11px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .voice-cancel:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Voice mode toggle */
        .voice-mode-toggle {
            display: flex;
            justify-content: center;
            gap: 2px;
            margin-bottom: var(--space-3);
            background: var(--bg-tertiary);
            padding: 3px;
            border-radius: 8px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        
        .voice-mode-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .voice-mode-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .voice-mode-btn:hover {
            color: var(--text-primary);
        }
        
        .voice-mode-btn.active {
            background: var(--accent);
            color: white;
        }
        
        /* Voice text input */
        .voice-text-input-wrapper {
            margin-top: var(--space-2);
        }
        
        #voice-text-input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
            font-family: inherit;
            resize: none;
            min-height: 50px;
        }
        
        #voice-text-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        #voice-text-input::placeholder {
            color: var(--text-muted);
        }
        
        .voice-text-submit {
            margin-top: 8px;
            padding: 8px 14px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            transition: all 0.2s;
        }
        .voice-text-submit svg {
            width: 14px;
            height: 14px;
        }
        
        .voice-text-submit:hover {
            filter: brightness(1.1);
        }
        
        .voice-text-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* API Key Modal */
        #api-key-modal {
            position: fixed;
            inset: 0;
            z-index: 10001;
            background: rgba(30,34,51,0.8);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        #api-key-modal.active { display: grid; }
        
        .api-key-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-6);
            width: min(400px, calc(100vw - 32px));
        }
        
        .api-key-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .api-key-desc {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            line-height: 1.5;
        }
        
        .api-key-status {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: var(--space-3);
            padding: var(--space-2);
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        .api-key-status.configured { color: #4ECDC4; }
        
        .api-key-input {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
        }
        .api-key-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .api-key-buttons {
            display: flex;
            gap: var(--space-3);
            justify-content: flex-end;
        }
        
        .api-key-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }
        .api-key-btn.primary {
            background: var(--accent);
            color: white;
        }
        .api-key-btn.secondary {
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
        }
        
        /* Import Notes Modal */
        #import-notes-modal {
            position: fixed;
            inset: 0;
            z-index: 10002;
            background: rgba(30,34,51,0.9);
            backdrop-filter: blur(12px);
            display: none;
            place-items: center;
            padding: var(--space-4);
        }
        #import-notes-modal.active { display: grid; }
        
        .import-notes-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: var(--space-5);
            width: min(500px, calc(100vw - 32px));
            max-height: calc(100vh - 64px);
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        .import-notes-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
        }
        
        .import-notes-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .import-notes-header h2 svg {
            width: 20px;
            height: 20px;
            color: var(--accent);
        }
        
        .import-notes-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .import-notes-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .import-notes-desc {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            line-height: 1.5;
        }
        
        .import-notes-dropzone {
            border: 2px dashed var(--glass-border);
            border-radius: 16px;
            padding: var(--space-6);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-tertiary);
            margin-bottom: var(--space-4);
        }
        
        .import-notes-dropzone:hover,
        .import-notes-dropzone.dragover {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        .import-notes-dropzone-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto var(--space-3);
            color: var(--text-muted);
        }
        
        .import-notes-dropzone.dragover .import-notes-dropzone-icon {
            color: var(--accent);
        }
        
        .import-notes-dropzone-text {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }
        
        .import-notes-dropzone-hint {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .import-notes-or {
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: var(--space-4);
            position: relative;
        }
        
        .import-notes-or::before,
        .import-notes-or::after {
            content: '';
            position: absolute;
            top: 50%;
            width: calc(50% - 20px);
            height: 1px;
            background: var(--glass-border);
        }
        
        .import-notes-or::before { left: 0; }
        .import-notes-or::after { right: 0; }
        
        .import-notes-textarea {
            width: 100%;
            min-height: 120px;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 13px;
            resize: vertical;
            margin-bottom: var(--space-4);
        }
        
        .import-notes-textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .import-notes-textarea::placeholder {
            color: var(--text-muted);
        }
        
        .import-notes-preview {
            margin-bottom: var(--space-4);
            display: none;
        }
        
        .import-notes-preview.active {
            display: block;
        }
        
        .import-notes-preview-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-2);
        }
        
        .import-notes-preview-image {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 12px;
            background: var(--bg-tertiary);
        }
        
        .import-notes-preview-file {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 12px;
        }
        
        .import-notes-preview-file svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
        }
        
        .import-notes-preview-file-info {
            flex: 1;
        }
        
        .import-notes-preview-file-name {
            font-size: 13px;
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .import-notes-preview-file-size {
            font-size: 11px;
            color: var(--text-muted);
        }
        
        .import-notes-preview-remove {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(220, 38, 38, 0.1);
            border: none;
            color: #dc2626;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .import-notes-options {
            margin-bottom: var(--space-4);
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 12px;
        }
        
        .import-notes-option {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .import-notes-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }
        
        .import-notes-actions {
            display: flex;
            gap: var(--space-3);
        }
        
        .import-notes-btn {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: none;
        }
        
        .import-notes-btn.primary {
            background: var(--accent);
            color: white;
        }
        
        .import-notes-btn.primary:hover {
            filter: brightness(1.1);
        }
        
        .import-notes-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .import-notes-btn.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
        }
        
        .import-notes-btn.secondary:hover {
            background: var(--bg-elevated);
        }
        
        .import-notes-processing {
            display: none;
            text-align: center;
            padding: var(--space-5);
        }
        
        .import-notes-processing.active {
            display: block;
        }
        
        .import-notes-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--glass-border);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto var(--space-3);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .import-notes-processing-text {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .import-notes-result {
            display: none;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin-bottom: var(--space-4);
        }
        
        .import-notes-result.active {
            display: block;
        }
        
        .import-notes-result-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: var(--space-3);
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .import-notes-result-header svg {
            width: 18px;
            height: 18px;
            color: #22c55e;
        }
        
        .import-notes-result-tree {
            font-size: 12px;
            font-family: var(--font-mono);
            color: var(--text-secondary);
            max-height: 200px;
            overflow-y: auto;
            padding: var(--space-2);
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .import-notes-result-node {
            padding: 2px 0;
        }
        
        .import-notes-result-node.category {
            color: var(--accent);
            font-weight: 500;
        }
        
        /* Auth Modal */
        #auth-modal {
            position: fixed;
            inset: 0;
            z-index: 10002;
            background: rgba(30,34,51,0.9);
            backdrop-filter: blur(12px);
            display: none;
            place-items: center;
        }
        #auth-modal.active { display: grid; }
        
        .auth-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: var(--space-6);
            width: min(400px, calc(100vw - 32px));
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        .auth-header {
            text-align: center;
            margin-bottom: var(--space-5);
        }
        
        .auth-logo {
            width: 56px;
            height: 56px;
            background: var(--accent);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 700;
            color: white;
            margin: 0 auto var(--space-4);
        }
        
        .auth-title {
            font-family: var(--font-display);
            font-size: 22px;
            font-weight: 600;
            margin-bottom: var(--space-1);
        }
        
        .auth-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .auth-divider {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin: var(--space-5) 0;
            color: var(--text-muted);
            font-size: 12px;
        }
        
        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--glass-border);
        }
        
        .auth-input {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: var(--space-3);
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .auth-input::placeholder {
            color: var(--text-muted);
        }
        
        .auth-btn {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all 0.2s;
        }
        
        .auth-btn.google {
            background: white;
            color: #333;
            border: 1px solid #ddd;
            margin-bottom: var(--space-3);
        }
        .auth-btn.google:hover {
            background: #f5f5f5;
        }
        
        .auth-btn.primary {
            background: var(--accent);
            color: white;
        }
        .auth-btn.primary:hover {
            filter: brightness(1.1);
        }
        
        .auth-btn.secondary {
            background: transparent;
            color: var(--text-secondary);
            padding: var(--space-2);
            margin-top: var(--space-3);
        }
        .auth-btn.secondary:hover {
            color: var(--text-primary);
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: var(--space-4);
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .auth-toggle a {
            color: var(--accent);
            cursor: pointer;
            text-decoration: none;
        }
        .auth-toggle a:hover {
            text-decoration: underline;
        }
        
        .auth-error {
            background: rgba(220, 38, 38, 0.1);
            border: 1px solid rgba(220, 38, 38, 0.3);
            color: #dc2626;
            padding: var(--space-3);
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: var(--space-3);
            display: none;
        }
        .auth-error.active { display: block; }
        
        .auth-close {
            position: absolute;
            top: var(--space-4);
            right: var(--space-4);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-2);
        }
        .auth-close:hover {
            color: var(--text-primary);
        }
        
        /* User Account Button */
        #user-account-wrapper {
            position: relative;
        }
        
        #user-account-btn {
            display: flex !important;
            align-items: center;
            gap: var(--space-2);
            position: relative;
        }
        
        .user-avatar {
            width: 28px;
            height: 28px;
            min-width: 28px;
            min-height: 28px;
            border-radius: 50%;
            background: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: white;
            overflow: hidden;
        }
        
        .user-avatar svg {
            width: 16px;
            height: 16px;
            stroke: white;
            fill: none;
        }
        
        /* Sync Indicator */
        #sync-indicator {
            position: absolute;
            bottom: 6px;
            right: 6px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
            border: 2px solid var(--glass-bg);
            transition: background 0.3s;
            cursor: pointer;
        }
        #sync-indicator.synced {
            background: #22c55e;
        }
        #sync-indicator.syncing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }
        #sync-indicator.error {
            background: #ef4444;
        }
        #sync-indicator.connected {
            background: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* User Dropdown Panel */
        #user-dropdown {
            position: fixed;
            top: 60px;
            right: var(--space-4);
            width: 280px;
            background: var(--bg-secondary);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 4px 32px rgba(0,0,0,0.4);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.2s var(--ease-out);
            z-index: var(--z-dropdown);
            overflow: hidden;
        }
        
        #user-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .user-dropdown-header {
            padding: 16px;
            border-bottom: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .user-dropdown-email {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .user-dropdown-signout {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
            transition: color 0.2s;
        }
        
        .user-dropdown-signout:hover {
            color: var(--accent);
        }
        
        .user-dropdown-section {
            padding: 12px;
        }
        
        .user-dropdown-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            padding: 0 4px;
        }
        
        .user-maps-list {
            max-height: 180px;
            overflow-y: auto;
        }
        
        .user-map-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .user-map-item:hover {
            background: var(--bg-tertiary);
        }
        
        .user-map-item.active {
            background: var(--accent-glow);
        }
        
        .user-map-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
        }
        
        .user-map-item.active .user-map-icon {
            background: var(--accent);
        }
        
        .user-map-info {
            flex: 1;
            min-width: 0;
        }
        
        .user-map-name {
            font-size: 0.85rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .user-map-date {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .user-map-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .user-map-item:hover .user-map-actions {
            opacity: 1;
        }
        
        .user-map-action {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 4px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .user-map-action:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .user-map-action.delete:hover {
            color: #ef4444;
        }
        
        .user-maps-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .user-dropdown-actions {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 8px 12px;
            border-top: 1px solid var(--glass-border);
        }
        
        .user-dropdown-action {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            width: 100%;
        }
        
        .user-dropdown-action:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .user-dropdown-action svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }
        
        .user-dropdown-sync {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--glass-border);
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .user-dropdown-sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .user-dropdown-sync-dot.synced {
            background: #22c55e;
        }
        
        .user-dropdown-sync-dot.syncing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }
        
        .user-dropdown-sync-dot.offline {
            background: var(--text-muted);
        }
        
        /* Offline state */
        .user-dropdown-offline {
            padding: 20px 16px;
            text-align: center;
        }
        
        .user-dropdown-offline-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        
        .user-dropdown-signin {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .user-dropdown-signin:hover {
            filter: brightness(1.1);
        }
        
        .side-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .side-btn-label {
            display: block;
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .side-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-1) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           INFO PANEL - Node Details
           ═══════════════════════════════════════════════════════════ */
        #info-panel {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: var(--space-2);
            opacity: 0;
            pointer-events: none;
            transition: all var(--duration-normal) var(--ease-out);
        }
        
        #info-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        
        .info-header {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-bottom: var(--space-1);
        }
        
        .info-color {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            position: relative;
            transition: transform var(--duration-fast);
        }
        
        .info-color:hover {
            transform: scale(1.05);
        }
        
        .info-color-picker {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 8px;
            display: none;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            z-index: 10;
            box-shadow: var(--shadow-lg);
        }
        
        .info-color-picker.active {
            display: grid;
        }
        
        .info-color-picker span {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform var(--duration-fast);
        }
        
        .info-color-picker span:hover {
            transform: scale(1.15);
        }
        
        .info-title-area {
            flex: 1;
            min-width: 0;
        }
        
        #info-title {
            font-family: var(--font-display);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 0;
            cursor: text;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            width: 100%;
            transition: all var(--duration-fast);
        }
        
        #info-title:hover {
            background: var(--bg-elevated);
        }
        
        #info-title:focus {
            background: var(--bg-elevated);
            border-color: var(--accent);
        }
        
        #info-meta {
            font-size: 10px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-2);
            padding-left: 6px;
        }
        
        .info-link {
            padding: 8px 12px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .info-link a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-secondary);
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .info-link a:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
        }
        
        .info-link img {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .info-link span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-close {
            width: 22px;
            height: 22px;
            border-radius: 6px;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-close:hover {
            background: var(--accent);
            color: white;
        }
        
        /* Expand Toggle Button */
        .info-expand-toggle {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-elevated);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-expand-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-expand-toggle .expand-icon {
            width: 16px;
            height: 16px;
            transition: transform 0.3s ease;
        }
        
        #info-panel.expanded .info-expand-toggle .expand-icon {
            transform: rotate(180deg);
        }
        
        /* Expanded Section */
        .info-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 0;
        }
        
        #info-panel.expanded .info-expanded {
            max-height: 50vh;
            opacity: 1;
            padding: 12px 0;
            border-top: 1px solid var(--bg-tertiary);
            margin-top: 8px;
            overflow-y: auto;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section-label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        #info-description {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            resize: none;
            min-height: 60px;
            max-height: 60px;
            transition: border-color 0.2s, min-height 0.3s ease, max-height 0.3s ease;
        }
        
        #info-description:focus {
            outline: none;
            border-color: var(--accent);
            min-height: 120px;
            max-height: 200px;
            resize: vertical;
        }
        
        #info-description::placeholder {
            color: var(--text-muted);
        }
        
        /* Context Question Feature */
        .info-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .info-section-header .info-section-label {
            margin-bottom: 0;
        }
        
        .context-question-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid var(--text-muted);
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0.6;
        }
        
        .context-question-btn:hover {
            opacity: 1;
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .context-question-btn.hidden {
            display: none;
        }
        
        .context-question-popover {
            display: none;
            margin-top: 8px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            border-radius: 10px;
            animation: fadeSlideIn 0.2s ease;
        }
        
        .context-question-popover.active {
            display: block;
        }
        
        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .context-question-text {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .context-question-input-wrapper {
            display: flex;
            gap: 8px;
        }
        
        #context-question-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        #context-question-input:focus {
            border-color: var(--accent);
        }
        
        .context-question-submit {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .context-question-submit:hover {
            transform: scale(1.05);
        }
        
        .context-question-submit:active {
            transform: scale(0.95);
        }
        
        .context-question-submit svg {
            width: 16px;
            height: 16px;
        }
        
        /* Path Breadcrumbs */
        .info-path {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .info-path-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 120px;
        }
        
        .info-path-item:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-path-item:hover .info-path-color {
            box-shadow: 0 0 0 2px rgba(255,255,255,0.5);
        }
        
        .info-path-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .info-path-name {
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-path-separator {
            color: var(--text-muted);
            font-size: 10px;
        }
        
        .info-path-current {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Link Card in Expanded View */
        .info-link-card {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-link-thumbnail {
            width: 80px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
            background: var(--bg-tertiary);
        }
        
        .info-link-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }
        
        .info-link-details a {
            display: flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 13px;
            transition: color 0.2s;
        }
        
        .info-link-details a:hover {
            color: var(--accent);
        }
        
        .info-link-favicon-small {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .info-link-meta {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        
        /* Transcript Section */
        #info-transcript-section .info-section-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .info-transcript-chars {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .info-transcript-wrapper {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-transcript-preview {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            max-height: 60px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        
        .info-transcript-toggle {
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .info-transcript-toggle:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-transcript-full {
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .info-transcript-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        /* Metadata Section */
        .info-metadata {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .info-meta-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .info-meta-label {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        
        .info-meta-value {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        #info-source {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            color: var(--text-tertiary);
        }
        
        #info-source:empty {
            display: none;
        }
        
        #info-source.ai {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }
        
        #info-source.link {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .info-slider {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-1) 0;
            margin-bottom: var(--space-2);
        }
        
        .info-slider-label {
            font-size: 10px;
            color: var(--text-muted);
            min-width: 55px;
        }
        
        .info-slider-wrapper {
            flex: 1;
            position: relative;
            height: 14px;
            display: flex;
            align-items: center;
        }
        
        .info-slider-wrapper::after {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--text-muted);
            pointer-events: none;
        }
        
        .info-slider input[type="range"] {
            flex: 1;
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.15s;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .info-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }
        
        .info-actions {
            display: flex;
            gap: var(--space-1);
            flex-wrap: nowrap;
        }
        
        .info-add-link {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .info-add-link-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
        }
        
        .info-add-link-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .info-add-link-input::placeholder {
            color: var(--text-tertiary);
        }
        
        .info-add-link-btn {
            padding: 8px;
            border-radius: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--duration-fast);
        }
        
        .info-add-link-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .info-add-link-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .info-action {
            flex: 1;
            min-width: 60px;
            padding: 6px var(--space-2);
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all var(--duration-fast);
        }
        
        .info-action svg {
            width: 12px;
            height: 12px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .info-action.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .info-action.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .info-action.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-action.ai {
            background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
            color: white;
        }
        
        .info-action.ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.4);
        }
        
        .info-action.danger {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.danger:hover {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }
        
        /* ═══════════════════════════════════════════════════════════
           ATTACHMENTS
           ═══════════════════════════════════════════════════════════ */
        .info-attachments {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--glass-border);
        }
        
        .attachments-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .attachments-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .attachment-add-btn {
            padding: 4px 8px;
            border-radius: 6px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all var(--duration-fast);
        }
        
        .attachment-add-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .attachments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
        }
        
        .attachment-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: all var(--duration-fast);
        }
        
        .attachment-item:hover {
            transform: scale(1.05);
            border-color: var(--accent);
        }
        
        .attachment-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .attachment-item .attachment-type {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 8px;
            padding: 2px 4px;
            border-radius: 4px;
            text-transform: uppercase;
        }
        
        .attachment-item .attachment-delete {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity var(--duration-fast);
        }
        
        .attachment-item:hover .attachment-delete {
            opacity: 1;
        }
        
        .attachment-item .attachment-generate {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-light));
            color: white;
            font-size: 11px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity var(--duration-fast);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .attachment-item:hover .attachment-generate {
            opacity: 1;
        }
        
        .attachment-item .attachment-generate:hover {
            transform: scale(1.1);
        }
        
        .attachments-dropzone {
            border: 2px dashed var(--glass-border);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 11px;
            transition: all var(--duration-fast);
            margin-top: 8px;
        }
        
        .attachments-dropzone.dragover {
            border-color: var(--accent);
            background: var(--accent-glow);
            color: var(--accent);
        }
        
        .attachments-dropzone svg {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            stroke: currentColor;
            fill: none;
        }
        
        /* Canvas drop overlay */
        .canvas-drop-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
            pointer-events: none;
        }
        
        .canvas-drop-overlay.active {
            display: grid;
        }
        
        .canvas-drop-content {
            text-align: center;
            color: white;
        }
        
        .canvas-drop-content svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            stroke: var(--accent);
            fill: none;
        }
        
        .canvas-drop-content h3 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .canvas-drop-content p {
            color: var(--text-muted);
            font-size: 14px;
        }
        
        /* Attachment badge on nodes */
        .node-attachment-badge {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            border: 2px solid var(--bg-primary);
        }
        
        /* Lightbox for viewing attachments */
        .lightbox-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-toast);
            background: rgba(0, 0, 0, 0.95);
            display: none;
            place-items: center;
            cursor: zoom-out;
        }
        
        .lightbox-overlay.active {
            display: grid;
        }
        
        .lightbox-content {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        
        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background var(--duration-fast);
        }
        
        .lightbox-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .lightbox-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 24px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            text-align: center;
            max-width: 80vw;
        }
        
        .lightbox-info .filename {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .lightbox-info .description {
            color: var(--text-muted);
        }

        /* ═══════════════════════════════════════════════════════════
           MODAL SYSTEM
           ═══════════════════════════════════════════════════════════ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-modal);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        
        .modal-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            width: min(480px, calc(100vw - 40px));
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: var(--space-7);
            box-shadow: var(--shadow-lg);
            animation: modalIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .modal-header {
            margin-bottom: var(--space-6);
        }
        
        .modal-title {
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .modal-subtitle {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .form-group {
            margin-bottom: var(--space-5);
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-2);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            font-size: 15px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        .form-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        .form-input::placeholder {
            color: var(--text-muted);
        }
        
        textarea.form-input {
            resize: vertical;
            min-height: 100px;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-2);
        }
        
        .color-swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--duration-fast);
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: white;
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.1);
        }
        
        .modal-actions {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-6);
        }
        
        .modal-btn {
            flex: 1;
            padding: var(--space-4);
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        .modal-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .modal-btn.cancel:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .modal-btn.submit {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .modal-btn.submit:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        /* ═══════════════════════════════════════════════════════════
           GOAL WIZARD - Manifestation Creation Flow
           ═══════════════════════════════════════════════════════════ */
        #goal-wizard {
            position: fixed;
            inset: 0;
            z-index: calc(var(--z-modal) + 10);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            display: none;
            place-items: center;
        }

        #goal-wizard.active {
            display: grid;
            animation: fadeIn var(--duration-fast);
        }

        .goal-wizard-content {
            width: min(520px, calc(100vw - 32px));
            max-height: calc(100vh - 60px);
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 28px;
            padding: var(--space-7);
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5), 0 0 60px var(--accent-glow);
            animation: wizardIn 0.4s var(--ease-spring);
        }

        @keyframes wizardIn {
            from { opacity: 0; transform: scale(0.9) translateY(30px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .goal-wizard-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .goal-wizard-icon {
            width: 64px;
            height: 64px;
            margin: 0 auto var(--space-4);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 20px;
            display: grid;
            place-items: center;
            font-size: 32px;
            box-shadow: 0 8px 32px var(--accent-glow);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 8px 32px var(--accent-glow); }
            50% { transform: scale(1.05); box-shadow: 0 12px 48px var(--accent-glow); }
        }

        .goal-wizard-title {
            font-family: var(--font-display);
            font-size: 26px;
            font-weight: 600;
            margin-bottom: var(--space-2);
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .goal-wizard-subtitle {
            font-size: 15px;
            color: var(--text-muted);
        }

        /* Progress Steps */
        .goal-wizard-progress {
            display: flex;
            justify-content: center;
            gap: var(--space-2);
            margin-bottom: var(--space-6);
        }

        .goal-wizard-step {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            transition: all var(--duration-normal);
        }

        .goal-wizard-step.active {
            background: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
            transform: scale(1.2);
        }

        .goal-wizard-step.completed {
            background: var(--success);
        }

        /* Form Steps */
        .goal-wizard-steps {
            position: relative;
            min-height: 200px;
        }

        .goal-wizard-step-content {
            display: none;
            animation: stepIn var(--duration-normal) var(--ease-out);
        }

        .goal-wizard-step-content.active {
            display: block;
        }

        @keyframes stepIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .goal-wizard-question {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: var(--space-4);
            color: var(--text-primary);
        }

        .goal-wizard-hint {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: var(--space-4);
            font-style: italic;
        }

        .goal-wizard-input {
            width: 100%;
            padding: var(--space-5);
            background: var(--bg-tertiary);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            font-size: 16px;
            outline: none;
            transition: all var(--duration-fast);
            color: var(--text-primary);
        }

        .goal-wizard-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 24px var(--accent-glow);
        }

        .goal-wizard-input::placeholder {
            color: var(--text-muted);
        }

        textarea.goal-wizard-input {
            resize: vertical;
            min-height: 100px;
        }

        /* Priority Selector */
        .goal-priority-selector {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-4);
        }

        .goal-priority-option {
            flex: 1;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border: 2px solid var(--glass-border);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }

        .goal-priority-option:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .goal-priority-option.selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        .goal-priority-label {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: var(--space-1);
        }

        .goal-priority-desc {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Summary Step */
        .goal-summary {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: var(--space-5);
        }

        .goal-summary-item {
            margin-bottom: var(--space-4);
        }

        .goal-summary-item:last-child {
            margin-bottom: 0;
        }

        .goal-summary-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-1);
        }

        .goal-summary-value {
            font-size: 15px;
            color: var(--text-primary);
        }

        /* Actions */
        .goal-wizard-actions {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-6);
        }

        .goal-wizard-btn {
            flex: 1;
            padding: var(--space-4) var(--space-5);
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--duration-fast);
            border: none;
        }

        .goal-wizard-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .goal-wizard-btn.secondary:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .goal-wizard-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        .goal-wizard-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px var(--accent-glow);
        }

        .goal-wizard-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Close Button */
        .goal-wizard-close {
            position: absolute;
            top: var(--space-4);
            right: var(--space-4);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            display: grid;
            place-items: center;
            transition: all var(--duration-fast);
        }

        .goal-wizard-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* ═══════════════════════════════════════════════════════════
           NEURAL NETWORK PANEL
           ═══════════════════════════════════════════════════════════ */
        #neural-panel {
            position: fixed;
            bottom: 100px;
            right: var(--space-4);
            width: 340px;
            max-height: 70vh;
            background: var(--bg-secondary);
            backdrop-filter: blur(24px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-modal);
            padding: var(--space-5);
            z-index: var(--z-modal);
            visibility: hidden;
            pointer-events: none;
            transform: translateY(20px);
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        #neural-panel.active {
            visibility: visible;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        .neural-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
        }
        
        .neural-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .neural-title svg {
            width: 20px;
            height: 20px;
            stroke: var(--accent);
        }
        
        .neural-close {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-close:hover {
            background: var(--accent);
            color: white;
        }
        
        .neural-close svg {
            width: 14px;
            height: 14px;
        }
        
        .neural-status {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: var(--space-4);
            margin-bottom: var(--space-4);
        }
        
        .neural-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }
        
        .neural-status-row:last-child {
            margin-bottom: 0;
        }
        
        .neural-status-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .neural-status-value.ready {
            color: #22c55e;
        }
        
        .neural-status-value.training {
            color: var(--accent);
        }
        
        .neural-status-value.not-ready {
            color: #f59e0b;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
            flex-shrink: 0;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-elevated);
            transition: 0.2s;
            border-radius: 20px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: var(--text-muted);
            transition: 0.2s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent);
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(16px);
            background-color: white;
        }

        .neural-progress {
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            overflow: hidden;
            margin-top: var(--space-3);
        }
        
        .neural-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .neural-categories {
            margin-bottom: var(--space-4);
        }
        
        .neural-categories-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-2);
        }
        
        .neural-category-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
        }
        
        .neural-category-tag {
            padding: var(--space-1) var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .neural-actions {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }
        
        .neural-btn {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: 12px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        .neural-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .neural-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .neural-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .neural-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .neural-btn.primary:active:not(:disabled) {
            transform: scale(0.98);
        }
        
        .neural-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .neural-btn.secondary:hover {
            background: var(--bg-elevated);
        }
        
        .neural-suggestions {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--glass-border);
        }
        
        .neural-suggestions-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-3);
        }
        
        .neural-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-suggestion:hover {
            background: var(--bg-elevated);
            transform: translateX(4px);
        }
        
        .neural-suggestion-text {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .neural-suggestion-score {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
            padding: 2px 8px;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            #neural-panel {
                position: fixed;
                left: 12px;
                right: 12px;
                bottom: 90px;
                width: auto;
                max-height: calc(100vh - 150px);
                z-index: 9999;
            }
            
            #neural-panel.active {
                visibility: visible !important;
                pointer-events: auto !important;
                transform: none !important;
            }
        }

        /* ═══════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════ */
        #toast-container {
            position: fixed;
            top: var(--space-4);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            pointer-events: none;
        }
        
        .toast {
            padding: 8px 16px;
            background: var(--bg-secondary);
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md);
            animation: toastIn var(--duration-normal) var(--ease-out);
            pointer-events: auto;
        }
        
        .toast span {
            font-size: 12px;
        }
        
        .toast.success {
            color: #22c55e;
        }
        
        .toast.success span {
            color: #22c55e;
        }
        
        .toast.error {
            color: #ef4444;
        }
        
        .toast.error span {
            color: #ef4444;
        }
        
        .toast.info {
            color: var(--text-primary);
        }
        
        .toast.info span {
            color: var(--accent);
        }
        
        .toast.exiting {
            animation: toastOut var(--duration-fast) var(--ease-out) forwards;
        }
        
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes toastOut {
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* ═══════════════════════════════════════════════════════════
           CELEBRATION PARTICLES
           ═══════════════════════════════════════════════════════════ */
        .celebration-particle {
            position: fixed;
            pointer-events: none;
            z-index: var(--z-toast);
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════
           DEPTH INDICATOR
           ═══════════════════════════════════════════════════════════ */
        #depth-indicator {
            position: fixed;
            top: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: none;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            box-shadow: var(--shadow-md);
        }
        
        #depth-indicator.active {
            display: flex;
        }
        
        .depth-back {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .depth-back:hover {
            background: var(--accent);
            color: white;
        }
        
        .depth-back svg {
            width: 14px;
            height: 14px;
        }
        
        .depth-path {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .depth-item {
            color: var(--text-secondary);
        }
        
        .depth-item.current {
            color: var(--accent);
            font-weight: 600;
        }

        /* ═══════════════════════════════════════════════════════════
           RADIAL MENU
           ═══════════════════════════════════════════════════════════ */
        #radial-menu {
            position: fixed;
            z-index: var(--z-overlay);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-fast);
        }
        
        #radial-menu.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-toggle {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 2px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: all var(--duration-fast);
        }
        
        .radial-toggle:hover,
        .radial-toggle.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .radial-toggle svg {
            width: 14px;
            height: 14px;
        }
        
        .radial-item {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: all var(--duration-fast);
        }
        
        .radial-item.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-item:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        .radial-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* ═══════════════════════════════════════════════════════════
           ONBOARDING
           ═══════════════════════════════════════════════════════════ */
        #onboarding-overlay {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slower);
        }
        
        #onboarding-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .onboarding-avatar {
            position: absolute;
            top: var(--space-4);
            right: var(--space-4);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--duration-normal);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }
        
        .onboarding-avatar:hover {
            background: var(--glass-hover);
            transform: scale(1.05);
        }
        
        .onboarding-avatar svg {
            width: 22px;
            height: 22px;
            stroke: var(--text-secondary);
        }
        
        .onboarding-avatar.logged-in {
            background: var(--accent);
            border-color: var(--accent);
        }
        
        .onboarding-avatar.logged-in svg {
            stroke: white;
        }
        
        .onboarding-content {
            text-align: center;
            max-width: 500px;
            padding: var(--space-6);
        }
        
        .onboarding-logo {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 42px;
            font-weight: 700;
            color: white;
            margin: 0 auto var(--space-7);
            box-shadow: var(--shadow-glow);
            animation: logoPulse 2s ease-in-out infinite;
        }
        
        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .onboarding-title {
            font-family: var(--font-display);
            font-size: 36px;
            font-weight: 700;
            margin-bottom: var(--space-3);
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .onboarding-subtitle {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: var(--space-8);
            line-height: 1.6;
        }
        
        .onboarding-input-wrapper {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-6);
        }
        
        #onboarding-name {
            flex: 1;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        #onboarding-name:focus {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #onboarding-start {
            padding: var(--space-4) var(--space-6);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        #onboarding-start:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color var(--duration-fast);
        }
        
        .onboarding-skip:hover {
            color: var(--text-secondary);
        }
        
        /* Choice Buttons */
        .onboarding-choices {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-6);
            margin-bottom: var(--space-4);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .onboarding-choice {
            flex: 1;
            min-width: 140px;
            max-width: 200px;
            padding: var(--space-4);
            background: var(--bg-secondary);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            cursor: pointer;
            transition: all var(--duration-fast);
            text-align: center;
        }
        
        .onboarding-choice:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-choice-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto var(--space-3);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .onboarding-choice-icon svg {
            width: 24px;
            height: 24px;
            stroke: white;
            fill: white;
            stroke-width: 2;
        }
        
        .onboarding-choice.ai .onboarding-choice-icon svg {
            stroke: none;
            fill: white;
        }
        
        .onboarding-choice.scratch .onboarding-choice-icon {
            background: linear-gradient(135deg, var(--text-secondary) 0%, var(--text-muted) 100%);
        }
        
        .onboarding-choice.load .onboarding-choice-icon {
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        }
        
        .onboarding-choice.load .onboarding-choice-icon svg {
            fill: none;
            stroke: white;
        }
        
        /* Hide load option by default, show only when logged in */
        .onboarding-choice.load {
            display: none;
        }
        
        .onboarding-choices.logged-in .onboarding-choice.load {
            display: block;
        }
        
        .onboarding-choice-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-2);
        }
        
        .onboarding-choice-desc {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        @media (max-width: 500px) {
            .onboarding-choices {
                flex-direction: column;
                align-items: center;
            }
            
            .onboarding-choice {
                max-width: 100%;
                width: 100%;
            }
        }
        
        /* Questionnaire Styles */
        .onboarding-questionnaire {
            display: none;
            text-align: left;
            max-width: 560px;
            width: 100%;
            padding: var(--space-6);
        }
        
        .onboarding-questionnaire.active {
            display: block;
        }
        
        .question-header {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }
        
        .question-logo {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        
        .question-progress {
            flex: 1;
        }
        
        .question-step {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }
        
        .question-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .question-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 2px;
            transition: width 0.4s ease;
        }
        
        .question-text {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.4;
            margin-bottom: var(--space-6);
        }
        
        .question-input {
            width: 100%;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            color: var(--text-primary);
            outline: none;
            transition: all var(--duration-fast);
            resize: none;
            min-height: 100px;
            font-family: inherit;
            line-height: 1.5;
        }
        
        .question-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(239, 131, 84, 0.15);
        }
        
        .question-input::placeholder {
            color: var(--text-muted);
        }
        
        .question-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-5);
        }
        
        .question-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-2) var(--space-3);
            border-radius: 8px;
            transition: all var(--duration-fast);
        }
        
        .question-skip:hover {
            color: var(--text-secondary);
            background: var(--bg-tertiary);
        }
        
        .question-nav {
            display: flex;
            gap: var(--space-3);
        }
        
        .question-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .question-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .question-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .question-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .question-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .question-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Processing state */
        .onboarding-processing {
            display: none;
            text-align: center;
            max-width: 400px;
            padding: var(--space-6);
        }
        
        .onboarding-processing.active {
            display: block;
        }
        
        .processing-spinner {
            width: 64px;
            height: 64px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto var(--space-6);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }
        
        .processing-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-3);
        }
        
        .processing-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           KEYBOARD HINTS
           ═══════════════════════════════════════════════════════════ */
        #keyboard-hints {
            position: fixed;
            bottom: calc(var(--space-5) + 70px + 80px);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-4);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--duration-fast);
        }
        
        #keyboard-hints.visible {
            opacity: 1;
        }
        
        .key-hint {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .key-hint kbd {
            font-family: var(--font-mono);
            font-size: 11px;
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           LOADING STATE
           ═══════════════════════════════════════════════════════════ */
        #loading {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: var(--bg-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slow);
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            text-align: center;
        }
        
        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--glass-border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-4);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loader-text {
            font-family: var(--font-display);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           THEME PICKER
           ═══════════════════════════════════════════════════════════ */
        #theme-picker {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-3);
            display: none;
            flex-direction: column;
            gap: var(--space-2);
            box-shadow: var(--shadow-lg);
        }
        
        #theme-picker.active {
            display: flex;
            animation: fadeIn var(--duration-fast);
        }
        
        .theme-option {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .theme-option:hover {
            background: var(--bg-elevated);
        }
        
        .theme-option.active {
            background: var(--accent);
            color: white;
        }
        
        .theme-preview {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            overflow: hidden;
        }
        
        .theme-preview span {
            flex: 1;
        }
        
        .theme-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* ═══════════════════════════════════════════════════════════
           MENU DROPDOWN
           ═══════════════════════════════════════════════════════════ */
        #menu-dropdown {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-2);
            min-width: 180px;
            display: none;
            box-shadow: var(--shadow-lg);
        }
        
        #menu-dropdown.active {
            display: block;
            animation: fadeIn var(--duration-fast);
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .menu-item:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .menu-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .menu-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-2) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           RESPONSIVE DESIGN
           ═══════════════════════════════════════════════════════════ */
        @media (max-width: 768px) {
            :root {
                --space-5: 16px;
                --space-6: 20px;
            }
            
            /* Hide quick capture on mobile */
            #quick-capture {
                display: none !important;
            }
            
            /* Toolbar slides up from bottom right on mobile */
            #side-panel {
                top: auto;
                bottom: 0;
                right: 0;
                transform: translateY(0);
                flex-direction: column;
                padding: var(--space-2);
                padding-bottom: var(--space-3);
                gap: var(--space-1);
                border-top-left-radius: 20px;
                border-top-right-radius: 0;
                border-bottom-left-radius: 0;
                border-bottom-right-radius: 0;
                transition: transform 0.3s ease, opacity 0.3s ease, bottom 0.3s ease, border-bottom-left-radius 0.3s ease;
                max-height: 75vh;
                overflow-y: auto;
            }
            
            #side-panel.collapsed {
                transform: translateY(calc(100% + 20px));
                opacity: 0;
                pointer-events: none;
            }
            
            /* Slide toolbar up when info panel is visible */
            #side-panel.info-visible {
                bottom: 180px;
                border-bottom-left-radius: 20px;
            }
            
            #toolbar-toggle {
                display: flex !important;
                align-items: center;
                justify-content: center;
                transition: opacity 0.2s ease, transform 0.2s ease, bottom 0.3s ease;
                bottom: 12px;
                right: 12px;
            }
            
            /* Move toggle up when info panel is visible */
            #toolbar-toggle.info-visible {
                bottom: 192px;
            }
            
            #toolbar-toggle.active {
                opacity: 0;
                pointer-events: none;
                transform: scale(0.8);
            }
            
            /* Toggle button inside toolbar */
            #side-panel .toolbar-close {
                display: flex !important;
                margin-top: 8px;
                background: var(--accent);
                color: white;
                border-radius: 10px;
            }
            
            #side-panel .toolbar-close:hover {
                filter: brightness(1.1);
            }
            
            /* Keep same styling as desktop - no labels, no column layout */
            #side-panel .side-btn {
                flex-direction: column;
                padding: var(--space-2) var(--space-3);
            }
            
            /* Hide labels on mobile - same as desktop */
            #side-panel .side-btn-label {
                display: none !important;
            }
            
            /* Hide dividers on mobile */
            .side-divider {
                display: none;
            }
            
            #info-panel {
                bottom: 140px; /* Above collapsed sheet (130px) + spacing */
                width: calc(100vw - 32px);
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                transition: bottom 0.3s var(--ease-out), opacity var(--duration-normal) var(--ease-out), transform var(--duration-normal) var(--ease-out);
                z-index: 290; /* Below sheet so sheet can slide over it */
            }

            #info-panel.active {
                transform: translateX(-50%) translateY(0);
            }

            /* Adjust info panel based on sheet state */
            body.sheet-minimized #info-panel {
                bottom: 80px; /* Above minimized sheet */
            }

            /* Info panel stays in place - sheet slides over it */
            body.sheet-expanded #info-panel {
                /* Keep same position, sheet covers it */
            }
            
            #keyboard-hints {
                display: none !important;
            }
        }
        
        /* Link Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        /* Custom Confirm Modal */
        .confirm-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            padding: 20px;
            animation: fadeIn 0.2s var(--ease-out);
        }
        
        .confirm-modal-overlay.active {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .confirm-modal {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 100%;
            max-width: 300px;
            padding: 24px 20px 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: scaleIn 0.25s var(--ease-spring);
        }
        
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .confirm-modal-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .confirm-modal-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--text-secondary);
        }
        
        .confirm-modal-icon.danger {
            background: rgba(239, 68, 68, 0.1);
        }
        
        .confirm-modal-icon.danger svg {
            stroke: #EF4444;
        }
        
        .confirm-modal-title {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        
        .confirm-modal-message {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 20px;
        }
        
        .confirm-modal-actions {
            display: flex;
            gap: 10px;
        }
        
        .confirm-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s var(--ease-out);
            border: none;
        }
        
        .confirm-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .confirm-btn-cancel:hover {
            background: var(--bg-elevated);
        }
        
        .confirm-btn-confirm {
            background: #EF4444;
            color: white;
        }
        
        .confirm-btn-confirm:hover {
            background: #DC2626;
        }
        
        .confirm-btn-confirm.primary {
            background: var(--accent);
        }
        
        .confirm-btn-confirm.primary:hover {
            filter: brightness(1.1);
        }
        
        .link-modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        .link-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .link-modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }
        
        .link-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-tertiary);
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .link-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-input-group {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .link-input-group label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .link-input-group input {
            flex: 1;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .link-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .link-fetch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .link-fetch-btn:hover {
            filter: brightness(1.1);
        }
        
        .link-preview {
            padding: 0 20px 20px;
        }
        
        .link-preview-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 24px;
            color: var(--text-tertiary);
            font-size: 13px;
        }
        
        .link-preview-content {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .link-preview-image {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--bg-tertiary);
            flex-shrink: 0;
        }
        
        .link-preview-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }
        
        .link-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border: none;
            background: transparent;
            padding: 0;
            width: 100%;
        }
        
        .link-preview-title:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-description {
            font-size: 12px;
            color: var(--text-secondary);
            border: none;
            background: transparent;
            padding: 0;
            resize: none;
            font-family: inherit;
        }
        
        .link-preview-description:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-source {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .link-preview-source img {
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        
        .link-transcript-status {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-transcript-status .spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .link-category {
            padding: 0 20px 20px;
        }
        
        .link-category label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
        }
        
        .link-category-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 2px solid var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .link-category-suggestion:hover {
            background: var(--bg-tertiary);
        }
        
        .link-category-suggestion.selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        .link-category-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .link-category-confidence {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .link-category-alt {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .link-category-alt-item {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .link-category-alt-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-category-alt-item.selected {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .link-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        
        .link-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .link-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .link-btn.primary {
            background: var(--accent);
            color: white;
        }
        
        .link-btn.primary:hover:not(:disabled) {
            filter: brightness(1.1);
        }
        
        .link-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Link indicator on nodes */
        .node-link-indicator {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .node-link-indicator svg {
            width: 10px;
            height: 10px;
            stroke: white;
        }
        
        /* ═══════════════════════════════════════════════════════════
           AI CHAT PANEL
           ═══════════════════════════════════════════════════════════ */
        #ai-chat-panel {
            position: fixed;
            right: -420px;
            top: 0;
            bottom: 0;
            width: 400px;
            max-width: calc(100vw - 20px);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            z-index: var(--z-modal);
            transition: right 0.35s var(--ease-out);
            box-shadow: -10px 0 40px rgba(0, 0, 0, 0.15);
        }
        
        #ai-chat-panel.open {
            right: 0;
        }
        
        /* Slide toggle button on left edge of chat panel */
        .chat-slide-toggle {
            position: absolute;
            left: -16px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 48px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .chat-slide-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            width: 20px;
            left: -20px;
        }
        
        .chat-slide-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
        }
        
        #ai-chat-panel.open .chat-slide-toggle svg {
            transform: rotate(180deg);
        }
        
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chat-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-icon svg {
            stroke: var(--accent);
        }
        
        .chat-title {
            font-family: var(--font-display);
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        
        .chat-header-actions {
            display: flex;
            gap: 8px;
        }
        
        .chat-header-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Hidden on desktop, shown on mobile via media query */
        .chat-mobile-close {
            display: none;
        }
        
        .chat-header-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .chat-header-btn.active {
            background: var(--accent);
            color: white;
        }
        
        .chat-header-btn.active:hover {
            background: var(--accent);
            filter: brightness(1.1);
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .chat-welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 40px 20px;
            gap: 12px;
        }
        
        .chat-welcome-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 8px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-welcome-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--accent);
        }
        
        .chat-title {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .chat-welcome-text {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.5;
            max-width: 280px;
        }
        
        .chat-welcome-examples {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
            max-width: 300px;
        }
        
        .chat-example-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        .chat-example-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        
        /* Message Bubbles */
        .chat-message {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 85%;
            animation: messageSlide 0.3s var(--ease-out);
        }
        
        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chat-message.user {
            align-self: flex-end;
        }
        
        .chat-message.assistant {
            align-self: flex-start;
        }
        
        .chat-bubble {
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 0.95rem;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .chat-message.user .chat-bubble {
            background: var(--accent);
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.assistant .chat-bubble {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
        }
        
        .chat-message-time {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0 4px;
        }
        
        .chat-message.user .chat-message-time {
            text-align: right;
        }
        
        /* Action indicators in messages */
        .chat-actions-indicator {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--glass-border);
        }
        
        .chat-action-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .chat-action-item.success {
            color: #26DE81;
        }
        
        .chat-action-item.warning {
            color: #F7B731;
        }
        
        .chat-action-item.error {
            color: #EF4444;
        }
        
        .chat-action-item.pending {
            color: var(--accent);
        }
        
        .chat-action-icon {
            font-size: 0.9em;
        }
        
        /* Typing indicator */
        .chat-typing {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            border-bottom-left-radius: 4px;
            width: fit-content;
        }
        
        .chat-typing-dot {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }
        
        .chat-typing-dot:nth-child(1) { animation-delay: 0s; }
        .chat-typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .chat-typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }
        
        /* Quick Suggestions */
        .chat-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 20px;
            border-top: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-suggestion-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 8px 14px;
            font-size: 0.85rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-suggestion-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        /* Input Area */
        .chat-input-area {
            padding: 16px 20px;
            border-top: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-input-container {
            position: relative;
            display: flex;
            align-items: flex-end;
            gap: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 8px 12px;
            transition: border-color 0.2s;
        }
        
        .chat-input-container:focus-within {
            border-color: var(--accent);
        }
        
        .chat-input-container:has(.chat-voice-overlay.active),
        .chat-input-container.recording {
            border-color: #EF4444;
        }
        
        #chat-input {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 0.95rem;
            resize: none;
            max-height: 120px;
            line-height: 1.4;
            padding: 4px 0;
        }
        
        #chat-input::placeholder {
            color: var(--text-muted);
        }
        
        #chat-input:focus {
            outline: none;
        }
        
        .chat-voice-btn,
        .chat-send-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-voice-btn:hover,
        .chat-send-btn:hover:not(:disabled) {
            color: var(--accent);
            background: var(--bg-tertiary);
        }
        
        .chat-send-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .chat-send-btn:not(:disabled) {
            color: var(--accent);
        }
        
        .chat-voice-btn.recording {
            color: #EF4444;
            background: rgba(239, 68, 68, 0.1);
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        .chat-voice-btn.processing {
            color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        @keyframes voicePulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }
        
        /* Voice recording overlay in chat input */
        .chat-voice-overlay {
            position: absolute;
            inset: 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .chat-voice-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .chat-voice-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chat-voice-bars {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 24px;
        }
        
        .chat-voice-bar {
            width: 3px;
            height: 8px;
            background: #EF4444;
            border-radius: 2px;
            animation: voiceBar 0.8s ease-in-out infinite;
        }
        
        .chat-voice-bar:nth-child(1) { animation-delay: 0s; }
        .chat-voice-bar:nth-child(2) { animation-delay: 0.1s; }
        .chat-voice-bar:nth-child(3) { animation-delay: 0.2s; }
        .chat-voice-bar:nth-child(4) { animation-delay: 0.3s; }
        .chat-voice-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes voiceBar {
            0%, 100% { height: 8px; }
            50% { height: 20px; }
        }
        
        .chat-voice-status {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .chat-voice-status.recording {
            color: #EF4444;
        }
        
        .chat-voice-status.processing {
            color: var(--accent);
        }
        
        .chat-voice-cancel {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-voice-cancel:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .chat-input-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-align: center;
        }
        
        .chat-hint-key {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.7rem;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            #ai-chat-panel {
                width: 100%;
                max-width: 100%;
                right: -100%;
            }
            
            #ai-chat-panel.open {
                right: 0;
            }
            
            .chat-slide-toggle {
                display: none;
            }
            
            /* Mobile close button in chat header */
            .chat-mobile-close {
                display: flex !important;
                margin-right: 8px;
            }
            
            body.chat-open #side-panel {
                right: var(--space-3);
            }
            
            .chat-welcome-examples {
                max-width: 100%;
            }
        }
        
        /* ═══════════════════════════════════════════════════════════
           MOBILE BOTTOM SHEET UI - Input-First Design
           Only applies to mobile (max-width: 768px)
           ═══════════════════════════════════════════════════════════ */
        
        /* Hide mobile bottom sheet on desktop */
        #mobile-bottom-sheet {
            display: none;
        }
        
        @media (max-width: 768px) {
            /* Show mobile bottom sheet, hide old mobile UI */
            #mobile-bottom-sheet {
                display: flex;
            }
            
            /* Hide old mobile toolbar */
            #toolbar-toggle {
                display: none !important;
            }
            
            #side-panel {
                display: none !important;
            }
            
            /* Hide desktop chat panel on mobile - use bottom sheet instead */
            #ai-chat-panel {
                display: none !important;
            }
            
            /* Simplify header for mobile */
            .brand {
                padding: var(--space-2);
            }
            
            .brand-subtitle {
                display: none;
            }
            
            /* Mobile Bottom Sheet Container - frosted glass with subtle glow */
            #mobile-bottom-sheet {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: var(--z-modal);
                flex-direction: column;
                background: rgba(22, 22, 30, 0.88);
                backdrop-filter: blur(40px) saturate(180%);
                -webkit-backdrop-filter: blur(40px) saturate(180%);
                border-top: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 24px 24px 0 0;
                box-shadow: 0 0 40px rgba(255, 255, 255, 0.04);
                transition: transform 0.3s var(--ease-out), height 0.3s var(--ease-out);
                min-height: 130px;
                max-height: 85vh;
                touch-action: none;
            }
            
            #mobile-bottom-sheet.expanded {
                height: 85vh;
            }
            
            /* Collapsed state - shows drag handle and quick actions */
            #mobile-bottom-sheet.collapsed {
                transform: translateY(calc(100% - 130px));
            }
            
            /* Minimized state - almost hidden, just grab line visible with safe area */
            #mobile-bottom-sheet.minimized {
                transform: translateY(calc(100% - 70px));
            }
            
            #mobile-bottom-sheet.minimized .sheet-quick-actions,
            #mobile-bottom-sheet.minimized .sheet-mini-toolbar {
                opacity: 0;
                pointer-events: none;
            }

            /* Keep gear toggle visible when minimized */
            #mobile-bottom-sheet.minimized .sheet-map-toggle {
                opacity: 1;
                pointer-events: auto;
            }
            
            /* Drag Handle - Waze style */
            .sheet-drag-handle {
                width: 100%;
                padding: 16px 0 20px;
                display: flex;
                justify-content: center;
                cursor: grab;
                touch-action: none;
                /* Larger hit area */
                min-height: 44px;
            }
            
            .sheet-drag-handle::before {
                content: '';
                width: 40px;
                height: 5px;
                background: var(--text-secondary);
                border-radius: 3px;
                opacity: 0.7;
                transition: opacity 0.2s, width 0.2s;
            }
            
            .sheet-drag-handle:active::before {
                opacity: 1;
                width: 50px;
            }
            
            /* Quick Actions Row - visible in collapsed state */
            .sheet-quick-actions {
                display: flex;
                justify-content: space-around;
                padding: var(--space-3) var(--space-4) var(--space-4);
                gap: var(--space-2);
                align-items: flex-end;
            }
            
            .sheet-quick-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: var(--space-2) var(--space-3);
                background: none;
                border: none;
                border-radius: 12px;
                color: var(--text-secondary);
                cursor: pointer;
                transition: all 0.2s;
                min-width: 60px;
            }
            
            .sheet-quick-btn:hover {
                background: var(--bg-elevated);
                color: var(--text-primary);
            }
            
            .sheet-quick-btn:active {
                transform: scale(0.95);
            }
            
            .sheet-quick-btn svg {
                width: 24px;
                height: 24px;
            }
            
            .sheet-quick-btn span {
                font-size: 10px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }
            
            /* Memo button - orange */
            .sheet-quick-btn.orange {
                color: var(--accent);
            }
            
            .sheet-quick-btn.orange svg {
                stroke: var(--accent);
            }
            
            .sheet-quick-btn.teal svg {
                stroke: #2dd4bf;
            }
            
            .sheet-quick-btn.purple svg {
                stroke: #a78bfa;
            }
            
            .sheet-quick-btn.voice-btn {
                background: linear-gradient(135deg, var(--accent), #f97316);
                color: white;
                padding: var(--space-3);
                border-radius: 50%;
                min-width: auto;
                width: 60px;
                height: 60px;
                box-shadow: 0 4px 15px rgba(251, 146, 60, 0.4);
                margin-top: -10px;
            }
            
            .sheet-quick-btn.voice-btn svg {
                width: 28px;
                height: 28px;
                stroke: white;
            }
            
            .sheet-quick-btn.voice-btn span {
                display: none;
            }
            
            .sheet-quick-btn.voice-btn:hover {
                transform: scale(1.05);
                background: linear-gradient(135deg, var(--accent), #f97316);
            }
            
            .sheet-quick-btn.voice-btn.recording {
                animation: pulse-recording 1s ease-in-out infinite;
                box-shadow: 0 4px 20px rgba(251, 146, 60, 0.6);
            }
            
            /* Mini Map Toolbar Toggle - top right corner of sheet */
            .sheet-map-toggle {
                position: absolute;
                right: var(--space-3);
                top: var(--space-3);
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background: var(--bg-secondary);
                border: 1px solid var(--glass-border);
                color: var(--text-secondary);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s;
                z-index: 5;
            }
            
            .sheet-map-toggle:hover {
                background: var(--bg-elevated);
                color: var(--text-primary);
            }
            
            .sheet-map-toggle.active {
                background: var(--accent);
                color: white;
                border-color: var(--accent);
            }
            
            .sheet-map-toggle svg {
                width: 16px;
                height: 16px;
            }
            
            /* Mini Map Toolbar - floats above sheet */
            .sheet-mini-toolbar {
                position: absolute;
                right: var(--space-3);
                top: -10px;
                transform: translateY(-100%);
                background: var(--glass-bg);
                backdrop-filter: blur(16px);
                border: 1px solid var(--glass-border);
                border-radius: 12px;
                padding: var(--space-2);
                display: flex;
                flex-direction: column;
                gap: var(--space-1);
                opacity: 0;
                pointer-events: none;
                transition: all 0.2s var(--ease-out);
                box-shadow: var(--shadow-lg);
                z-index: 10;
            }
            
            .sheet-mini-toolbar.visible {
                opacity: 1;
                pointer-events: auto;
            }
            
            .sheet-mini-toolbar-btn {
                display: flex;
                align-items: center;
                gap: var(--space-2);
                padding: var(--space-2) var(--space-3);
                background: none;
                border: none;
                border-radius: 8px;
                color: var(--text-secondary);
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s;
                white-space: nowrap;
            }
            
            .sheet-mini-toolbar-btn:hover {
                background: var(--bg-elevated);
                color: var(--text-primary);
            }
            
            .sheet-mini-toolbar-btn:active {
                transform: scale(0.95);
            }
            
            .sheet-mini-toolbar-btn svg {
                width: 16px;
                height: 16px;
                flex-shrink: 0;
            }
            
            .sheet-mini-toolbar-btn.active {
                color: var(--accent);
            }
            
            /* Hide mini toolbar when expanded */
            #mobile-bottom-sheet.expanded .sheet-mini-toolbar,
            #mobile-bottom-sheet.expanded .sheet-map-toggle {
                display: none;
            }
            
            /* Hide quick actions when expanded, show full UI */
            #mobile-bottom-sheet.expanded .sheet-quick-actions {
                display: none;
            }
            
            #mobile-bottom-sheet:not(.expanded) .sheet-header,
            #mobile-bottom-sheet:not(.expanded) .sheet-tabs,
            #mobile-bottom-sheet:not(.expanded) .sheet-content {
                display: none;
            }
            
            /* Sheet Header with Quick Input */
            .sheet-header {
                padding: 0 var(--space-4) var(--space-3);
                border-bottom: 1px solid var(--glass-border);
            }
            
            .sheet-input-container {
                display: flex;
                gap: var(--space-2);
                align-items: center;
                background: var(--bg-secondary);
                border-radius: 16px;
                padding: var(--space-2) var(--space-3);
                border: 1px solid var(--glass-border);
            }
            
            .sheet-input-container:focus-within {
                border-color: var(--accent);
                box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.15);
            }
            
            .sheet-voice-btn {
                width: 44px;
                height: 44px;
                border-radius: 50%;
                background: linear-gradient(135deg, var(--accent), #f97316);
                border: none;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
                transition: all 0.2s;
                box-shadow: 0 2px 8px rgba(251, 146, 60, 0.3);
            }
            
            .sheet-voice-btn:hover {
                transform: scale(1.05);
            }
            
            .sheet-voice-btn:active {
                transform: scale(0.95);
            }
            
            .sheet-voice-btn.recording {
                animation: pulse-recording 1s ease-in-out infinite;
            }
            
            .sheet-voice-btn svg {
                width: 22px;
                height: 22px;
            }
            
            .sheet-text-input {
                flex: 1;
                background: none;
                border: none;
                color: var(--text-primary);
                font-size: 16px;
                padding: var(--space-2);
                outline: none;
                min-width: 0;
            }
            
            .sheet-text-input::placeholder {
                color: var(--text-tertiary);
            }
            
            .sheet-send-btn {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background: var(--accent);
                border: none;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                flex-shrink: 0;
                opacity: 0.5;
                transition: all 0.2s;
            }
            
            .sheet-send-btn:not(:disabled) {
                opacity: 1;
            }
            
            .sheet-send-btn:not(:disabled):hover {
                transform: scale(1.05);
            }
            
            .sheet-send-btn svg {
                width: 18px;
                height: 18px;
            }
            
            /* Sheet Tabs */
            .sheet-tabs {
                display: flex;
                padding: var(--space-2) var(--space-4);
                gap: var(--space-2);
                border-bottom: 1px solid var(--glass-border);
            }
            
            .sheet-tab {
                flex: 1;
                padding: var(--space-2) var(--space-3);
                background: none;
                border: none;
                border-radius: 10px;
                color: var(--text-secondary);
                font-size: 13px;
                font-weight: 500;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                transition: all 0.2s;
            }
            
            .sheet-tab:hover {
                background: var(--bg-elevated);
            }
            
            .sheet-tab.active {
                background: var(--accent);
                color: white;
            }
            
            .sheet-tab svg {
                width: 16px;
                height: 16px;
            }
            
            /* Sheet Content Area */
            .sheet-content {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                padding: var(--space-3) var(--space-4);
                display: none;
            }
            
            .sheet-content.active {
                display: block;
            }
            
            /* Chat Tab Content */
            .sheet-chat-messages {
                display: flex;
                flex-direction: column;
                gap: var(--space-3);
                padding-bottom: var(--space-4);
            }
            
            .sheet-chat-welcome {
                text-align: center;
                padding: var(--space-6) var(--space-4);
                color: var(--text-secondary);
            }
            
            .sheet-chat-welcome-icon {
                width: 48px;
                height: 48px;
                margin: 0 auto var(--space-3);
                background: var(--bg-elevated);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .sheet-chat-welcome-icon svg {
                width: 24px;
                height: 24px;
                stroke: var(--accent);
            }
            
            .sheet-chat-welcome h3 {
                color: var(--text-primary);
                font-size: 16px;
                margin-bottom: var(--space-2);
            }
            
            .sheet-chat-welcome p {
                font-size: 14px;
                line-height: 1.5;
            }
            
            .sheet-suggestions {
                display: flex;
                flex-wrap: wrap;
                gap: var(--space-2);
                margin-top: var(--space-4);
                justify-content: center;
            }
            
            .sheet-suggestion {
                padding: var(--space-2) var(--space-3);
                background: var(--bg-secondary);
                border: 1px solid var(--glass-border);
                border-radius: 20px;
                color: var(--text-secondary);
                font-size: 13px;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .sheet-suggestion:hover {
                background: var(--bg-elevated);
                color: var(--text-primary);
                border-color: var(--accent);
            }
            
            /* Recent Tab Content */
            .sheet-recent-list {
                display: flex;
                flex-direction: column;
                gap: var(--space-2);
            }
            
            .sheet-recent-item {
                display: flex;
                align-items: center;
                gap: var(--space-3);
                padding: var(--space-3);
                background: var(--bg-secondary);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .sheet-recent-item:hover {
                background: var(--bg-elevated);
            }
            
            .sheet-recent-icon {
                width: 36px;
                height: 36px;
                border-radius: 10px;
                background: var(--accent);
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            }
            
            .sheet-recent-icon svg {
                width: 18px;
                height: 18px;
                stroke: white;
            }
            
            .sheet-recent-info {
                flex: 1;
                min-width: 0;
            }
            
            .sheet-recent-title {
                font-size: 14px;
                font-weight: 500;
                color: var(--text-primary);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .sheet-recent-meta {
                font-size: 12px;
                color: var(--text-tertiary);
                margin-top: 2px;
            }
            
            .sheet-recent-empty {
                text-align: center;
                padding: var(--space-6);
                color: var(--text-tertiary);
            }
            
            /* Tools Tab Content */
            .sheet-tools-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: var(--space-3);
            }
            
            .sheet-tool {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: var(--space-2);
                padding: var(--space-4) var(--space-2);
                background: var(--bg-secondary);
                border-radius: 16px;
                cursor: pointer;
                transition: all 0.2s;
                border: 1px solid transparent;
            }
            
            .sheet-tool:hover {
                background: var(--bg-elevated);
                border-color: var(--glass-border);
            }
            
            .sheet-tool:active {
                transform: scale(0.95);
            }
            
            .sheet-tool-icon {
                width: 44px;
                height: 44px;
                border-radius: 12px;
                background: var(--bg-elevated);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .sheet-tool-icon svg {
                width: 22px;
                height: 22px;
                stroke: var(--text-secondary);
            }
            
            .sheet-tool-icon.accent svg {
                stroke: var(--accent);
            }
            
            .sheet-tool-icon.teal svg {
                stroke: #2dd4bf;
            }
            
            .sheet-tool-icon.purple svg {
                stroke: #a78bfa;
            }
            
            .sheet-tool-label {
                font-size: 11px;
                font-weight: 500;
                color: var(--text-secondary);
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }
            
            /* Map Tab - Shows mini controls for map interaction */
            .sheet-map-controls {
                display: flex;
                flex-direction: column;
                gap: var(--space-4);
            }
            
            .sheet-map-info {
                text-align: center;
                padding: var(--space-3);
                background: var(--bg-secondary);
                border-radius: 12px;
            }
            
            .sheet-map-info p {
                color: var(--text-secondary);
                font-size: 13px;
            }
            
            .sheet-map-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: var(--space-3);
            }
            
            .sheet-map-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: var(--space-2);
                padding: var(--space-4);
                background: var(--bg-secondary);
                border: none;
                border-radius: 12px;
                color: var(--text-primary);
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s;
            }
            
            .sheet-map-btn:hover {
                background: var(--bg-elevated);
            }
            
            .sheet-map-btn svg {
                width: 20px;
                height: 20px;
            }
            
            /* Message bubbles in sheet chat */
            .sheet-message {
                max-width: 85%;
                padding: var(--space-3);
                border-radius: 16px;
                font-size: 14px;
                line-height: 1.5;
            }
            
            .sheet-message.user {
                align-self: flex-end;
                background: var(--accent);
                color: white;
                border-bottom-right-radius: 4px;
            }
            
            .sheet-message.assistant {
                align-self: flex-start;
                background: var(--bg-secondary);
                color: var(--text-primary);
                border-bottom-left-radius: 4px;
            }
            
            .sheet-message.thinking {
                display: flex;
                gap: 4px;
                padding: var(--space-3) var(--space-4);
            }
            
            .sheet-message.thinking span {
                width: 8px;
                height: 8px;
                background: var(--text-tertiary);
                border-radius: 50%;
                animation: thinking-dot 1.4s ease-in-out infinite;
            }
            
            .sheet-message.thinking span:nth-child(2) {
                animation-delay: 0.2s;
            }
            
            .sheet-message.thinking span:nth-child(3) {
                animation-delay: 0.4s;
            }
            
            @keyframes thinking-dot {
                0%, 80%, 100% {
                    transform: scale(1);
                    opacity: 0.4;
                }
                40% {
                    transform: scale(1.2);
                    opacity: 1;
                }
            }
        }
        
        /* ═══════════════════════════════════════════════════════════
           MOBILE PERFORMANCE OPTIMIZATIONS
           Disable expensive effects on mobile devices
           ═══════════════════════════════════════════════════════════ */
        @media (max-width: 768px) {
            /* Disable all backdrop-filter for performance */
            *, *::before, *::after {
                backdrop-filter: none !important;
                -webkit-backdrop-filter: none !important;
            }
            
            /* Use solid backgrounds instead of blur */
            .glass, [class*="glass"] {
                background: var(--bg-secondary) !important;
            }
            
            #mobile-bottom-sheet {
                background: var(--bg-primary) !important;
            }
            
            #neural-panel,
            #ai-chat-panel,
            #api-key-modal,
            #auth-modal,
            .modal-overlay,
            .modal-content,
            .toast,
            .confirm-modal {
                background: var(--bg-secondary) !important;
            }
            
            /* Reduce animations */
            .nebula, .nebula-1, .nebula-2, .nebula-3 {
                display: none !important;
            }
            
            /* Disable expensive shadows on some elements */
            .sheet-quick-btn.voice-btn {
                box-shadow: none !important;
            }
            
            /* Force neural panel visibility when active */
            #neural-panel.active {
                visibility: visible !important;
                display: block !important;
                pointer-events: auto !important;
                transform: translateY(0) !important;
            }
        }
        
        /* Further optimizations for low-power mode / older devices */
        @media (max-width: 768px) and (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- Ambient Background -->
    <div id="ambient-bg">
        <div class="nebula nebula-1"></div>
        <div class="nebula nebula-2"></div>
        <div class="nebula nebula-3"></div>
    </div>
    <div id="particle-bg"></div>
    
    <!-- 3D Canvas -->
    <div id="canvas-container" role="application" aria-label="3D mind map visualization - use mouse to rotate, scroll to zoom"></div>
    
    <!-- Focus Mode Overlay -->
    <div id="focus-overlay"></div>
    
    <!-- Loading -->
    <div id="loading">
        <div class="loader">
            <div class="loader-spinner"></div>
            <div class="loader-text">Loading your mind...</div>
        </div>
    </div>
    
    <!-- Onboarding -->
    <div id="onboarding-overlay" style="display: flex;">
        <!-- User avatar for login access -->
        <button class="onboarding-avatar" id="onboarding-avatar" aria-label="Sign in or view account">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                <circle cx="12" cy="7" r="4"/>
            </svg>
        </button>
        
        <!-- Welcome Screen -->
        <div class="onboarding-content" id="onboarding-welcome">
            <div class="onboarding-logo">M</div>
            <h1 class="onboarding-title">Welcome to MYND</h1>
            <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
            <div class="onboarding-input-wrapper">
                <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
            </div>
            <div class="onboarding-choices" id="onboarding-choices">
                <div class="onboarding-choice ai" id="onboarding-ai">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                    </div>
                    <div class="onboarding-choice-title">AI-Assisted Setup</div>
                    <div class="onboarding-choice-desc">Answer a few questions and let AI build your map</div>
                </div>
                <div class="onboarding-choice scratch" id="onboarding-scratch">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    </div>
                    <div class="onboarding-choice-title">Start from Scratch</div>
                    <div class="onboarding-choice-desc">Begin with a simple template</div>
                </div>
                <div class="onboarding-choice load" id="onboarding-load">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                            <polyline points="12 11 12 17"/>
                            <polyline points="9 14 12 11 15 14"/>
                        </svg>
                    </div>
                    <div class="onboarding-choice-title">Load Saved Map</div>
                    <div class="onboarding-choice-desc">Continue where you left off</div>
                </div>
            </div>
        </div>
        
        <!-- Questionnaire -->
        <div class="onboarding-questionnaire" id="onboarding-questionnaire">
            <div class="question-header">
                <div class="question-logo">M</div>
                <div class="question-progress">
                    <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                    <div class="question-progress-bar">
                        <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                    </div>
                </div>
            </div>
            <div class="question-text" id="question-text">What's one goal you want to make real progress on in the next 30 days?</div>
            <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
            <div class="question-actions">
                <span class="question-skip" id="question-skip-btn">Skip this question</span>
                <div class="question-nav">
                    <button class="question-btn secondary" id="question-back" style="display: none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                        Back
                    </button>
                    <button class="question-btn primary" id="question-next">
                        Next
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Processing -->
        <div class="onboarding-processing" id="onboarding-processing">
            <div class="processing-spinner"></div>
            <div class="processing-title">Building your mind map...</div>
            <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
        </div>
    </div>
    
    <!-- Header -->
    <div id="header">
        <div class="brand">
            <div class="brand-logo">M</div>
            <div class="brand-text">
                <h1>MYND</h1>
                <p>Mind Architect</p>
            </div>
        </div>
    </div>

    <!-- Version indicator for testing -->
    <div id="version-indicator" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(99, 102, 241, 0.9); color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; z-index: 10000; font-family: system-ui, sans-serif;">V3.27</div>

    <!-- Mobile Header (replaces header and top-controls on mobile) -->
    <div id="mobile-header">
        <!-- Top: Small centered MYND branding -->
        <div class="mobile-header-brand" id="mobile-brand-btn">
            <div class="mobile-brand-logo">M</div>
            <span class="mobile-brand-text">MYND</span>
        </div>

        <!-- Search bar pill with integrated controls -->
        <div class="mobile-search-bar">
            <!-- Left: Menu button (circle) -->
            <button class="mobile-search-menu" id="mobile-menu-btn" aria-label="Menu">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="4" y1="6" x2="20" y2="6"/>
                    <line x1="4" y1="12" x2="20" y2="12"/>
                    <line x1="4" y1="18" x2="20" y2="18"/>
                </svg>
            </button>

            <!-- Center: Search input -->
            <input type="text" class="mobile-search-input" id="mobile-search-input" placeholder="Search Nodes..." autocomplete="off" />

            <!-- Right: User avatar (circle) -->
            <button class="mobile-search-user" id="mobile-user-btn" aria-label="Account">
                <div class="mobile-user-avatar" id="mobile-user-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                </div>
                <div class="mobile-sync-indicator" id="mobile-sync-indicator"></div>
            </button>
        </div>
    </div>

    <!-- Floating Action Buttons (right side, below search bar) -->
    <div id="mobile-floating-actions">
        <button class="mobile-fab" id="mobile-undo-btn" aria-label="Undo" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
            </svg>
        </button>
        <button class="mobile-fab goal-fab" id="mobile-goal-btn" aria-label="Create Goal">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <circle cx="12" cy="12" r="6"/>
                <circle cx="12" cy="12" r="2"/>
            </svg>
        </button>
        <button class="mobile-fab" id="mobile-theme-btn" aria-label="Theme">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/>
            </svg>
        </button>
    </div>
    
    <!-- Mobile Zoom Slider (minimal scrollbar style) -->
    <div id="mobile-zoom-slider">
        <div class="zoom-thumb" id="mobile-zoom-thumb"></div>
    </div>
    
    <!-- Top Controls -->
    <div id="top-controls">
        <div id="user-account-wrapper">
            <button class="icon-btn" id="user-account-btn" title="Account" aria-label="Account">
                <div class="user-avatar" id="user-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                </div>
                <div id="sync-indicator" title="Offline mode"></div>
            </button>
        </div>
        <button class="icon-btn" id="theme-btn" title="Theme" aria-label="Change color theme">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/></svg>
        </button>
        <button class="icon-btn" id="menu-btn" title="Menu" aria-label="Open menu">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
        <button class="icon-btn goal-btn" id="goal-btn" title="Create Goal" aria-label="Create a new goal">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>
        </button>
        <button class="icon-btn" id="undo-btn" title="Undo" aria-label="Undo last action" disabled>
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
        </button>
    </div>
    
    <!-- User Dropdown (outside top-controls for mobile visibility) -->
    <div id="user-dropdown">
        <!-- Logged in state -->
        <div id="user-dropdown-loggedin" style="display: none;">
            <div class="user-dropdown-header">
                <div class="user-dropdown-email" id="user-dropdown-email">user@email.com</div>
                <button class="user-dropdown-signout" id="user-dropdown-signout">Sign out</button>
            </div>
            
            <div class="user-dropdown-section">
                <div class="user-dropdown-section-title">Your Maps</div>
                <div class="user-maps-list" id="user-maps-list">
                    <!-- Maps loaded dynamically -->
                </div>
            </div>
            
            <div class="user-dropdown-actions">
                <button class="user-dropdown-action" id="user-action-new">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    New Map
                </button>
                <button class="user-dropdown-action" id="user-action-import">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Import Map
                </button>
                <button class="user-dropdown-action" id="user-action-export">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    Export Map
                </button>
            </div>
            
            <div class="user-dropdown-sync" id="user-dropdown-sync">
                <span class="user-dropdown-sync-dot synced"></span>
                <span id="user-sync-status">Synced</span>
            </div>
        </div>
        
        <!-- Logged out state -->
        <div id="user-dropdown-loggedout">
            <div class="user-dropdown-offline">
                <div class="user-dropdown-offline-text">
                    Sign in to save your maps to the cloud and access them anywhere
                </div>
                <button class="user-dropdown-signin" id="user-dropdown-signin">Sign In</button>
            </div>
            
            <div class="user-dropdown-actions">
                <button class="user-dropdown-action" id="user-action-import-offline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Import Map
                </button>
                <button class="user-dropdown-action" id="user-action-export-offline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    Export Map
                </button>
            </div>
        </div>
    </div>
    
    <!-- Theme Picker -->
    <div id="theme-picker">
        <div class="theme-option" data-theme="sandstone">
            <div class="theme-preview"><span style="background:#C4978A"></span><span style="background:#F9F7F0"></span></div>
            <span class="theme-name">Sandstone</span>
        </div>
        <div class="theme-option active" data-theme="coral">
            <div class="theme-preview"><span style="background:#E87D7D"></span><span style="background:#FFFFFF"></span></div>
            <span class="theme-name">Coral</span>
        </div>
        <div class="theme-option" data-theme="ember">
            <div class="theme-preview"><span style="background:#E87830"></span><span style="background:#FAF6F0"></span></div>
            <span class="theme-name">Ember</span>
        </div>
        <div class="theme-option" data-theme="frost">
            <div class="theme-preview"><span style="background:#5B8DEF"></span><span style="background:#E8ECF0"></span></div>
            <span class="theme-name">Frost</span>
        </div>
        <div class="theme-option" data-theme="obsidian">
            <div class="theme-preview"><span style="background:#8B5CF6"></span><span style="background:#0A0A0C"></span></div>
            <span class="theme-name">Obsidian</span>
        </div>
    </div>
    
    <!-- Menu Dropdown -->
    <div id="menu-dropdown">
        <div class="menu-item" id="menu-search">
            <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
            Search
        </div>
        <div class="menu-item" id="menu-shortcuts">
            <svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h8M6 16h.01M10 16h.01M14 16h.01M18 16h.01"/></svg>
            Shortcuts
        </div>
        <div class="menu-item" id="menu-settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
            Settings
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-new">
            <svg viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>
            New Map
        </div>
        <div class="menu-item" id="menu-save">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Save Map
        </div>
        <div class="menu-item" id="menu-load">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
            Load Map
        </div>
        <div class="menu-item" id="menu-import-notes">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                <polyline points="14 2 14 8 20 8"/>
                <path d="M8 13h2"/>
                <path d="M8 17h2"/>
                <path d="M14 13h2"/>
                <path d="M14 17h2"/>
            </svg>
            Import Notes
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-help">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
            Help
        </div>
    </div>
    
    <!-- Depth Indicator -->
    <div id="depth-indicator">
        <div class="depth-back" id="depth-back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
        </div>
        <div class="depth-path" id="depth-path"></div>
    </div>
    
    <!-- Side Panel -->
    <button id="toolbar-toggle" onclick="document.getElementById('side-panel').classList.toggle('collapsed'); this.classList.toggle('active')">☰</button>
    <div id="side-panel" role="toolbar" aria-label="Mind map controls">
        <div class="side-btn" id="btn-home" title="Reset View" role="button" aria-label="Reset camera to home view">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
            <span class="side-btn-label">Home</span>
        </div>
        <div class="side-btn" id="btn-expand" title="Expand All" role="button" aria-label="Expand all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
            <span class="side-btn-label">Expand</span>
        </div>
        <div class="side-btn" id="btn-collapse" title="Collapse All" role="button" aria-label="Collapse all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"/></svg>
            <span class="side-btn-label">Collapse</span>
        </div>
        <div class="side-btn active" id="btn-autocam" title="Toggle Auto Camera" role="button" aria-label="Toggle automatic camera movement" aria-pressed="true">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>
            <span class="side-btn-label">Auto Cam</span>
        </div>
        <div class="side-divider" role="separator"></div>
        <div class="side-btn" id="btn-add" title="Add Node" role="button" aria-label="Add new node">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            <span class="side-btn-label">Add</span>
        </div>
        <div class="side-btn" id="btn-link" title="Add Link" role="button" aria-label="Add link from URL">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
            <span class="side-btn-label">Link</span>
        </div>
        <div class="side-btn" id="btn-move" title="Move Mode" role="button" aria-label="Toggle move mode for dragging nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
            <span class="side-btn-label">Move</span>
        </div>
        <div class="side-btn ai-feature" id="btn-voice" title="Voice Memo - Quick AI command" role="button" aria-label="Voice memo">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="12" r="3"/>
                <circle cx="12" cy="12" r="7" opacity="0.5"/>
                <circle cx="12" cy="12" r="10" opacity="0.25"/>
            </svg>
            <span class="side-btn-label">Memo</span>
        </div>
        <div class="side-btn ai-feature" id="btn-chat" title="AI Chat - Ongoing conversation" role="button" aria-label="Open AI chat panel">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M15 5h4a2 2 0 012 2v6a2 2 0 01-2 2h-1l-3 3v-3h-2a2 2 0 01-2-2V7a2 2 0 012-2z"/>
                <path d="M9 13H5a2 2 0 01-2-2V5a2 2 0 012-2h8a2 2 0 012 2v1" opacity="0.5"/>
            </svg>
            <span class="side-btn-label">Chat</span>
        </div>
        <div class="side-btn ai-feature" id="btn-neural" title="Personal Neural Network" role="button" aria-label="Open neural network panel">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="12" rx="10" ry="4"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60 12 12)"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120 12 12)"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>
            <span class="side-btn-label">Neural</span>
        </div>
        <!-- Close button for mobile -->
        <div class="side-btn toolbar-close" id="btn-toolbar-close" onclick="document.getElementById('side-panel').classList.add('collapsed'); document.getElementById('toolbar-toggle').classList.remove('active')" title="Close" role="button" aria-label="Close toolbar">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            <span class="side-btn-label">Close</span>
        </div>
    </div>
    
    <!-- Voice Memo Indicator -->
    <div id="voice-backdrop"></div>
    
    <!-- Canvas Drop Overlay for drag/drop files -->
    <div class="canvas-drop-overlay" id="canvas-drop-overlay">
        <div class="canvas-drop-content">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
            </svg>
            <h3>Drop to attach</h3>
            <p id="canvas-drop-target">Will be added to selected node</p>
        </div>
    </div>
    
    <!-- Lightbox for viewing attachments -->
    <div class="lightbox-overlay" id="lightbox-overlay">
        <button class="lightbox-close" id="lightbox-close">&times;</button>
        <img class="lightbox-content" id="lightbox-image" src="" alt="">
        <div class="lightbox-info">
            <div class="filename" id="lightbox-filename"></div>
            <div class="description" id="lightbox-description"></div>
        </div>
    </div>
    
    <div id="voice-indicator">
        <div class="voice-mode-toggle">
            <button class="voice-mode-btn active" id="voice-mode-speak" title="Speak">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
            </button>
            <button class="voice-mode-btn" id="voice-mode-type" title="Type">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="6" y1="12" x2="18" y2="12"/><line x1="6" y1="16" x2="18" y2="16"/></svg>
            </button>
        </div>
        <div class="voice-icon" id="voice-icon">
            <svg id="voice-icon-mic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            <svg id="voice-icon-brain" style="display:none" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4h.09c.49 0 .97-.07 1.41-.2"/><path d="M12 2a4 4 0 0 1 4 4c0 .74-.2 1.43-.56 2.02A4 4 0 0 1 18 12c0 1.2-.52 2.27-1.35 3A4 4 0 0 1 18 18a4 4 0 0 1-4 4h-.09c-.49 0-.97-.07-1.41-.2"/><path d="M12 2v20"/><path d="M9 10h6"/><path d="M9 14h6"/></svg>
        </div>
        <div class="voice-status" id="voice-status">Listening...</div>
        <div class="voice-transcript" id="voice-transcript">Say something...</div>
        <div class="voice-text-input-wrapper" id="voice-text-wrapper" style="display: none;">
            <textarea id="voice-text-input" placeholder="Describe what you want to add or do..." rows="3"></textarea>
            <button class="voice-text-submit" id="voice-text-submit">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                Send
            </button>
        </div>
        <div class="voice-hint" id="voice-hint">Tap anywhere or press Escape to cancel</div>
        <button class="voice-cancel" id="voice-cancel">Cancel</button>
    </div>
    
    <!-- Settings Modal -->
    <div id="api-key-modal">
        <div class="api-key-content">
            <div class="api-key-title">Settings</div>
            
            <!-- Neural Network Section -->
            <div style="margin-bottom: 20px;">
                <div style="font-size: 12px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Neural Network</div>
                <div class="api-key-desc" id="neural-stats-settings">The neural network learns from your mind map to provide intelligent suggestions and organization.</div>
                <div style="display: flex; gap: 8px; margin-top: 10px;">
                    <button class="api-key-btn primary" id="neural-train-settings-btn" style="flex: 1;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    </button>
                    <button class="api-key-btn secondary" id="neural-reset-settings-btn" style="flex: 1; background: rgba(220, 38, 38, 0.1); border-color: rgba(220, 38, 38, 0.3); color: #dc2626;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>
                        </svg>
                        Reset
                    </button>
                </div>
            </div>
            
            <div class="api-key-buttons">
                <button class="api-key-btn secondary" id="api-key-cancel">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Import Notes Modal -->
    <div id="import-notes-modal">
        <div class="import-notes-content">
            <div class="import-notes-header">
                <h2>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <path d="M12 18v-6"/>
                        <path d="M9 15l3-3 3 3"/>
                    </svg>
                    Import Notes
                </h2>
                <button class="import-notes-close" id="import-notes-close">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            
            <p class="import-notes-desc">
                Upload a photo of your handwritten notes, a screenshot, or paste text. AI will analyze and organize your notes into a structured mind map.
            </p>
            
            <!-- Main input area (hidden when processing) -->
            <div id="import-notes-input">
                <!-- Drag & Drop Zone -->
                <div class="import-notes-dropzone" id="import-notes-dropzone">
                    <input type="file" id="import-notes-file" accept="image/*,.pdf,.txt,.md" style="display:none">
                    <svg class="import-notes-dropzone-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <div class="import-notes-dropzone-text">Drop image or file here, or click to browse</div>
                    <div class="import-notes-dropzone-hint">Supports: Images, PDF, Text files</div>
                </div>
                
                <!-- Preview -->
                <div class="import-notes-preview" id="import-notes-preview">
                    <div class="import-notes-preview-label">Preview</div>
                    <img class="import-notes-preview-image" id="import-notes-preview-image" src="" alt="Preview">
                    <div class="import-notes-preview-file" id="import-notes-preview-file" style="display:none">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                            <polyline points="14 2 14 8 20 8"/>
                        </svg>
                        <div class="import-notes-preview-file-info">
                            <div class="import-notes-preview-file-name" id="import-notes-file-name"></div>
                            <div class="import-notes-preview-file-size" id="import-notes-file-size"></div>
                        </div>
                        <button class="import-notes-preview-remove" id="import-notes-remove">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                                <path d="M18 6L6 18M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <div class="import-notes-or">or</div>
                
                <!-- Text Input -->
                <textarea class="import-notes-textarea" id="import-notes-text" placeholder="Paste your notes here...&#10;&#10;Example:&#10;- Project ideas&#10;  - Mobile app&#10;  - Website redesign&#10;- Tasks&#10;  - Call client&#10;  - Review proposal"></textarea>
                
                <!-- Options -->
                <div class="import-notes-options">
                    <label class="import-notes-option">
                        <input type="checkbox" id="import-notes-smart-placement" checked>
                        <span>Smart placement (match to existing nodes using AI + neural net)</span>
                    </label>
                    <label class="import-notes-option" style="margin-top: 8px;">
                        <input type="checkbox" id="import-notes-add-selected">
                        <span>Add new categories under selected node</span>
                    </label>
                </div>
                
                <!-- Actions -->
                <div class="import-notes-actions">
                    <button class="import-notes-btn secondary" id="import-notes-cancel">Cancel</button>
                    <button class="import-notes-btn primary" id="import-notes-analyze" disabled>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                            <path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2z"/>
                        </svg>
                        Analyze with AI
                    </button>
                </div>
            </div>
            
            <!-- Processing -->
            <div class="import-notes-processing" id="import-notes-processing">
                <div class="import-notes-spinner"></div>
                <div class="import-notes-processing-text" id="import-notes-processing-text">Analyzing your notes...</div>
            </div>
            
            <!-- Result Preview -->
            <div class="import-notes-result" id="import-notes-result">
                <div class="import-notes-result-header">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                        <polyline points="22 4 12 14.01 9 11.01"/>
                    </svg>
                    Structure Found
                </div>
                <div class="import-notes-result-tree" id="import-notes-result-tree"></div>
            </div>
            
            <!-- Result Actions (hidden until result ready) -->
            <div class="import-notes-actions" id="import-notes-result-actions" style="display:none">
                <button class="import-notes-btn secondary" id="import-notes-retry">Try Again</button>
                <button class="import-notes-btn primary" id="import-notes-create">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add to Map
                </button>
            </div>
        </div>
    </div>
    
    <!-- Auth Modal -->
    <div id="auth-modal">
        <div class="auth-content" style="position: relative;">
            <button class="auth-close" id="auth-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
            
            <div class="auth-header">
                <div class="auth-logo">M</div>
                <div class="auth-title" id="auth-title">Welcome to MYND</div>
                <div class="auth-subtitle" id="auth-subtitle">Sign in to save and sync your mind maps across devices</div>
            </div>
            
            <div class="auth-error" id="auth-error"></div>
            
            <!-- Google Sign In -->
            <button class="auth-btn google" id="auth-google">
                <svg viewBox="0 0 24 24" style="width:18px;height:18px;">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
            
            <div class="auth-divider">or</div>
            
            <!-- Email Form -->
            <form id="auth-form">
                <input type="email" class="auth-input" id="auth-email" placeholder="Email address" required>
                <input type="password" class="auth-input" id="auth-password" placeholder="Password" required>
                <button type="submit" class="auth-btn primary" id="auth-submit">Sign In</button>
            </form>
            
            <button class="auth-btn secondary" id="auth-forgot">Forgot password?</button>
            
            <div class="auth-toggle">
                <span id="auth-toggle-text">Don't have an account?</span>
                <a id="auth-toggle-link">Sign up</a>
            </div>
            
            <!-- Skip option for offline use -->
            <div style="margin-top: var(--space-4); padding-top: var(--space-3); border-top: 1px solid var(--glass-border);">
                <button class="auth-btn secondary" id="auth-skip" style="width: 100%; background: transparent; border: 1px dashed var(--glass-border);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:8px;">
                        <path d="M5 12h14M12 5l7 7-7 7"/>
                    </svg>
                    Skip for now — build without saving
                </button>
                <p style="font-size: 11px; color: var(--text-muted); text-align: center; margin-top: var(--space-2);">
                    Your map won't be saved if you close the browser
                </p>
            </div>
        </div>
    </div>
    
    <!-- Quick Capture -->
    <div id="quick-capture">
        <div class="quick-capture-wrapper">
            <input type="text" id="quick-input" placeholder="What's on your mind?" autocomplete="off">
            <button class="quick-btn secondary" id="quick-link" title="Add Link" aria-label="Add link from URL">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
            </button>
            <button class="quick-btn primary" id="quick-add">
                Add
            </button>
        </div>
    </div>
    
    <!-- Link Modal -->
    <div id="link-modal" class="modal-overlay">
        <div class="link-modal-content">
            <div class="link-modal-header">
                <h3>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                    Add Link
                </h3>
                <button class="link-modal-close" id="link-modal-close" aria-label="Close">×</button>
            </div>
            
            <div class="link-input-group">
                <label for="link-url">Paste URL</label>
                <input type="url" id="link-url" placeholder="https://..." autocomplete="off">
                <button class="link-fetch-btn" id="link-fetch">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M21 12a9 9 0 1 1-9-9"/><polyline points="21 3 21 9 15 9"/></svg>
                    Fetch
                </button>
            </div>
            
            <div class="link-preview" id="link-preview" style="display:none;">
                <div class="link-preview-loading" id="link-preview-loading">
                    <div class="loading-spinner"></div>
                    Fetching link info...
                </div>
                <div class="link-preview-content" id="link-preview-content" style="display:none;">
                    <img class="link-preview-image" id="link-preview-image" alt="">
                    <div class="link-preview-info">
                        <input type="text" class="link-preview-title" id="link-preview-title" placeholder="Title">
                        <textarea class="link-preview-description" id="link-preview-description" placeholder="Description (optional)" rows="2"></textarea>
                        <div class="link-preview-source" id="link-preview-source"></div>
                        <div class="link-transcript-status" id="link-transcript-status" style="display:none;"></div>
                    </div>
                </div>
            </div>
            
            <div class="link-category" id="link-category" style="display:none;">
                <label>AI Suggested Placement</label>
                <div class="link-category-suggestion" id="link-category-suggestion">
                    <span class="link-category-name" id="link-category-name">Loading...</span>
                    <span class="link-category-confidence" id="link-category-confidence"></span>
                </div>
                <div class="link-category-alt" id="link-category-alt"></div>
            </div>
            
            <div class="link-modal-actions">
                <button class="link-btn secondary" id="link-cancel">Cancel</button>
                <button class="link-btn primary" id="link-add" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    Add to Map
                </button>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div class="info-header">
            <div class="info-color" id="info-color">
                <div class="info-color-picker" id="info-color-picker"></div>
            </div>
            <div class="info-title-area">
                <input type="text" id="info-title" value="Node Title" />
                <div id="info-meta">
                    <span id="info-children">0 children</span>
                    <span id="info-source"></span>
                </div>
            </div>
            <button class="info-expand-toggle" id="info-expand-toggle" aria-label="Expand panel">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="expand-icon"><polyline points="6 15 12 9 18 15"/></svg>
            </button>
            <div class="info-close" id="info-close">
                <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </div>
        </div>
        
        <!-- Expanded Section -->
        <div class="info-expanded" id="info-expanded">
            <!-- Description -->
            <div class="info-section">
                <div class="info-section-header">
                    <label class="info-section-label">Description</label>
                    <button class="context-question-btn" id="context-question-btn" title="Help me understand this better">
                        <span>?</span>
                    </button>
                </div>
                <textarea id="info-description" placeholder="Add a description..." rows="2"></textarea>
                <!-- Context Question Popover -->
                <div class="context-question-popover" id="context-question-popover">
                    <div class="context-question-text" id="context-question-text"></div>
                    <div class="context-question-input-wrapper">
                        <input type="text" id="context-question-input" placeholder="Type your answer..." autocomplete="off">
                        <button class="context-question-submit" id="context-question-submit">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Path to Node -->
            <div class="info-section" id="info-path-section">
                <label class="info-section-label">Path</label>
                <div class="info-path" id="info-path"></div>
            </div>
            
            <!-- Add Link (creates child node with link) -->
            <div class="info-section" id="info-add-link-section" style="display: none;">
                <label class="info-section-label">Add Child Link</label>
                <div class="info-add-link">
                    <input type="url" class="info-add-link-input" id="info-add-link-input" placeholder="Paste URL...">
                    <button class="info-add-link-btn" id="info-add-link-btn" title="Add link as child node">
                        <svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                    </button>
                </div>
            </div>
            
            <!-- Link Info (if this node has a link) -->
            <div class="info-section" id="info-link-section" style="display: none;">
                <label class="info-section-label">Linked Content</label>
                <div class="info-link-card" id="info-link-card">
                    <img class="info-link-thumbnail" id="info-link-thumbnail" alt="" style="display: none;">
                    <div class="info-link-details">
                        <a href="#" id="info-link-full-url" target="_blank" rel="noopener noreferrer">
                            <img class="info-link-favicon-small" id="info-link-favicon-small" src="" alt="">
                            <span id="info-link-full-domain"></span>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;flex-shrink:0;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
                        </a>
                        <div class="info-link-meta" id="info-link-meta"></div>
                    </div>
                </div>
            </div>
            
            <!-- Transcript Section (if this node has a transcript) -->
            <div class="info-section" id="info-transcript-section" style="display: none;">
                <label class="info-section-label">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;opacity:0.7;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                        Transcript
                    </span>
                    <span class="info-transcript-chars" id="info-transcript-chars"></span>
                </label>
                <div class="info-transcript-wrapper">
                    <div class="info-transcript-preview" id="info-transcript-preview"></div>
                    <button class="info-transcript-toggle" id="info-transcript-toggle">Show full transcript</button>
                </div>
                <div class="info-transcript-full" id="info-transcript-full" style="display: none;">
                    <div class="info-transcript-text" id="info-transcript-text"></div>
                </div>
            </div>
            
            <!-- Node Metadata -->
            <div class="info-section info-metadata">
                <div class="info-meta-item" id="info-created-section" style="display: none;">
                    <span class="info-meta-label">Created</span>
                    <span class="info-meta-value" id="info-created"></span>
                </div>
                <div class="info-meta-item" id="info-added-by-section">
                    <span class="info-meta-label">Added by</span>
                    <span class="info-meta-value" id="info-added-by">You</span>
                </div>
            </div>
            
            <!-- Attachments Section -->
            <div class="info-attachments" id="info-attachments">
                <div class="attachments-header">
                    <span class="attachments-title">Attachments</span>
                    <button class="attachment-add-btn" id="attachment-add-btn">
                        <svg viewBox="0 0 24 24" width="12" height="12" stroke="currentColor" fill="none" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        Add
                    </button>
                </div>
                <div class="attachments-grid" id="attachments-grid"></div>
                <div class="attachments-dropzone" id="attachments-dropzone">
                    <svg viewBox="0 0 24 24" stroke-width="1.5">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                    </svg>
                    <div>Drop files here or paste</div>
                    <div style="font-size: 9px; opacity: 0.7;">Images & PDFs supported</div>
                </div>
                <input type="file" id="attachment-file-input" accept="image/*,.pdf" multiple style="display: none;">
            </div>
        </div>
        
        <div class="info-link" id="info-link" style="display: none;">
            <a href="#" id="info-link-url" target="_blank" rel="noopener noreferrer">
                <img id="info-link-favicon" src="" alt="">
                <span id="info-link-domain"></span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
            </a>
        </div>
        <div class="info-slider">
            <span class="info-slider-label">Importance</span>
            <div class="info-slider-wrapper">
                <input type="range" id="info-importance" min="0.5" max="2" step="0.1" value="1" />
            </div>
        </div>
        <div class="info-actions" role="group" aria-label="Node actions">
            <button class="info-action danger" id="action-delete" aria-label="Delete this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                Delete
            </button>
            <button class="info-action secondary" id="action-dive" aria-label="Dive into this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
                Dive
            </button>
            <button class="info-action secondary" id="action-organize" aria-label="Organize children by type" style="display: none;">
                <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
                Organize
            </button>
            <button class="info-action ai" id="action-brainstorm" aria-label="AI brainstorm ideas for this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
                Brainstorm
            </button>
            <button class="info-action primary" id="action-add" aria-label="Add a child node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                Add Child
            </button>
        </div>
    </div>
    
    <!-- Keyboard Hints -->
    <div id="keyboard-hints">
        <div class="key-hint"><kbd>←→</kbd> Siblings</div>
        <div class="key-hint"><kbd>⇧←→</kbd> Reorder</div>
        <div class="key-hint"><kbd>↑↓</kbd> Parent/Child</div>
        <div class="key-hint"><kbd>Space</kbd> Expand</div>
        <div class="key-hint"><kbd>?</kbd> Help</div>
    </div>
    
    <!-- Spotlight Search -->
    <div id="spotlight-overlay">
        <div class="spotlight-container">
            <div class="spotlight-input-wrapper">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                <input type="text" id="spotlight-input" placeholder="Search nodes, commands, or type to create..." autocomplete="off">
                <span class="spotlight-hint">esc</span>
            </div>
            <div class="spotlight-results" id="spotlight-results">
                <div class="spotlight-section">
                    <div class="spotlight-section-title">Quick Actions</div>
                    <div class="spotlight-item" data-action="new-node">
                        <div class="spotlight-item-icon" style="background: var(--accent);">+</div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">Create New Node</div>
                            <div class="spotlight-item-subtitle">Add a new thought to your map</div>
                        </div>
                        <div class="spotlight-item-shortcut"><kbd>Tab</kbd></div>
                    </div>
                    <div class="spotlight-item" data-action="brainstorm">
                        <div class="spotlight-item-icon" style="background: linear-gradient(135deg, var(--purple), var(--pink));">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                            </svg>
                        </div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">AI Brainstorm</div>
                            <div class="spotlight-item-subtitle">Generate ideas for selected node</div>
                        </div>
                    </div>
                </div>
                <div class="spotlight-section" id="spotlight-nodes-section">
                    <div class="spotlight-section-title">Nodes</div>
                    <div id="spotlight-nodes-list"></div>
                </div>
            </div>
            <div class="spotlight-footer">
                <div class="spotlight-footer-hint"><kbd>↑↓</kbd> Navigate</div>
                <div class="spotlight-footer-hint"><kbd>↵</kbd> Select</div>
                <div class="spotlight-footer-hint"><kbd>esc</kbd> Close</div>
            </div>
        </div>
    </div>
    
    <!-- Radial Menu -->
    <div id="radial-menu">
        <div class="radial-toggle">
            <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="12" cy="5" r="2"/><circle cx="12" cy="19" r="2"/></svg>
        </div>
        <div class="radial-item" data-action="add" title="Add Child">
            <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        </div>
        <div class="radial-item" data-action="edit" title="Edit">
            <svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
        </div>
        <div class="radial-item" data-action="dive" title="Dive In">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
        </div>
        <div class="radial-item" data-action="brainstorm" title="AI Brainstorm">
            <svg viewBox="0 0 24 24"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
        </div>
        <div class="radial-item" data-action="delete" title="Delete">
            <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </div>
    </div>
    
    <!-- Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modal-title">Add Node</h2>
                <p class="modal-subtitle" id="modal-subtitle">Create a new thought</p>
            </div>
            <div class="form-group">
                <label class="form-label">Name</label>
                <input type="text" class="form-input" id="input-name" placeholder="What's this thought about?">
            </div>
            <div class="form-group">
                <label class="form-label">Description (optional)</label>
                <textarea class="form-input" id="input-desc" placeholder="Add more details..."></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Color</label>
                <div class="color-grid" id="color-grid"></div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn cancel" id="modal-cancel">Cancel</button>
                <button class="modal-btn submit" id="modal-submit">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div id="toast-container"></div>
    
    <!-- Custom Confirm Modal -->
    <div id="confirm-modal" class="confirm-modal-overlay">
        <div class="confirm-modal">
            <div class="confirm-modal-icon" id="confirm-modal-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
            </div>
            <div class="confirm-modal-title" id="confirm-modal-title">Confirm Action</div>
            <div class="confirm-modal-message" id="confirm-modal-message">Are you sure?</div>
            <div class="confirm-modal-actions">
                <button class="confirm-btn confirm-btn-cancel" id="confirm-modal-cancel">Cancel</button>
                <button class="confirm-btn confirm-btn-confirm" id="confirm-modal-confirm">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Goal Creation Wizard -->
    <div id="goal-wizard">
        <div class="goal-wizard-content">
            <button class="goal-wizard-close" id="goal-wizard-close">×</button>

            <div class="goal-wizard-header">
                <div class="goal-wizard-icon">✨</div>
                <h2 class="goal-wizard-title">Create Your Vision</h2>
                <p class="goal-wizard-subtitle">Let's turn your dream into reality</p>
            </div>

            <!-- Progress Indicator -->
            <div class="goal-wizard-progress">
                <div class="goal-wizard-step active" data-step="1"></div>
                <div class="goal-wizard-step" data-step="2"></div>
                <div class="goal-wizard-step" data-step="3"></div>
                <div class="goal-wizard-step" data-step="4"></div>
            </div>

            <!-- Step Contents -->
            <div class="goal-wizard-steps">
                <!-- Step 1: The Dream -->
                <div class="goal-wizard-step-content active" data-step="1">
                    <p class="goal-wizard-question">What do you want to manifest?</p>
                    <p class="goal-wizard-hint">Dream big. Describe your ideal outcome.</p>
                    <input type="text" class="goal-wizard-input" id="goal-desire"
                           placeholder="I want to..." autofocus>
                </div>

                <!-- Step 2: The Why -->
                <div class="goal-wizard-step-content" data-step="2">
                    <p class="goal-wizard-question">Why does this matter to you?</p>
                    <p class="goal-wizard-hint">Connect to your deeper motivation. This fuels your journey.</p>
                    <textarea class="goal-wizard-input" id="goal-why"
                              placeholder="This matters because..."></textarea>
                </div>

                <!-- Step 3: Success Criteria -->
                <div class="goal-wizard-step-content" data-step="3">
                    <p class="goal-wizard-question">How will you know you've achieved it?</p>
                    <p class="goal-wizard-hint">Be specific. What does success look like?</p>
                    <textarea class="goal-wizard-input" id="goal-success"
                              placeholder="I'll know I've succeeded when..."></textarea>

                    <p class="goal-wizard-question" style="margin-top: var(--space-5);">Priority</p>
                    <div class="goal-priority-selector">
                        <div class="goal-priority-option" data-priority="high">
                            <div class="goal-priority-label">🔥 High</div>
                            <div class="goal-priority-desc">Top focus</div>
                        </div>
                        <div class="goal-priority-option selected" data-priority="medium">
                            <div class="goal-priority-label">⭐ Medium</div>
                            <div class="goal-priority-desc">Important</div>
                        </div>
                        <div class="goal-priority-option" data-priority="low">
                            <div class="goal-priority-label">🌱 Low</div>
                            <div class="goal-priority-desc">Someday</div>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Summary -->
                <div class="goal-wizard-step-content" data-step="4">
                    <p class="goal-wizard-question">Your Vision</p>
                    <p class="goal-wizard-hint">Review your goal before manifesting it.</p>

                    <div class="goal-summary">
                        <div class="goal-summary-item">
                            <div class="goal-summary-label">Dream</div>
                            <div class="goal-summary-value" id="summary-desire">-</div>
                        </div>
                        <div class="goal-summary-item">
                            <div class="goal-summary-label">Why It Matters</div>
                            <div class="goal-summary-value" id="summary-why">-</div>
                        </div>
                        <div class="goal-summary-item">
                            <div class="goal-summary-label">Success Looks Like</div>
                            <div class="goal-summary-value" id="summary-success">-</div>
                        </div>
                        <div class="goal-summary-item">
                            <div class="goal-summary-label">Priority</div>
                            <div class="goal-summary-value" id="summary-priority">-</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="goal-wizard-actions">
                <button class="goal-wizard-btn secondary" id="goal-wizard-back" style="display: none;">Back</button>
                <button class="goal-wizard-btn primary" id="goal-wizard-next">Next</button>
            </div>
        </div>
    </div>

    <!-- Neural Network Panel -->
    <div id="neural-panel">
        <div class="neural-header">
            <div class="neural-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4c.74 0 1.43-.2 2-.56A4 4 0 0 0 16 22a4 4 0 0 0 4-4c0-1.2-.52-2.27-1.35-3A4 4 0 0 0 20 12a4 4 0 0 0-2.56-3.98c.36-.59.56-1.28.56-2.02a4 4 0 0 0-4-4"/>
                    <circle cx="12" cy="12" r="2"/>
                </svg>
                Your Neural Net
            </div>
            <div class="neural-close" id="neural-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </div>
        </div>
        
        <div class="neural-status">
            <div class="neural-status-row" style="padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--bg-tertiary);">
                <span style="display: flex; align-items: center; gap: 6px;">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                        <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                        <line x1="12" y1="2" x2="12" y2="12"/>
                    </svg>
                    Auto-Training
                </span>
                <label class="toggle-switch" style="margin: 0;">
                    <input type="checkbox" id="neural-training-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="neural-status-row">
                <span>Status</span>
                <span class="neural-status-value" id="neural-status-text">Initializing...</span>
            </div>
            <div class="neural-status-row">
                <span>Learned Categories</span>
                <span class="neural-status-value" id="neural-category-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Expansion Patterns</span>
                <span class="neural-status-value" id="neural-pattern-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Cached Embeddings</span>
                <span class="neural-status-value" id="neural-embedding-count">0</span>
            </div>
            <div class="neural-progress" id="neural-progress" style="display: none;">
                <div class="neural-progress-bar" id="neural-progress-bar"></div>
            </div>
        </div>
        
        <!-- Train Button (shows when not ready) -->
        <button class="neural-btn" id="neural-train-panel-btn" style="margin-top: 8px; background: linear-gradient(135deg, #f59e0b, #fbbf24);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
            </svg>
            Train on My Map
        </button>
        
        <!-- Preference Learning Stats -->
        <div class="neural-status" id="neural-preference-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
                Preference Learning
            </div>
            <div class="neural-status-row">
                <span>Suggestions Accepted</span>
                <span class="neural-status-value" id="pref-accepted-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Suggestions Ignored</span>
                <span class="neural-status-value" id="pref-ignored-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Acceptance Rate</span>
                <span class="neural-status-value" id="pref-acceptance-rate">—</span>
            </div>
            <div class="neural-status-row" id="pref-style-row" style="display: none;">
                <span>Style Preference</span>
                <span class="neural-status-value" id="pref-style">—</span>
            </div>
        </div>
        
        <!-- Incremental Learning Stats -->
        <div class="neural-status" id="neural-incremental-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M23 6l-9.5 9.5-5-5L1 18"/>
                    <path d="M17 6h6v6"/>
                </svg>
                Live Learning
            </div>
            <div class="neural-status-row">
                <span>Pattern Weights</span>
                <span class="neural-status-value" id="incr-pattern-weights">0</span>
            </div>
            <div class="neural-status-row">
                <span>High Confidence</span>
                <span class="neural-status-value" id="incr-high-confidence">0</span>
            </div>
            <div class="neural-status-row">
                <span>Avg Weight</span>
                <span class="neural-status-value" id="incr-avg-weight">—</span>
            </div>
            <div class="neural-status-row" id="incr-pending-row" style="display: none;">
                <span>Pending Embeddings</span>
                <span class="neural-status-value" id="incr-pending">0</span>
            </div>
        </div>
        
        <!-- Semantic Memory Stats -->
        <div class="neural-status" id="neural-memory-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/>
                    <path d="M12 6v6l4 2"/>
                </svg>
                Semantic Memory
            </div>
            <div class="neural-status-row">
                <span>Total Memories</span>
                <span class="neural-status-value" id="mem-total-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Important</span>
                <span class="neural-status-value" id="mem-important-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Avg Importance</span>
                <span class="neural-status-value" id="mem-avg-importance">—</span>
            </div>
        </div>
        
        <!-- User Profile Stats -->
        <div class="neural-status" id="neural-profile-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                    <circle cx="12" cy="7" r="4"/>
                </svg>
                User Profile
            </div>
            <div class="neural-status-row">
                <span>Nodes Tracked</span>
                <span class="neural-status-value" id="profile-nodes-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Preferred Depth</span>
                <span class="neural-status-value" id="profile-depth">—</span>
            </div>
            <div class="neural-status-row">
                <span>Naming Style</span>
                <span class="neural-status-value" id="profile-naming-style">—</span>
            </div>
            <div class="neural-status-row" id="profile-focus-row" style="display: none;">
                <span>Focus Areas</span>
                <span class="neural-status-value" id="profile-focus">—</span>
            </div>
            <div class="neural-status-row" id="profile-peak-row" style="display: none;">
                <span>Peak Hours</span>
                <span class="neural-status-value" id="profile-peak-hours">—</span>
            </div>
        </div>
        
        <!-- Cognitive Graph Transformer Stats -->
        <div class="neural-status" id="neural-cgt-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                    <path d="M2 12h20"/>
                </svg>
                Cognitive Graph (Advanced)
            </div>
            <div class="neural-status-row">
                <span>Graph Embeddings</span>
                <span class="neural-status-value" id="cgt-embeddings">0</span>
            </div>
            <div class="neural-status-row">
                <span>Actions Tracked</span>
                <span class="neural-status-value" id="cgt-actions">0</span>
            </div>
            <div class="neural-status-row">
                <span>Action Patterns</span>
                <span class="neural-status-value" id="cgt-patterns">0</span>
            </div>
            <div class="neural-status-row">
                <span>Cognitive State</span>
                <span class="neural-status-value" id="cgt-state">—</span>
            </div>
            <div class="neural-status-row" id="cgt-insight-row" style="display: none;">
                <span>Current Insight</span>
                <span class="neural-status-value" id="cgt-insight" style="font-size: 10px; max-width: 150px; text-overflow: ellipsis; overflow: hidden;">—</span>
            </div>
        </div>
        
        <!-- CGT Insights Button -->
        <button class="neural-btn" id="cgt-insights-btn" style="margin-top: 12px; background: linear-gradient(135deg, var(--accent), var(--accent-light));">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="16" x2="12" y2="12"/>
                <line x1="12" y1="8" x2="12.01" y2="8"/>
            </svg>
            Get AI Insights
        </button>
        
        <!-- Style Fingerprint Section (Phase 4) -->
        <div class="neural-status" id="neural-style-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                    <path d="M2 17l10 5 10-5"/>
                    <path d="M2 12l10 5 10-5"/>
                </svg>
                Your Thinking Style
            </div>
            <div class="neural-status-row">
                <span>Style Traits</span>
                <span class="neural-status-value" id="style-traits" style="font-size: 10px; max-width: 140px; text-overflow: ellipsis; overflow: hidden;">Learning...</span>
            </div>
            <div class="neural-status-row">
                <span>Learned Patterns</span>
                <span class="neural-status-value" id="style-patterns">0</span>
            </div>
            <div class="neural-status-row">
                <span>Structure Memory</span>
                <span class="neural-status-value" id="style-memories">0</span>
            </div>
            <div class="neural-status-row">
                <span>Style Confidence</span>
                <span class="neural-status-value" id="style-confidence">—</span>
            </div>
        </div>
        
        <!-- Transfer Suggestions Button -->
        <button class="neural-btn" id="transfer-suggest-btn" style="margin-top: 12px; background: linear-gradient(135deg, #8b5cf6, #a78bfa);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                <path d="M2 17l10 5 10-5"/>
                <path d="M2 12l10 5 10-5"/>
            </svg>
            Get Pattern Suggestions
        </button>
        
        <!-- Semantic Engine Section (Real Transformers.js) -->
        <div class="neural-status" id="neural-semantic-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 6v6l4 2"/>
                </svg>
                Semantic Engine
                <span style="font-size: 9px; background: rgba(34, 197, 94, 0.2); color: #22c55e; padding: 1px 4px; border-radius: 3px;">REAL AI</span>
            </div>
            <div class="neural-status-row">
                <span>Model</span>
                <span class="neural-status-value" id="semantic-model" style="font-size: 9px;">Not loaded</span>
            </div>
            <div class="neural-status-row" id="semantic-progress-row" style="display: none;">
                <span>Loading</span>
                <span class="neural-status-value" id="semantic-progress">0%</span>
            </div>
            <div class="neural-status-row" id="semantic-embeddings-row" style="display: none;">
                <span>Embeddings</span>
                <span class="neural-status-value" id="semantic-embeddings">0</span>
            </div>
            <div class="neural-status-row" id="semantic-inference-row" style="display: none;">
                <span>Avg Inference</span>
                <span class="neural-status-value" id="semantic-inference">—</span>
            </div>
        </div>
        
        <!-- Semantic Features Buttons -->
        <button class="neural-btn" id="semantic-load-btn" style="margin-top: 8px; background: linear-gradient(135deg, #10b981, #34d399);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                <circle cx="12" cy="12" r="10"/>
                <path d="M12 6v6l4 2"/>
            </svg>
            Load Semantic Model (22MB)
        </button>
        
        <button class="neural-btn" id="semantic-cluster-btn" style="margin-top: 4px; background: linear-gradient(135deg, #8b5cf6, #a78bfa); display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                <circle cx="6" cy="6" r="3"/>
                <circle cx="18" cy="6" r="3"/>
                <circle cx="12" cy="18" r="3"/>
            </svg>
            Detect Topic Clusters
        </button>
        
        <button class="neural-btn" id="semantic-holes-btn" style="margin-top: 4px; background: linear-gradient(135deg, #f59e0b, #fbbf24); display: none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44"/>
                <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44"/>
            </svg>
            Find Hidden Connections
        </button>
        
        <!-- GPU Compute Section -->
        <div class="neural-status" id="neural-gpu-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <rect x="4" y="4" width="16" height="16" rx="2"/>
                    <rect x="9" y="9" width="6" height="6"/>
                </svg>
                GPU Compute
            </div>
            <div class="neural-status-row">
                <span>WebGPU</span>
                <span class="neural-status-value" id="gpu-status" style="font-size: 10px;">Checking...</span>
            </div>
            <div class="neural-status-row" id="gpu-ops-row" style="display: none;">
                <span>Operations</span>
                <span class="neural-status-value" id="gpu-ops-count">0</span>
            </div>
            <div class="neural-status-row" id="gpu-time-row" style="display: none;">
                <span>Avg Time</span>
                <span class="neural-status-value" id="gpu-avg-time">—</span>
            </div>
        </div>
        
        <!-- Benchmark Button -->
        <button class="neural-btn" id="gpu-benchmark-btn" style="margin-top: 8px; background: linear-gradient(135deg, #06b6d4, #22d3ee); font-size: 11px; padding: 8px 12px;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
            </svg>
            Run GPU Benchmark
        </button>
        
        <!-- Relationship Types Stats -->
        <div class="neural-status" id="neural-relationship-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M4 6h16M4 12h16M4 18h7"/>
                    <circle cx="18" cy="18" r="3"/>
                </svg>
                Relationship Types
            </div>
            <div class="neural-status-row">
                <span>Classified</span>
                <span class="neural-status-value" id="rel-classified-count">0</span>
            </div>
            <div class="neural-status-row" id="rel-dominant-row" style="display: none;">
                <span>Dominant</span>
                <span class="neural-status-value" id="rel-dominant-type">—</span>
            </div>
            <div class="neural-status-row" id="rel-transfer-row" style="display: none;">
                <span>Transfer Ready</span>
                <span class="neural-status-value" id="rel-transfer-count">0</span>
            </div>
        </div>
        
        <!-- Concept Abstraction Stats -->
        <div class="neural-status" id="neural-concept-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <circle cx="12" cy="12" r="3"/>
                    <circle cx="12" cy="12" r="8" stroke-dasharray="4 2"/>
                </svg>
                Concept Abstraction
            </div>
            <div class="neural-status-row">
                <span>Schemas</span>
                <span class="neural-status-value" id="concept-schemas">0</span>
            </div>
            <div class="neural-status-row">
                <span>Clusters</span>
                <span class="neural-status-value" id="concept-clusters">0</span>
            </div>
            <div class="neural-status-row" id="concept-hierarchy-row" style="display: none;">
                <span>Hierarchies</span>
                <span class="neural-status-value" id="concept-hierarchies">0</span>
            </div>
            <div class="neural-status-row" id="concept-transfers-row" style="display: none;">
                <span>Transfers Applied</span>
                <span class="neural-status-value" id="concept-transfers">0</span>
            </div>
        </div>
        
        <!-- Meta-Learner Stats (How You Think) -->
        <div class="neural-status" id="neural-meta-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 2a8 8 0 0 1 8 8c0 3-2 5.5-4 7l-1 4H9l-1-4c-2-1.5-4-4-4-7a8 8 0 0 1 8-8z"/>
                    <path d="M9 22h6"/>
                </svg>
                Thinking Patterns
            </div>
            <div class="neural-status-row">
                <span>Building Style</span>
                <span class="neural-status-value" id="meta-building-style">Learning...</span>
            </div>
            <div class="neural-status-row">
                <span>Decision Speed</span>
                <span class="neural-status-value" id="meta-decision-speed">Learning...</span>
            </div>
            <div class="neural-status-row" id="meta-rhythm-row" style="display: none;">
                <span>Work Rhythm</span>
                <span class="neural-status-value" id="meta-rhythm">—</span>
            </div>
            <div class="neural-status-row" id="meta-selectivity-row" style="display: none;">
                <span>Selectivity</span>
                <span class="neural-status-value" id="meta-selectivity">—</span>
            </div>
            <div class="neural-status-row" id="meta-sessions-row" style="display: none;">
                <span>Sessions Analyzed</span>
                <span class="neural-status-value" id="meta-sessions">0</span>
            </div>
        </div>
        
        <!-- Meta-Learner Insights -->
        <div id="meta-insights-section" style="display: none; margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">Your Strengths</div>
            <div id="meta-strengths" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
        </div>
        
        <div class="neural-categories" id="neural-categories" style="display: none;">
            <div class="neural-categories-title">Learned Categories</div>
            <div class="neural-category-list" id="neural-category-list"></div>
        </div>
        
        <div class="neural-actions">
            <button class="neural-btn primary" id="neural-smart-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                </svg>
                Smart Expand Selected
            </button>
            <button class="neural-btn secondary" id="neural-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><circle cx="12" cy="17" r="0.5"/>
                </svg>
                Find Related Nodes
            </button>
        </div>
        
        <div class="neural-suggestions" id="neural-suggestions" style="display: none;">
            <div class="neural-suggestions-title">AI Suggestions <span id="neural-suggestions-for" style="font-weight: 400; color: var(--text-secondary);"></span></div>
            <div id="neural-suggestions-list"></div>
        </div>
    </div>

    <!-- AI Chat Panel -->
    <div id="ai-chat-panel">
        <!-- Slide toggle on left edge -->
        <button class="chat-slide-toggle" id="chat-slide-toggle" title="Toggle chat">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"/>
            </svg>
        </button>
        
        <div class="chat-header">
            <div class="chat-header-left">
                <button class="chat-header-btn chat-mobile-close" id="chat-mobile-close" title="Close chat">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 18 9 12 15 6"/>
                    </svg>
                </button>
                <span class="chat-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                    </svg>
                </span>
                <span class="chat-title">MYND Chat</span>
            </div>
            <div class="chat-header-actions">
                <button class="chat-header-btn" id="chat-tts-toggle" title="Voice responses ON">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                    </svg>
                </button>
                <button class="chat-header-btn" id="chat-clear" title="Clear conversation">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="chat-messages" id="chat-messages">
            <div class="chat-welcome">
                <div class="chat-welcome-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                    </svg>
                </div>
                <div class="chat-welcome-title">Your cognitive companion</div>
                <div class="chat-welcome-text">
                    I'm here to help you think better — capturing ideas, surfacing connections, and turning thoughts into action.
                </div>
                <div class="chat-welcome-examples">
                    <button class="chat-example-btn">Help me think through my goals</button>
                    <button class="chat-example-btn">What patterns do you see in my map?</button>
                    <button class="chat-example-btn">I have a vague idea I want to explore...</button>
                    <button class="chat-example-btn">What am I missing?</button>
                </div>
            </div>
        </div>
        
        <div class="chat-suggestions" id="chat-suggestions" style="display: none;">
            <!-- Quick reply suggestions appear here -->
        </div>
        
        <div class="chat-input-area">
            <div class="chat-input-container">
                <textarea 
                    id="chat-input" 
                    placeholder="Ask me anything..." 
                    rows="1"
                    aria-label="Chat message"
                ></textarea>
                <button class="chat-voice-btn" id="chat-voice-btn" title="Voice input">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/>
                        <path d="M19 10v2a7 7 0 01-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                </button>
                <button class="chat-send-btn" id="chat-send-btn" title="Send message" disabled>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                </button>
                
                <!-- Voice recording overlay -->
                <div class="chat-voice-overlay" id="chat-voice-overlay">
                    <div class="chat-voice-indicator">
                        <div class="chat-voice-bars">
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                        </div>
                        <span class="chat-voice-status recording" id="chat-voice-status">Listening...</span>
                    </div>
                    <button class="chat-voice-cancel" id="chat-voice-cancel">Cancel</button>
                </div>
            </div>
            <div class="chat-input-hint">
                <span class="chat-hint-key">Enter</span> to send · <span class="chat-hint-key">Shift+Enter</span> for new line
            </div>
        </div>
    </div>
    
    <!-- Hidden file input -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <!-- Mobile Bottom Sheet (Input-First UI) -->
    <div id="mobile-bottom-sheet">
        <!-- Mini Map Toolbar (floats above sheet when toggled) -->
        <div class="sheet-mini-toolbar" id="sheet-mini-toolbar">
            <button class="sheet-mini-toolbar-btn" data-action="expand-all">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="1"/>
                    <circle cx="12" cy="5" r="1"/>
                    <circle cx="12" cy="19" r="1"/>
                    <circle cx="19" cy="12" r="1"/>
                    <circle cx="5" cy="12" r="1"/>
                </svg>
                Expand
            </button>
            <button class="sheet-mini-toolbar-btn" data-action="collapse-all">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                Collapse
            </button>
            <button class="sheet-mini-toolbar-btn" id="mini-autocam-btn" data-action="auto-cam">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M23 7l-7 5 7 5V7z"/>
                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                </svg>
                Auto Cam
            </button>
        </div>
        
        <!-- Drag Handle -->
        <div class="sheet-drag-handle" id="sheet-drag-handle"></div>
        
        <!-- Mini Toolbar Toggle (right side) -->
        <button class="sheet-map-toggle" id="sheet-map-toggle" title="Map controls">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/>
            </svg>
        </button>
        
        <!-- Quick Actions - Visible when collapsed -->
        <div class="sheet-quick-actions">
            <button class="sheet-quick-btn" data-action="add-node">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="5" x2="12" y2="19"/>
                    <line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                <span>Add</span>
            </button>
            <button class="sheet-quick-btn teal" data-action="open-chat">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                </svg>
                <span>Chat</span>
            </button>
            <button class="sheet-quick-btn voice-btn" id="sheet-quick-voice" data-action="voice">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                    <line x1="8" y1="23" x2="16" y2="23"/>
                </svg>
                <span>Voice</span>
            </button>
            <button class="sheet-quick-btn orange" data-action="memo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                </svg>
                <span>Memo</span>
            </button>
            <button class="sheet-quick-btn purple" data-action="neural">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <ellipse cx="12" cy="12" rx="10" ry="4"/>
                    <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60 12 12)"/>
                    <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120 12 12)"/>
                </svg>
                <span>Neural</span>
            </button>
        </div>
        
        <!-- Quick Input Header -->
        <div class="sheet-header">
            <div class="sheet-input-container">
                <button class="sheet-voice-btn" id="sheet-voice-btn" title="Voice input">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                </button>
                <input type="text" class="sheet-text-input" id="sheet-text-input" placeholder="What's on your mind?">
                <button class="sheet-send-btn" id="sheet-send-btn" disabled title="Send">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Tab Navigation -->
        <div class="sheet-tabs">
            <button class="sheet-tab active" data-tab="chat">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                </svg>
                Chat
            </button>
            <button class="sheet-tab" data-tab="recent">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                </svg>
                Recent
            </button>
            <button class="sheet-tab" data-tab="tools">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/>
                </svg>
                Tools
            </button>
            <button class="sheet-tab" data-tab="map">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                Map
            </button>
        </div>
        
        <!-- Tab Contents -->
        <!-- Chat Tab -->
        <div class="sheet-content active" id="sheet-content-chat">
            <div class="sheet-chat-messages" id="sheet-chat-messages">
                <div class="sheet-chat-welcome">
                    <div class="sheet-chat-welcome-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                        </svg>
                    </div>
                    <h3>Your cognitive companion</h3>
                    <p>Capture ideas, build your mind map, and let AI help organize your thoughts.</p>
                    <div class="sheet-suggestions">
                        <button class="sheet-suggestion">Add a new idea</button>
                        <button class="sheet-suggestion">What patterns do you see?</button>
                        <button class="sheet-suggestion">Help me brainstorm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Recent Tab -->
        <div class="sheet-content" id="sheet-content-recent">
            <div class="sheet-recent-list" id="sheet-recent-list">
                <div class="sheet-recent-empty">
                    <p>No recent captures yet.</p>
                    <p style="margin-top: 8px; font-size: 12px;">Use voice or text to add thoughts!</p>
                </div>
            </div>
        </div>
        
        <!-- Tools Tab -->
        <div class="sheet-content" id="sheet-content-tools">
            <div class="sheet-tools-grid">
                <div class="sheet-tool" data-action="add-node">
                    <div class="sheet-tool-icon accent">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Add Node</span>
                </div>
                <div class="sheet-tool" data-action="add-link">
                    <div class="sheet-tool-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Add Link</span>
                </div>
                <div class="sheet-tool" data-action="neural">
                    <div class="sheet-tool-icon purple">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <ellipse cx="12" cy="12" rx="10" ry="4"/>
                            <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60 12 12)"/>
                            <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120 12 12)"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Neural</span>
                </div>
                <div class="sheet-tool" data-action="focus">
                    <div class="sheet-tool-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Overview</span>
                </div>
                <div class="sheet-tool" data-action="export">
                    <div class="sheet-tool-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Export</span>
                </div>
                <div class="sheet-tool" data-action="import-notes">
                    <div class="sheet-tool-icon accent">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                            <polyline points="14 2 14 8 20 8"/>
                            <path d="M12 18v-6"/>
                            <path d="M9 15l3-3 3 3"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Import Notes</span>
                </div>
                <div class="sheet-tool" data-action="settings">
                    <div class="sheet-tool-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="4" y1="21" x2="4" y2="14"/>
                            <line x1="4" y1="10" x2="4" y2="3"/>
                            <line x1="12" y1="21" x2="12" y2="12"/>
                            <line x1="12" y1="8" x2="12" y2="3"/>
                            <line x1="20" y1="21" x2="20" y2="16"/>
                            <line x1="20" y1="12" x2="20" y2="3"/>
                            <line x1="1" y1="14" x2="7" y2="14"/>
                            <line x1="9" y1="8" x2="15" y2="8"/>
                            <line x1="17" y1="16" x2="23" y2="16"/>
                        </svg>
                    </div>
                    <span class="sheet-tool-label">Settings</span>
                </div>
            </div>
        </div>
        
        <!-- Map Tab -->
        <div class="sheet-content" id="sheet-content-map">
            <div class="sheet-map-controls">
                <div class="sheet-map-info">
                    <p>Tap the map to interact. Use gestures to navigate:</p>
                    <p style="margin-top: 8px; font-size: 12px; color: var(--text-tertiary);">
                        • One finger: rotate<br>
                        • Two fingers: pan & zoom<br>
                        • Tap node: select
                    </p>
                </div>
                <div class="sheet-map-actions">
                    <button class="sheet-map-btn" data-action="home">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                            <polyline points="9 22 9 12 15 12 15 22"/>
                        </svg>
                        Reset View
                    </button>
                    <button class="sheet-map-btn" data-action="expand-all">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="1"/>
                            <circle cx="12" cy="5" r="1"/>
                            <circle cx="12" cy="19" r="1"/>
                            <circle cx="19" cy="12" r="1"/>
                            <circle cx="5" cy="12" r="1"/>
                        </svg>
                        Expand All
                    </button>
                    <button class="sheet-map-btn" data-action="collapse-all">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                        Collapse
                    </button>
                    <button class="sheet-map-btn" data-action="auto-cam">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 7l-7 5 7 5V7z"/>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                        </svg>
                        Auto Cam
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- TensorFlow.js and USE - Lazy loaded when AI features first used -->
    <!-- Scripts will be loaded dynamically by loadTensorFlow() -->
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- MYND Modules -->
    <script src="js/config.js"></script>
    <script src="js/goal-system.js"></script>

    <script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // CONFIG is now loaded from js/config.js

    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE CLIENT INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    let supabase = null;
    
    function initSupabase() {
        if (supabase) return supabase;
        
        if (CONFIG.SUPABASE_URL === 'YOUR_SUPABASE_URL' || 
            CONFIG.SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
            console.warn('Supabase not configured - running in local-only mode');
            return null;
        }
        
        try {
            supabase = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
            console.log('✓ Supabase client initialized');
            return supabase;
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            return null;
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // TENSORFLOW LAZY LOADER - Only load when AI features are used
    // ═══════════════════════════════════════════════════════════════════
    const TensorFlowLoader = {
        loaded: false,
        loading: false,
        loadPromise: null,
        
        async load() {
            // Already loaded
            if (this.loaded && typeof tf !== 'undefined' && typeof use !== 'undefined') {
                return true;
            }
            
            // Already loading - return existing promise
            if (this.loading && this.loadPromise) {
                return this.loadPromise;
            }
            
            this.loading = true;
            
            this.loadPromise = new Promise(async (resolve, reject) => {
                try {
                    console.log('📦 Loading TensorFlow.js (first AI feature used)...');
                    showToast('Loading AI engine...', 'info');
                    
                    // Load TensorFlow.js
                    await this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js');
                    
                    // Load Universal Sentence Encoder
                    await this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js');
                    
                    // Initialize GPU backend
                    if (typeof tf !== 'undefined') {
                        try {
                            await tf.setBackend('webgl');
                            await tf.ready();
                            console.log(`✓ TensorFlow.js loaded with ${tf.getBackend()} backend`);
                        } catch (e) {
                            console.log('WebGL not available, using CPU');
                        }
                    }
                    
                    this.loaded = true;
                    this.loading = false;
                    showToast('AI engine ready', 'success');
                    resolve(true);
                    
                } catch (error) {
                    console.error('Failed to load TensorFlow:', error);
                    this.loading = false;
                    showToast('Failed to load AI engine', 'error');
                    reject(error);
                }
            });
            
            return this.loadPromise;
        },
        
        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        },
        
        isLoaded() {
            return this.loaded && typeof tf !== 'undefined' && typeof use !== 'undefined';
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ANIMATION THROTTLING - Reduce CPU when idle
    // ═══════════════════════════════════════════════════════════════════
    const AnimationController = {
        isIdle: false,
        needsRender: true,  // Flag to request a render
        idleTimeout: null,
        lastInteraction: Date.now(),
        isTabVisible: true,
        targetFPS: 60,
        frameInterval: 1000 / 60,
        lastFrameTime: 0,
        animatingNodes: 0,
        renderRequested: false,
        idleFPS: 5,  // Very low FPS when truly idle
        
        init() {
            // Track tab visibility
            document.addEventListener('visibilitychange', () => {
                this.isTabVisible = !document.hidden;
                if (this.isTabVisible) {
                    this.wake();
                }
            });
            
            // Track user interaction - request render on any interaction
            ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'wheel', 'keydown'].forEach(event => {
                document.addEventListener(event, () => this.wake(), { passive: true });
            });
        },
        
        wake() {
            this.lastInteraction = Date.now();
            this.isIdle = false;
            this.needsRender = true;
            this.targetFPS = 60;
            this.frameInterval = 1000 / 60;
            
            clearTimeout(this.idleTimeout);
            this.idleTimeout = setTimeout(() => this.checkIdle(), 2000);
        },
        
        // Call this to request a render (from any code that changes scene)
        requestRender() {
            this.needsRender = true;
        },
        
        checkIdle() {
            const timeSinceInteraction = Date.now() - this.lastInteraction;
            
            if (timeSinceInteraction > 2000 && this.animatingNodes === 0) {
                this.isIdle = true;
                this.targetFPS = this.idleFPS;
                this.frameInterval = 1000 / this.idleFPS;
            }
        },
        
        shouldRenderFrame(currentTime) {
            // Always skip if tab is hidden
            if (!this.isTabVisible) return false;
            
            // Skip if nothing needs rendering and we're idle
            if (this.isIdle && !this.needsRender && this.animatingNodes === 0) {
                return false;
            }
            
            // Throttle based on target FPS
            if (currentTime - this.lastFrameTime < this.frameInterval) {
                return false;
            }
            
            this.lastFrameTime = currentTime;
            this.needsRender = false;  // Reset after rendering
            return true;
        },
        
        setAnimatingCount(count) {
            const wasAnimating = this.animatingNodes > 0;
            this.animatingNodes = count;
            if (count > 0 && !wasAnimating) {
                this.wake();
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE AUTH - User authentication management
    // ═══════════════════════════════════════════════════════════════════
    const SupabaseAuth = {
        user: null,
        listeners: [],
        
        async init() {
            if (!supabase) return null;
            
            // Get initial session
            const { data: { session } } = await supabase.auth.getSession();
            this.user = session?.user || null;
            
            // Listen for auth changes
            supabase.auth.onAuthStateChange((event, session) => {
                const previousUser = this.user;
                this.user = session?.user || null;
                
                console.log(`Auth state changed: ${event}`, this.user?.email || 'logged out');
                
                // Notify listeners
                this.listeners.forEach(callback => callback(this.user, previousUser, event));
            });
            
            return this.user;
        },
        
        onAuthChange(callback) {
            this.listeners.push(callback);
        },
        
        async signInWithGoogle() {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: window.location.origin + window.location.pathname
                }
            });
            
            if (error) {
                console.error('Google sign-in error:', error);
                showToast('Sign in failed: ' + error.message, 'error');
            }
            
            return { data, error };
        },
        
        async signInWithEmail(email, password) {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signInWithPassword({
                email,
                password
            });
            
            if (error) {
                console.error('Email sign-in error:', error);
                showToast('Sign in failed: ' + error.message, 'error');
            }
            
            return { data, error };
        },
        
        async signUpWithEmail(email, password) {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signUp({
                email,
                password,
                options: {
                    emailRedirectTo: window.location.origin + window.location.pathname
                }
            });
            
            if (error) {
                console.error('Sign-up error:', error);
                showToast('Sign up failed: ' + error.message, 'error');
            } else if (data.user && !data.session) {
                showToast('Check your email to confirm your account', 'success');
            }
            
            return { data, error };
        },
        
        async signOut() {
            if (!supabase) return;
            
            const { error } = await supabase.auth.signOut();
            if (error) {
                console.error('Sign-out error:', error);
                showToast('Sign out failed', 'error');
            } else {
                showToast('Signed out successfully', 'success');
            }
            
            return { error };
        },
        
        async resetPassword(email) {
            if (!supabase) return { error: 'Supabase not configured' };
            
            const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
                redirectTo: window.location.origin + window.location.pathname
            });
            
            if (error) {
                showToast('Password reset failed: ' + error.message, 'error');
            } else {
                showToast('Check your email for reset instructions', 'success');
            }
            
            return { data, error };
        },
        
        isLoggedIn() {
            return !!this.user;
        },
        
        getUser() {
            return this.user;
        },
        
        getUserEmail() {
            return this.user?.email || null;
        },
        
        getUserId() {
            return this.user?.id || null;
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE SYNC - Cloud data synchronization with Real-time
    // ═══════════════════════════════════════════════════════════════════
    const SupabaseSync = {
        currentMapId: null,
        syncEnabled: false,
        syncDebounceTimer: null,
        isSyncing: false,
        lastSyncTime: null,
        realtimeChannel: null,
        isReceivingUpdate: false, // Flag to prevent echo
        lastKnownVersion: null,
        
        async init() {
            if (!supabase || !SupabaseAuth.isLoggedIn()) {
                this.syncEnabled = false;
                return;
            }
            
            this.syncEnabled = true;
            console.log('✓ Supabase sync enabled');
            
            // Set up auth state change listener for reconnection
            supabase.auth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_OUT') {
                    this.unsubscribeFromRealtime();
                    this.syncEnabled = false;
                } else if (event === 'SIGNED_IN' && session) {
                    this.syncEnabled = true;
                }
            });
        },
        
        // ─── Real-time Subscription ────────────────────────────────────────
        
        async subscribeToRealtime(mapId) {
            if (!this.syncEnabled || !mapId) return;
            
            // Unsubscribe from previous channel if exists
            this.unsubscribeFromRealtime();
            
            console.log('📡 Subscribing to real-time updates for map:', mapId);
            
            this.realtimeChannel = supabase
                .channel(`map-${mapId}`)
                .on(
                    'postgres_changes',
                    {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'mind_maps',
                        filter: `id=eq.${mapId}`
                    },
                    (payload) => this.handleRealtimeUpdate(payload)
                )
                .subscribe((status) => {
                    console.log('📡 Realtime subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        this.updateSyncIndicator('connected');
                    } else if (status === 'CHANNEL_ERROR') {
                        this.updateSyncIndicator('error');
                    }
                });
        },
        
        unsubscribeFromRealtime() {
            if (this.realtimeChannel) {
                console.log('📡 Unsubscribing from real-time updates');
                supabase.removeChannel(this.realtimeChannel);
                this.realtimeChannel = null;
            }
        },
        
        handleRealtimeUpdate(payload) {
            // Ignore if we just sent this update (echo prevention)
            if (this.isReceivingUpdate) {
                console.log('📡 Ignoring echo update');
                return;
            }
            
            const newData = payload.new;
            const updatedAt = new Date(newData.updated_at).getTime();
            
            // Check if this is newer than our last known version
            if (this.lastKnownVersion && updatedAt <= this.lastKnownVersion) {
                console.log('📡 Ignoring older update');
                return;
            }
            
            console.log('📡 Received real-time update from another device');
            
            // Show notification to user
            this.showSyncNotification(newData);
        },
        
        showSyncNotification(newData) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'sync-notification';
            notification.innerHTML = `
                <div class="sync-notification-content">
                    <div class="sync-notification-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 0 1-9 9m9-9a9 9 0 0 0-9-9m9 9H3m9 9a9 9 0 0 1-9-9m9 9c1.66 0 3-4.03 3-9s-1.34-9-3-9m0 18c-1.66 0-3-4.03-3-9s1.34-9 3-9m-9 9a9 9 0 0 1 9-9"/>
                        </svg>
                    </div>
                    <div class="sync-notification-text">
                        <strong>Changes from another device</strong>
                        <span>Your map was updated elsewhere</span>
                    </div>
                    <div class="sync-notification-actions">
                        <button class="sync-btn sync-btn-refresh">Load Changes</button>
                        <button class="sync-btn sync-btn-dismiss">Keep Mine</button>
                    </div>
                </div>
            `;
            
            // Add styles if not present
            if (!document.getElementById('sync-notification-styles')) {
                const style = document.createElement('style');
                style.id = 'sync-notification-styles';
                style.textContent = `
                    .sync-notification {
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: var(--glass-bg);
                        backdrop-filter: blur(20px);
                        border: 1px solid var(--accent);
                        border-radius: 12px;
                        padding: 16px 20px;
                        z-index: 10000;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                        animation: slideDown 0.3s var(--ease-out);
                        max-width: 340px;
                        width: 90%;
                    }
                    @keyframes slideDown {
                        from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        to { opacity: 1; transform: translateX(-50%) translateY(0); }
                    }
                    .sync-notification-content {
                        display: flex;
                        flex-direction: column;
                        gap: 12px;
                    }
                    .sync-notification-icon {
                        text-align: center;
                    }
                    .sync-notification-icon svg {
                        width: 32px;
                        height: 32px;
                        stroke: var(--accent);
                    }
                    .sync-notification-text {
                        text-align: center;
                    }
                    .sync-notification-text strong {
                        display: block;
                        color: var(--text-primary);
                        margin-bottom: 4px;
                    }
                    .sync-notification-text span {
                        color: var(--text-secondary);
                        font-size: 0.9rem;
                    }
                    .sync-notification-actions {
                        display: flex;
                        gap: 10px;
                        justify-content: center;
                    }
                    .sync-btn {
                        padding: 8px 16px;
                        border-radius: 8px;
                        font-size: 0.9rem;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .sync-btn-refresh {
                        background: var(--accent);
                        color: white;
                        border: none;
                    }
                    .sync-btn-refresh:hover {
                        filter: brightness(1.1);
                    }
                    .sync-btn-dismiss {
                        background: transparent;
                        color: var(--text-secondary);
                        border: 1px solid var(--border-color);
                    }
                    .sync-btn-dismiss:hover {
                        background: var(--bg-tertiary);
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Handle button clicks
            notification.querySelector('.sync-btn-refresh').addEventListener('click', async () => {
                notification.remove();
                await this.loadAndApplyRemoteChanges(newData);
            });
            
            notification.querySelector('.sync-btn-dismiss').addEventListener('click', () => {
                notification.remove();
                // Force save our version
                this.forceSave();
            });
            
            // Auto-dismiss after 30 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 30000);
        },
        
        async loadAndApplyRemoteChanges(newData) {
            try {
                showToast('Loading changes...', 'info');
                
                // Apply the remote data
                if (newData.data) {
                    store.data = newData.data;
                    store.save();
                    this.lastKnownVersion = new Date(newData.updated_at).getTime();
                    
                    // Rebuild the scene
                    buildScene();
                    
                    // Re-train neural net on updated map (if training enabled)
                    setTimeout(() => {
                        if (typeof neuralNet !== 'undefined' && isNeuralTrainingAllowed()) {
                            neuralNet.train(store).catch(err => console.warn('Neural net training failed:', err));
                        }
                    }, 300);
                    
                    showToast('Map updated from cloud', 'success');
                }
            } catch (error) {
                console.error('Failed to apply remote changes:', error);
                showToast('Failed to load changes', 'error');
            }
        },
        
        async forceSave() {
            this.isReceivingUpdate = true;
            await this.saveMap(store.data, store.data.label || 'My Mind');
            this.isReceivingUpdate = false;
            showToast('Your version saved to cloud', 'success');
        },
        
        // ─── Mind Map Operations ─────────────────────────────────────────
        
        async loadUserMaps() {
            if (!this.syncEnabled) return [];
            
            const { data, error } = await supabase
                .from('mind_maps')
                .select('id, name, updated_at, created_at')
                .order('updated_at', { ascending: false });
            
            if (error) {
                console.error('Failed to load maps:', error);
                return [];
            }
            
            return data || [];
        },
        
        async loadMap(mapId) {
            if (!this.syncEnabled) return null;
            
            const { data, error } = await supabase
                .from('mind_maps')
                .select('*')
                .eq('id', mapId)
                .single();
            
            if (error) {
                console.error('Failed to load map:', error);
                return null;
            }
            
            this.currentMapId = mapId;
            this.lastKnownVersion = new Date(data.updated_at).getTime();
            
            // Subscribe to real-time updates for this map
            await this.subscribeToRealtime(mapId);
            
            return data;
        },
        
        async saveMap(mapData, mapName = 'My Mind') {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            // Set flag to prevent echo
            this.isReceivingUpdate = true;
            
            // If we have a current map, update it
            if (this.currentMapId) {
                const { data, error } = await supabase
                    .from('mind_maps')
                    .update({
                        name: mapName,
                        data: mapData,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', this.currentMapId)
                    .select()
                    .single();
                
                // Reset flag after a short delay (to account for realtime latency)
                setTimeout(() => { this.isReceivingUpdate = false; }, 1000);
                
                if (error) {
                    console.error('Failed to update map:', error);
                    return null;
                }
                
                this.lastSyncTime = Date.now();
                this.lastKnownVersion = new Date(data.updated_at).getTime();
                return data;
            }
            
            // Otherwise create new map
            const { data, error } = await supabase
                .from('mind_maps')
                .insert({
                    user_id: userId,
                    name: mapName,
                    data: mapData
                })
                .select()
                .single();
            
            setTimeout(() => { this.isReceivingUpdate = false; }, 1000);
            
            if (error) {
                console.error('Failed to create map:', error);
                return null;
            }
            
            this.currentMapId = data.id;
            this.lastSyncTime = Date.now();
            this.lastKnownVersion = new Date(data.updated_at).getTime();
            
            // Subscribe to real-time updates for the new map
            await this.subscribeToRealtime(data.id);
            
            return data;
        },
        
        async deleteMap(mapId) {
            if (!this.syncEnabled) return false;
            
            const { error } = await supabase
                .from('mind_maps')
                .delete()
                .eq('id', mapId);
            
            if (error) {
                console.error('Failed to delete map:', error);
                return false;
            }
            
            if (this.currentMapId === mapId) {
                this.currentMapId = null;
                this.unsubscribeFromRealtime();
            }
            
            return true;
        },
        
        async renameMap(mapId, newName) {
            if (!this.syncEnabled) return false;
            
            const { error } = await supabase
                .from('mind_maps')
                .update({ name: newName, updated_at: new Date().toISOString() })
                .eq('id', mapId);
            
            if (error) {
                console.error('Failed to rename map:', error);
                return false;
            }
            
            return true;
        },
        
        async duplicateMap(mapId, newName) {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            // Load the original map
            const original = await this.loadMap(mapId);
            if (!original) return null;
            
            // Create a copy
            const { data, error } = await supabase
                .from('mind_maps')
                .insert({
                    user_id: userId,
                    name: newName,
                    data: original.data
                })
                .select()
                .single();
            
            if (error) {
                console.error('Failed to duplicate map:', error);
                return null;
            }
            
            return data;
        },
        
        // Debounced save for real-time editing
        scheduleSave(mapData, mapName) {
            if (!this.syncEnabled) return;
            
            if (this.syncDebounceTimer) {
                clearTimeout(this.syncDebounceTimer);
            }
            
            // Update indicator to show pending
            this.updateSyncIndicator('syncing');
            
            this.syncDebounceTimer = setTimeout(async () => {
                if (this.isSyncing) return;
                
                this.isSyncing = true;
                await this.saveMap(mapData, mapName);
                this.isSyncing = false;
                
                // Update sync indicator
                this.updateSyncIndicator('synced');
            }, 2000); // Sync every 2 seconds of inactivity
        },
        
        updateSyncIndicator(status = 'synced') {
            const indicator = document.getElementById('sync-indicator');
            if (!indicator) return;
            
            indicator.classList.remove('synced', 'syncing', 'error', 'connected');
            
            switch (status) {
                case 'synced':
                    indicator.classList.add('synced');
                    indicator.title = 'Synced to cloud';
                    break;
                case 'syncing':
                    indicator.classList.add('syncing');
                    indicator.title = 'Syncing...';
                    break;
                case 'connected':
                    indicator.classList.add('synced');
                    indicator.title = 'Connected - Real-time sync active';
                    break;
                case 'error':
                    indicator.classList.add('error');
                    indicator.title = 'Sync error';
                    break;
            }
        },
        
        // ─── Neural Patterns Operations ──────────────────────────────────
        
        async loadNeuralPatterns() {
            if (!this.syncEnabled) return new Map();
            
            const { data, error } = await supabase
                .from('neural_patterns')
                .select('*');
            
            if (error) {
                console.error('Failed to load neural patterns:', error);
                return new Map();
            }
            
            // Convert to Map format used by PersonalNeuralNet
            const patterns = new Map();
            for (const row of data || []) {
                patterns.set(row.pattern_key, {
                    weight: row.weight,
                    occurrences: row.occurrences,
                    accepted: row.accepted,
                    sources: row.sources || [],
                    relationshipType: row.relationship_type,
                    relationshipConfidence: row.relationship_confidence
                });
            }
            
            return patterns;
        },
        
        async saveNeuralPattern(patternKey, patternData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('neural_patterns')
                .upsert({
                    user_id: userId,
                    pattern_key: patternKey,
                    weight: patternData.weight,
                    occurrences: patternData.occurrences,
                    accepted: patternData.accepted,
                    sources: patternData.sources,
                    relationship_type: patternData.relationshipType,
                    relationship_confidence: patternData.relationshipConfidence
                }, {
                    onConflict: 'user_id,pattern_key'
                });
            
            if (error) {
                console.error('Failed to save neural pattern:', error);
            }
        },
        
        async saveAllNeuralPatterns(patternsMap) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const patterns = Array.from(patternsMap.entries()).map(([key, data]) => ({
                user_id: userId,
                pattern_key: key,
                weight: data.weight,
                occurrences: data.occurrences,
                accepted: data.accepted,
                sources: data.sources,
                relationship_type: data.relationshipType,
                relationship_confidence: data.relationshipConfidence
            }));
            
            if (patterns.length === 0) return;
            
            const { error } = await supabase
                .from('neural_patterns')
                .upsert(patterns, {
                    onConflict: 'user_id,pattern_key'
                });
            
            if (error) {
                console.error('Failed to save neural patterns:', error);
            }
        },
        
        // ─── User Profile Operations ─────────────────────────────────────
        
        async loadUserProfile() {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            const { data, error } = await supabase
                .from('user_profiles')
                .select('*')
                .eq('user_id', userId)
                .single();
            
            if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
                console.error('Failed to load user profile:', error);
            }
            
            return data;
        },
        
        async saveUserProfile(profileData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('user_profiles')
                .upsert({
                    user_id: userId,
                    building_style: profileData.buildingStyle || {},
                    exploration_style: profileData.explorationStyle || {},
                    refinement_style: profileData.refinementStyle || {},
                    decision_style: profileData.decisionStyle || {},
                    session_rhythm: profileData.sessionRhythm || {},
                    branch_commitment: profileData.branchCommitment || {},
                    cognitive_patterns: profileData.cognitivePatterns || {},
                    preferences: profileData.preferences || {},
                    insights: profileData.insights || {}
                }, {
                    onConflict: 'user_id'
                });
            
            if (error) {
                console.error('Failed to save user profile:', error);
            }
        },
        
        // ─── Concept Abstractions Operations ─────────────────────────────
        
        async loadConceptAbstractions() {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            const { data, error } = await supabase
                .from('concept_abstractions')
                .select('*')
                .eq('user_id', userId)
                .single();
            
            if (error && error.code !== 'PGRST116') {
                console.error('Failed to load concept abstractions:', error);
            }
            
            return data;
        },
        
        async saveConceptAbstractions(abstractionData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('concept_abstractions')
                .upsert({
                    user_id: userId,
                    schemas: abstractionData.schemas || {},
                    clusters: abstractionData.clusters || {},
                    hierarchy_patterns: abstractionData.hierarchyPatterns || {},
                    stats: abstractionData.stats || {}
                }, {
                    onConflict: 'user_id'
                });
            
            if (error) {
                console.error('Failed to save concept abstractions:', error);
            }
        },
        
        // ─── Semantic Memories Operations ────────────────────────────────
        
        async loadSemanticMemories() {
            if (!this.syncEnabled) return [];
            
            const { data, error } = await supabase
                .from('semantic_memories')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(200);
            
            if (error) {
                console.error('Failed to load semantic memories:', error);
                return [];
            }
            
            return data || [];
        },
        
        async saveSemanticMemory(memory) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('semantic_memories')
                .insert({
                    user_id: userId,
                    event: memory.event,
                    context: memory.context,
                    importance: memory.importance,
                    metadata: memory.metadata,
                    embedding: memory.embedding
                });
            
            if (error) {
                console.error('Failed to save semantic memory:', error);
            }
        },
        
        // ─── Full Sync ───────────────────────────────────────────────────
        
        async performFullSync(store, neuralNet, metaLearner, conceptAbstractor) {
            if (!this.syncEnabled) return;
            
            console.log('Starting full cloud sync...');
            
            try {
                // Save current map
                await this.saveMap(store.exportData(), store.data?.label || 'My Mind');
                
                // Save neural patterns
                if (neuralNet?.patternWeights) {
                    await this.saveAllNeuralPatterns(neuralNet.patternWeights);
                }
                
                // Save neural model weights
                if (neuralNet) {
                    await this.saveNeuralModels(neuralNet);
                }
                
                // Save user profile (MetaLearner data)
                if (metaLearner) {
                    await this.saveUserProfile({
                        buildingStyle: metaLearner.buildingStyle,
                        explorationStyle: metaLearner.explorationStyle,
                        refinementStyle: metaLearner.refinementStyle,
                        decisionStyle: metaLearner.decisionStyle,
                        sessionRhythm: metaLearner.sessionRhythm,
                        branchCommitment: metaLearner.branchCommitment,
                        cognitivePatterns: metaLearner.cognitivePatterns,
                        insights: metaLearner.insights
                    });
                }
                
                // Save concept abstractions
                if (conceptAbstractor) {
                    await this.saveConceptAbstractions({
                        schemas: Object.fromEntries(conceptAbstractor.schemas || []),
                        clusters: Object.fromEntries(conceptAbstractor.clusters || []),
                        hierarchyPatterns: Object.fromEntries(conceptAbstractor.hierarchyPatterns || []),
                        stats: conceptAbstractor.stats
                    });
                }
                
                console.log('✓ Full sync complete');
                showToast('Synced to cloud', 'success');
                this.updateSyncIndicator();
                
            } catch (error) {
                console.error('Full sync failed:', error);
                showToast('Sync failed', 'error');
            }
        },
        
        // ─── Neural Model Operations ───────────────────────────────────────
        
        async saveNeuralModels(neuralNet) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            try {
                // Extract model data using neuralNet's internal method logic
                const extractWeights = async (model) => {
                    if (!model) return null;
                    const weights = [];
                    for (const layer of model.layers) {
                        const layerWeights = layer.getWeights();
                        const extracted = [];
                        for (const w of layerWeights) {
                            const data = await w.data();
                            extracted.push({
                                shape: w.shape,
                                data: Array.from(data)
                            });
                        }
                        weights.push(extracted);
                    }
                    return weights;
                };
                
                const modelData = {
                    version: 3,
                    savedAt: Date.now(),
                    categories: neuralNet.categories || [],
                    commonPatterns: neuralNet.commonPatterns || [],
                    expansionPatterns: Array.from(neuralNet.expansionPatterns?.entries() || []),
                    patternWeights: Array.from(neuralNet.patternWeights?.entries() || []),
                    categoryWeights: await extractWeights(neuralNet.categoryModel),
                    connectionWeights: await extractWeights(neuralNet.connectionModel),
                    predictionWeights: await extractWeights(neuralNet.predictionModel)
                };
                
                const { error } = await supabase
                    .from('neural_models')
                    .upsert({
                        user_id: userId,
                        model_data: modelData,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id'
                    });
                
                if (error) {
                    console.error('Failed to save neural models to cloud:', error);
                } else {
                    const sizeKB = JSON.stringify(modelData).length / 1024;
                    console.log(`✓ Neural models synced to cloud (${sizeKB.toFixed(1)}KB)`);
                }
                
            } catch (error) {
                console.error('Neural model cloud sync error:', error);
            }
        },
        
        async loadNeuralModels() {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            try {
                const { data, error } = await supabase
                    .from('neural_models')
                    .select('model_data, updated_at')
                    .eq('user_id', userId)
                    .single();
                
                if (error) {
                    if (error.code !== 'PGRST116') { // Not found is ok
                        console.error('Failed to load neural models from cloud:', error);
                    }
                    return null;
                }
                
                if (data?.model_data) {
                    console.log(`✓ Neural models loaded from cloud (saved: ${new Date(data.updated_at).toLocaleString()})`);
                    return {
                        modelData: data.model_data,
                        updatedAt: new Date(data.updated_at).getTime()
                    };
                }
                
                return null;
                
            } catch (error) {
                console.error('Neural model cloud load error:', error);
                return null;
            }
        },
        
        // ─── AI Feedback Operations ────────────────────────────────────────
        
        async saveAIFeedback(feedback) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            try {
                const { error } = await supabase
                    .from('ai_feedback')
                    .insert({
                        user_id: userId,
                        suggestion_type: feedback.type,
                        user_action: feedback.action,
                        predicted: feedback.predicted,
                        chosen: feedback.chosen,
                        response_time_ms: feedback.responseTime,
                        created_at: new Date(feedback.timestamp).toISOString()
                    });
                
                if (error) {
                    console.warn('Failed to save AI feedback to cloud:', error);
                }
            } catch (error) {
                console.warn('AI feedback cloud sync error:', error);
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // INDEXEDDB STORAGE FOR NEURAL NETWORK
    // ═══════════════════════════════════════════════════════════════════
    const NeuralDB = {
        db: null,
        
        async init() {
            if (this.db) return this.db;
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CONFIG.NEURAL_NET.DB_NAME, CONFIG.NEURAL_NET.DB_VERSION);
                
                request.onerror = () => {
                    console.error('Failed to open IndexedDB:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    console.log('✓ IndexedDB initialized for neural network storage');
                    resolve(this.db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object store for model data
                    if (!db.objectStoreNames.contains(CONFIG.NEURAL_NET.STORE_NAME)) {
                        db.createObjectStore(CONFIG.NEURAL_NET.STORE_NAME, { keyPath: 'id' });
                        console.log('✓ Created IndexedDB object store');
                    }
                };
            });
        },
        
        async save(key, data) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.put({ id: key, data: data, timestamp: Date.now() });
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB save error:', error);
                return false;
            }
        },
        
        async load(key) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.get(key);
                    
                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result.data);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB load error:', error);
                return null;
            }
        },
        
        async delete(key) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.delete(key);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB delete error:', error);
                return false;
            }
        },
        
        async getSize() {
            try {
                await this.init();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const totalSize = JSON.stringify(request.result).length;
                        resolve(totalSize);
                    };
                    request.onerror = () => resolve(0);
                });
            } catch (error) {
                return 0;
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ATTACHMENT STORAGE - IndexedDB for file blobs
    // ═══════════════════════════════════════════════════════════════════
    const AttachmentDB = {
        db: null,
        
        async init() {
            if (this.db) return this.db;
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CONFIG.ATTACHMENTS.DB_NAME, CONFIG.ATTACHMENTS.DB_VERSION);
                
                request.onerror = () => {
                    console.error('Failed to open AttachmentDB:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    console.log('✓ AttachmentDB initialized');
                    resolve(this.db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(CONFIG.ATTACHMENTS.STORE_NAME)) {
                        db.createObjectStore(CONFIG.ATTACHMENTS.STORE_NAME, { keyPath: 'id' });
                        console.log('✓ Created AttachmentDB object store');
                    }
                };
            });
        },
        
        async save(id, blob, metadata = {}) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.ATTACHMENTS.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.ATTACHMENTS.STORE_NAME);
                    
                    const record = {
                        id,
                        blob,
                        ...metadata,
                        savedAt: Date.now()
                    };
                    
                    const request = store.put(record);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('AttachmentDB save error:', error);
                return false;
            }
        },
        
        async load(id) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.ATTACHMENTS.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.ATTACHMENTS.STORE_NAME);
                    
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('AttachmentDB load error:', error);
                return null;
            }
        },
        
        async delete(id) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.ATTACHMENTS.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.ATTACHMENTS.STORE_NAME);
                    
                    const request = store.delete(id);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('AttachmentDB delete error:', error);
                return false;
            }
        },
        
        async getAll() {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.ATTACHMENTS.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.ATTACHMENTS.STORE_NAME);
                    
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('AttachmentDB getAll error:', error);
                return [];
            }
        },
        
        async getSize() {
            try {
                const all = await this.getAll();
                let totalSize = 0;
                for (const record of all) {
                    if (record.blob instanceof Blob) {
                        totalSize += record.blob.size;
                    }
                }
                return totalSize;
            } catch (error) {
                return 0;
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ATTACHMENT PROCESSOR - Handles images, PDFs, AI descriptions
    // ═══════════════════════════════════════════════════════════════════
    const AttachmentProcessor = {
        pdfWorker: null,
        
        // Generate unique attachment ID
        generateId() {
            return `att-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        },
        
        // Check if file type is supported
        isSupported(file) {
            return CONFIG.ATTACHMENTS.supportedImages.includes(file.type) ||
                   CONFIG.ATTACHMENTS.supportedDocs.includes(file.type);
        },
        
        // Check if file is an image
        isImage(file) {
            return CONFIG.ATTACHMENTS.supportedImages.includes(file.type);
        },
        
        // Check if file is a PDF
        isPDF(file) {
            return file.type === 'application/pdf';
        },
        
        // Create thumbnail from image file
        async createImageThumbnail(file, maxSize = CONFIG.ATTACHMENTS.thumbnailSize) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(file);
                
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    
                    // Calculate thumbnail dimensions
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height) {
                        if (width > maxSize) {
                            height = Math.round(height * maxSize / width);
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = Math.round(width * maxSize / height);
                            height = maxSize;
                        }
                    }
                    
                    // Draw to canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Export as base64
                    const thumbnail = canvas.toDataURL('image/jpeg', CONFIG.ATTACHMENTS.thumbnailQuality);
                    resolve(thumbnail);
                };
                
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load image'));
                };
                
                img.src = url;
            });
        },
        
        // Create thumbnail from PDF first page
        async createPDFThumbnail(file, maxSize = CONFIG.ATTACHMENTS.thumbnailSize) {
            try {
                // Load PDF.js if not already loaded
                if (typeof pdfjsLib === 'undefined') {
                    await this.loadPDFJS();
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const page = await pdf.getPage(1);
                
                const viewport = page.getViewport({ scale: 1 });
                const scale = maxSize / Math.max(viewport.width, viewport.height);
                const scaledViewport = page.getViewport({ scale });
                
                const canvas = document.createElement('canvas');
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;
                const ctx = canvas.getContext('2d');
                
                await page.render({
                    canvasContext: ctx,
                    viewport: scaledViewport
                }).promise;
                
                const thumbnail = canvas.toDataURL('image/jpeg', CONFIG.ATTACHMENTS.thumbnailQuality);
                pdf.destroy();
                
                return thumbnail;
            } catch (error) {
                console.error('PDF thumbnail error:', error);
                // Return a placeholder
                return this.createPlaceholderThumbnail('PDF');
            }
        },
        
        // Create placeholder thumbnail for failed processing
        createPlaceholderThumbnail(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, 100, 100);
            
            ctx.fillStyle = '#888';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(type, 50, 55);
            
            return canvas.toDataURL('image/jpeg', 0.8);
        },
        
        // Load PDF.js library dynamically
        async loadPDFJS() {
            if (typeof pdfjsLib !== 'undefined') return;
            
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                script.onload = () => {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 
                        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    console.log('✓ PDF.js loaded');
                    resolve();
                };
                script.onerror = () => reject(new Error('Failed to load PDF.js'));
                document.head.appendChild(script);
            });
        },
        
        // Extract text from PDF
        async extractPDFText(file) {
            try {
                if (typeof pdfjsLib === 'undefined') {
                    await this.loadPDFJS();
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdf.numPages;
                const textParts = [];
                
                for (let i = 1; i <= Math.min(numPages, 20); i++) { // Limit to 20 pages
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    textParts.push(pageText);
                }
                
                pdf.destroy();
                return {
                    text: textParts.join('\n\n'),
                    pageCount: numPages
                };
            } catch (error) {
                console.error('PDF text extraction error:', error);
                return { text: '', pageCount: 0 };
            }
        },
        
        // Get AI description for image (uses Claude API if available)
        async getImageDescription(file, nodeLabel = '') {
            try {
                const apiKey = localStorage.getItem('claude-api-key');
                if (!apiKey) {
                    return this.getBasicImageInfo(file);
                }
                
                // Convert to base64
                const base64 = await this.fileToBase64(file);
                const mediaType = file.type;
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 300,
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64.split(',')[1]
                                    }
                                },
                                {
                                    type: 'text',
                                    text: `Describe this image in 1-2 sentences for a mind map node${nodeLabel ? ` related to "${nodeLabel}"` : ''}. Be concise and focus on the main content.`
                                }
                            ]
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                return data.content[0].text;
            } catch (error) {
                console.warn('Image description error:', error);
                return this.getBasicImageInfo(file);
            }
        },
        
        // Basic image info fallback
        getBasicImageInfo(file) {
            const sizeKB = Math.round(file.size / 1024);
            return `Image: ${file.name} (${sizeKB}KB)`;
        },
        
        // Get AI summary for PDF
        async getPDFSummary(text, filename, nodeLabel = '') {
            try {
                const apiKey = localStorage.getItem('claude-api-key');
                if (!apiKey || !text || text.length < 50) {
                    return `PDF document: ${filename}`;
                }
                
                // Truncate text if too long
                const truncatedText = text.slice(0, 8000);
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 300,
                        messages: [{
                            role: 'user',
                            content: `Summarize this PDF document in 2-3 sentences for a mind map node${nodeLabel ? ` related to "${nodeLabel}"` : ''}. Be concise.\n\nDocument text:\n${truncatedText}`
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                return data.content[0].text;
            } catch (error) {
                console.warn('PDF summary error:', error);
                return `PDF document: ${filename}`;
            }
        },
        
        // Convert file to base64
        async fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsDataURL(file);
            });
        },
        
        // Process a file and create attachment object
        async processFile(file, nodeLabel = '') {
            if (!this.isSupported(file)) {
                throw new Error(`Unsupported file type: ${file.type}`);
            }
            
            if (file.size > CONFIG.ATTACHMENTS.maxFileSize) {
                throw new Error(`File too large: ${Math.round(file.size / 1024 / 1024)}MB (max ${CONFIG.ATTACHMENTS.maxFileSize / 1024 / 1024}MB)`);
            }
            
            const id = this.generateId();
            const attachment = {
                id,
                type: this.isImage(file) ? 'image' : 'pdf',
                filename: file.name,
                mimeType: file.type,
                size: file.size,
                thumbnail: null,
                aiDescription: '',
                extractedText: '',
                embedding: null,
                addedAt: Date.now()
            };
            
            try {
                if (this.isImage(file)) {
                    // Process image
                    attachment.thumbnail = await this.createImageThumbnail(file);
                    attachment.aiDescription = await this.getImageDescription(file, nodeLabel);
                } else if (this.isPDF(file)) {
                    // Process PDF
                    attachment.thumbnail = await this.createPDFThumbnail(file);
                    const { text, pageCount } = await this.extractPDFText(file);
                    attachment.extractedText = text;
                    attachment.pageCount = pageCount;
                    attachment.aiDescription = await this.getPDFSummary(text, file.name, nodeLabel);
                }
                
                // Generate embedding for AI description + extracted text
                if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                    const textForEmbedding = `${attachment.aiDescription} ${attachment.extractedText}`.slice(0, 1000);
                    if (textForEmbedding.length > 20) {
                        try {
                            const embedding = await neuralNet.getEmbedding(textForEmbedding);
                            if (embedding) {
                                attachment.embedding = Array.from(embedding);
                            }
                        } catch (e) {
                            console.warn('Embedding generation failed:', e);
                        }
                    }
                }
                
                // Store full file in IndexedDB
                await AttachmentDB.save(id, file, { filename: file.name, mimeType: file.type });
                
                return attachment;
            } catch (error) {
                console.error('Attachment processing error:', error);
                // Return partial attachment
                attachment.aiDescription = `${attachment.type}: ${file.name}`;
                return attachment;
            }
        },
        
        // Get full file blob from storage
        async getFile(attachmentId) {
            const record = await AttachmentDB.load(attachmentId);
            return record?.blob || null;
        },
        
        // Delete attachment and its stored file
        async deleteAttachment(attachmentId) {
            await AttachmentDB.delete(attachmentId);
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ATTACHMENT MANAGER - UI and integration for node attachments
    // ═══════════════════════════════════════════════════════════════════
    const AttachmentManager = {
        currentNodeId: null,
        processingCount: 0,
        
        // Initialize attachment event handlers
        init() {
            // Add button click
            document.getElementById('attachment-add-btn')?.addEventListener('click', () => {
                document.getElementById('attachment-file-input').click();
            });
            
            // File input change
            document.getElementById('attachment-file-input')?.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0 && this.currentNodeId) {
                    await this.addFiles(files, this.currentNodeId);
                }
                e.target.value = ''; // Reset
            });
            
            // Dropzone in info panel
            const dropzone = document.getElementById('attachments-dropzone');
            if (dropzone) {
                dropzone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropzone.classList.add('dragover');
                });
                
                dropzone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropzone.classList.remove('dragover');
                });
                
                dropzone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropzone.classList.remove('dragover');
                    
                    const files = Array.from(e.dataTransfer.files).filter(f => AttachmentProcessor.isSupported(f));
                    if (files.length > 0 && this.currentNodeId) {
                        await this.addFiles(files, this.currentNodeId);
                    }
                });
            }
            
            // Canvas drag/drop
            this.initCanvasDragDrop();
            
            // Paste handler
            this.initPasteHandler();
            
            // Lightbox
            this.initLightbox();
            
            console.log('✓ AttachmentManager initialized');
        },
        
        // Initialize canvas drag/drop
        initCanvasDragDrop() {
            const overlay = document.getElementById('canvas-drop-overlay');
            const container = document.getElementById('three-container');
            if (!container || !overlay) return;
            
            let dragCounter = 0;
            
            container.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                
                // Check if it's a file drag
                if (e.dataTransfer.types.includes('Files')) {
                    overlay.classList.add('active');
                    
                    // Update target text
                    const targetText = document.getElementById('canvas-drop-target');
                    if (typeof selectedNode !== 'undefined' && selectedNode) {
                        targetText.textContent = `Will be added to "${selectedNode.userData.label}"`;
                    } else {
                        targetText.textContent = 'Select a node first, or will add to root';
                    }
                }
            });
            
            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    overlay.classList.remove('active');
                }
            });
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                dragCounter = 0;
                overlay.classList.remove('active');
                
                const files = Array.from(e.dataTransfer.files).filter(f => AttachmentProcessor.isSupported(f));
                if (files.length === 0) return;
                
                // Determine target node
                let targetNodeId;
                if (typeof selectedNode !== 'undefined' && selectedNode) {
                    targetNodeId = selectedNode.userData.id;
                } else {
                    targetNodeId = typeof currentContextId !== 'undefined' ? currentContextId : 'mynd';
                }
                
                await this.addFiles(files, targetNodeId);
            });
            
            // Also handle drop on overlay itself
            overlay.addEventListener('dragover', (e) => e.preventDefault());
            overlay.addEventListener('drop', async (e) => {
                e.preventDefault();
                overlay.classList.remove('active');
                dragCounter = 0;
                
                const files = Array.from(e.dataTransfer.files).filter(f => AttachmentProcessor.isSupported(f));
                if (files.length === 0) return;
                
                let targetNodeId;
                if (typeof selectedNode !== 'undefined' && selectedNode) {
                    targetNodeId = selectedNode.userData.id;
                } else {
                    targetNodeId = typeof currentContextId !== 'undefined' ? currentContextId : 'mynd';
                }
                
                await this.addFiles(files, targetNodeId);
            });
        },
        
        // Initialize paste handler
        initPasteHandler() {
            document.addEventListener('paste', async (e) => {
                // Don't intercept if typing in an input
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
                    return;
                }
                
                const items = Array.from(e.clipboardData.items);
                const files = [];
                
                for (const item of items) {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file && AttachmentProcessor.isSupported(file)) {
                            files.push(file);
                        }
                    }
                }
                
                if (files.length === 0) return;
                
                e.preventDefault();
                
                // Determine target node
                let targetNodeId;
                if (typeof selectedNode !== 'undefined' && selectedNode) {
                    targetNodeId = selectedNode.userData.id;
                } else if (this.currentNodeId) {
                    targetNodeId = this.currentNodeId;
                } else {
                    targetNodeId = typeof currentContextId !== 'undefined' ? currentContextId : 'mynd';
                }
                
                await this.addFiles(files, targetNodeId);
            });
        },
        
        // Initialize lightbox
        initLightbox() {
            const overlay = document.getElementById('lightbox-overlay');
            const closeBtn = document.getElementById('lightbox-close');
            
            if (overlay) {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        this.closeLightbox();
                    }
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', () => this.closeLightbox());
            }
            
            // ESC to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && overlay?.classList.contains('active')) {
                    this.closeLightbox();
                }
            });
        },
        
        // Open lightbox
        openLightbox(attachment) {
            const overlay = document.getElementById('lightbox-overlay');
            const image = document.getElementById('lightbox-image');
            const filename = document.getElementById('lightbox-filename');
            const description = document.getElementById('lightbox-description');
            
            if (!overlay) return;
            
            // For images, show thumbnail first then load full
            if (attachment.type === 'image') {
                image.src = attachment.thumbnail;
                filename.textContent = attachment.filename;
                description.textContent = attachment.aiDescription || '';
                overlay.classList.add('active');
                
                // Try to load full image
                AttachmentProcessor.getFile(attachment.id).then(blob => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        image.onload = () => URL.revokeObjectURL(url);
                        image.src = url;
                    }
                });
            } else if (attachment.type === 'pdf') {
                // For PDF, show thumbnail and offer to open
                image.src = attachment.thumbnail;
                filename.textContent = attachment.filename;
                description.textContent = attachment.aiDescription || 'Click to download PDF';
                overlay.classList.add('active');
            }
        },
        
        // Close lightbox
        closeLightbox() {
            const overlay = document.getElementById('lightbox-overlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        },
        
        // Add files to a node
        async addFiles(files, nodeId) {
            if (!nodeId || files.length === 0) return;
            
            const nodeData = typeof store !== 'undefined' ? store.findNode(nodeId) : null;
            if (!nodeData) {
                console.warn('Node not found:', nodeId);
                return;
            }
            
            const nodeLabel = nodeData.label || '';
            
            // Initialize attachments array if needed
            if (!nodeData.attachments) {
                nodeData.attachments = [];
            }
            
            // Check limit
            if (nodeData.attachments.length + files.length > CONFIG.ATTACHMENTS.maxAttachmentsPerNode) {
                if (typeof showToast !== 'undefined') {
                    showToast(`Max ${CONFIG.ATTACHMENTS.maxAttachmentsPerNode} attachments per node`, 'error');
                }
                return;
            }
            
            this.processingCount += files.length;
            if (typeof showToast !== 'undefined') {
                showToast(`Processing ${files.length} file${files.length > 1 ? 's' : ''}...`, 'info');
            }
            
            const results = [];
            
            for (const file of files) {
                try {
                    const attachment = await AttachmentProcessor.processFile(file, nodeLabel);
                    nodeData.attachments.push(attachment);
                    results.push(attachment);
                    
                    // Train neural network on this content
                    this.trainOnAttachment(nodeData, attachment);
                    
                } catch (error) {
                    console.error('Failed to process file:', error);
                    if (typeof showToast !== 'undefined') {
                        showToast(`Failed: ${file.name}`, 'error');
                    }
                }
            }
            
            this.processingCount -= files.length;
            
            if (results.length > 0) {
                // Save to store
                if (typeof store !== 'undefined') {
                    store.updateNode(nodeId, { attachments: nodeData.attachments });
                }
                
                // Update UI if this is the selected node
                if (this.currentNodeId === nodeId) {
                    this.renderAttachments(nodeData);
                }
                
                if (typeof showToast !== 'undefined') {
                    showToast(`Added ${results.length} attachment${results.length > 1 ? 's' : ''}!`, 'success');
                }
            }
            
            return results;
        },
        
        // Delete attachment from node
        async deleteAttachment(nodeId, attachmentId) {
            const nodeData = typeof store !== 'undefined' ? store.findNode(nodeId) : null;
            if (!nodeData || !nodeData.attachments) return;
            
            const index = nodeData.attachments.findIndex(a => a.id === attachmentId);
            if (index === -1) return;
            
            // Remove from node
            nodeData.attachments.splice(index, 1);
            
            // Delete from IndexedDB
            await AttachmentProcessor.deleteAttachment(attachmentId);
            
            // Save to store
            if (typeof store !== 'undefined') {
                store.updateNode(nodeId, { attachments: nodeData.attachments });
            }
            
            // Update UI
            if (this.currentNodeId === nodeId) {
                this.renderAttachments(nodeData);
            }
            
            if (typeof showToast !== 'undefined') {
                showToast('Attachment removed', 'info');
            }
        },
        
        // Train neural network on attachment content
        trainOnAttachment(nodeData, attachment) {
            try {
                if (typeof neuralNet === 'undefined' || !neuralNet.isReady) return;
                
                const content = attachment.aiDescription || attachment.extractedText || '';
                if (content.length < 10) return;
                
                // Get node path for context
                const path = typeof store !== 'undefined' ? store.getPath(nodeData.id) : [nodeData];
                const depth = path.length - 1;
                
                // Learn pattern: parent label -> attachment description
                if (nodeData.label) {
                    neuralNet.incrementalLearnPattern(
                        nodeData.label,
                        content.slice(0, 100), // Truncate for pattern
                        attachment.type,
                        depth
                    );
                }
                
                // Queue embedding
                neuralNet.queueEmbedding(`${nodeData.label} ${content.slice(0, 200)}`);
                
                // Add to semantic memory
                if (typeof semanticMemory !== 'undefined' && semanticMemory.loaded) {
                    semanticMemory.addMemory('attachment_added', 
                        `Added ${attachment.type} "${attachment.filename}" to node "${nodeData.label}": ${content.slice(0, 150)}`,
                        { nodeId: nodeData.id, attachmentId: attachment.id, type: attachment.type }
                    );
                }
                
                console.log(`🧠 Trained on attachment: ${attachment.filename}`);
            } catch (e) {
                console.warn('Failed to train on attachment:', e);
            }
        },
        
        // Render attachments in info panel
        renderAttachments(nodeData) {
            this.currentNodeId = nodeData?.id || null;
            
            const container = document.getElementById('info-attachments');
            const grid = document.getElementById('attachments-grid');
            
            if (!container || !grid) return;
            
            const attachments = nodeData?.attachments || [];
            
            // Clear grid
            grid.innerHTML = '';
            
            if (attachments.length === 0) {
                // Show empty state (dropzone is always visible)
                return;
            }
            
            // Render each attachment
            attachments.forEach(attachment => {
                const item = document.createElement('div');
                item.className = 'attachment-item';
                item.title = attachment.aiDescription || attachment.filename;
                
                // Thumbnail
                const img = document.createElement('img');
                img.src = attachment.thumbnail || '';
                img.alt = attachment.filename;
                item.appendChild(img);
                
                // Type badge
                const typeBadge = document.createElement('span');
                typeBadge.className = 'attachment-type';
                typeBadge.textContent = attachment.type === 'pdf' ? 'PDF' : 
                    attachment.mimeType?.split('/')[1]?.toUpperCase() || 'IMG';
                item.appendChild(typeBadge);
                
                // Delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'attachment-delete';
                deleteBtn.textContent = '×';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('Remove this attachment?')) {
                        this.deleteAttachment(nodeData.id, attachment.id);
                    }
                });
                item.appendChild(deleteBtn);
                
                // Generate nodes button (if has content)
                if (attachment.extractedText || attachment.aiDescription) {
                    const generateBtn = document.createElement('span');
                    generateBtn.className = 'attachment-generate';
                    generateBtn.innerHTML = '✨';
                    generateBtn.title = 'Generate child nodes from content';
                    generateBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await this.generateNodesFromAttachment(nodeData.id, attachment);
                    });
                    item.appendChild(generateBtn);
                }
                
                // Click to view
                item.addEventListener('click', () => {
                    if (attachment.type === 'pdf') {
                        // Offer to download PDF
                        this.downloadAttachment(attachment);
                    } else {
                        this.openLightbox(attachment);
                    }
                });
                
                grid.appendChild(item);
            });
        },
        
        // Download attachment
        async downloadAttachment(attachment) {
            const blob = await AttachmentProcessor.getFile(attachment.id);
            if (!blob) {
                if (typeof showToast !== 'undefined') {
                    showToast('File not found in storage', 'error');
                }
                return;
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = attachment.filename;
            a.click();
            URL.revokeObjectURL(url);
        },
        
        // Get attachments for export (thumbnails only, not full files)
        getExportData(attachments) {
            if (!attachments || attachments.length === 0) return [];
            
            return attachments.map(a => ({
                id: a.id,
                type: a.type,
                filename: a.filename,
                mimeType: a.mimeType,
                size: a.size,
                thumbnail: a.thumbnail,
                aiDescription: a.aiDescription,
                extractedText: a.extractedText?.slice(0, 2000), // Truncate text
                embedding: a.embedding,
                addedAt: a.addedAt
            }));
        },
        
        // Generate child nodes from attachment content
        async generateNodesFromAttachment(nodeId, attachment) {
            const apiKey = localStorage.getItem('claude-api-key');
            if (!apiKey) {
                if (typeof showToast !== 'undefined') {
                    showToast('Set Claude API key in settings to generate nodes', 'error');
                }
                return;
            }
            
            const nodeData = store.findNode(nodeId);
            if (!nodeData) return;
            
            // Get content from attachment
            const content = attachment.extractedText || attachment.aiDescription || '';
            if (content.length < 20) {
                if (typeof showToast !== 'undefined') {
                    showToast('Not enough content to generate nodes', 'error');
                }
                return;
            }
            
            if (typeof showToast !== 'undefined') {
                showToast('Analyzing content...', 'info');
            }
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1024,
                        messages: [{
                            role: 'user',
                            content: `You are helping organize a mind map. The parent node is "${nodeData.label}".

I have a ${attachment.type === 'pdf' ? 'PDF document' : 'image'} attached with the following content:

---
${content.slice(0, 4000)}
---

Based on this content, suggest 3-6 child nodes that capture the main concepts, sections, or key points from this ${attachment.type === 'pdf' ? 'document' : 'image'}.

Respond ONLY with a JSON array of objects, each with "label" (short, 2-5 words) and "description" (1-2 sentences) keys. Example:
[{"label": "Key Concept", "description": "Brief explanation of this concept"}]`
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                const text = data.content[0].text;
                
                // Parse JSON from response
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (!jsonMatch) {
                    throw new Error('Could not parse response');
                }
                
                const suggestions = JSON.parse(jsonMatch[0]);
                
                if (!Array.isArray(suggestions) || suggestions.length === 0) {
                    throw new Error('No suggestions generated');
                }
                
                // Add nodes
                let addedCount = 0;
                for (const suggestion of suggestions.slice(0, 6)) {
                    if (suggestion.label) {
                        const newNode = store.addChild(nodeId, {
                            label: suggestion.label,
                            description: suggestion.description || '',
                            color: nodeData.color,
                            source: 'attachment-ai',
                            attachmentSource: attachment.id
                        });
                        
                        if (newNode) {
                            addedCount++;
                            
                            // Train neural network
                            if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                                neuralNet.incrementalLearnPattern(
                                    nodeData.label,
                                    suggestion.label,
                                    'attachment-generated',
                                    (store.getPath(nodeId)?.length || 1)
                                );
                            }
                        }
                    }
                }
                
                if (addedCount > 0) {
                    // Refresh view
                    bus.emit('graph:refresh');
                    
                    if (typeof showToast !== 'undefined') {
                        showToast(`Created ${addedCount} nodes from ${attachment.filename}!`, 'success');
                    }
                }
                
            } catch (error) {
                console.error('Generate nodes error:', error);
                if (typeof showToast !== 'undefined') {
                    showToast('Failed to generate nodes: ' + error.message, 'error');
                }
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // USER PREFERENCE TRACKER - Learns from accepted/rejected suggestions
    // ═══════════════════════════════════════════════════════════════════
    class PreferenceTracker {
        constructor() {
            this.pendingSuggestions = new Map(); // sessionId -> { parentLabel, parentId, suggestions, timestamp }
            this.currentSessionId = null;
            
            // Preference history
            this.history = {
                accepted: [],  // { label, parentLabel, type, timestamp, context }
                ignored: [],   // { label, parentLabel, type, timestamp, context }
            };
            
            // Aggregated insights (computed from history)
            this.insights = {
                acceptanceRateByType: { ml: { accepted: 0, total: 0 }, ai: { accepted: 0, total: 0 } },
                preferredPatterns: {},      // label patterns user tends to accept
                avoidedPatterns: {},        // label patterns user tends to ignore
                preferredParentChildPairs: [], // successful parent->child relationships
                topAcceptedLabels: [],      // most frequently accepted suggestion labels
                topIgnoredLabels: [],       // most frequently ignored suggestion labels
                stylePreferences: {
                    prefersActionLabels: 0,    // -1 to 1 scale
                    prefersShortLabels: 0,     // -1 to 1 scale  
                    prefersDescriptive: 0,     // -1 to 1 scale
                }
            };
            
            this.maxHistorySize = 500; // Keep last 500 decisions
            this.loaded = false;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('preference-history');
                if (saved) {
                    this.history = saved.history || this.history;
                    this.insights = { ...this.insights, ...saved.insights };
                    console.log(`✓ Loaded preference history: ${this.history.accepted.length} accepted, ${this.history.ignored.length} ignored`);
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load preference history:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('preference-history', {
                    history: this.history,
                    insights: this.insights,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save preference history:', error);
            }
        }
        
        // Start tracking a new suggestion session
        startSession(parentId, parentLabel, suggestions) {
            // First, finalize any pending session (mark unclicked as ignored)
            this.finalizePendingSession();
            
            // Create new session
            this.currentSessionId = `session_${Date.now()}`;
            this.pendingSuggestions.set(this.currentSessionId, {
                parentId,
                parentLabel,
                suggestions: suggestions.map(s => ({
                    label: s.label,
                    type: s.type || 'ai',
                    confidence: s.confidence,
                    accepted: false
                })),
                timestamp: Date.now()
            });
            
            console.log(`📊 Preference tracking: Started session for "${parentLabel}" with ${suggestions.length} suggestions`);
            return this.currentSessionId;
        }
        
        // Record that user accepted a suggestion
        recordAccept(label, type = 'ai') {
            if (!this.currentSessionId) return;
            
            const session = this.pendingSuggestions.get(this.currentSessionId);
            if (!session) return;
            
            // Mark as accepted in pending
            const suggestion = session.suggestions.find(s => s.label === label);
            if (suggestion) {
                suggestion.accepted = true;
            }
            
            // Add to accepted history
            const record = {
                label,
                parentLabel: session.parentLabel,
                parentId: session.parentId,
                type,
                timestamp: Date.now(),
                context: this.extractContext(label)
            };
            
            this.history.accepted.push(record);
            this.trimHistory();
            this.updateInsights();
            this.save();
            
            console.log(`✓ Preference: Accepted "${label}" (${type}) under "${session.parentLabel}"`);
        }
        
        // Finalize pending session - mark unaccepted suggestions as ignored
        finalizePendingSession() {
            if (!this.currentSessionId) return;
            
            const session = this.pendingSuggestions.get(this.currentSessionId);
            if (!session) return;
            
            // Record ignored suggestions
            const ignored = session.suggestions.filter(s => !s.accepted);
            ignored.forEach(s => {
                this.history.ignored.push({
                    label: s.label,
                    parentLabel: session.parentLabel,
                    parentId: session.parentId,
                    type: s.type,
                    timestamp: Date.now(),
                    context: this.extractContext(s.label)
                });
            });
            
            if (ignored.length > 0) {
                console.log(`📊 Preference: Ignored ${ignored.length} suggestions from "${session.parentLabel}"`);
                
                // Create semantic memory for significant rejections (3+ ignored in one session)
                if (ignored.length >= 3 && typeof semanticMemory !== 'undefined') {
                    const ignoredLabels = ignored.map(s => s.label).slice(0, 3).join(', ');
                    semanticMemory.addMemory(
                        'suggestion_rejected',
                        `User ignored multiple suggestions under "${session.parentLabel}": ${ignoredLabels}`,
                        { parentLabel: session.parentLabel, ignoredCount: ignored.length, ignoredLabels: ignored.map(s => s.label) }
                    );
                }
            }
            
            // Cleanup
            this.pendingSuggestions.delete(this.currentSessionId);
            this.currentSessionId = null;
            
            this.trimHistory();
            this.updateInsights();
            this.save();
        }
        
        // Extract context features from a label
        extractContext(label) {
            const words = label.split(/\s+/);
            const actionVerbs = ['do', 'make', 'create', 'build', 'start', 'finish', 'complete', 'review', 'plan', 'design', 'implement', 'develop', 'write', 'read', 'learn', 'practice', 'track', 'monitor', 'analyze', 'improve'];
            const isAction = actionVerbs.some(v => label.toLowerCase().startsWith(v) || label.toLowerCase().includes(v));
            
            return {
                wordCount: words.length,
                charCount: label.length,
                isAction,
                hasNumbers: /\d/.test(label),
                isQuestion: label.includes('?'),
                startsWithVerb: actionVerbs.some(v => label.toLowerCase().startsWith(v)),
                firstWord: words[0]?.toLowerCase() || ''
            };
        }
        
        // Keep history within size limit
        trimHistory() {
            if (this.history.accepted.length > this.maxHistorySize) {
                this.history.accepted = this.history.accepted.slice(-this.maxHistorySize);
            }
            if (this.history.ignored.length > this.maxHistorySize) {
                this.history.ignored = this.history.ignored.slice(-this.maxHistorySize);
            }
        }
        
        // Update aggregated insights from history
        updateInsights() {
            // Reset counters
            this.insights.acceptanceRateByType = { 
                ml: { accepted: 0, total: 0 }, 
                ai: { accepted: 0, total: 0 } 
            };
            
            // Count by type
            this.history.accepted.forEach(r => {
                const type = r.type || 'ai';
                if (this.insights.acceptanceRateByType[type]) {
                    this.insights.acceptanceRateByType[type].accepted++;
                    this.insights.acceptanceRateByType[type].total++;
                }
            });
            
            this.history.ignored.forEach(r => {
                const type = r.type || 'ai';
                if (this.insights.acceptanceRateByType[type]) {
                    this.insights.acceptanceRateByType[type].total++;
                }
            });
            
            // Compute label frequency
            const acceptedLabels = {};
            const ignoredLabels = {};
            
            this.history.accepted.forEach(r => {
                acceptedLabels[r.label] = (acceptedLabels[r.label] || 0) + 1;
            });
            
            this.history.ignored.forEach(r => {
                ignoredLabels[r.label] = (ignoredLabels[r.label] || 0) + 1;
            });
            
            // Top accepted/ignored
            this.insights.topAcceptedLabels = Object.entries(acceptedLabels)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([label, count]) => ({ label, count }));
                
            this.insights.topIgnoredLabels = Object.entries(ignoredLabels)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([label, count]) => ({ label, count }));
            
            // Compute parent->child success pairs
            const parentChildSuccess = {};
            this.history.accepted.forEach(r => {
                const key = `${r.parentLabel}→${r.label}`;
                parentChildSuccess[key] = (parentChildSuccess[key] || 0) + 1;
            });
            
            this.insights.preferredParentChildPairs = Object.entries(parentChildSuccess)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([pair, count]) => ({ pair, count }));
            
            // Analyze style preferences
            this.analyzeStylePreferences();
        }
        
        // Analyze what style of labels user prefers
        analyzeStylePreferences() {
            const accepted = this.history.accepted.slice(-100); // Recent 100
            const ignored = this.history.ignored.slice(-100);
            
            if (accepted.length + ignored.length < 10) return; // Not enough data
            
            // Action labels
            const acceptedActions = accepted.filter(r => r.context?.isAction).length;
            const ignoredActions = ignored.filter(r => r.context?.isAction).length;
            const totalActions = acceptedActions + ignoredActions;
            if (totalActions > 5) {
                this.insights.stylePreferences.prefersActionLabels = 
                    (acceptedActions / totalActions) * 2 - 1; // -1 to 1 scale
            }
            
            // Short labels (1-2 words)
            const acceptedShort = accepted.filter(r => r.context?.wordCount <= 2).length;
            const ignoredShort = ignored.filter(r => r.context?.wordCount <= 2).length;
            const totalShort = acceptedShort + ignoredShort;
            if (totalShort > 5) {
                this.insights.stylePreferences.prefersShortLabels = 
                    (acceptedShort / totalShort) * 2 - 1;
            }
            
            // Descriptive (3+ words)
            const acceptedDesc = accepted.filter(r => r.context?.wordCount >= 3).length;
            const ignoredDesc = ignored.filter(r => r.context?.wordCount >= 3).length;
            const totalDesc = acceptedDesc + ignoredDesc;
            if (totalDesc > 5) {
                this.insights.stylePreferences.prefersDescriptive = 
                    (acceptedDesc / totalDesc) * 2 - 1;
            }
        }
        
        // Get acceptance rate for a type (or overall)
        getAcceptanceRate(type = null) {
            if (type) {
                const stats = this.insights.acceptanceRateByType[type];
                if (!stats || stats.total === 0) return null;
                return stats.accepted / stats.total;
            }
            
            const totalAccepted = this.history.accepted.length;
            const totalIgnored = this.history.ignored.length;
            const total = totalAccepted + totalIgnored;
            if (total === 0) return null;
            return totalAccepted / total;
        }
        
        // Generate insights string for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Acceptance rates
            const mlRate = this.getAcceptanceRate('ml');
            const aiRate = this.getAcceptanceRate('ai');
            const overallRate = this.getAcceptanceRate();
            
            if (overallRate !== null && this.history.accepted.length + this.history.ignored.length >= 10) {
                insights.push(`User acceptance rate: ${Math.round(overallRate * 100)}% overall`);
                
                if (mlRate !== null && this.insights.acceptanceRateByType.ml.total >= 5) {
                    insights.push(`  - ML suggestions: ${Math.round(mlRate * 100)}%`);
                }
                if (aiRate !== null && this.insights.acceptanceRateByType.ai.total >= 5) {
                    insights.push(`  - AI suggestions: ${Math.round(aiRate * 100)}%`);
                }
            }
            
            // Style preferences
            const style = this.insights.stylePreferences;
            if (style.prefersActionLabels > 0.3) {
                insights.push('User prefers action-oriented labels (verbs like "Plan X", "Review Y")');
            } else if (style.prefersActionLabels < -0.3) {
                insights.push('User prefers noun-based labels over action verbs');
            }
            
            if (style.prefersShortLabels > 0.3) {
                insights.push('User prefers concise 1-2 word labels');
            } else if (style.prefersDescriptive > 0.3) {
                insights.push('User prefers descriptive multi-word labels');
            }
            
            // Frequently accepted patterns
            if (this.insights.preferredParentChildPairs.length > 0) {
                const topPairs = this.insights.preferredParentChildPairs.slice(0, 3);
                if (topPairs.some(p => p.count >= 2)) {
                    insights.push('Frequently accepted patterns:');
                    topPairs.filter(p => p.count >= 2).forEach(p => {
                        insights.push(`  - ${p.pair}`);
                    });
                }
            }
            
            // Frequently ignored patterns (to avoid)
            if (this.insights.topIgnoredLabels.length > 0) {
                const topIgnored = this.insights.topIgnoredLabels.filter(l => l.count >= 3).slice(0, 3);
                if (topIgnored.length > 0) {
                    insights.push('Avoid these frequently-rejected suggestions:');
                    topIgnored.forEach(l => {
                        insights.push(`  - "${l.label}" (rejected ${l.count}x)`);
                    });
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI display
        getStats() {
            return {
                totalAccepted: this.history.accepted.length,
                totalIgnored: this.history.ignored.length,
                mlAcceptanceRate: this.getAcceptanceRate('ml'),
                aiAcceptanceRate: this.getAcceptanceRate('ai'),
                overallAcceptanceRate: this.getAcceptanceRate(),
                topAccepted: this.insights.topAcceptedLabels.slice(0, 5),
                topIgnored: this.insights.topIgnoredLabels.slice(0, 5),
                stylePreferences: this.insights.stylePreferences
            };
        }
        
        // Reset all preference data
        async reset() {
            this.history = { accepted: [], ignored: [] };
            this.insights = {
                acceptanceRateByType: { ml: { accepted: 0, total: 0 }, ai: { accepted: 0, total: 0 } },
                preferredPatterns: {},
                avoidedPatterns: {},
                preferredParentChildPairs: [],
                topAcceptedLabels: [],
                topIgnoredLabels: [],
                stylePreferences: {
                    prefersActionLabels: 0,
                    prefersShortLabels: 0,
                    prefersDescriptive: 0,
                }
            };
            this.pendingSuggestions.clear();
            this.currentSessionId = null;
            await NeuralDB.delete('preference-history');
            console.log('✓ Preference tracker reset');
        }
    }
    
    // Create global preference tracker instance
    const preferenceTracker = new PreferenceTracker();
    
    // ═══════════════════════════════════════════════════════════════════
    // SEMANTIC MEMORY SYSTEM - Long-term context awareness
    // ═══════════════════════════════════════════════════════════════════
    class SemanticMemory {
        constructor() {
            this.memories = [];
            this.maxMemories = 200; // Keep last 200 memories
            this.minImportance = 0.2; // Minimum importance to keep
            this.decayRate = 0.995; // Daily decay multiplier
            this.loaded = false;
            this.encoder = null; // Will be set from neuralNet
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('semantic-memories');
                if (saved && saved.memories) {
                    this.memories = saved.memories;
                    console.log(`✓ Loaded ${this.memories.length} semantic memories`);
                    
                    // Apply decay based on time since last load
                    if (saved.lastDecay) {
                        const daysSinceDecay = (Date.now() - saved.lastDecay) / (1000 * 60 * 60 * 24);
                        if (daysSinceDecay >= 1) {
                            this.applyDecay(Math.floor(daysSinceDecay));
                        }
                    }
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load semantic memories:', error);
                this.loaded = true;
            }
        }
        
        // Set encoder reference (called from neuralNet after it loads)
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('semantic-memories', {
                    memories: this.memories,
                    lastDecay: Date.now(),
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save semantic memories:', error);
            }
        }
        
        // Create a new memory
        async addMemory(event, context, metadata = {}) {
            // Generate embedding for the context
            let embedding = null;
            if (this.encoder) {
                try {
                    const embeddings = await this.encoder.embed([context]);
                    const embeddingArray = await embeddings.array();
                    embedding = embeddingArray[0];
                    embeddings.dispose();
                } catch (error) {
                    console.error('Failed to generate memory embedding:', error);
                }
            }
            
            // Calculate importance based on event type
            let importance = this.calculateImportance(event, metadata);
            
            const memory = {
                id: `mem_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                event,
                context,
                embedding,
                importance,
                timestamp: Date.now(),
                metadata
            };
            
            this.memories.push(memory);
            
            // Prune if over limit
            this.pruneMemories();
            
            console.log(`🧠 Memory stored: "${context.substring(0, 50)}..." (importance: ${importance.toFixed(2)})`);
            
            // Debounced save
            this.scheduleSave();
            
            return memory;
        }
        
        // Calculate importance based on event type
        calculateImportance(event, metadata) {
            const baseImportance = {
                'suggestion_accepted': 0.7,
                'suggestion_rejected': 0.4,
                'pattern_emerged': 0.8,
                'node_created_manual': 0.5,
                'node_deleted': 0.3,
                'brainstorm_completed': 0.6,
                'preference_pattern': 0.75,
                'session_insight': 0.65
            };
            
            let importance = baseImportance[event] || 0.5;
            
            // Boost for repeated patterns
            if (metadata.occurrences && metadata.occurrences > 1) {
                importance = Math.min(1.0, importance + 0.1 * (metadata.occurrences - 1));
            }
            
            // Boost for high confidence patterns
            if (metadata.confidence && metadata.confidence > 0.7) {
                importance = Math.min(1.0, importance + 0.1);
            }
            
            return importance;
        }
        
        // Find memories relevant to a query using embedding similarity
        async recallMemories(query, limit = 5, minSimilarity = 0.4) {
            if (!this.encoder || this.memories.length === 0) {
                return [];
            }
            
            try {
                // Get embedding for query
                const queryEmbeddings = await this.encoder.embed([query]);
                const queryEmbedding = (await queryEmbeddings.array())[0];
                queryEmbeddings.dispose();
                
                // Score all memories with embeddings
                const scored = this.memories
                    .filter(m => m.embedding)
                    .map(m => ({
                        memory: m,
                        similarity: this.cosineSimilarity(queryEmbedding, m.embedding),
                        // Combine similarity with importance and recency
                        score: this.calculateRecallScore(m, this.cosineSimilarity(queryEmbedding, m.embedding))
                    }))
                    .filter(s => s.similarity >= minSimilarity)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, limit);
                
                return scored.map(s => ({
                    ...s.memory,
                    similarity: s.similarity,
                    score: s.score
                }));
            } catch (error) {
                console.error('Memory recall error:', error);
                return [];
            }
        }
        
        // Calculate recall score combining similarity, importance, and recency
        calculateRecallScore(memory, similarity) {
            const daysSinceCreation = (Date.now() - memory.timestamp) / (1000 * 60 * 60 * 24);
            const recencyBoost = Math.exp(-daysSinceCreation / 30); // Decay over 30 days
            
            // Weighted combination
            return (similarity * 0.5) + (memory.importance * 0.3) + (recencyBoost * 0.2);
        }
        
        // Cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Get recent memories
        getRecentMemories(limit = 10, eventFilter = null) {
            let filtered = this.memories;
            
            if (eventFilter) {
                filtered = filtered.filter(m => m.event === eventFilter);
            }
            
            return filtered
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, limit);
        }
        
        // Get high-importance memories
        getImportantMemories(limit = 10, minImportance = 0.6) {
            return this.memories
                .filter(m => m.importance >= minImportance)
                .sort((a, b) => b.importance - a.importance)
                .slice(0, limit);
        }
        
        // Apply time-based decay to importance
        applyDecay(days = 1) {
            const decayMultiplier = Math.pow(this.decayRate, days);
            
            this.memories.forEach(m => {
                m.importance *= decayMultiplier;
            });
            
            // Remove memories below minimum importance
            const before = this.memories.length;
            this.memories = this.memories.filter(m => m.importance >= this.minImportance);
            
            if (this.memories.length < before) {
                console.log(`🧹 Decayed and pruned ${before - this.memories.length} low-importance memories`);
            }
        }
        
        // Prune memories if over limit
        pruneMemories() {
            if (this.memories.length <= this.maxMemories) return;
            
            // Sort by importance * recency score
            this.memories.sort((a, b) => {
                const scoreA = a.importance * Math.exp(-(Date.now() - a.timestamp) / (1000 * 60 * 60 * 24 * 30));
                const scoreB = b.importance * Math.exp(-(Date.now() - b.timestamp) / (1000 * 60 * 60 * 24 * 30));
                return scoreB - scoreA;
            });
            
            // Keep top memories
            const removed = this.memories.length - this.maxMemories;
            this.memories = this.memories.slice(0, this.maxMemories);
            console.log(`🧹 Pruned ${removed} oldest/least important memories`);
        }
        
        // Boost importance of an existing memory
        boostMemory(memoryId, boostAmount = 0.1) {
            const memory = this.memories.find(m => m.id === memoryId);
            if (memory) {
                memory.importance = Math.min(1.0, memory.importance + boostAmount);
                this.scheduleSave();
            }
        }
        
        // Generate insights string for Claude prompts
        async getPromptMemories(nodeLabel, nodePath, limit = 3) {
            if (this.memories.length === 0) return null;
            
            // Create context query from node info
            const query = `${nodeLabel} ${nodePath.join(' ')}`;
            
            // Recall relevant memories
            const relevant = await this.recallMemories(query, limit, 0.35);
            
            if (relevant.length === 0) return null;
            
            const lines = ['Relevant memories from past interactions:'];
            relevant.forEach(m => {
                lines.push(`- ${m.context} (${this.formatTimeAgo(m.timestamp)})`);
            });
            
            return lines.join('\n');
        }
        
        // Format timestamp as "X ago"
        formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
            return `${Math.floor(seconds / 604800)}w ago`;
        }
        
        // Get stats for UI
        getStats() {
            const importantCount = this.memories.filter(m => m.importance >= 0.6).length;
            const avgImportance = this.memories.length > 0
                ? this.memories.reduce((sum, m) => sum + m.importance, 0) / this.memories.length
                : 0;
            
            const eventCounts = {};
            this.memories.forEach(m => {
                eventCounts[m.event] = (eventCounts[m.event] || 0) + 1;
            });
            
            return {
                totalMemories: this.memories.length,
                importantMemories: importantCount,
                avgImportance,
                eventCounts,
                oldestMemory: this.memories.length > 0 
                    ? Math.min(...this.memories.map(m => m.timestamp))
                    : null
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 3000);
        }
        
        // Reset all memories
        async reset() {
            this.memories = [];
            await NeuralDB.delete('semantic-memories');
            console.log('✓ Semantic memories reset');
        }
    }
    
    // Create global semantic memory instance
    const semanticMemory = new SemanticMemory();
    
    // ═══════════════════════════════════════════════════════════════════
    // USER PROFILE - Evolving preferences and behavior patterns
    // ═══════════════════════════════════════════════════════════════════
    class UserProfile {
        constructor() {
            this.loaded = false;
            
            // Depth preferences
            this.depthStats = {
                totalNodes: 0,
                depthCounts: {}, // depth -> count
                avgDepth: 0,
                maxDepthReached: 0,
                preferredDepth: 2 // Default: moderate depth
            };
            
            // Naming style preferences
            this.namingStats = {
                totalLabels: 0,
                wordCounts: [], // Last 100 label word counts
                charCounts: [], // Last 100 label char counts
                avgWords: 2,
                avgChars: 15,
                actionLabelCount: 0,
                nounLabelCount: 0,
                questionCount: 0,
                style: 'balanced' // 'concise', 'descriptive', 'action-oriented', 'balanced'
            };
            
            // Category preferences (which top-level areas user focuses on)
            this.categoryStats = {
                interactions: {}, // categoryLabel -> { views, edits, expansions, lastActive }
                topCategories: [],
                focusAreas: [], // Categories with most activity
                neglectedAreas: [] // Categories rarely touched
            };
            
            // Time patterns
            this.timeStats = {
                hourlyActivity: new Array(24).fill(0), // Activity by hour (0-23)
                dailyActivity: new Array(7).fill(0), // Activity by day (0=Sun, 6=Sat)
                sessions: [], // Last 50 session summaries
                peakHours: [],
                peakDays: [],
                avgSessionLength: 0, // minutes
                totalSessions: 0
            };
            
            // Current session tracking
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
            
            this.maxHistorySize = 100;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('user-profile');
                if (saved) {
                    if (saved.depthStats) this.depthStats = { ...this.depthStats, ...saved.depthStats };
                    if (saved.namingStats) this.namingStats = { ...this.namingStats, ...saved.namingStats };
                    if (saved.categoryStats) this.categoryStats = { ...this.categoryStats, ...saved.categoryStats };
                    if (saved.timeStats) {
                        this.timeStats = { ...this.timeStats, ...saved.timeStats };
                        // Ensure arrays exist
                        if (!Array.isArray(this.timeStats.hourlyActivity)) {
                            this.timeStats.hourlyActivity = new Array(24).fill(0);
                        }
                        if (!Array.isArray(this.timeStats.dailyActivity)) {
                            this.timeStats.dailyActivity = new Array(7).fill(0);
                        }
                    }
                    console.log(`✓ Loaded user profile (${this.depthStats.totalNodes} nodes tracked)`);
                }
                this.loaded = true;
                
                // Start new session
                this.startSession();
            } catch (error) {
                console.error('Failed to load user profile:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('user-profile', {
                    depthStats: this.depthStats,
                    namingStats: this.namingStats,
                    categoryStats: this.categoryStats,
                    timeStats: this.timeStats,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save user profile:', error);
            }
        }
        
        // Start a new session
        startSession() {
            // End previous session if exists
            if (this.currentSession.nodeCount > 0) {
                this.endSession();
            }
            
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
        }
        
        // End current session and record stats
        endSession() {
            const duration = (Date.now() - this.currentSession.startTime) / 60000; // minutes
            
            if (duration > 1 && this.currentSession.nodeCount > 0) { // Only record meaningful sessions
                const session = {
                    timestamp: this.currentSession.startTime,
                    duration: Math.round(duration),
                    nodeCount: this.currentSession.nodeCount,
                    categories: Array.from(this.currentSession.categories),
                    actionCount: this.currentSession.actions.length
                };
                
                this.timeStats.sessions.push(session);
                if (this.timeStats.sessions.length > 50) {
                    this.timeStats.sessions = this.timeStats.sessions.slice(-50);
                }
                
                this.timeStats.totalSessions++;
                
                // Update average session length
                const recentSessions = this.timeStats.sessions.slice(-20);
                this.timeStats.avgSessionLength = Math.round(
                    recentSessions.reduce((sum, s) => sum + s.duration, 0) / recentSessions.length
                );
                
                this.scheduleSave();
            }
        }
        
        // Track node creation
        trackNodeCreated(node, parent, depth, store) {
            const now = new Date();
            
            // Update time stats
            this.timeStats.hourlyActivity[now.getHours()]++;
            this.timeStats.dailyActivity[now.getDay()]++;
            
            // Update depth stats
            this.depthStats.totalNodes++;
            this.depthStats.depthCounts[depth] = (this.depthStats.depthCounts[depth] || 0) + 1;
            this.depthStats.maxDepthReached = Math.max(this.depthStats.maxDepthReached, depth);
            this.updateDepthPreference();
            
            // Update naming stats
            this.trackLabelStyle(node.label);
            
            // Update category stats (find root category)
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'creation');
                this.currentSession.categories.add(rootCategory);
            }
            
            // Update session
            this.currentSession.nodeCount++;
            this.currentSession.actions.push({ type: 'create', label: node.label, timestamp: Date.now() });
            
            this.updatePeakTimes();
            this.scheduleSave();
        }
        
        // Track node selection/viewing
        trackNodeViewed(node, store) {
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'view');
            }
        }
        
        // Track node expansion (showing children)
        trackNodeExpanded(node, store) {
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'expansion');
            }
        }
        
        // Track label style
        trackLabelStyle(label) {
            const words = label.trim().split(/\s+/);
            const wordCount = words.length;
            const charCount = label.length;
            
            // Store in rolling window
            this.namingStats.wordCounts.push(wordCount);
            this.namingStats.charCounts.push(charCount);
            
            if (this.namingStats.wordCounts.length > this.maxHistorySize) {
                this.namingStats.wordCounts = this.namingStats.wordCounts.slice(-this.maxHistorySize);
                this.namingStats.charCounts = this.namingStats.charCounts.slice(-this.maxHistorySize);
            }
            
            // Update averages
            this.namingStats.totalLabels++;
            this.namingStats.avgWords = this.namingStats.wordCounts.reduce((a, b) => a + b, 0) / this.namingStats.wordCounts.length;
            this.namingStats.avgChars = this.namingStats.charCounts.reduce((a, b) => a + b, 0) / this.namingStats.charCounts.length;
            
            // Check for action verbs
            const actionVerbs = ['do', 'make', 'create', 'build', 'start', 'finish', 'complete', 'review', 'plan', 'design', 'implement', 'develop', 'write', 'read', 'learn', 'practice', 'track', 'monitor', 'analyze', 'improve', 'fix', 'update', 'add', 'remove', 'check', 'test'];
            const firstWord = words[0]?.toLowerCase();
            
            if (actionVerbs.includes(firstWord)) {
                this.namingStats.actionLabelCount++;
            } else {
                this.namingStats.nounLabelCount++;
            }
            
            if (label.includes('?')) {
                this.namingStats.questionCount++;
            }
            
            // Determine overall style
            this.updateNamingStyle();
        }
        
        // Update naming style classification
        updateNamingStyle() {
            const { avgWords, actionLabelCount, nounLabelCount, totalLabels } = this.namingStats;
            
            if (totalLabels < 10) {
                this.namingStats.style = 'balanced';
                return;
            }
            
            const actionRatio = actionLabelCount / totalLabels;
            
            if (avgWords <= 1.5) {
                this.namingStats.style = 'concise';
            } else if (avgWords >= 3.5) {
                this.namingStats.style = 'descriptive';
            } else if (actionRatio > 0.4) {
                this.namingStats.style = 'action-oriented';
            } else {
                this.namingStats.style = 'balanced';
            }
        }
        
        // Update depth preference
        updateDepthPreference() {
            const counts = this.depthStats.depthCounts;
            const depths = Object.keys(counts).map(Number);
            
            if (depths.length === 0) return;
            
            // Calculate weighted average depth
            let totalWeight = 0;
            let weightedSum = 0;
            
            depths.forEach(depth => {
                const count = counts[depth];
                weightedSum += depth * count;
                totalWeight += count;
            });
            
            this.depthStats.avgDepth = weightedSum / totalWeight;
            
            // Determine preferred depth
            if (this.depthStats.avgDepth <= 1.5) {
                this.depthStats.preferredDepth = 1; // Shallow
            } else if (this.depthStats.avgDepth <= 2.5) {
                this.depthStats.preferredDepth = 2; // Moderate
            } else if (this.depthStats.avgDepth <= 3.5) {
                this.depthStats.preferredDepth = 3; // Deep
            } else {
                this.depthStats.preferredDepth = 4; // Very deep
            }
        }
        
        // Find root category for a node
        findRootCategory(node, store) {
            if (!store || !node) return null;
            
            const path = store.getPath(node.id);
            if (path.length >= 2) {
                return path[1].label; // First child of root is the "category"
            }
            return node.label; // Node itself is a root category
        }
        
        // Track interaction with a category
        trackCategoryInteraction(categoryLabel, type) {
            if (!this.categoryStats.interactions[categoryLabel]) {
                this.categoryStats.interactions[categoryLabel] = {
                    views: 0,
                    edits: 0,
                    expansions: 0,
                    creations: 0,
                    lastActive: Date.now()
                };
            }
            
            const cat = this.categoryStats.interactions[categoryLabel];
            cat.lastActive = Date.now();
            
            switch (type) {
                case 'view': cat.views++; break;
                case 'edit': cat.edits++; break;
                case 'expansion': cat.expansions++; break;
                case 'creation': cat.creations++; break;
            }
            
            this.updateCategoryRankings();
        }
        
        // Update category rankings
        updateCategoryRankings() {
            const interactions = this.categoryStats.interactions;
            const categories = Object.entries(interactions);
            
            if (categories.length === 0) return;
            
            // Score each category
            const scored = categories.map(([label, stats]) => {
                const recencyBoost = Math.exp(-(Date.now() - stats.lastActive) / (1000 * 60 * 60 * 24 * 7)); // 7-day decay
                const activityScore = stats.creations * 3 + stats.expansions * 2 + stats.edits * 1.5 + stats.views * 0.5;
                return {
                    label,
                    score: activityScore * (0.5 + 0.5 * recencyBoost),
                    stats
                };
            });
            
            // Sort by score
            scored.sort((a, b) => b.score - a.score);
            
            // Top categories
            this.categoryStats.topCategories = scored.slice(0, 5).map(s => s.label);
            
            // Focus areas (high activity)
            const avgScore = scored.reduce((sum, s) => sum + s.score, 0) / scored.length;
            this.categoryStats.focusAreas = scored
                .filter(s => s.score > avgScore * 1.5)
                .slice(0, 3)
                .map(s => s.label);
            
            // Neglected areas (low activity, not recently touched)
            const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
            this.categoryStats.neglectedAreas = scored
                .filter(s => s.stats.lastActive < oneWeekAgo && s.score < avgScore * 0.5)
                .slice(0, 3)
                .map(s => s.label);
        }
        
        // Update peak times
        updatePeakTimes() {
            // Find peak hours
            const hourly = this.timeStats.hourlyActivity;
            const maxHourly = Math.max(...hourly);
            if (maxHourly > 0) {
                this.timeStats.peakHours = hourly
                    .map((count, hour) => ({ hour, count }))
                    .filter(h => h.count >= maxHourly * 0.7)
                    .map(h => h.hour);
            }
            
            // Find peak days
            const daily = this.timeStats.dailyActivity;
            const maxDaily = Math.max(...daily);
            if (maxDaily > 0) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                this.timeStats.peakDays = daily
                    .map((count, day) => ({ day: dayNames[day], count }))
                    .filter(d => d.count >= maxDaily * 0.7)
                    .map(d => d.day);
            }
        }
        
        // Generate insights string for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Depth preference
            if (this.depthStats.totalNodes >= 20) {
                const depthDesc = {
                    1: 'shallow, flat hierarchies',
                    2: 'moderate depth (2-3 levels)',
                    3: 'deep hierarchies (3-4 levels)',
                    4: 'very deep, detailed hierarchies'
                };
                insights.push(`Structure preference: ${depthDesc[this.depthStats.preferredDepth] || 'moderate depth'}`);
            }
            
            // Naming style
            if (this.namingStats.totalLabels >= 15) {
                const styleDesc = {
                    'concise': 'concise, 1-2 word labels',
                    'descriptive': 'descriptive, detailed labels (3+ words)',
                    'action-oriented': 'action-oriented labels (verbs like "Plan X", "Review Y")',
                    'balanced': 'balanced label style'
                };
                insights.push(`Naming style: ${styleDesc[this.namingStats.style]}`);
            }
            
            // Focus areas
            if (this.categoryStats.focusAreas.length > 0) {
                insights.push(`Current focus areas: ${this.categoryStats.focusAreas.join(', ')}`);
            }
            
            // Time context
            const now = new Date();
            const currentHour = now.getHours();
            if (this.timeStats.peakHours.includes(currentHour)) {
                insights.push('User is in their peak productivity time');
            }
            
            // Neglected areas (subtle hint)
            if (this.categoryStats.neglectedAreas.length > 0 && Math.random() < 0.3) {
                insights.push(`Areas that might need attention: ${this.categoryStats.neglectedAreas.join(', ')}`);
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI
        getStats() {
            return {
                totalNodes: this.depthStats.totalNodes,
                avgDepth: this.depthStats.avgDepth,
                preferredDepth: this.depthStats.preferredDepth,
                maxDepth: this.depthStats.maxDepthReached,
                namingStyle: this.namingStats.style,
                avgLabelWords: this.namingStats.avgWords,
                totalLabels: this.namingStats.totalLabels,
                topCategories: this.categoryStats.topCategories,
                focusAreas: this.categoryStats.focusAreas,
                neglectedAreas: this.categoryStats.neglectedAreas,
                peakHours: this.timeStats.peakHours,
                peakDays: this.timeStats.peakDays,
                totalSessions: this.timeStats.totalSessions,
                avgSessionLength: this.timeStats.avgSessionLength,
                currentSessionNodes: this.currentSession.nodeCount
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 5000);
        }
        
        // Reset profile
        async reset() {
            this.depthStats = {
                totalNodes: 0,
                depthCounts: {},
                avgDepth: 0,
                maxDepthReached: 0,
                preferredDepth: 2
            };
            this.namingStats = {
                totalLabels: 0,
                wordCounts: [],
                charCounts: [],
                avgWords: 2,
                avgChars: 15,
                actionLabelCount: 0,
                nounLabelCount: 0,
                questionCount: 0,
                style: 'balanced'
            };
            this.categoryStats = {
                interactions: {},
                topCategories: [],
                focusAreas: [],
                neglectedAreas: []
            };
            this.timeStats = {
                hourlyActivity: new Array(24).fill(0),
                dailyActivity: new Array(7).fill(0),
                sessions: [],
                peakHours: [],
                peakDays: [],
                avgSessionLength: 0,
                totalSessions: 0
            };
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
            
            await NeuralDB.delete('user-profile');
            console.log('✓ User profile reset');
        }
    }
    
    // Create global user profile instance
    const userProfile = new UserProfile();
    
    // ═══════════════════════════════════════════════════════════════════
    // RELATIONSHIP TYPE CLASSIFIER - Understanding pattern semantics
    // ═══════════════════════════════════════════════════════════════════
    class RelationshipClassifier {
        constructor() {
            this.cache = new Map(); // Cache classifications
            this.typeEmbeddings = null; // Cached embeddings for relationship type exemplars
            this.encoder = null;
            
            // Relationship type definitions with keywords and exemplars
            this.relationshipTypes = {
                decomposition: {
                    description: 'Breaking down into parts/steps',
                    keywords: ['step', 'phase', 'stage', 'part', 'component', 'milestone', 'task', 'subtask', 'section', 'module', 'chapter', 'segment'],
                    parentPatterns: ['goal', 'project', 'plan', 'process', 'system', 'program', 'recipe', 'guide', 'tutorial'],
                    exemplars: [
                        ['Goals', 'Milestones'],
                        ['Project', 'Tasks'],
                        ['Recipe', 'Steps'],
                        ['Process', 'Phases'],
                        ['Book', 'Chapters']
                    ]
                },
                component: {
                    description: 'Parts that make up a whole',
                    keywords: ['include', 'contain', 'consist', 'feature', 'element', 'aspect', 'ingredient', 'material', 'resource'],
                    parentPatterns: ['system', 'product', 'team', 'body', 'machine', 'kit', 'set', 'collection', 'stack'],
                    exemplars: [
                        ['Health', 'Exercise'],
                        ['Computer', 'CPU'],
                        ['Team', 'Designer'],
                        ['Kitchen', 'Oven'],
                        ['Stack', 'React']
                    ]
                },
                sequence: {
                    description: 'Ordered steps or timeline',
                    keywords: ['first', 'then', 'next', 'after', 'before', 'finally', 'step 1', 'step 2', 'day 1', 'week 1', 'phase 1'],
                    parentPatterns: ['workflow', 'routine', 'schedule', 'timeline', 'agenda', 'itinerary', 'procedure'],
                    exemplars: [
                        ['Morning Routine', 'Wake Up'],
                        ['Workflow', 'Step 1'],
                        ['Onboarding', 'Day 1'],
                        ['Sprint', 'Week 1'],
                        ['Pipeline', 'Stage 1']
                    ]
                },
                category: {
                    description: 'Types or classifications',
                    keywords: ['type', 'kind', 'category', 'class', 'genre', 'variety', 'style', 'format', 'mode'],
                    parentPatterns: ['types', 'kinds', 'categories', 'options', 'varieties', 'styles', 'formats'],
                    exemplars: [
                        ['Music', 'Jazz'],
                        ['Animals', 'Mammals'],
                        ['Vehicles', 'Cars'],
                        ['Content', 'Blog Posts'],
                        ['Exercises', 'Cardio']
                    ]
                },
                example: {
                    description: 'Specific instances or examples',
                    keywords: ['example', 'instance', 'case', 'sample', 'illustration', 'e.g.', 'such as', 'like'],
                    parentPatterns: ['examples', 'ideas', 'suggestions', 'options', 'possibilities', 'concepts'],
                    exemplars: [
                        ['Fruits', 'Apple'],
                        ['Countries', 'Japan'],
                        ['Tools', 'Hammer'],
                        ['Languages', 'Python'],
                        ['Hobbies', 'Photography']
                    ]
                },
                attribute: {
                    description: 'Properties or characteristics',
                    keywords: ['color', 'size', 'weight', 'height', 'price', 'cost', 'duration', 'speed', 'quality', 'status', 'priority', 'level'],
                    parentPatterns: ['details', 'specs', 'properties', 'attributes', 'characteristics', 'settings', 'config', 'metadata'],
                    exemplars: [
                        ['Car', 'Color'],
                        ['Task', 'Priority'],
                        ['Product', 'Price'],
                        ['File', 'Size'],
                        ['User', 'Role']
                    ]
                },
                cause_effect: {
                    description: 'Causal relationships',
                    keywords: ['because', 'therefore', 'result', 'outcome', 'consequence', 'impact', 'effect', 'leads to', 'causes'],
                    parentPatterns: ['problem', 'issue', 'risk', 'threat', 'opportunity', 'action', 'decision'],
                    exemplars: [
                        ['Problem', 'Solution'],
                        ['Risk', 'Mitigation'],
                        ['Action', 'Outcome'],
                        ['Cause', 'Effect'],
                        ['Investment', 'Return']
                    ]
                },
                comparison: {
                    description: 'Alternatives or contrasts',
                    keywords: ['vs', 'versus', 'or', 'alternative', 'option', 'pro', 'con', 'advantage', 'disadvantage', 'compare'],
                    parentPatterns: ['options', 'alternatives', 'choices', 'comparison', 'decision', 'tradeoff'],
                    exemplars: [
                        ['Options', 'Option A'],
                        ['Pros and Cons', 'Pros'],
                        ['React vs Vue', 'React'],
                        ['Buy vs Rent', 'Buy'],
                        ['Tradeoffs', 'Speed']
                    ]
                },
                temporal: {
                    description: 'Time-based organization',
                    keywords: ['today', 'tomorrow', 'monday', 'january', 'q1', 'q2', '2024', '2025', 'morning', 'evening', 'daily', 'weekly', 'monthly'],
                    parentPatterns: ['schedule', 'calendar', 'plan', 'roadmap', 'timeline', 'agenda', 'journal'],
                    exemplars: [
                        ['Schedule', 'Monday'],
                        ['2024', 'Q1'],
                        ['Daily', 'Morning'],
                        ['Week', 'Day 1'],
                        ['Roadmap', 'Phase 1']
                    ]
                },
                action: {
                    description: 'Actions or tasks to perform',
                    keywords: ['do', 'make', 'create', 'build', 'write', 'review', 'check', 'update', 'fix', 'implement', 'design', 'test', 'deploy'],
                    parentPatterns: ['tasks', 'todo', 'actions', 'backlog', 'checklist', 'workflow'],
                    exemplars: [
                        ['Tasks', 'Review Code'],
                        ['Todo', 'Buy Groceries'],
                        ['Sprint', 'Implement Feature'],
                        ['Checklist', 'Verify Setup'],
                        ['Actions', 'Send Email']
                    ]
                }
            };
            
            // Weights for scoring
            this.weights = {
                keywordMatch: 0.4,
                parentPatternMatch: 0.3,
                embeddingSimilarity: 0.3
            };
        }
        
        // Set encoder reference
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Classify relationship type (heuristic-first, embedding fallback)
        async classify(parentLabel, childLabel, useEmbeddings = true) {
            const cacheKey = `${parentLabel.toLowerCase()}→${childLabel.toLowerCase()}`;
            
            // Check cache
            if (this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Fast path: heuristic classification
            const heuristicResult = this.classifyByHeuristics(parentLabel, childLabel);
            
            if (heuristicResult.confidence >= 0.6) {
                this.cache.set(cacheKey, heuristicResult);
                return heuristicResult;
            }
            
            // Slow path: embedding similarity (only if encoder available and enabled)
            if (useEmbeddings && this.encoder) {
                const embeddingResult = await this.classifyByEmbeddings(parentLabel, childLabel);
                
                // Combine heuristic and embedding scores
                const combined = this.combineResults(heuristicResult, embeddingResult);
                this.cache.set(cacheKey, combined);
                return combined;
            }
            
            // Fall back to heuristic result
            this.cache.set(cacheKey, heuristicResult);
            return heuristicResult;
        }
        
        // Fast heuristic classification
        classifyByHeuristics(parentLabel, childLabel) {
            const parentLower = parentLabel.toLowerCase();
            const childLower = childLabel.toLowerCase();
            const scores = {};
            
            for (const [type, config] of Object.entries(this.relationshipTypes)) {
                let score = 0;
                
                // Check child label for keywords
                const keywordMatches = config.keywords.filter(kw => childLower.includes(kw)).length;
                if (keywordMatches > 0) {
                    score += this.weights.keywordMatch * Math.min(keywordMatches / 2, 1);
                }
                
                // Check parent label for patterns
                const parentMatches = config.parentPatterns.filter(p => parentLower.includes(p)).length;
                if (parentMatches > 0) {
                    score += this.weights.parentPatternMatch * Math.min(parentMatches, 1);
                }
                
                // Check for numbered sequences
                if (type === 'sequence' || type === 'temporal') {
                    if (/\b(step|phase|day|week|stage)\s*\d/i.test(childLabel) ||
                        /^\d+[\.\)]\s/.test(childLabel)) {
                        score += 0.3;
                    }
                }
                
                // Check for action verbs at start
                if (type === 'action') {
                    const actionStarters = ['do', 'make', 'create', 'build', 'write', 'review', 'check', 'update', 'fix', 'implement', 'design', 'test', 'deploy', 'add', 'remove', 'send', 'get', 'set', 'run'];
                    const firstWord = childLower.split(/\s+/)[0];
                    if (actionStarters.includes(firstWord)) {
                        score += 0.4;
                    }
                }
                
                scores[type] = score;
            }
            
            // Find best match
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const [bestType, bestScore] = sorted[0];
            const [secondType, secondScore] = sorted[1] || [null, 0];
            
            // Confidence based on margin between top two
            const margin = bestScore - secondScore;
            const confidence = Math.min(bestScore + margin * 0.5, 1);
            
            return {
                type: bestScore > 0.1 ? bestType : 'unknown',
                confidence: bestScore > 0.1 ? confidence : 0.1,
                scores,
                method: 'heuristic'
            };
        }
        
        // Embedding-based classification
        async classifyByEmbeddings(parentLabel, childLabel) {
            try {
                // Build type embeddings if not cached
                if (!this.typeEmbeddings) {
                    await this.buildTypeEmbeddings();
                }
                
                // Get embedding for this parent-child pair
                const pairText = `${parentLabel} contains ${childLabel}`;
                const pairEmbedding = await this.getEmbedding(pairText);
                
                if (!pairEmbedding) {
                    return { type: 'unknown', confidence: 0, method: 'embedding_failed' };
                }
                
                // Compare to each type's exemplar embeddings
                const scores = {};
                
                for (const [type, embeddings] of Object.entries(this.typeEmbeddings)) {
                    // Average similarity to all exemplars of this type
                    let totalSim = 0;
                    for (const exemplarEmb of embeddings) {
                        totalSim += this.cosineSimilarity(pairEmbedding, exemplarEmb);
                    }
                    scores[type] = totalSim / embeddings.length;
                }
                
                // Find best match
                const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
                const [bestType, bestScore] = sorted[0];
                
                return {
                    type: bestType,
                    confidence: Math.max(0, Math.min(bestScore, 1)),
                    scores,
                    method: 'embedding'
                };
            } catch (error) {
                console.error('Embedding classification error:', error);
                return { type: 'unknown', confidence: 0, method: 'embedding_error' };
            }
        }
        
        // Build embeddings for exemplar pairs
        async buildTypeEmbeddings() {
            if (!this.encoder) return;
            
            console.log('🧠 Building relationship type embeddings...');
            this.typeEmbeddings = {};
            
            for (const [type, config] of Object.entries(this.relationshipTypes)) {
                const texts = config.exemplars.map(([parent, child]) => 
                    `${parent} contains ${child}`
                );
                
                try {
                    const embeddings = await this.encoder.embed(texts);
                    const embeddingArray = await embeddings.array();
                    this.typeEmbeddings[type] = embeddingArray;
                    embeddings.dispose();
                } catch (error) {
                    console.error(`Failed to embed ${type} exemplars:`, error);
                    this.typeEmbeddings[type] = [];
                }
            }
            
            console.log('✓ Relationship type embeddings ready');
        }
        
        // Get embedding for a single text
        async getEmbedding(text) {
            if (!this.encoder) return null;
            
            try {
                const embeddings = await this.encoder.embed([text]);
                const embeddingArray = await embeddings.array();
                embeddings.dispose();
                return embeddingArray[0];
            } catch (error) {
                console.error('Embedding error:', error);
                return null;
            }
        }
        
        // Cosine similarity
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Combine heuristic and embedding results
        combineResults(heuristic, embedding) {
            if (embedding.type === 'unknown' || embedding.confidence < 0.3) {
                return heuristic;
            }
            
            // Weight the combination by confidence
            const hWeight = 0.6;
            const eWeight = 0.4;
            
            // If they agree, boost confidence
            if (heuristic.type === embedding.type) {
                return {
                    type: heuristic.type,
                    confidence: Math.min(1, heuristic.confidence * hWeight + embedding.confidence * eWeight + 0.15),
                    method: 'combined_agree'
                };
            }
            
            // If they disagree, use higher confidence
            if (embedding.confidence > heuristic.confidence + 0.2) {
                return {
                    type: embedding.type,
                    confidence: embedding.confidence * 0.8,
                    method: 'combined_embedding_wins'
                };
            }
            
            return {
                type: heuristic.type,
                confidence: heuristic.confidence * 0.9,
                method: 'combined_heuristic_wins'
            };
        }
        
        // Find patterns with same relationship type (for transfer learning)
        async findAnalogousPatterns(parentLabel, childLabel, patternWeights, limit = 5) {
            // Classify this relationship
            const classification = await this.classify(parentLabel, childLabel, false); // Heuristics only for speed
            
            if (classification.type === 'unknown' || classification.confidence < 0.4) {
                return [];
            }
            
            const analogous = [];
            
            // Scan cached classifications for same type
            for (const [key, cachedResult] of this.cache.entries()) {
                if (cachedResult.type === classification.type && 
                    cachedResult.confidence >= 0.5 &&
                    key !== `${parentLabel.toLowerCase()}→${childLabel.toLowerCase()}`) {
                    
                    const [cachedParent, cachedChild] = key.split('→');
                    const patternKey = `${cachedParent}→${cachedChild}`;
                    const weight = patternWeights.get(patternKey);
                    
                    if (weight && weight.weight >= 0.4) {
                        analogous.push({
                            parentLabel: cachedParent,
                            childLabel: cachedChild,
                            relationshipType: cachedResult.type,
                            confidence: cachedResult.confidence,
                            weight: weight.weight
                        });
                    }
                }
            }
            
            // Sort by weight * confidence
            analogous.sort((a, b) => (b.weight * b.confidence) - (a.weight * a.confidence));
            
            return analogous.slice(0, limit);
        }
        
        // Get relationship type description for Claude prompts
        getTypeDescription(type) {
            return this.relationshipTypes[type]?.description || 'General relationship';
        }
        
        // Get stats
        getStats() {
            const typeCounts = {};
            for (const [, result] of this.cache) {
                typeCounts[result.type] = (typeCounts[result.type] || 0) + 1;
            }
            
            return {
                cachedClassifications: this.cache.size,
                typeDistribution: typeCounts,
                hasEmbeddings: !!this.typeEmbeddings
            };
        }
        
        // Clear cache
        clearCache() {
            this.cache.clear();
        }
    }
    
    // Create global classifier instance
    const relationshipClassifier = new RelationshipClassifier();
    
    // ═══════════════════════════════════════════════════════════════════
    // CONCEPT ABSTRACTOR - Learning structural schemas across domains
    // ═══════════════════════════════════════════════════════════════════
    class ConceptAbstractor {
        constructor() {
            this.encoder = null;
            this.loaded = false;
            
            // Structural schemas: abstract templates for hierarchies
            // Schema format: { role -> [typical children roles] }
            this.schemas = new Map();
            
            // Concept clusters: groups of semantically similar labels
            // Maps normalized label -> cluster ID
            this.conceptClusters = new Map();
            
            // Cluster definitions: cluster ID -> { labels, centroid, abstractRole }
            this.clusters = new Map();
            
            // Hierarchy patterns: multi-level structural patterns
            // Maps "role1→role2→role3" -> { examples, confidence }
            this.hierarchyPatterns = new Map();
            
            // Abstract roles (learned categories of concepts)
            this.abstractRoles = {
                plannable: {
                    description: 'Things that can be planned/organized',
                    seeds: ['goal', 'project', 'plan', 'initiative', 'campaign', 'program', 'strategy', 'mission'],
                    typicalChildren: ['milestone', 'phase', 'task', 'step', 'objective', 'target']
                },
                container: {
                    description: 'Things that contain components',
                    seeds: ['system', 'product', 'machine', 'device', 'platform', 'application', 'service', 'kit'],
                    typicalChildren: ['component', 'module', 'part', 'feature', 'element', 'unit']
                },
                process: {
                    description: 'Sequential procedures',
                    seeds: ['workflow', 'process', 'procedure', 'routine', 'pipeline', 'flow', 'cycle'],
                    typicalChildren: ['step', 'stage', 'phase', 'action', 'task']
                },
                category_parent: {
                    description: 'Classification containers',
                    seeds: ['types', 'categories', 'kinds', 'classes', 'genres', 'varieties', 'options'],
                    typicalChildren: ['type', 'category', 'option', 'variant', 'style']
                },
                collection: {
                    description: 'Groups of similar items',
                    seeds: ['list', 'collection', 'set', 'group', 'library', 'inventory', 'portfolio'],
                    typicalChildren: ['item', 'entry', 'element', 'piece', 'asset']
                },
                domain: {
                    description: 'Knowledge/life areas',
                    seeds: ['health', 'finance', 'career', 'education', 'relationships', 'personal', 'work', 'life'],
                    typicalChildren: ['aspect', 'area', 'goal', 'habit', 'practice', 'skill']
                },
                entity: {
                    description: 'Things with attributes',
                    seeds: ['person', 'company', 'product', 'project', 'event', 'place', 'organization'],
                    typicalChildren: ['name', 'description', 'status', 'date', 'owner', 'priority']
                },
                temporal: {
                    description: 'Time-based containers',
                    seeds: ['year', 'quarter', 'month', 'week', 'day', 'schedule', 'calendar', 'timeline'],
                    typicalChildren: ['event', 'task', 'meeting', 'deadline', 'milestone']
                }
            };
            
            // Similarity threshold for clustering
            this.clusterThreshold = 0.65;
            
            // Cache for role assignments
            this.roleCache = new Map();
            
            // Stats
            this.stats = {
                clustersFormed: 0,
                schemasLearned: 0,
                transfersApplied: 0
            };
        }
        
        // Set encoder reference
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('concept-abstractions');
                if (saved) {
                    if (saved.schemas) {
                        this.schemas = new Map(saved.schemas);
                    }
                    if (saved.conceptClusters) {
                        this.conceptClusters = new Map(saved.conceptClusters);
                    }
                    if (saved.clusters) {
                        this.clusters = new Map(saved.clusters);
                    }
                    if (saved.hierarchyPatterns) {
                        this.hierarchyPatterns = new Map(saved.hierarchyPatterns);
                    }
                    if (saved.stats) {
                        this.stats = saved.stats;
                    }
                    console.log(`✓ Loaded concept abstractions (${this.schemas.size} schemas, ${this.clusters.size} clusters)`);
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load concept abstractions:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('concept-abstractions', {
                    schemas: Array.from(this.schemas.entries()),
                    conceptClusters: Array.from(this.conceptClusters.entries()),
                    clusters: Array.from(this.clusters.entries()),
                    hierarchyPatterns: Array.from(this.hierarchyPatterns.entries()),
                    stats: this.stats,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save concept abstractions:', error);
            }
        }
        
        // Identify the abstract role of a label (using seeds + embeddings)
        async identifyRole(label, useEmbeddings = true) {
            const normalized = label.toLowerCase().trim();
            
            // Check cache
            if (this.roleCache.has(normalized)) {
                return this.roleCache.get(normalized);
            }
            
            // Fast path: check seed words
            for (const [role, config] of Object.entries(this.abstractRoles)) {
                for (const seed of config.seeds) {
                    if (normalized.includes(seed) || seed.includes(normalized)) {
                        const result = { role, confidence: 0.8, method: 'seed' };
                        this.roleCache.set(normalized, result);
                        return result;
                    }
                }
            }
            
            // Check if it matches typical children
            for (const [role, config] of Object.entries(this.abstractRoles)) {
                for (const child of config.typicalChildren) {
                    if (normalized.includes(child) || child.includes(normalized)) {
                        const result = { role: `${role}_child`, confidence: 0.7, method: 'typical_child' };
                        this.roleCache.set(normalized, result);
                        return result;
                    }
                }
            }
            
            // Slow path: embedding similarity (if available)
            if (useEmbeddings && this.encoder) {
                const roleScores = await this.scoreRolesByEmbedding(label);
                if (roleScores && roleScores.bestScore > 0.5) {
                    const result = { role: roleScores.bestRole, confidence: roleScores.bestScore, method: 'embedding' };
                    this.roleCache.set(normalized, result);
                    return result;
                }
            }
            
            // Check existing clusters
            const clusterId = this.conceptClusters.get(normalized);
            if (clusterId) {
                const cluster = this.clusters.get(clusterId);
                if (cluster && cluster.abstractRole) {
                    const result = { role: cluster.abstractRole, confidence: 0.6, method: 'cluster' };
                    this.roleCache.set(normalized, result);
                    return result;
                }
            }
            
            return { role: 'unknown', confidence: 0, method: 'none' };
        }
        
        // Score roles by embedding similarity
        async scoreRolesByEmbedding(label) {
            if (!this.encoder) return null;
            
            try {
                // Get embedding for the label
                const labelEmbedding = await this.getEmbedding(label);
                if (!labelEmbedding) return null;
                
                const scores = {};
                let bestRole = 'unknown';
                let bestScore = 0;
                
                // Compare to seed words of each role
                for (const [role, config] of Object.entries(this.abstractRoles)) {
                    const seedText = config.seeds.slice(0, 4).join(' ');
                    const seedEmbedding = await this.getEmbedding(seedText);
                    
                    if (seedEmbedding) {
                        const similarity = this.cosineSimilarity(labelEmbedding, seedEmbedding);
                        scores[role] = similarity;
                        
                        if (similarity > bestScore) {
                            bestScore = similarity;
                            bestRole = role;
                        }
                    }
                }
                
                return { scores, bestRole, bestScore };
            } catch (error) {
                console.error('Role scoring error:', error);
                return null;
            }
        }
        
        // Learn a structural pattern from parent-child relationship
        async learnPattern(parentLabel, childLabel, depth, relationshipType) {
            const parentRole = await this.identifyRole(parentLabel, false); // Heuristics only for speed
            const childRole = await this.identifyRole(childLabel, false);
            
            // Create or update schema
            if (parentRole.role !== 'unknown' && parentRole.confidence >= 0.5) {
                const schemaKey = parentRole.role;
                
                if (!this.schemas.has(schemaKey)) {
                    this.schemas.set(schemaKey, {
                        childRoles: new Map(),
                        examples: [],
                        relationshipTypes: {}
                    });
                    this.stats.schemasLearned++;
                }
                
                const schema = this.schemas.get(schemaKey);
                
                // Track child role frequency
                const childRoleKey = childRole.role !== 'unknown' ? childRole.role : 'generic';
                const currentCount = schema.childRoles.get(childRoleKey) || 0;
                schema.childRoles.set(childRoleKey, currentCount + 1);
                
                // Track relationship type
                if (relationshipType) {
                    schema.relationshipTypes[relationshipType] = (schema.relationshipTypes[relationshipType] || 0) + 1;
                }
                
                // Store example (limited)
                if (schema.examples.length < 20) {
                    schema.examples.push({
                        parent: parentLabel,
                        child: childLabel,
                        depth,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Learn hierarchy pattern if we have depth info
            if (depth >= 2) {
                await this.learnHierarchyPattern(parentLabel, childLabel, depth);
            }
            
            this.scheduleSave();
        }
        
        // Learn multi-level hierarchy patterns
        async learnHierarchyPattern(parentLabel, childLabel, depth) {
            const parentRole = await this.identifyRole(parentLabel, false);
            const childRole = await this.identifyRole(childLabel, false);
            
            if (parentRole.role === 'unknown' || childRole.role === 'unknown') return;
            
            // Create hierarchy key based on roles
            const hierarchyKey = `${parentRole.role}→${childRole.role}`;
            
            if (!this.hierarchyPatterns.has(hierarchyKey)) {
                this.hierarchyPatterns.set(hierarchyKey, {
                    examples: [],
                    occurrences: 0,
                    avgDepth: depth,
                    confidence: 0.3
                });
            }
            
            const pattern = this.hierarchyPatterns.get(hierarchyKey);
            pattern.occurrences++;
            pattern.avgDepth = (pattern.avgDepth * (pattern.occurrences - 1) + depth) / pattern.occurrences;
            pattern.confidence = Math.min(1.0, 0.3 + pattern.occurrences * 0.1);
            
            if (pattern.examples.length < 10) {
                pattern.examples.push({ parent: parentLabel, child: childLabel });
            }
        }
        
        // Cluster similar concepts together
        async clusterConcept(label, embedding = null) {
            const normalized = label.toLowerCase().trim();
            
            // Skip if already clustered
            if (this.conceptClusters.has(normalized)) {
                return this.conceptClusters.get(normalized);
            }
            
            // Get embedding if not provided
            if (!embedding && this.encoder) {
                embedding = await this.getEmbedding(label);
            }
            
            if (!embedding) return null;
            
            // Find most similar existing cluster
            let bestCluster = null;
            let bestSimilarity = 0;
            
            for (const [clusterId, cluster] of this.clusters) {
                if (cluster.centroid) {
                    const similarity = this.cosineSimilarity(embedding, cluster.centroid);
                    if (similarity > bestSimilarity && similarity >= this.clusterThreshold) {
                        bestSimilarity = similarity;
                        bestCluster = clusterId;
                    }
                }
            }
            
            if (bestCluster) {
                // Add to existing cluster
                const cluster = this.clusters.get(bestCluster);
                cluster.labels.push(normalized);
                
                // Update centroid (running average)
                if (cluster.centroid) {
                    for (let i = 0; i < cluster.centroid.length; i++) {
                        cluster.centroid[i] = (cluster.centroid[i] * (cluster.labels.length - 1) + embedding[i]) / cluster.labels.length;
                    }
                }
                
                this.conceptClusters.set(normalized, bestCluster);
                return bestCluster;
            }
            
            // Create new cluster
            const newClusterId = `cluster_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            const role = await this.identifyRole(label, false);
            
            this.clusters.set(newClusterId, {
                labels: [normalized],
                centroid: embedding,
                abstractRole: role.role !== 'unknown' ? role.role : null,
                createdAt: Date.now()
            });
            
            this.conceptClusters.set(normalized, newClusterId);
            this.stats.clustersFormed++;
            
            return newClusterId;
        }
        
        // Find structurally similar patterns for a new parent
        async findStructuralAnalogs(parentLabel, existingChildren = [], limit = 5) {
            const parentRole = await this.identifyRole(parentLabel, true);
            
            if (parentRole.role === 'unknown' || parentRole.confidence < 0.4) {
                return [];
            }
            
            const analogs = [];
            const existingNormalized = existingChildren.map(c => c.toLowerCase());
            
            // Get schema for this role
            const schema = this.schemas.get(parentRole.role);
            
            if (schema && schema.examples.length > 0) {
                // Find children from examples that might transfer
                const seenChildren = new Set();
                
                for (const example of schema.examples) {
                    const childNormalized = example.child.toLowerCase();
                    
                    // Skip if already exists or already seen
                    if (existingNormalized.includes(childNormalized) || seenChildren.has(childNormalized)) {
                        continue;
                    }
                    
                    seenChildren.add(childNormalized);
                    
                    // Calculate transfer score
                    const childRole = await this.identifyRole(example.child, false);
                    const roleMatch = childRole.role !== 'unknown' ? 0.3 : 0;
                    
                    analogs.push({
                        label: example.child,
                        fromParent: example.parent,
                        schemaRole: parentRole.role,
                        childRole: childRole.role,
                        confidence: (parentRole.confidence * 0.5 + roleMatch + 0.2),
                        source: 'schema'
                    });
                }
            }
            
            // Also check hierarchy patterns
            for (const [key, pattern] of this.hierarchyPatterns) {
                if (key.startsWith(parentRole.role + '→') && pattern.confidence >= 0.4) {
                    for (const example of pattern.examples) {
                        const childNormalized = example.child.toLowerCase();
                        
                        if (!existingNormalized.includes(childNormalized) && 
                            !analogs.some(a => a.label.toLowerCase() === childNormalized)) {
                            analogs.push({
                                label: example.child,
                                fromParent: example.parent,
                                schemaRole: parentRole.role,
                                confidence: pattern.confidence * 0.8,
                                source: 'hierarchy'
                            });
                        }
                    }
                }
            }
            
            // Sort by confidence and limit
            analogs.sort((a, b) => b.confidence - a.confidence);
            
            this.stats.transfersApplied += Math.min(analogs.length, limit);
            
            return analogs.slice(0, limit);
        }
        
        // Get suggestions based on abstract role
        async getSuggestionsByRole(parentLabel, existingChildren = [], limit = 3) {
            const parentRole = await this.identifyRole(parentLabel, false);
            
            if (parentRole.role === 'unknown') {
                return [];
            }
            
            const roleConfig = this.abstractRoles[parentRole.role];
            if (!roleConfig) return [];
            
            const existingNormalized = existingChildren.map(c => c.toLowerCase());
            const suggestions = [];
            
            // Suggest typical children for this role
            for (const typicalChild of roleConfig.typicalChildren) {
                if (!existingNormalized.some(e => e.includes(typicalChild))) {
                    suggestions.push({
                        label: typicalChild.charAt(0).toUpperCase() + typicalChild.slice(1),
                        confidence: parentRole.confidence * 0.6,
                        source: 'role_typical',
                        role: parentRole.role
                    });
                }
                
                if (suggestions.length >= limit) break;
            }
            
            return suggestions;
        }
        
        // Generate insights for Claude prompts
        async getPromptInsights(parentLabel, path = []) {
            const insights = [];
            
            // Identify parent role
            const parentRole = await this.identifyRole(parentLabel, false);
            
            if (parentRole.role !== 'unknown' && parentRole.confidence >= 0.5) {
                const roleConfig = this.abstractRoles[parentRole.role];
                if (roleConfig) {
                    insights.push(`Structural role: "${parentLabel}" is a ${roleConfig.description.toLowerCase()}`);
                    
                    // Get schema info
                    const schema = this.schemas.get(parentRole.role);
                    if (schema && schema.examples.length >= 3) {
                        const exampleParents = [...new Set(schema.examples.map(e => e.parent))].slice(0, 3);
                        insights.push(`Similar structures: ${exampleParents.join(', ')}`);
                    }
                }
            }
            
            // Check for hierarchy patterns along the path
            if (path.length >= 2) {
                const pathRoles = [];
                for (const node of path.slice(-3)) { // Last 3 nodes
                    const role = await this.identifyRole(node, false);
                    if (role.role !== 'unknown') {
                        pathRoles.push(role.role);
                    }
                }
                
                if (pathRoles.length >= 2) {
                    const patternKey = pathRoles.slice(-2).join('→');
                    const pattern = this.hierarchyPatterns.get(patternKey);
                    if (pattern && pattern.confidence >= 0.5) {
                        insights.push(`Hierarchy pattern detected: ${patternKey} (seen ${pattern.occurrences}x)`);
                    }
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get embedding (helper)
        async getEmbedding(text) {
            if (!this.encoder) return null;
            
            try {
                const embeddings = await this.encoder.embed([text]);
                const embeddingArray = await embeddings.array();
                embeddings.dispose();
                return embeddingArray[0];
            } catch (error) {
                return null;
            }
        }
        
        // Cosine similarity (helper)
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Get stats for UI
        getStats() {
            return {
                schemas: this.schemas.size,
                clusters: this.clusters.size,
                hierarchyPatterns: this.hierarchyPatterns.size,
                ...this.stats
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 5000);
        }
        
        // Reset
        async reset() {
            this.schemas.clear();
            this.conceptClusters.clear();
            this.clusters.clear();
            this.hierarchyPatterns.clear();
            this.roleCache.clear();
            this.stats = { clustersFormed: 0, schemasLearned: 0, transfersApplied: 0 };
            await NeuralDB.delete('concept-abstractions');
            console.log('✓ Concept abstractions reset');
        }
    }
    
    // Create global concept abstractor instance
    const conceptAbstractor = new ConceptAbstractor();
    
    // ═══════════════════════════════════════════════════════════════════
    // META-LEARNER - Understanding HOW the user thinks
    // ═══════════════════════════════════════════════════════════════════
    class MetaLearner {
        constructor() {
            this.loaded = false;
            
            // Building style: breadth-first vs depth-first
            this.buildingStyle = {
                // Track sequences of node creation depths
                depthSequences: [], // Last 100: [2, 2, 3, 3, 4, 2, 2, 3...] 
                breadthFirstScore: 0.5, // 0 = pure depth-first, 1 = pure breadth-first
                consecutiveSameDepth: 0,
                consecutiveDeeper: 0,
                lastDepth: 0,
                
                // Pattern: does user complete a level before going deeper?
                levelCompletionRate: 0.5
            };
            
            // Exploration patterns: how user navigates
            this.explorationStyle = {
                // Selection sequence: do they jump around or stay local?
                selectionJumps: [], // Distance between consecutive selections
                localityScore: 0.5, // 0 = random jumping, 1 = very local/sequential
                
                // Expansion patterns
                expandBeforeCreate: 0, // Times user expanded existing before creating new
                createBeforeExpand: 0, // Times user created new without expanding first
                
                // Return visits: do they revisit branches?
                branchRevisits: new Map(), // branchId -> visit count
                revisitRate: 0
            };
            
            // Refinement behavior
            this.refinementStyle = {
                editCount: 0,
                createCount: 0,
                editVsCreateRatio: 0.5, // Higher = more editing/refining
                
                // Edit timing: do they edit immediately or come back later?
                immediateEdits: 0, // Edit within 30 seconds of creation
                delayedEdits: 0, // Edit after 30+ seconds
                
                // Description usage
                nodesWithDescription: 0,
                totalNodes: 0,
                descriptionRate: 0
            };
            
            // Decision patterns
            this.decisionStyle = {
                // Suggestion acceptance speed
                acceptanceTimes: [], // Time from suggestion shown to accepted (last 50)
                avgAcceptanceTime: 0,
                quickDecider: false, // < 3 seconds average
                
                // Acceptance selectivity
                suggestionsShown: 0,
                suggestionsAccepted: 0,
                selectivityRate: 0.5, // Lower = accepts more, higher = very selective
                
                // Add All vs individual picks
                addAllCount: 0,
                individualPickCount: 0,
                batchPreference: 0.5 // Higher = prefers Add All
            };
            
            // Session rhythm
            this.sessionRhythm = {
                // Activity bursts vs steady work
                actionTimestamps: [], // Last 200 action timestamps
                burstScore: 0.5, // 0 = very steady, 1 = very bursty
                avgTimeBetweenActions: 0,
                
                // Session patterns
                sessionsAnalyzed: 0,
                avgActionsPerSession: 0,
                avgSessionDuration: 0,
                
                // Momentum: does productivity increase or decrease over session?
                momentumPattern: 'steady' // 'accelerating', 'decelerating', 'steady', 'burst-rest'
            };
            
            // Branch commitment
            this.branchCommitment = {
                // Track depth reached per branch before moving on
                branchDepths: new Map(), // rootChildId -> maxDepth reached
                avgBranchDepth: 0,
                
                // Abandonment patterns
                abandonedBranches: [], // Branches not touched in 7+ days
                abandonmentRate: 0,
                
                // Focus: do they focus on one branch or spread attention?
                focusScore: 0.5, // 0 = very spread out, 1 = deep focus on few branches
                activeBranches: 0,
                
                // Branch switching frequency
                switchesPerSession: 0,
                avgTimeOnBranch: 0
            };
            
            // Cognitive load indicators
            this.cognitivePatterns = {
                // Complexity preference
                avgChildrenPerNode: 0,
                prefersFlatStructure: false, // Many children, shallow depth
                prefersDeepStructure: false, // Few children, deep depth
                
                // Naming complexity
                avgLabelComplexity: 0, // Based on word count, specificity
                
                // Pause patterns (thinking time)
                longPauses: 0, // Pauses > 30 seconds
                shortPauses: 0, // Pauses < 10 seconds
                thinkingRatio: 0.5
            };
            
            // Current tracking state
            this.currentState = {
                sessionStart: Date.now(),
                lastAction: Date.now(),
                lastNodeCreated: null,
                lastNodeSelected: null,
                lastDepth: 0,
                currentBranch: null,
                actionsThisSession: 0,
                suggestionsCurrentlyShown: null,
                suggestionShowTime: null
            };
            
            // Historical insights
            this.insights = {
                lastUpdated: null,
                summary: '',
                strengths: [],
                suggestions: []
            };
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('meta-learner');
                if (saved) {
                    if (saved.buildingStyle) this.buildingStyle = { ...this.buildingStyle, ...saved.buildingStyle };
                    if (saved.explorationStyle) this.explorationStyle = { ...this.explorationStyle, ...saved.explorationStyle };
                    if (saved.refinementStyle) this.refinementStyle = { ...this.refinementStyle, ...saved.refinementStyle };
                    if (saved.decisionStyle) this.decisionStyle = { ...this.decisionStyle, ...saved.decisionStyle };
                    if (saved.sessionRhythm) this.sessionRhythm = { ...this.sessionRhythm, ...saved.sessionRhythm };
                    if (saved.branchCommitment) {
                        this.branchCommitment = { ...this.branchCommitment, ...saved.branchCommitment };
                        if (saved.branchCommitment.branchDepths) {
                            this.branchCommitment.branchDepths = new Map(saved.branchCommitment.branchDepths);
                        }
                    }
                    if (saved.explorationStyle) {
                        this.explorationStyle = { ...this.explorationStyle, ...saved.explorationStyle };
                        if (saved.explorationStyle.branchRevisits) {
                            this.explorationStyle.branchRevisits = new Map(saved.explorationStyle.branchRevisits);
                        }
                    }
                    if (saved.cognitivePatterns) this.cognitivePatterns = { ...this.cognitivePatterns, ...saved.cognitivePatterns };
                    if (saved.insights) this.insights = saved.insights;
                    
                    console.log(`✓ Loaded meta-learner (${this.sessionRhythm.sessionsAnalyzed} sessions analyzed)`);
                }
                this.loaded = true;
                
                // Start new session tracking
                this.startSession();
            } catch (error) {
                console.error('Failed to load meta-learner:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('meta-learner', {
                    buildingStyle: this.buildingStyle,
                    explorationStyle: {
                        ...this.explorationStyle,
                        branchRevisits: Array.from(this.explorationStyle.branchRevisits.entries())
                    },
                    refinementStyle: this.refinementStyle,
                    decisionStyle: this.decisionStyle,
                    sessionRhythm: this.sessionRhythm,
                    branchCommitment: {
                        ...this.branchCommitment,
                        branchDepths: Array.from(this.branchCommitment.branchDepths.entries())
                    },
                    cognitivePatterns: this.cognitivePatterns,
                    insights: this.insights,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save meta-learner:', error);
            }
        }
        
        // Start a new session
        startSession() {
            this.currentState = {
                sessionStart: Date.now(),
                lastAction: Date.now(),
                lastNodeCreated: null,
                lastNodeSelected: null,
                lastDepth: 0,
                currentBranch: null,
                actionsThisSession: 0,
                suggestionsCurrentlyShown: null,
                suggestionShowTime: null
            };
        }
        
        // End session and analyze
        endSession() {
            const duration = (Date.now() - this.currentState.sessionStart) / 60000; // minutes
            
            if (duration >= 1 && this.currentState.actionsThisSession >= 3) {
                this.sessionRhythm.sessionsAnalyzed++;
                
                // Update averages
                const n = this.sessionRhythm.sessionsAnalyzed;
                this.sessionRhythm.avgActionsPerSession = 
                    ((n - 1) * this.sessionRhythm.avgActionsPerSession + this.currentState.actionsThisSession) / n;
                this.sessionRhythm.avgSessionDuration = 
                    ((n - 1) * this.sessionRhythm.avgSessionDuration + duration) / n;
                
                // Analyze rhythm patterns
                this.analyzeSessionRhythm();
                
                // Update insights
                this.updateInsights();
                
                this.scheduleSave();
            }
        }
        
        // Track node creation
        trackNodeCreated(node, parent, depth, store) {
            const now = Date.now();
            const timeSinceLastAction = now - this.currentState.lastAction;
            
            // Update action timestamps
            this.sessionRhythm.actionTimestamps.push(now);
            if (this.sessionRhythm.actionTimestamps.length > 200) {
                this.sessionRhythm.actionTimestamps = this.sessionRhythm.actionTimestamps.slice(-200);
            }
            
            // Track building style
            this.trackBuildingStyle(depth);
            
            // Track refinement (creation vs editing)
            this.refinementStyle.createCount++;
            this.refinementStyle.totalNodes++;
            this.refinementStyle.editVsCreateRatio = 
                this.refinementStyle.editCount / (this.refinementStyle.editCount + this.refinementStyle.createCount);
            
            // Track branch commitment
            const rootBranch = this.getRootBranch(node.id, store);
            if (rootBranch) {
                const currentMaxDepth = this.branchCommitment.branchDepths.get(rootBranch) || 0;
                if (depth > currentMaxDepth) {
                    this.branchCommitment.branchDepths.set(rootBranch, depth);
                }
                
                // Track branch switching
                if (this.currentState.currentBranch && this.currentState.currentBranch !== rootBranch) {
                    this.branchCommitment.switchesPerSession++;
                }
                this.currentState.currentBranch = rootBranch;
            }
            
            // Track cognitive patterns (pause analysis)
            if (timeSinceLastAction > 30000) {
                this.cognitivePatterns.longPauses++;
            } else if (timeSinceLastAction < 10000) {
                this.cognitivePatterns.shortPauses++;
            }
            this.cognitivePatterns.thinkingRatio = 
                this.cognitivePatterns.longPauses / 
                Math.max(1, this.cognitivePatterns.longPauses + this.cognitivePatterns.shortPauses);
            
            // Track children count for cognitive complexity
            if (parent.children) {
                const siblingCount = parent.children.length;
                const totalParents = this.refinementStyle.totalNodes - 1;
                if (totalParents > 0) {
                    this.cognitivePatterns.avgChildrenPerNode = 
                        ((totalParents - 1) * this.cognitivePatterns.avgChildrenPerNode + siblingCount) / totalParents;
                }
            }
            
            // Update state
            this.currentState.lastAction = now;
            this.currentState.lastNodeCreated = node.id;
            this.currentState.lastDepth = depth;
            this.currentState.actionsThisSession++;
            
            this.scheduleSave();
        }
        
        // Track building style (breadth-first vs depth-first)
        trackBuildingStyle(depth) {
            // Add to depth sequence
            this.buildingStyle.depthSequences.push(depth);
            if (this.buildingStyle.depthSequences.length > 100) {
                this.buildingStyle.depthSequences = this.buildingStyle.depthSequences.slice(-100);
            }
            
            // Analyze pattern
            const lastDepth = this.buildingStyle.lastDepth;
            
            if (depth === lastDepth) {
                // Same level - breadth-first indicator
                this.buildingStyle.consecutiveSameDepth++;
                this.buildingStyle.consecutiveDeeper = 0;
            } else if (depth > lastDepth) {
                // Going deeper - depth-first indicator
                this.buildingStyle.consecutiveDeeper++;
                this.buildingStyle.consecutiveSameDepth = 0;
            } else {
                // Going shallower - could be either (completing a branch)
                this.buildingStyle.consecutiveSameDepth = 0;
                this.buildingStyle.consecutiveDeeper = 0;
            }
            
            this.buildingStyle.lastDepth = depth;
            
            // Calculate breadth-first score based on sequences
            this.calculateBuildingStyleScore();
        }
        
        // Calculate building style score
        calculateBuildingStyleScore() {
            if (this.buildingStyle.depthSequences.length < 10) return;
            
            const sequences = this.buildingStyle.depthSequences;
            let sameDepthTransitions = 0;
            let deeperTransitions = 0;
            let shallowerTransitions = 0;
            
            for (let i = 1; i < sequences.length; i++) {
                const diff = sequences[i] - sequences[i - 1];
                if (diff === 0) sameDepthTransitions++;
                else if (diff > 0) deeperTransitions++;
                else shallowerTransitions++;
            }
            
            const total = sameDepthTransitions + deeperTransitions + shallowerTransitions;
            
            // Breadth-first: many same-depth transitions
            // Depth-first: many deeper transitions followed by shallower
            this.buildingStyle.breadthFirstScore = sameDepthTransitions / total;
            
            // Level completion rate: ratio of completing a level before going deeper
            this.buildingStyle.levelCompletionRate = 
                (sameDepthTransitions + shallowerTransitions) / total;
        }
        
        // Track node selection
        trackNodeSelected(node, depth, store) {
            const now = Date.now();
            
            // Track exploration locality
            if (this.currentState.lastNodeSelected) {
                // Calculate "distance" between selections (simplified: depth difference)
                const lastDepth = this.currentState.lastDepth;
                const jumpDistance = Math.abs(depth - lastDepth);
                
                this.explorationStyle.selectionJumps.push(jumpDistance);
                if (this.explorationStyle.selectionJumps.length > 50) {
                    this.explorationStyle.selectionJumps = this.explorationStyle.selectionJumps.slice(-50);
                }
                
                // Calculate locality score
                const avgJump = this.explorationStyle.selectionJumps.reduce((a, b) => a + b, 0) / 
                    this.explorationStyle.selectionJumps.length;
                this.explorationStyle.localityScore = Math.max(0, 1 - avgJump / 3); // Normalize
            }
            
            // Track branch revisits
            const rootBranch = this.getRootBranch(node.id, store);
            if (rootBranch) {
                const visits = this.explorationStyle.branchRevisits.get(rootBranch) || 0;
                this.explorationStyle.branchRevisits.set(rootBranch, visits + 1);
                
                // Calculate revisit rate
                const totalVisits = Array.from(this.explorationStyle.branchRevisits.values())
                    .reduce((a, b) => a + b, 0);
                const uniqueBranches = this.explorationStyle.branchRevisits.size;
                this.explorationStyle.revisitRate = uniqueBranches > 0 ? 
                    (totalVisits - uniqueBranches) / totalVisits : 0;
            }
            
            this.currentState.lastNodeSelected = node.id;
            this.currentState.lastDepth = depth;
            this.currentState.lastAction = now;
        }
        
        // Track node editing
        trackNodeEdited(node, editType) {
            const now = Date.now();
            
            this.refinementStyle.editCount++;
            this.refinementStyle.editVsCreateRatio = 
                this.refinementStyle.editCount / (this.refinementStyle.editCount + this.refinementStyle.createCount);
            
            // Check if immediate edit (within 30 seconds of creation)
            if (this.currentState.lastNodeCreated === node.id) {
                const timeSinceCreation = now - this.currentState.lastAction;
                if (timeSinceCreation < 30000) {
                    this.refinementStyle.immediateEdits++;
                } else {
                    this.refinementStyle.delayedEdits++;
                }
            }
            
            // Track description usage
            if (editType === 'description' && node.description) {
                this.refinementStyle.nodesWithDescription++;
                this.refinementStyle.descriptionRate = 
                    this.refinementStyle.nodesWithDescription / Math.max(1, this.refinementStyle.totalNodes);
            }
            
            this.currentState.lastAction = now;
            this.scheduleSave();
        }
        
        // Track suggestions shown
        trackSuggestionsShown(suggestions, parentNode) {
            this.currentState.suggestionsCurrentlyShown = suggestions;
            this.currentState.suggestionShowTime = Date.now();
            this.decisionStyle.suggestionsShown += suggestions.length;
        }
        
        // Track suggestion accepted
        trackSuggestionAccepted(label, wasAddAll = false) {
            const now = Date.now();
            
            this.decisionStyle.suggestionsAccepted++;
            
            // Track acceptance time
            if (this.currentState.suggestionShowTime) {
                const acceptanceTime = now - this.currentState.suggestionShowTime;
                this.decisionStyle.acceptanceTimes.push(acceptanceTime);
                if (this.decisionStyle.acceptanceTimes.length > 50) {
                    this.decisionStyle.acceptanceTimes = this.decisionStyle.acceptanceTimes.slice(-50);
                }
                
                // Calculate average
                this.decisionStyle.avgAcceptanceTime = 
                    this.decisionStyle.acceptanceTimes.reduce((a, b) => a + b, 0) / 
                    this.decisionStyle.acceptanceTimes.length;
                
                this.decisionStyle.quickDecider = this.decisionStyle.avgAcceptanceTime < 3000;
            }
            
            // Track Add All vs individual
            if (wasAddAll) {
                this.decisionStyle.addAllCount++;
            } else {
                this.decisionStyle.individualPickCount++;
            }
            
            const totalDecisions = this.decisionStyle.addAllCount + this.decisionStyle.individualPickCount;
            this.decisionStyle.batchPreference = this.decisionStyle.addAllCount / Math.max(1, totalDecisions);
            
            // Update selectivity
            this.decisionStyle.selectivityRate = 1 - 
                (this.decisionStyle.suggestionsAccepted / Math.max(1, this.decisionStyle.suggestionsShown));
            
            this.scheduleSave();
        }
        
        // Track node expansion
        trackNodeExpanded(node, store) {
            // Track expand before create pattern
            if (this.currentState.lastAction) {
                const timeSinceLastAction = Date.now() - this.currentState.lastAction;
                if (timeSinceLastAction < 5000) {
                    this.explorationStyle.expandBeforeCreate++;
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // SEMANTIC MEMORY BRIDGE: Learn from AI feedback patterns
        // ═══════════════════════════════════════════════════════════════════
        // Track how user responds to AI suggestions to improve understanding

        // AI feedback patterns
        aiFeedbackPatterns = {
            categoryAcceptance: new Map(), // category -> {accepted, rejected, modified}
            modificationPatterns: [], // What users choose instead
            responseTimeByConfidence: [], // [{ confidence, responseTime, action }]
            trustLevel: 0.5 // 0 = distrust AI, 1 = fully trust AI
        }

        trackAIFeedback(feedback) {
            if (!feedback || feedback.action === 'ignored') return;

            const { type, action, content, modification, responseTime } = feedback;

            // Track category-specific patterns
            if (type === 'category' && content?.predicted) {
                const cat = content.predicted;
                if (!this.aiFeedbackPatterns.categoryAcceptance.has(cat)) {
                    this.aiFeedbackPatterns.categoryAcceptance.set(cat, {
                        accepted: 0, rejected: 0, modified: 0
                    });
                }
                const stats = this.aiFeedbackPatterns.categoryAcceptance.get(cat);
                stats[action]++;

                // Track what user chose instead
                if (action === 'modified' && modification) {
                    this.aiFeedbackPatterns.modificationPatterns.push({
                        predicted: content.predicted,
                        chosen: modification,
                        confidence: content.confidence || 0,
                        timestamp: Date.now()
                    });
                    // Keep last 100
                    if (this.aiFeedbackPatterns.modificationPatterns.length > 100) {
                        this.aiFeedbackPatterns.modificationPatterns.shift();
                    }
                }
            }

            // Track response time by confidence level
            if (content?.confidence && responseTime) {
                this.aiFeedbackPatterns.responseTimeByConfidence.push({
                    confidence: content.confidence,
                    responseTime,
                    action
                });
                // Keep last 100
                if (this.aiFeedbackPatterns.responseTimeByConfidence.length > 100) {
                    this.aiFeedbackPatterns.responseTimeByConfidence.shift();
                }
            }

            // Update overall trust level based on feedback
            this.updateAITrustLevel(action);

            // Update decision style with AI-specific insights
            if (action === 'accepted') {
                this.decisionStyle.suggestionsAccepted++;
            }
            this.decisionStyle.suggestionsShown++;
            this.decisionStyle.selectivityRate = 1 -
                (this.decisionStyle.suggestionsAccepted / Math.max(1, this.decisionStyle.suggestionsShown));

            this.scheduleSave();

            console.log(`📊 MetaLearner: AI feedback tracked (${action}, trust: ${this.aiFeedbackPatterns.trustLevel.toFixed(2)})`);
        }

        updateAITrustLevel(action) {
            // Adjust trust based on action
            const trustDelta = {
                'accepted': 0.02,   // Trust increases slightly
                'modified': -0.005, // Trust decreases very slightly (still useful)
                'rejected': -0.03   // Trust decreases more
            };

            const delta = trustDelta[action] || 0;
            this.aiFeedbackPatterns.trustLevel = Math.max(0.1, Math.min(0.95,
                this.aiFeedbackPatterns.trustLevel + delta
            ));
        }

        // Get insights about AI feedback patterns for prompts
        getAIFeedbackInsights() {
            const patterns = this.aiFeedbackPatterns;

            // Find categories with low acceptance
            const problematicCategories = [];
            for (const [cat, stats] of patterns.categoryAcceptance) {
                const total = stats.accepted + stats.rejected + stats.modified;
                if (total >= 3) {
                    const acceptRate = stats.accepted / total;
                    if (acceptRate < 0.3) {
                        problematicCategories.push({ category: cat, acceptRate });
                    }
                }
            }

            // Find common modifications
            const modFreq = {};
            for (const mod of patterns.modificationPatterns.slice(-50)) {
                const key = `${mod.predicted}→${mod.chosen}`;
                modFreq[key] = (modFreq[key] || 0) + 1;
            }
            const commonMods = Object.entries(modFreq)
                .filter(([_, count]) => count >= 2)
                .map(([pattern, count]) => ({ pattern, count }));

            return {
                trustLevel: patterns.trustLevel,
                problematicCategories,
                commonModifications: commonMods,
                totalFeedback: patterns.responseTimeByConfidence.length
            };
        }

        // Analyze session rhythm
        analyzeSessionRhythm() {
            const timestamps = this.sessionRhythm.actionTimestamps;
            if (timestamps.length < 10) return;
            
            // Calculate intervals
            const intervals = [];
            for (let i = 1; i < timestamps.length; i++) {
                intervals.push(timestamps[i] - timestamps[i - 1]);
            }
            
            // Average time between actions
            this.sessionRhythm.avgTimeBetweenActions = 
                intervals.reduce((a, b) => a + b, 0) / intervals.length;
            
            // Burstiness: variance in intervals
            const mean = this.sessionRhythm.avgTimeBetweenActions;
            const variance = intervals.reduce((sum, i) => sum + Math.pow(i - mean, 2), 0) / intervals.length;
            const stdDev = Math.sqrt(variance);
            const coefficientOfVariation = stdDev / mean;
            
            // High CV = bursty, Low CV = steady
            this.sessionRhythm.burstScore = Math.min(1, coefficientOfVariation / 2);
            
            // Analyze momentum (are intervals getting shorter or longer?)
            const firstHalf = intervals.slice(0, Math.floor(intervals.length / 2));
            const secondHalf = intervals.slice(Math.floor(intervals.length / 2));
            
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            
            const ratio = secondAvg / firstAvg;
            
            if (ratio < 0.7) {
                this.sessionRhythm.momentumPattern = 'accelerating';
            } else if (ratio > 1.3) {
                this.sessionRhythm.momentumPattern = 'decelerating';
            } else if (this.sessionRhythm.burstScore > 0.6) {
                this.sessionRhythm.momentumPattern = 'burst-rest';
            } else {
                this.sessionRhythm.momentumPattern = 'steady';
            }
        }
        
        // Get root branch for a node
        getRootBranch(nodeId, store) {
            if (!store) return null;
            
            const path = store.getPath(nodeId);
            if (path.length >= 2) {
                return path[1].id; // First child of root
            }
            return nodeId;
        }
        
        // Update insights based on all patterns
        updateInsights() {
            const strengths = [];
            const suggestions = [];
            
            // Building style insights
            if (this.buildingStyle.breadthFirstScore > 0.6) {
                strengths.push('Systematic breadth-first builder');
            } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                strengths.push('Deep-dive depth-first thinker');
            }
            
            // Exploration insights
            if (this.explorationStyle.localityScore > 0.7) {
                strengths.push('Focused, sequential explorer');
            } else if (this.explorationStyle.localityScore < 0.3) {
                suggestions.push('Consider focusing on one area before jumping');
            }
            
            // Refinement insights
            if (this.refinementStyle.editVsCreateRatio > 0.3) {
                strengths.push('Thoughtful refiner');
            }
            if (this.refinementStyle.descriptionRate > 0.3) {
                strengths.push('Detail-oriented documenter');
            } else if (this.refinementStyle.descriptionRate < 0.1 && this.refinementStyle.totalNodes > 20) {
                suggestions.push('Adding descriptions could help clarify ideas');
            }
            
            // Decision insights
            if (this.decisionStyle.quickDecider) {
                strengths.push('Quick, confident decision maker');
            }
            if (this.decisionStyle.selectivityRate > 0.7) {
                strengths.push('Selective and discerning');
            }
            
            // Session rhythm insights
            if (this.sessionRhythm.momentumPattern === 'accelerating') {
                strengths.push('Builds momentum over sessions');
            } else if (this.sessionRhythm.momentumPattern === 'burst-rest') {
                strengths.push('Works in productive bursts');
            }
            
            // Cognitive pattern insights
            if (this.cognitivePatterns.thinkingRatio > 0.4) {
                strengths.push('Thoughtful, deliberate approach');
            }
            
            this.insights = {
                lastUpdated: Date.now(),
                summary: this.generateSummary(),
                strengths,
                suggestions
            };
        }
        
        // Generate a natural language summary
        generateSummary() {
            const parts = [];
            
            // Building style
            if (this.buildingStyle.breadthFirstScore > 0.6) {
                parts.push('builds systematically across topics');
            } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                parts.push('dives deep into specific areas');
            } else {
                parts.push('balances breadth and depth');
            }
            
            // Rhythm
            if (this.sessionRhythm.momentumPattern === 'accelerating') {
                parts.push('picks up speed as they work');
            } else if (this.sessionRhythm.momentumPattern === 'burst-rest') {
                parts.push('works in focused bursts');
            }
            
            // Decision style
            if (this.decisionStyle.batchPreference > 0.6) {
                parts.push('prefers accepting suggestions in batches');
            } else if (this.decisionStyle.selectivityRate > 0.6) {
                parts.push('carefully selects individual suggestions');
            }
            
            return parts.length > 0 ? 
                `User ${parts.join(', ')}.` : 
                'Still learning user patterns.';
        }
        
        // Get insights for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Building style
            if (this.buildingStyle.depthSequences.length >= 20) {
                if (this.buildingStyle.breadthFirstScore > 0.6) {
                    insights.push('User builds breadth-first (suggest siblings before children)');
                } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                    insights.push('User builds depth-first (suggest deeper children)');
                }
            }
            
            // Decision style - helps calibrate suggestion count
            if (this.decisionStyle.suggestionsAccepted > 10) {
                if (this.decisionStyle.selectivityRate > 0.7) {
                    insights.push('User is highly selective (suggest only best matches)');
                } else if (this.decisionStyle.selectivityRate < 0.3) {
                    insights.push('User accepts most suggestions (can include exploratory options)');
                }
            }
            
            // Cognitive style
            if (this.cognitivePatterns.avgChildrenPerNode > 0) {
                if (this.cognitivePatterns.avgChildrenPerNode < 2.5) {
                    insights.push('User prefers focused nodes (suggest fewer, more specific children)');
                } else if (this.cognitivePatterns.avgChildrenPerNode > 4) {
                    insights.push('User likes comprehensive breakdowns (can suggest more children)');
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI
        getStats() {
            return {
                buildingStyle: this.buildingStyle.breadthFirstScore > 0.6 ? 'Breadth-first' :
                    this.buildingStyle.breadthFirstScore < 0.3 ? 'Depth-first' : 'Balanced',
                buildingScore: this.buildingStyle.breadthFirstScore,
                localityScore: this.explorationStyle.localityScore,
                refinementRatio: this.refinementStyle.editVsCreateRatio,
                selectivityRate: this.decisionStyle.selectivityRate,
                quickDecider: this.decisionStyle.quickDecider,
                momentumPattern: this.sessionRhythm.momentumPattern,
                burstScore: this.sessionRhythm.burstScore,
                sessionsAnalyzed: this.sessionRhythm.sessionsAnalyzed,
                thinkingRatio: this.cognitivePatterns.thinkingRatio,
                insights: this.insights
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 10000); // Save every 10 seconds of inactivity
        }
        
        // Reset
        async reset() {
            this.buildingStyle = {
                depthSequences: [],
                breadthFirstScore: 0.5,
                consecutiveSameDepth: 0,
                consecutiveDeeper: 0,
                lastDepth: 0,
                levelCompletionRate: 0.5
            };
            this.explorationStyle = {
                selectionJumps: [],
                localityScore: 0.5,
                expandBeforeCreate: 0,
                createBeforeExpand: 0,
                branchRevisits: new Map(),
                revisitRate: 0
            };
            this.refinementStyle = {
                editCount: 0,
                createCount: 0,
                editVsCreateRatio: 0.5,
                immediateEdits: 0,
                delayedEdits: 0,
                nodesWithDescription: 0,
                totalNodes: 0,
                descriptionRate: 0
            };
            this.decisionStyle = {
                acceptanceTimes: [],
                avgAcceptanceTime: 0,
                quickDecider: false,
                suggestionsShown: 0,
                suggestionsAccepted: 0,
                selectivityRate: 0.5,
                addAllCount: 0,
                individualPickCount: 0,
                batchPreference: 0.5
            };
            this.sessionRhythm = {
                actionTimestamps: [],
                burstScore: 0.5,
                avgTimeBetweenActions: 0,
                sessionsAnalyzed: 0,
                avgActionsPerSession: 0,
                avgSessionDuration: 0,
                momentumPattern: 'steady'
            };
            this.branchCommitment = {
                branchDepths: new Map(),
                avgBranchDepth: 0,
                abandonedBranches: [],
                abandonmentRate: 0,
                focusScore: 0.5,
                activeBranches: 0,
                switchesPerSession: 0,
                avgTimeOnBranch: 0
            };
            this.cognitivePatterns = {
                avgChildrenPerNode: 0,
                prefersFlatStructure: false,
                prefersDeepStructure: false,
                avgLabelComplexity: 0,
                longPauses: 0,
                shortPauses: 0,
                thinkingRatio: 0.5
            };
            this.insights = {
                lastUpdated: null,
                summary: '',
                strengths: [],
                suggestions: []
            };
            
            await NeuralDB.delete('meta-learner');
            console.log('✓ Meta-learner reset');
        }
    }
    
    // Create global meta-learner instance
    const metaLearner = new MetaLearner();
    
    // ═══════════════════════════════════════════════════════════════════
    // NEURAL NETWORK TRAINING WORKER
    // ═══════════════════════════════════════════════════════════════════
    // Create a worker for training a single model type
    const createModelWorker = (modelType) => {
        const workerCode = `
            // Load TensorFlow.js in worker
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');
            
            // Try to use WebGL backend for GPU acceleration
            async function initBackend() {
                try {
                    await tf.setBackend('webgl');
                    await tf.ready();
                    return tf.getBackend();
                } catch (e) {
                    return 'cpu';
                }
            }
            
            // Default config - will be overridden by main thread
            let CONFIG = {
                embeddingDim: 512,
                hiddenUnits: 128,
                learningRate: 0.001,
                epochs: 15,
                batchSize: 16
            };
            
            function buildCategoryModel(numCategories) {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim],
                    units: CONFIG.hiddenUnits,
                    activation: 'relu',
                    kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: Math.max(32, CONFIG.hiddenUnits / 2), activation: 'relu' }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: numCategories, activation: 'softmax' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                return model;
            }
            
            function buildConnectionModel() {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim * 2],
                    units: CONFIG.hiddenUnits * 2, // Scale with hiddenUnits
                    activation: 'relu'
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: Math.max(32, CONFIG.hiddenUnits / 2), activation: 'relu' }));
                model.add(tf.layers.dense({ units: 4, activation: 'sigmoid' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                return model;
            }
            
            function buildPredictionModel() {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim],
                    units: CONFIG.hiddenUnits * 2, // Scale with hiddenUnits
                    activation: 'relu',
                    kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: CONFIG.hiddenUnits * 2, activation: 'relu' }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: CONFIG.embeddingDim, activation: 'linear' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate * 0.5),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                return model;
            }
            
            async function extractWeights(model) {
                const weights = [];
                for (const layer of model.layers) {
                    const layerWeights = layer.getWeights();
                    const layerData = [];
                    for (const w of layerWeights) {
                        layerData.push({
                            shape: w.shape,
                            data: await w.data()
                        });
                    }
                    weights.push(layerData);
                }
                return weights;
            }
            
            self.onmessage = async function(e) {
                const { type, data, modelType, config } = e.data;
                
                // Update config if provided
                if (config) {
                    CONFIG = { ...CONFIG, ...config };
                }
                
                if (type === 'train') {
                    try {
                        // Initialize GPU backend
                        const backend = await initBackend();
                        self.postMessage({ type: 'progress', modelType, progress: 0, message: 'Using ' + backend + ' (epochs=' + CONFIG.epochs + ')' });
                        
                        let model, xs, ys, weights = null;
                        
                        if (modelType === 'category' && data.numCategories > 1 && data.inputs.length > 0) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildCategoryModel(data.numCategories);
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);

                            // Create sample weights tensor if feedback weights are provided
                            const hasSampleWeights = data.sampleWeights && data.sampleWeights.length === data.inputs.length;
                            const sw = hasSampleWeights ? tf.tensor1d(data.sampleWeights) : null;

                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: CONFIG.batchSize,
                                validationSplit: 0.2,
                                shuffle: true,
                                sampleWeight: sw,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({
                                            type: 'progress',
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            accuracy: logs.acc,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });

                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                            if (sw) sw.dispose();
                            
                        } else if (modelType === 'connection' && data.inputs.length > 10) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildConnectionModel();
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);

                            // Create sample weights tensor if feedback weights are provided
                            const hasSampleWeights = data.sampleWeights && data.sampleWeights.length === data.inputs.length;
                            const sw = hasSampleWeights ? tf.tensor1d(data.sampleWeights) : null;

                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: CONFIG.batchSize,
                                validationSplit: 0.2,
                                shuffle: true,
                                sampleWeight: sw,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({
                                            type: 'progress',
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            accuracy: logs.acc,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });

                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                            if (sw) sw.dispose();
                            
                        } else if (modelType === 'prediction' && data.inputs.length > 5) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildPredictionModel();
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);

                            // Create sample weights tensor if feedback weights are provided
                            const hasSampleWeights = data.sampleWeights && data.sampleWeights.length === data.inputs.length;
                            const sw = hasSampleWeights ? tf.tensor1d(data.sampleWeights) : null;

                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: Math.min(CONFIG.batchSize, data.inputs.length),
                                validationSplit: 0.2,
                                shuffle: true,
                                sampleWeight: sw,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({
                                            type: 'progress',
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });

                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                            if (sw) sw.dispose();
                        }
                        
                        self.postMessage({ type: 'complete', modelType, weights });
                        
                    } catch (error) {
                        self.postMessage({ type: 'error', modelType, error: error.message });
                    }
                }
            };
            
            self.postMessage({ type: 'ready' });
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // EMBEDDING WORKER - Offload USE inference to background thread
    // ═══════════════════════════════════════════════════════════════════
    const createEmbeddingWorker = () => {
        const workerCode = `
            // Load TensorFlow.js and Universal Sentence Encoder
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js');
            
            let encoder = null;
            let isReady = false;
            
            // Initialize encoder
            async function init() {
                try {
                    // Try WebGL backend
                    try {
                        await tf.setBackend('webgl');
                        await tf.ready();
                    } catch (e) {
                        console.log('WebGL not available in worker, using CPU');
                    }
                    
                    encoder = await use.load();
                    isReady = true;
                    self.postMessage({ type: 'ready', backend: tf.getBackend() });
                } catch (error) {
                    self.postMessage({ type: 'error', error: error.message });
                }
            }
            
            self.onmessage = async function(e) {
                const { type, id, text, texts } = e.data;
                
                if (type === 'embed' && isReady) {
                    try {
                        const embeddings = await encoder.embed([text]);
                        const vector = (await embeddings.array())[0];
                        embeddings.dispose();
                        self.postMessage({ type: 'embedding', id, vector });
                    } catch (error) {
                        self.postMessage({ type: 'error', id, error: error.message });
                    }
                } else if (type === 'embedBatch' && isReady) {
                    try {
                        const embeddings = await encoder.embed(texts);
                        const vectors = await embeddings.array();
                        embeddings.dispose();
                        self.postMessage({ type: 'embeddings', id, vectors });
                    } catch (error) {
                        self.postMessage({ type: 'error', id, error: error.message });
                    }
                } else if (!isReady) {
                    self.postMessage({ type: 'notReady', id });
                }
            };
            
            // Start initialization
            init();
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // PERSONAL NEURAL NETWORK - TensorFlow.js Integration
    // ═══════════════════════════════════════════════════════════════════
    class PersonalNeuralNet {
        constructor() {
            this.encoder = null;
            this.embeddingWorker = null;
            this.embeddingWorkerReady = false;
            this.pendingEmbeddingRequests = new Map(); // id -> {resolve, reject}
            this.embeddingRequestId = 0;
            this.categoryModel = null;
            this.connectionModel = null;
            this.predictionModel = null; // New: Predicts likely child nodes
            this.expansionPatterns = new Map(); // Learned parent->children patterns
            this.patternWeights = new Map(); // Weights for parent->child pairs (incremental learning)
            this.embeddings = new Map(); // Cache embeddings for nodes
            this.isReady = false;
            this.isInitializing = false; // Track if initialization is in progress
            this.isTraining = false;
            this.trainingProgress = 0;
            this.categories = []; // Learned categories (top-level nodes)
            this.commonPatterns = []; // Frequently seen expansion patterns
            this.pendingEmbeddings = []; // Queue of texts waiting to be embedded
            this.embeddingDebounceTimer = null;
            this.trainingWorkers = []; // Array for parallel workers
            this.callbacks = {
                onReady: [],
                onTrainingStart: [],
                onTrainingProgress: [],
                onTrainingComplete: [],
                onPrediction: [],
                onSuggestion: [],
                onIncrementalLearn: []
            };
        }
        
        // Initialize the encoder and load any saved models
        async initialize() {
            try {
                console.log('🧠 Initializing Personal Neural Network...');
                
                // Lazy load TensorFlow.js if not already loaded
                if (!TensorFlowLoader.isLoaded()) {
                    try {
                        await TensorFlowLoader.load();
                    } catch (loadError) {
                        console.warn('⚠️ TensorFlow.js could not be loaded:', loadError);
                        this.loadError = 'TensorFlow.js not loaded';
                        return false;
                    }
                }
                
                // Start embedding worker in background
                if (typeof Worker !== 'undefined') {
                    try {
                        this.embeddingWorker = createEmbeddingWorker();
                        this.embeddingWorker.onmessage = (e) => {
                            const { type, id, vector, vectors, backend, error } = e.data;
                            
                            if (type === 'ready') {
                                this.embeddingWorkerReady = true;
                                console.log(`✓ Embedding worker ready (${backend} backend)`);
                            } else if (type === 'embedding') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.resolve(vector);
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            } else if (type === 'embeddings') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.resolve(vectors);
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            } else if (type === 'error' || type === 'notReady') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.reject(new Error(error || 'Worker not ready'));
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            }
                        };
                        this.embeddingWorker.onerror = (err) => {
                            console.warn('Embedding worker error:', err);
                            this.embeddingWorkerReady = false;
                        };
                    } catch (workerError) {
                        console.warn('Could not create embedding worker:', workerError);
                    }
                }
                
                // Load Universal Sentence Encoder on main thread (fallback + sharing with other systems)
                if (typeof use !== 'undefined') {
                    try {
                        this.encoder = await use.load();
                        console.log('✓ Universal Sentence Encoder loaded (main thread)');
                        
                        // Share encoder with semantic memory system
                        semanticMemory.setEncoder(this.encoder);

                        // Share encoder with relationship classifier
                        relationshipClassifier.setEncoder(this.encoder);

                        // Share encoder with concept abstractor
                        conceptAbstractor.setEncoder(this.encoder);

                        // Share encoder with CodeRAG system
                        codeRAG.setEncoder(this.encoder);
                    } catch (loadError) {
                        // Model fetch blocked (common in preview environments)
                        console.warn('⚠️ Neural network: Model loading blocked (preview environment)');
                        console.warn('   Neural features will work when running locally or hosted');
                        this.loadError = 'Preview environment - run locally for neural features';
                        return false;
                    }
                } else {
                    console.warn('Universal Sentence Encoder not available');
                    this.loadError = 'TensorFlow.js not loaded';
                    return false;
                }
                
                // Try to load saved models
                await this.loadModels();
                
                // Load cached embeddings
                this.loadEmbeddings();
                
                this.isReady = true;
                this.emit('onReady');
                console.log('✓ Personal Neural Network ready');
                return true;
            } catch (error) {
                console.warn('Neural network unavailable:', error.message);
                this.loadError = error.message;
                return false;
            }
        }
        
        // Event system
        on(event, callback) {
            if (this.callbacks[event]) {
                this.callbacks[event].push(callback);
            }
        }
        
        emit(event, data) {
            if (this.callbacks[event]) {
                this.callbacks[event].forEach(cb => cb(data));
            }
        }
        
        // Generate embedding for text (uses worker when available)
        async getEmbedding(text) {
            if (!this.encoder && !this.embeddingWorkerReady) return null;
            
            const cacheKey = text.toLowerCase().trim();
            if (this.embeddings.has(cacheKey)) {
                return this.embeddings.get(cacheKey);
            }
            
            try {
                let vector;
                
                // Use worker if available (non-blocking)
                if (this.embeddingWorkerReady && this.embeddingWorker) {
                    const id = ++this.embeddingRequestId;
                    vector = await new Promise((resolve, reject) => {
                        this.pendingEmbeddingRequests.set(id, { resolve, reject });
                        this.embeddingWorker.postMessage({ type: 'embed', id, text });
                        
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            if (this.pendingEmbeddingRequests.has(id)) {
                                this.pendingEmbeddingRequests.delete(id);
                                reject(new Error('Embedding timeout'));
                            }
                        }, 10000);
                    });
                } else if (this.encoder) {
                    // Fallback to main thread
                    const embeddings = await this.encoder.embed([text]);
                    const embedding = await embeddings.array();
                    vector = embedding[0];
                    embeddings.dispose();
                } else {
                    return null;
                }
                
                this.embeddings.set(cacheKey, vector);
                return vector;
            } catch (error) {
                // If worker fails, try main thread fallback
                if (this.encoder) {
                    try {
                        const embeddings = await this.encoder.embed([text]);
                        const embedding = await embeddings.array();
                        const vector = embedding[0];
                        embeddings.dispose();
                        this.embeddings.set(cacheKey, vector);
                        return vector;
                    } catch (e) {
                        console.error('Embedding fallback error:', e);
                    }
                }
                console.error('Embedding error:', error);
                return null;
            }
        }
        
        // Get embeddings for multiple texts efficiently (uses worker when available)
        async getEmbeddings(texts) {
            if (!this.encoder && !this.embeddingWorkerReady) return null;
            
            // Check cache first
            const uncachedTexts = [];
            const uncachedIndices = [];
            const results = new Array(texts.length);
            
            texts.forEach((text, i) => {
                const cacheKey = text.toLowerCase().trim();
                if (this.embeddings.has(cacheKey)) {
                    results[i] = this.embeddings.get(cacheKey);
                } else {
                    uncachedTexts.push(text);
                    uncachedIndices.push(i);
                }
            });
            
            // If all cached, return immediately
            if (uncachedTexts.length === 0) {
                return results;
            }
            
            try {
                let vectors;
                
                // Use worker if available (non-blocking)
                if (this.embeddingWorkerReady && this.embeddingWorker) {
                    const id = ++this.embeddingRequestId;
                    vectors = await new Promise((resolve, reject) => {
                        this.pendingEmbeddingRequests.set(id, { resolve, reject });
                        this.embeddingWorker.postMessage({ type: 'embedBatch', id, texts: uncachedTexts });
                        
                        // Timeout after 30 seconds for batch
                        setTimeout(() => {
                            if (this.pendingEmbeddingRequests.has(id)) {
                                this.pendingEmbeddingRequests.delete(id);
                                reject(new Error('Batch embedding timeout'));
                            }
                        }, 30000);
                    });
                } else if (this.encoder) {
                    // Fallback to main thread
                    const embeddings = await this.encoder.embed(uncachedTexts);
                    vectors = await embeddings.array();
                    embeddings.dispose();
                } else {
                    return null;
                }
                
                // Cache and fill results
                uncachedTexts.forEach((text, i) => {
                    const cacheKey = text.toLowerCase().trim();
                    this.embeddings.set(cacheKey, vectors[i]);
                    results[uncachedIndices[i]] = vectors[i];
                });
                
                return results;
            } catch (error) {
                // If worker fails, try main thread fallback
                if (this.encoder) {
                    try {
                        const embeddings = await this.encoder.embed(uncachedTexts);
                        const vectors = await embeddings.array();
                        embeddings.dispose();
                        
                        uncachedTexts.forEach((text, i) => {
                            const cacheKey = text.toLowerCase().trim();
                            this.embeddings.set(cacheKey, vectors[i]);
                            results[uncachedIndices[i]] = vectors[i];
                        });
                        
                        return results;
                    } catch (e) {
                        console.error('Batch embedding fallback error:', e);
                    }
                }
                console.error('Batch embedding error:', error);
                return null;
            }
        }
        
        // Build the category prediction model
        buildCategoryModel(numCategories) {
            const model = tf.sequential();
            
            // Input: 512-dim embedding
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: CONFIG.NEURAL_NET.hiddenUnits,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: Math.max(32, CONFIG.NEURAL_NET.hiddenUnits / 2),
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: probability for each category
            model.add(tf.layers.dense({
                units: numCategories,
                activation: 'softmax'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the connection prediction model
        buildConnectionModel() {
            const model = tf.sequential();
            
            // Input: concatenated embeddings of two nodes (512 + 512 = 1024)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim * 2],
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: Math.max(32, CONFIG.NEURAL_NET.hiddenUnits / 2),
                activation: 'relu'
            }));
            
            // Output: connection probability and connection type
            // [shouldConnect, isParentChild, isSibling, isRelated]
            model.add(tf.layers.dense({
                units: 4,
                activation: 'sigmoid'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the node prediction model - predicts likely child node embeddings
        buildPredictionModel() {
            const model = tf.sequential();
            
            // Input: parent node embedding (512)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: predicted "average child" embedding (512)
            // This represents the semantic centroid of expected children
            model.add(tf.layers.dense({
                units: CONFIG.NEURAL_NET.embeddingDim,
                activation: 'linear' // Linear for embedding space
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate * 0.5),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }
        
        // Prepare training data from the mind map structure
        // feedbackWeights: Map<pattern, {weight, confidence}> from AIFeedback
        async prepareTrainingData(store, feedbackWeights = new Map()) {
            const allNodes = [];
            const categoryLabels = [];
            
            // Collect all nodes with their text and category
            const collectNodes = (node, category = null, depth = 0) => {
                if (depth === 0) {
                    // Root node - skip
                } else if (depth === 1) {
                    // This is a category (top-level node)
                    category = node.label;
                    if (!this.categories.includes(category)) {
                        this.categories.push(category);
                    }
                }
                
                if (depth > 0 && category) {
                    const text = node.description 
                        ? `${node.label}. ${node.description}`
                        : node.label;
                    allNodes.push({
                        id: node.id,
                        text: text,
                        label: node.label,
                        category: category,
                        categoryIndex: this.categories.indexOf(category),
                        depth: depth,
                        parentId: null, // Will be set below
                        children: node.children?.map(c => c.id) || []
                    });
                }
                
                if (node.children) {
                    node.children.forEach(child => {
                        collectNodes(child, category || node.label, depth + 1);
                    });
                }
            };
            
            collectNodes(store.data);
            
            // Set parent IDs
            const setParents = (node, parentId = null) => {
                const nodeData = allNodes.find(n => n.id === node.id);
                if (nodeData) {
                    nodeData.parentId = parentId;
                }
                if (node.children) {
                    node.children.forEach(child => setParents(child, node.id));
                }
            };
            setParents(store.data);
            
            if (allNodes.length < CONFIG.NEURAL_NET.minTrainingNodes) {
                console.log(`Need at least ${CONFIG.NEURAL_NET.minTrainingNodes} nodes to train`);
                return null;
            }
            
            // Get embeddings for all node texts
            const texts = allNodes.map(n => n.text);
            const embeddings = await this.getEmbeddings(texts);
            
            if (!embeddings) return null;
            
            // Helper to get sample weight from feedback
            const getSampleWeight = (label) => {
                if (!feedbackWeights || feedbackWeights.size === 0) return 1.0;
                const key = label.toLowerCase().trim();
                const feedback = feedbackWeights.get(key);
                if (feedback) {
                    // Blend feedback weight with confidence
                    return 1.0 + (feedback.weight - 1.0) * feedback.confidence;
                }
                return 1.0;
            };

            // Prepare category training data with sample weights
            const categoryData = {
                inputs: [],
                outputs: [],
                sampleWeights: []
            };

            allNodes.forEach((node, i) => {
                if (node.categoryIndex >= 0) {
                    categoryData.inputs.push(embeddings[i]);
                    // One-hot encode the category
                    const oneHot = new Array(this.categories.length).fill(0);
                    oneHot[node.categoryIndex] = 1;
                    categoryData.outputs.push(oneHot);
                    // Weight based on feedback for this node's label
                    categoryData.sampleWeights.push(getSampleWeight(node.label));
                }
            });

            // === KNOWLEDGE DISTILLATION: Add teacher examples from Claude ===
            // These are "soft targets" from Claude that help the local model
            // learn Claude's reasoning patterns
            if (typeof TeacherKnowledge !== 'undefined') {
                const teacherExamples = await TeacherKnowledge.getTrainingExamples('category', this);

                for (const ex of teacherExamples) {
                    // Find category index
                    const catIndex = this.categories.indexOf(ex.category);
                    if (catIndex === -1) continue; // Category not in our list

                    // Add teacher example with soft one-hot (uses confidence as temperature)
                    categoryData.inputs.push(ex.embedding);

                    // Soft target: main category gets confidence, rest gets distributed remainder
                    const softTarget = new Array(this.categories.length).fill(0);
                    softTarget[catIndex] = ex.confidence;
                    // Distribute remaining probability among other categories
                    const remainder = (1 - ex.confidence) / (this.categories.length - 1);
                    for (let i = 0; i < softTarget.length; i++) {
                        if (i !== catIndex) softTarget[i] = remainder;
                    }
                    categoryData.outputs.push(softTarget);

                    // Teacher examples get higher weight (Claude is authoritative)
                    categoryData.sampleWeights.push(CONFIG.NEURAL_NET.teacherExampleWeight);
                }

                if (teacherExamples.length > 0) {
                    console.log(`📚 Added ${teacherExamples.length} teacher examples for knowledge distillation`);
                }
            }

            // Prepare connection training data with sample weights
            const connectionData = {
                inputs: [],
                outputs: [],
                sampleWeights: []
            };

            // Positive examples: actual parent-child and sibling pairs
            allNodes.forEach((node, i) => {
                // Parent-child connections
                node.children.forEach(childId => {
                    const childIndex = allNodes.findIndex(n => n.id === childId);
                    if (childIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[childIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 1, 0, 1]); // connected, parent-child, not sibling, related
                        // Weight based on both parent and child labels
                        const weight = (getSampleWeight(node.label) + getSampleWeight(allNodes[childIndex].label)) / 2;
                        connectionData.sampleWeights.push(weight);
                    }
                });

                // Sibling connections (same parent)
                const siblings = allNodes.filter(n =>
                    n.parentId === node.parentId && n.id !== node.id
                );
                siblings.slice(0, 3).forEach(sibling => {
                    const siblingIndex = allNodes.findIndex(n => n.id === sibling.id);
                    if (siblingIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[siblingIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 0, 1, 1]); // connected, not parent-child, sibling, related
                        const weight = (getSampleWeight(node.label) + getSampleWeight(sibling.label)) / 2;
                        connectionData.sampleWeights.push(weight);
                    }
                });
            });

            // Negative examples: random unconnected pairs
            const numNegative = Math.min(connectionData.inputs.length, allNodes.length * 2);
            for (let i = 0; i < numNegative; i++) {
                const idx1 = Math.floor(Math.random() * allNodes.length);
                const idx2 = Math.floor(Math.random() * allNodes.length);
                if (idx1 !== idx2) {
                    const node1 = allNodes[idx1];
                    const node2 = allNodes[idx2];

                    // Check if they're not actually connected
                    const isConnected = node1.children.includes(node2.id) ||
                                       node2.children.includes(node1.id) ||
                                       node1.parentId === node2.parentId;

                    if (!isConnected) {
                        const combined = [...embeddings[idx1], ...embeddings[idx2]];
                        connectionData.inputs.push(combined);
                        // Different categories = probably not related
                        const sameCategory = node1.category === node2.category;
                        connectionData.outputs.push([0, 0, 0, sameCategory ? 0.5 : 0]);
                        connectionData.sampleWeights.push(1.0); // Neutral weight for negative examples
                    }
                }
            }
            
            // Prepare prediction training data (parent -> average child embedding) with sample weights
            const predictionData = {
                inputs: [],
                outputs: [],
                sampleWeights: [],
                patterns: [] // Store label patterns for pattern matching
            };

            // For each parent with children, create training pair
            allNodes.forEach((node, i) => {
                if (node.children.length > 0) {
                    // Get all child embeddings
                    const childEmbeddings = [];
                    const childLabels = [];

                    node.children.forEach(childId => {
                        const childIndex = allNodes.findIndex(n => n.id === childId);
                        if (childIndex >= 0) {
                            childEmbeddings.push(embeddings[childIndex]);
                            childLabels.push(allNodes[childIndex].label);
                        }
                    });

                    if (childEmbeddings.length > 0) {
                        // Input: parent embedding
                        predictionData.inputs.push(embeddings[i]);

                        // Output: centroid (average) of child embeddings
                        const centroid = new Array(CONFIG.NEURAL_NET.embeddingDim).fill(0);
                        childEmbeddings.forEach(childEmb => {
                            childEmb.forEach((val, j) => {
                                centroid[j] += val / childEmbeddings.length;
                            });
                        });
                        predictionData.outputs.push(centroid);

                        // Sample weight based on parent and average child weights
                        const childWeights = childLabels.map(l => getSampleWeight(l));
                        const avgChildWeight = childWeights.reduce((a, b) => a + b, 0) / childWeights.length;
                        const weight = (getSampleWeight(node.label) + avgChildWeight) / 2;
                        predictionData.sampleWeights.push(weight);

                        // Store pattern for label-based suggestions
                        predictionData.patterns.push({
                            parentLabel: node.label.toLowerCase(),
                            childLabels: childLabels
                        });
                    }
                }
            });
            
            // Store expansion patterns for quick lookup
            this.expansionPatterns.clear();
            predictionData.patterns.forEach(p => {
                // Normalize parent label for fuzzy matching
                const key = this.normalizeLabel(p.parentLabel);
                if (!this.expansionPatterns.has(key)) {
                    this.expansionPatterns.set(key, []);
                }
                this.expansionPatterns.get(key).push(...p.childLabels);
            });
            
            // Find common patterns across similar parents
            this.learnCommonPatterns(predictionData.patterns);
            
            return { categoryData, connectionData, predictionData, allNodes, embeddings };
        }
        
        // Normalize label for pattern matching
        normalizeLabel(label) {
            return label.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Learn common expansion patterns
        learnCommonPatterns(patterns) {
            // Group similar child labels across different parents
            const childFrequency = new Map();
            
            patterns.forEach(p => {
                p.childLabels.forEach(label => {
                    const normalized = this.normalizeLabel(label);
                    childFrequency.set(normalized, (childFrequency.get(normalized) || 0) + 1);
                });
            });
            
            // Find commonly used child labels (appear in multiple parent contexts)
            this.commonPatterns = Array.from(childFrequency.entries())
                .filter(([label, count]) => count >= 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([label]) => label);
            
            console.log(`✓ Learned ${this.commonPatterns.length} common expansion patterns`);
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // INCREMENTAL LEARNING - Real-time pattern updates
        // ═══════════════════════════════════════════════════════════════════
        
        // Learn a new parent->child pattern immediately when node is added
        incrementalLearnPattern(parentLabel, childLabel, source = 'user', depth = 1) {
            if (!parentLabel || !childLabel) return;
            
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            // Add to expansion patterns
            if (!this.expansionPatterns.has(normalizedParent)) {
                this.expansionPatterns.set(normalizedParent, []);
            }
            
            const children = this.expansionPatterns.get(normalizedParent);
            if (!children.includes(childLabel)) {
                children.push(childLabel);
            }
            
            // Initialize or update weight
            const currentWeight = this.patternWeights.get(patternKey) || { 
                weight: 0.3, 
                occurrences: 0, 
                accepted: 0,
                sources: [],
                relationshipType: null,
                relationshipConfidence: 0
            };
            
            currentWeight.occurrences++;
            currentWeight.weight = Math.min(1.0, currentWeight.weight + 0.1);
            if (!currentWeight.sources.includes(source)) {
                currentWeight.sources.push(source);
            }
            
            // Classify relationship type (heuristics only for performance)
            if (!currentWeight.relationshipType) {
                const classification = relationshipClassifier.classifyByHeuristics(parentLabel, childLabel);
                if (classification.confidence >= 0.3) {
                    currentWeight.relationshipType = classification.type;
                    currentWeight.relationshipConfidence = classification.confidence;
                }
            }
            
            this.patternWeights.set(patternKey, currentWeight);
            
            // Learn structural pattern for concept abstraction
            conceptAbstractor.learnPattern(
                parentLabel, 
                childLabel, 
                depth, 
                currentWeight.relationshipType
            );
            
            // Update common patterns if this child appears frequently
            const childOccurrences = Array.from(this.patternWeights.entries())
                .filter(([key]) => key.endsWith(`→${normalizedChild}`))
                .length;
            
            if (childOccurrences >= 2 && !this.commonPatterns.includes(normalizedChild)) {
                this.commonPatterns.push(normalizedChild);
                if (this.commonPatterns.length > 25) {
                    this.commonPatterns = this.commonPatterns.slice(-25);
                }
            }
            
            console.log(`📚 Incremental learn: "${parentLabel}" → "${childLabel}" (weight: ${currentWeight.weight.toFixed(2)}, type: ${currentWeight.relationshipType || 'unknown'})`);
            this.emit('onIncrementalLearn', { parentLabel, childLabel, weight: currentWeight.weight });
            
            // Debounced save
            this.scheduleSave();
        }
        
        // Boost pattern weight when user accepts a suggestion
        boostPattern(parentLabel, childLabel, suggestionType = 'ai') {
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            const previousWeight = this.patternWeights.get(patternKey);
            const wasHighConfidence = previousWeight && previousWeight.weight >= 0.7;
            
            const currentWeight = previousWeight || {
                weight: 0.5,
                occurrences: 1,
                accepted: 0,
                sources: []
            };
            
            // Significant boost for accepted suggestions
            currentWeight.accepted++;
            currentWeight.weight = Math.min(1.0, currentWeight.weight + 0.25);
            if (!currentWeight.sources.includes('accepted')) {
                currentWeight.sources.push('accepted');
            }
            
            this.patternWeights.set(patternKey, currentWeight);
            
            console.log(`⬆️ Boosted pattern: "${parentLabel}" → "${childLabel}" (weight: ${currentWeight.weight.toFixed(2)}, accepted: ${currentWeight.accepted}x)`);
            
            // Create memory when pattern reaches high confidence for the first time
            if (!wasHighConfidence && currentWeight.weight >= 0.7 && typeof semanticMemory !== 'undefined') {
                semanticMemory.addMemory(
                    'pattern_emerged',
                    `Strong pattern emerged: "${parentLabel}" → "${childLabel}" (accepted ${currentWeight.accepted}x)`,
                    { parentLabel, childLabel, weight: currentWeight.weight, acceptedCount: currentWeight.accepted }
                );
            }
            
            // Also add to expansion patterns if not present
            if (!this.expansionPatterns.has(normalizedParent)) {
                this.expansionPatterns.set(normalizedParent, []);
            }
            const children = this.expansionPatterns.get(normalizedParent);
            if (!children.includes(childLabel)) {
                children.push(childLabel);
            }
            
            this.scheduleSave();
        }
        
        // Get weight for a pattern (for use in predictions)
        getPatternWeight(parentLabel, childLabel) {
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            const weight = this.patternWeights.get(patternKey);
            return weight ? weight.weight : 0.3; // Default weight
        }
        
        // Find patterns with same relationship type for transfer learning
        findAnalogousByType(relationshipType, excludeParent, excludeChildren = [], limit = 3) {
            const analogous = [];
            const normalizedExclude = excludeChildren.map(c => this.normalizeLabel(c));
            
            // Scan all patterns with matching relationship type
            for (const [patternKey, weight] of this.patternWeights) {
                // Must have matching relationship type with decent confidence
                if (weight.relationshipType !== relationshipType || 
                    weight.relationshipConfidence < 0.4 ||
                    weight.weight < 0.4) {
                    continue;
                }
                
                const [parentPart, childPart] = patternKey.split('→');
                
                // Skip if same parent or child already exists
                if (parentPart === excludeParent || normalizedExclude.includes(childPart)) {
                    continue;
                }
                
                // Calculate transfer score based on pattern strength and relationship confidence
                const transferScore = (weight.weight * 0.6 + weight.relationshipConfidence * 0.4) * 0.7; // Discount for being analogous
                
                analogous.push({
                    fromParent: parentPart,
                    childLabel: childPart,
                    relationshipType,
                    transferScore,
                    originalWeight: weight.weight
                });
            }
            
            // Sort by transfer score
            analogous.sort((a, b) => b.transferScore - a.transferScore);
            
            // Return top suggestions (avoid duplicates)
            const seen = new Set();
            const result = [];
            
            for (const item of analogous) {
                if (!seen.has(item.childLabel) && result.length < limit) {
                    seen.add(item.childLabel);
                    result.push(item);
                }
            }
            
            return result;
        }
        
        // Queue embedding for async processing
        queueEmbedding(text) {
            if (!text || this.embeddings.has(text)) return;
            
            if (!this.pendingEmbeddings.includes(text)) {
                this.pendingEmbeddings.push(text);
            }
            
            // Debounce embedding processing
            if (this.embeddingDebounceTimer) {
                clearTimeout(this.embeddingDebounceTimer);
            }
            
            this.embeddingDebounceTimer = setTimeout(() => {
                this.processPendingEmbeddings();
            }, 500); // Process after 500ms of inactivity
        }
        
        // Process queued embeddings in batch
        async processPendingEmbeddings() {
            if (!this.encoder || this.pendingEmbeddings.length === 0) return;
            
            const toProcess = this.pendingEmbeddings.splice(0, 10); // Process up to 10 at a time
            
            try {
                const embeddings = await this.encoder.embed(toProcess);
                const embeddingArrays = await embeddings.array();
                embeddings.dispose();
                
                toProcess.forEach((text, i) => {
                    this.embeddings.set(text, embeddingArrays[i]);
                });
                
                console.log(`📊 Cached ${toProcess.length} new embeddings (total: ${this.embeddings.size})`);
                
                // If more pending, continue processing
                if (this.pendingEmbeddings.length > 0) {
                    this.embeddingDebounceTimer = setTimeout(() => {
                        this.processPendingEmbeddings();
                    }, 100);
                } else {
                    // Save embeddings when done
                    this.saveEmbeddings();
                }
            } catch (error) {
                console.error('Error processing embeddings:', error);
                // Re-queue failed items
                this.pendingEmbeddings.unshift(...toProcess);
            }
        }
        
        // Debounced save to avoid excessive writes
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.saveModels();
            }, 2000); // Save after 2 seconds of inactivity
        }
        
        // Get incremental learning stats
        getIncrementalStats() {
            const weights = Array.from(this.patternWeights.values());
            const totalPatterns = weights.length;
            const acceptedPatterns = weights.filter(w => w.accepted > 0).length;
            const avgWeight = weights.length > 0 
                ? weights.reduce((sum, w) => sum + w.weight, 0) / weights.length 
                : 0;
            const highConfidencePatterns = weights.filter(w => w.weight >= 0.7).length;
            
            return {
                totalPatterns,
                acceptedPatterns,
                avgWeight,
                highConfidencePatterns,
                pendingEmbeddings: this.pendingEmbeddings.length
            };
        }
        
        // Restore model weights from worker results
        async restoreModelWeights(model, weights) {
            if (!weights || weights.length === 0) return;
            
            for (let i = 0; i < model.layers.length && i < weights.length; i++) {
                const layerWeights = weights[i];
                if (layerWeights.length > 0) {
                    const tensors = layerWeights.map(w => tf.tensor(Array.from(w.data), w.shape));
                    model.layers[i].setWeights(tensors);
                    tensors.forEach(t => t.dispose());
                }
            }
        }
        
        // Train the models on the user's mind map data (using Web Worker)
        async train(store) {
            if (!this.isReady || this.isTraining) {
                console.log('Neural network not ready or already training');
                return false;
            }

            this.isTraining = true;
            this.trainingProgress = 0;
            this.emit('onTrainingStart');

            try {
                // Load feedback weights to incorporate user preferences into training
                console.log('🧠 Loading feedback weights...');
                const feedbackWeights = typeof AIFeedback !== 'undefined'
                    ? AIFeedback.getFeedbackWeights()
                    : new Map();

                console.log('🧠 Preparing training data...');
                const data = await this.prepareTrainingData(store, feedbackWeights);
                
                if (!data) {
                    this.isTraining = false;
                    return false;
                }
                
                const { categoryData, connectionData, predictionData } = data;
                
                // Check if Web Workers are supported
                if (typeof Worker !== 'undefined') {
                    console.log('🧠 Training 3 models in parallel...');
                    
                    return new Promise(async (resolve) => {
                        const results = {
                            categoryWeights: null,
                            connectionWeights: null,
                            predictionWeights: null
                        };
                        
                        const progress = { category: 0, connection: 0, prediction: 0 };
                        const workers = [];
                        let completedCount = 0;
                        let expectedCount = 0;
                        
                        const updateProgress = () => {
                            // Average progress across all active models
                            const avgProgress = (progress.category + progress.connection + progress.prediction) / 3;
                            this.trainingProgress = avgProgress;
                            this.emit('onTrainingProgress', { 
                                phase: 'parallel',
                                progress: avgProgress,
                                details: progress
                            });
                        };
                        
                        const checkComplete = async () => {
                            completedCount++;
                            if (completedCount >= expectedCount) {
                                console.log('🧠 All models trained, restoring...');
                                
                                // Restore models on main thread
                                if (results.categoryWeights && this.categories.length > 1) {
                                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                                    await this.restoreModelWeights(this.categoryModel, results.categoryWeights);
                                    console.log('✓ Category model restored');
                                }
                                
                                if (results.connectionWeights) {
                                    this.connectionModel = this.buildConnectionModel();
                                    await this.restoreModelWeights(this.connectionModel, results.connectionWeights);
                                    console.log('✓ Connection model restored');
                                }
                                
                                if (results.predictionWeights) {
                                    this.predictionModel = this.buildPredictionModel();
                                    await this.restoreModelWeights(this.predictionModel, results.predictionWeights);
                                    console.log('✓ Prediction model restored');
                                }
                                
                                // Cleanup
                                workers.forEach(w => w.terminate());
                                
                                // Save models
                                await this.saveModels();
                                this.saveEmbeddings();
                                
                                this.isTraining = false;
                                this.trainingProgress = 100;
                                this.emit('onTrainingComplete', { categories: this.categories });
                                
                                console.log('✓ Parallel training complete!');
                                resolve(true);
                            }
                        };
                        
                        const createWorkerHandler = (modelType) => {
                            const worker = createModelWorker(modelType);
                            workers.push(worker);
                            
                            worker.onmessage = async (e) => {
                                const { type, modelType: mt, progress: p, weights, error } = e.data;
                                
                                if (type === 'ready') {
                                    // Send training data based on model type
                                    let trainingData;
                                    if (mt === 'category' || modelType === 'category') {
                                        trainingData = {
                                            inputs: categoryData.inputs,
                                            outputs: categoryData.outputs,
                                            sampleWeights: categoryData.sampleWeights,
                                            numCategories: this.categories.length
                                        };
                                    } else if (mt === 'connection' || modelType === 'connection') {
                                        trainingData = {
                                            inputs: connectionData.inputs,
                                            outputs: connectionData.outputs,
                                            sampleWeights: connectionData.sampleWeights
                                        };
                                    } else {
                                        trainingData = {
                                            inputs: predictionData.inputs,
                                            outputs: predictionData.outputs,
                                            sampleWeights: predictionData.sampleWeights
                                        };
                                    }
                                    
                                    worker.postMessage({
                                        type: 'train',
                                        modelType,
                                        data: trainingData,
                                        config: {
                                            epochs: CONFIG.NEURAL_NET.epochs,
                                            batchSize: CONFIG.NEURAL_NET.batchSize,
                                            hiddenUnits: CONFIG.NEURAL_NET.hiddenUnits,
                                            learningRate: CONFIG.NEURAL_NET.learningRate
                                        }
                                    });
                                } else if (type === 'progress') {
                                    progress[modelType] = p;
                                    updateProgress();
                                } else if (type === 'complete') {
                                    if (weights) {
                                        results[modelType + 'Weights'] = weights;
                                    }
                                    await checkComplete();
                                } else if (type === 'error') {
                                    console.error(`Worker ${modelType} error:`, error);
                                    await checkComplete();
                                }
                            };
                            
                            worker.onerror = async (err) => {
                                console.error(`Worker ${modelType} error:`, err);
                                await checkComplete();
                            };
                        };
                        
                        // Spawn workers for models that have enough data
                        if (this.categories.length > 1 && categoryData.inputs.length > 0) {
                            expectedCount++;
                            createWorkerHandler('category');
                        }
                        
                        if (connectionData.inputs.length > 10) {
                            expectedCount++;
                            createWorkerHandler('connection');
                        }
                        
                        if (predictionData.inputs.length > 5) {
                            expectedCount++;
                            createWorkerHandler('prediction');
                        }
                        
                        // If no models to train, resolve immediately
                        if (expectedCount === 0) {
                            this.isTraining = false;
                            resolve(false);
                        }
                    });
                } else {
                    // Fallback to main thread training (old method)
                    console.log('🧠 Training on main thread (Web Workers not supported)...');
                    return this.trainOnMainThread(categoryData, connectionData, predictionData);
                }
                
            } catch (error) {
                console.error('Training error:', error);
                this.isTraining = false;
                return false;
            }
        }
        
        // Fallback: Train on main thread if Web Workers aren't available
        async trainOnMainThread(categoryData, connectionData, predictionData) {
            try {
                // Train category model (0-33%)
                if (this.categories.length > 1 && categoryData.inputs.length > 0) {
                    console.log(`🧠 Training category model (${this.categories.length} categories)...`);
                    
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    
                    const xs = tf.tensor2d(categoryData.inputs);
                    const ys = tf.tensor2d(categoryData.outputs);
                    
                    await this.categoryModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'category',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                                // Yield to UI
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Category model trained');
                }
                
                // Train connection model (33-66%)
                if (connectionData.inputs.length > 10) {
                    console.log(`🧠 Training connection model (${connectionData.inputs.length} pairs)...`);
                    
                    this.connectionModel = this.buildConnectionModel();
                    
                    const xs = tf.tensor2d(connectionData.inputs);
                    const ys = tf.tensor2d(connectionData.outputs);
                    
                    await this.connectionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = 33 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'connection',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Connection model trained');
                }
                
                // Train prediction model (66-100%)
                if (predictionData.inputs.length > 5) {
                    console.log(`🧠 Training prediction model (${predictionData.inputs.length} parent-child pairs)...`);
                    
                    this.predictionModel = this.buildPredictionModel();
                    
                    const xs = tf.tensor2d(predictionData.inputs);
                    const ys = tf.tensor2d(predictionData.outputs);
                    
                    await this.predictionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: Math.min(CONFIG.NEURAL_NET.batchSize, predictionData.inputs.length),
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = 66 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 34;
                                this.emit('onTrainingProgress', {
                                    phase: 'prediction',
                                    progress: this.trainingProgress,
                                    loss: logs.loss
                                });
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Prediction model trained');
                }
                
                // Save models
                await this.saveModels();
                this.saveEmbeddings();
                
                this.isTraining = false;
                this.trainingProgress = 100;
                this.emit('onTrainingComplete', { categories: this.categories });
                
                console.log('✓ Training complete!');
                return true;
                
            } catch (error) {
                console.error('Training error:', error);
                this.isTraining = false;
                return false;
            }
        }

        // Online learning: immediate single-sample update from user feedback
        // This is fast (~50ms) and runs after each accept/modify/reject
        async learnFromFeedback(feedback) {
            // Only learn from category feedback for now
            if (feedback.type !== 'category') return false;

            // Need a trained category model
            if (!this.categoryModel || !this.encoder || this.categories.length < 2) {
                return false;
            }

            // Don't do online learning while batch training
            if (this.isTraining) return false;

            // Need both predicted and chosen categories
            const predicted = feedback.content?.predicted;
            const chosen = feedback.modification || predicted;
            const action = feedback.action;

            if (!predicted || !chosen) return false;

            // Find category indices
            const chosenIndex = this.categories.indexOf(chosen);
            if (chosenIndex === -1) {
                // Category not in our list - can't learn from this
                return false;
            }

            try {
                // Get the node text from context
                const nodeText = feedback.context?.nodeLabel || feedback.context?.nodeText;
                if (!nodeText) return false;

                console.log(`⚡ Online learning: ${action} (predicted: ${predicted}, chosen: ${chosen})`);

                // Get embedding for this text
                const embedding = await this.getEmbedding(nodeText);
                if (!embedding) return false;

                // Create one-hot target for the chosen category
                const target = new Array(this.categories.length).fill(0);
                target[chosenIndex] = 1;

                // Determine learning rate based on feedback type
                // Higher for rejections (strong signal), lower for accepts (reinforcement)
                const lrMultipliers = CONFIG.NEURAL_NET.onlineLearningRates;
                let onlineLearningRate;
                if (action === 'rejected') {
                    onlineLearningRate = CONFIG.NEURAL_NET.learningRate * lrMultipliers.rejected;
                } else if (action === 'modified') {
                    onlineLearningRate = CONFIG.NEURAL_NET.learningRate * lrMultipliers.modified;
                } else {
                    onlineLearningRate = CONFIG.NEURAL_NET.learningRate * lrMultipliers.accepted;
                }

                // Create tensors
                const xs = tf.tensor2d([embedding]);
                const ys = tf.tensor2d([target]);

                // Do a single training step with adjusted learning rate
                // We temporarily update the optimizer's learning rate
                const originalLR = this.categoryModel.optimizer.learningRate;

                // TensorFlow.js doesn't allow changing LR directly, so we do 1 epoch
                // with sample weight to simulate LR adjustment
                const sampleWeight = tf.tensor1d([onlineLearningRate / CONFIG.NEURAL_NET.learningRate]);

                await this.categoryModel.fit(xs, ys, {
                    epochs: 1,
                    batchSize: 1,
                    shuffle: false,
                    verbose: 0,
                    sampleWeight: sampleWeight
                });

                // Cleanup
                xs.dispose();
                ys.dispose();
                sampleWeight.dispose();

                console.log(`✓ Online learning complete (${action})`);

                // Emit event for UI feedback
                this.emit('onOnlineLearning', { action, predicted, chosen });

                return true;

            } catch (error) {
                console.error('Online learning error:', error);
                return false;
            }
        }

        // Predict the best category for new text
        async predictCategory(text) {
            if (!this.categoryModel || !this.encoder) return null;
            
            try {
                const embedding = await this.getEmbedding(text);
                if (!embedding) return null;
                
                const input = tf.tensor2d([embedding]);
                const prediction = this.categoryModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                // Get top predictions
                const results = this.categories.map((cat, i) => ({
                    category: cat,
                    confidence: probs[0][i]
                })).sort((a, b) => b.confidence - a.confidence);
                
                this.emit('onPrediction', { type: 'category', results });
                return results;
                
            } catch (error) {
                console.error('Category prediction error:', error);
                return null;
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // ACTIVE LEARNING: Route uncertain predictions to Claude
        // ═══════════════════════════════════════════════════════════════════
        // When the local model is uncertain, ask Claude for help
        // Claude's response becomes a teacher example for future training

        activeLearningStat = { routed: 0, local: 0 }

        async predictCategoryWithActiveLearning(text, store) {
            // First, get local model's prediction
            const localPredictions = await this.predictCategory(text);

            // If no local predictions, try Claude directly
            if (!localPredictions || localPredictions.length === 0) {
                console.log('🎯 Active Learning: No local predictions, routing to Claude');
                return await this.routeToClaudeForCategory(text, store, null);
            }

            const topPrediction = localPredictions[0];
            const confidence = topPrediction.confidence || topPrediction.probability || 0;
            const uncertaintyThreshold = CONFIG.NEURAL_NET.uncertaintyThreshold;

            // Check if we're uncertain
            if (confidence < uncertaintyThreshold) {
                console.log(`🎯 Active Learning: Low confidence (${Math.round(confidence * 100)}%), routing to Claude`);
                this.activeLearningStat.routed++;

                // Route to Claude for a better prediction
                const claudeResult = await this.routeToClaudeForCategory(text, store, localPredictions);

                if (claudeResult) {
                    return claudeResult;
                }

                // Fall back to local predictions if Claude fails
                console.log('🎯 Active Learning: Claude unavailable, using local predictions');
            } else {
                this.activeLearningStat.local++;
            }

            // High confidence or Claude unavailable - return local predictions
            // Map to consistent format
            return localPredictions.map(p => ({
                category: p.category,
                confidence: p.confidence || p.probability,
                source: 'local'
            }));
        }

        async routeToClaudeForCategory(text, store, localPredictions) {
            try {
                // Use enhanceWithClaude which already captures teacher knowledge
                const claudeResult = await this.enhanceWithClaude(text, store);

                if (claudeResult && claudeResult.category) {
                    // Build predictions array with Claude's result at top
                    const predictions = [{
                        category: claudeResult.category,
                        confidence: claudeResult.confidence || 0.85,
                        source: 'claude',
                        reasoning: claudeResult.reasoning
                    }];

                    // Add related concepts as alternatives
                    if (claudeResult.relatedConcepts) {
                        claudeResult.relatedConcepts.forEach((concept, i) => {
                            predictions.push({
                                category: concept,
                                confidence: 0.5 - (i * 0.1),
                                source: 'claude-related'
                            });
                        });
                    }

                    // Merge with local predictions (lower priority)
                    if (localPredictions) {
                        localPredictions.forEach(p => {
                            if (!predictions.find(pred => pred.category === p.category)) {
                                predictions.push({
                                    category: p.category,
                                    confidence: (p.confidence || p.probability) * 0.7, // Discount local
                                    source: 'local'
                                });
                            }
                        });
                    }

                    console.log(`🎯 Active Learning: Claude suggests "${claudeResult.category}" (${Math.round((claudeResult.confidence || 0.85) * 100)}%)`);
                    return predictions;
                }

                return null;

            } catch (error) {
                console.error('Active learning routing error:', error);
                return null;
            }
        }

        // Get active learning statistics
        getActiveLearningStats() {
            const total = this.activeLearningStat.routed + this.activeLearningStat.local;
            return {
                ...this.activeLearningStat,
                total,
                routingRate: total > 0 ? this.activeLearningStat.routed / total : 0
            };
        }

        // Find semantically similar nodes to a given text
        async findSimilarNodes(text, store, maxResults = 5) {
            if (!this.encoder) return [];
            
            try {
                const queryEmbedding = await this.getEmbedding(text);
                if (!queryEmbedding) return [];
                
                const allNodes = store.getAllNodes();
                const similarities = [];
                
                for (const node of allNodes) {
                    if (node.id === store.data.id) continue; // Skip root
                    
                    // Try to get cached embedding or compute new one
                    let nodeEmbedding = this.embeddings.get(node.label);
                    
                    if (!nodeEmbedding) {
                        // Check if we have embedding for label + description
                        const fullText = node.description 
                            ? `${node.label}: ${node.description}` 
                            : node.label;
                        nodeEmbedding = this.embeddings.get(fullText);
                    }
                    
                    // If we still don't have embedding, use the label's cached embedding
                    if (!nodeEmbedding) {
                        nodeEmbedding = this.embeddings.get(node.label.toLowerCase());
                    }
                    
                    if (nodeEmbedding) {
                        const similarity = this.cosineSimilarity(queryEmbedding, nodeEmbedding);
                        if (similarity > 0.2) { // Threshold for relevance
                            similarities.push({
                                nodeId: node.id,
                                label: node.label,
                                similarity: similarity
                            });
                        }
                    }
                }
                
                // Sort by similarity and return top results
                return similarities
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, maxResults);
                
            } catch (error) {
                console.error('Find similar nodes error:', error);
                return [];
            }
        }
        
        // Predict connection strength between two nodes
        async predictConnection(text1, text2) {
            if (!this.connectionModel || !this.encoder) return null;
            
            try {
                const [emb1, emb2] = await Promise.all([
                    this.getEmbedding(text1),
                    this.getEmbedding(text2)
                ]);
                
                if (!emb1 || !emb2) return null;
                
                const combined = [...emb1, ...emb2];
                const input = tf.tensor2d([combined]);
                const prediction = this.connectionModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                const result = {
                    shouldConnect: probs[0][0],
                    isParentChild: probs[0][1],
                    isSibling: probs[0][2],
                    isRelated: probs[0][3]
                };
                
                this.emit('onPrediction', { type: 'connection', result });
                return result;
                
            } catch (error) {
                console.error('Connection prediction error:', error);
                return null;
            }
        }
        
        // Find suggested connections for a node
        async suggestConnections(nodeText, store, maxSuggestions = 5) {
            if (!this.connectionModel) return [];
            
            const suggestions = [];
            const nodeEmbedding = await this.getEmbedding(nodeText);
            if (!nodeEmbedding) return [];
            
            // Get all nodes
            const allNodes = [];
            const collectNodes = (node, depth = 0) => {
                if (depth > 0) {
                    allNodes.push({
                        id: node.id,
                        label: node.label,
                        text: node.description ? `${node.label}. ${node.description}` : node.label
                    });
                }
                node.children?.forEach(child => collectNodes(child, depth + 1));
            };
            collectNodes(store.data);
            
            // Check connection with each node
            for (const other of allNodes) {
                const prediction = await this.predictConnection(nodeText, other.text);
                if (prediction && prediction.isRelated > 0.6) {
                    suggestions.push({
                        nodeId: other.id,
                        label: other.label,
                        ...prediction
                    });
                }
            }
            
            // Sort by relatedness and return top suggestions
            return suggestions
                .sort((a, b) => b.isRelated - a.isRelated)
                .slice(0, maxSuggestions);
        }
        
        // Predict likely children for a node using neural network + patterns
        async predictChildren(nodeText, existingChildren = [], maxSuggestions = 5) {
            const suggestions = [];
            
            // Method 1: Pattern-based suggestions with learned weights (fast)
            const normalizedLabel = this.normalizeLabel(nodeText);
            
            // Check for exact and partial pattern matches
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    children.forEach(child => {
                        const normalizedChild = this.normalizeLabel(child);
                        // Skip if already exists
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedChild)) {
                            // Get learned weight for this specific pattern
                            const patternWeight = this.getPatternWeight(pattern, child);
                            
                            const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedChild);
                            if (existing) {
                                existing.confidence += patternWeight * 0.4;
                                existing.sources.push('pattern');
                            } else {
                                suggestions.push({
                                    label: child,
                                    confidence: patternWeight,
                                    sources: ['pattern'],
                                    type: 'learned'
                                });
                            }
                        }
                    });
                }
            }
            
            // Method 2: Common pattern suggestions
            this.commonPatterns.forEach(pattern => {
                if (!existingChildren.some(e => this.normalizeLabel(e) === pattern)) {
                    const existing = suggestions.find(s => this.normalizeLabel(s.label) === pattern);
                    if (existing) {
                        existing.confidence += 0.1;
                        existing.sources.push('common');
                    } else {
                        suggestions.push({
                            label: pattern,
                            confidence: 0.3,
                            sources: ['common'],
                            type: 'common'
                        });
                    }
                }
            });
            
            // Method 2.5: Analogous patterns by relationship type (transfer learning)
            // If we have existing children, analyze what relationship types are established
            // and suggest patterns that follow the same structure from other domains
            if (existingChildren.length > 0 && suggestions.length < maxSuggestions) {
                try {
                    // Classify relationship type of first existing child
                    const sampleChild = existingChildren[0];
                    const classification = relationshipClassifier.classifyByHeuristics(nodeText, sampleChild);
                    
                    if (classification.type !== 'unknown' && classification.confidence >= 0.4) {
                        // Find patterns with same relationship type from other domains
                        const analogous = this.findAnalogousByType(classification.type, normalizedLabel, existingChildren);
                        
                        analogous.forEach(pattern => {
                            const normalizedChild = this.normalizeLabel(pattern.childLabel);
                            if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedChild)) {
                                const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedChild);
                                if (existing) {
                                    existing.confidence += pattern.transferScore * 0.3;
                                    existing.sources.push('analogous');
                                    existing.relationshipType = classification.type;
                                } else {
                                    suggestions.push({
                                        label: pattern.childLabel,
                                        confidence: pattern.transferScore,
                                        sources: ['analogous'],
                                        type: 'transfer',
                                        relationshipType: classification.type,
                                        analogousTo: pattern.fromParent
                                    });
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Analogous pattern error:', error);
                }
            }
            
            // Method 2.75: Concept abstraction - structural schema transfer
            // Find patterns from semantically similar parents (e.g., "Goals" ≈ "Projects")
            if (suggestions.length < maxSuggestions) {
                try {
                    // Get structural analogs based on abstract role
                    const structuralAnalogs = await conceptAbstractor.findStructuralAnalogs(
                        nodeText, 
                        existingChildren, 
                        Math.max(2, maxSuggestions - suggestions.length)
                    );
                    
                    for (const analog of structuralAnalogs) {
                        const normalizedAnalog = this.normalizeLabel(analog.label);
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedAnalog)) {
                            const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedAnalog);
                            if (existing) {
                                existing.confidence += analog.confidence * 0.25;
                                existing.sources.push('schema');
                            } else {
                                suggestions.push({
                                    label: analog.label,
                                    confidence: analog.confidence,
                                    sources: ['schema'],
                                    type: 'structural',
                                    schemaRole: analog.schemaRole,
                                    fromParent: analog.fromParent
                                });
                            }
                        }
                    }
                    
                    // Also get role-based suggestions (typical children for this type of parent)
                    const roleSuggestions = await conceptAbstractor.getSuggestionsByRole(
                        nodeText,
                        existingChildren,
                        2
                    );
                    
                    for (const suggestion of roleSuggestions) {
                        const normalizedSugg = this.normalizeLabel(suggestion.label);
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedSugg) &&
                            !suggestions.some(s => this.normalizeLabel(s.label) === normalizedSugg)) {
                            suggestions.push({
                                label: suggestion.label,
                                confidence: suggestion.confidence,
                                sources: ['role'],
                                type: 'role_typical',
                                role: suggestion.role
                            });
                        }
                    }
                } catch (error) {
                    console.error('Concept abstraction error:', error);
                }
            }
            
            // Method 3: Neural network prediction (find similar nodes)
            if (this.predictionModel && this.encoder) {
                try {
                    const parentEmbedding = await this.getEmbedding(nodeText);
                    if (parentEmbedding) {
                        // Predict the "expected child centroid"
                        const input = tf.tensor2d([parentEmbedding]);
                        const prediction = this.predictionModel.predict(input);
                        const predictedCentroid = await prediction.array();
                        
                        input.dispose();
                        prediction.dispose();
                        
                        // Find cached embeddings closest to the predicted centroid
                        const similarities = [];
                        for (const [text, embedding] of this.embeddings) {
                            const similarity = this.cosineSimilarity(predictedCentroid[0], embedding);
                            if (similarity > 0.5) {
                                similarities.push({ text, similarity });
                            }
                        }
                        
                        // Get top similar texts as suggestions
                        similarities
                            .sort((a, b) => b.similarity - a.similarity)
                            .slice(0, 5)
                            .forEach(s => {
                                const normalizedText = this.normalizeLabel(s.text);
                                if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedText)) {
                                    const existing = suggestions.find(sg => this.normalizeLabel(sg.label) === normalizedText);
                                    if (existing) {
                                        existing.confidence += s.similarity * 0.3;
                                        existing.sources.push('neural');
                                    } else {
                                        suggestions.push({
                                            label: s.text.split('.')[0], // Get just the label part
                                            confidence: s.similarity * 0.4,
                                            sources: ['neural'],
                                            type: 'neural'
                                        });
                                    }
                                }
                            });
                    }
                } catch (error) {
                    console.error('Neural prediction error:', error);
                }
            }
            
            // Sort by confidence and return top suggestions
            const results = suggestions
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, maxSuggestions)
                .map(s => ({
                    ...s,
                    confidence: Math.min(s.confidence, 1.0)
                }));
            
            this.emit('onSuggestion', { type: 'children', results });
            return results;
        }
        
        // Calculate cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (a.length !== b.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const denominator = Math.sqrt(normA) * Math.sqrt(normB);
            return denominator === 0 ? 0 : dotProduct / denominator;
        }
        
        // Get suggestions for a specific node (combines all methods)
        async getSuggestionsForNode(node, store) {
            const suggestions = {
                children: [],
                hasML: false,
                hasPatterns: false
            };
            
            if (!this.isReady) return suggestions;
            
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            const existingChildren = (node.children || []).map(c => c.label);
            
            // Get prediction-based suggestions
            const childSuggestions = await this.predictChildren(nodeText, existingChildren);
            
            if (childSuggestions.length > 0) {
                suggestions.children = childSuggestions;
                suggestions.hasML = childSuggestions.some(s => s.sources.includes('neural'));
                suggestions.hasPatterns = childSuggestions.some(s => 
                    s.sources.includes('pattern') || s.sources.includes('common')
                );
            }
            
            return suggestions;
        }
        
        // Check if a node has strong suggestions (for UI indicator)
        async hasStrongSuggestions(node) {
            if (!this.isReady || this.expansionPatterns.size === 0) return false;
            
            const normalizedLabel = this.normalizeLabel(node.label);
            const existingChildren = (node.children || []).map(c => this.normalizeLabel(c.label));
            
            // Quick check against patterns
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    // Check if there are un-added children
                    const newChildren = children.filter(c => 
                        !existingChildren.includes(this.normalizeLabel(c))
                    );
                    if (newChildren.length > 0) return true;
                }
            }
            
            return false;
        }
        
        // Generate AI-enhanced child suggestions using Claude
        async generateSmartSuggestions(node, store) {
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            // Get our ML predictions first
            const existingChildren = (node.children || []).map(c => c.label);
            const mlSuggestions = await this.predictChildren(nodeText, existingChildren, 2);
            
            // Get path context
            const path = store.getPath(node.id);
            const pathStr = path.map(n => n.label).join(' → ');
            const pathLabels = path.map(n => n.label);
            
            // Get user preference insights
            const preferenceInsights = preferenceTracker.getPromptInsights();
            
            // Get relevant semantic memories
            const memoryInsights = await semanticMemory.getPromptMemories(node.label, pathLabels, 3);
            
            // Get user profile insights
            const profileInsights = userProfile.getPromptInsights();
            
            // Analyze relationship types in existing structure
            let relationshipInsights = null;
            if (existingChildren.length > 0) {
                const typeCount = {};
                for (const child of existingChildren.slice(0, 5)) {
                    const classification = relationshipClassifier.classifyByHeuristics(node.label, child);
                    if (classification.type !== 'unknown' && classification.confidence >= 0.4) {
                        typeCount[classification.type] = (typeCount[classification.type] || 0) + 1;
                    }
                }
                
                const dominantTypes = Object.entries(typeCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2)
                    .map(([type]) => relationshipClassifier.getTypeDescription(type));
                
                if (dominantTypes.length > 0) {
                    relationshipInsights = `Current structure pattern: ${dominantTypes.join(', ')}`;
                }
            }
            
            // Get concept abstraction insights
            const conceptInsights = await conceptAbstractor.getPromptInsights(node.label, pathLabels);
            
            // Get meta-learner insights (how user thinks)
            const metaInsights = metaLearner.getPromptInsights();
            
            // Build semantic context string
            let semanticContext = '';
            if (mlSuggestions.length > 0) {
                semanticContext += `LEARNED PATTERNS suggest:\n${mlSuggestions.map(s => `- ${s.label} (${Math.round(s.confidence * 100)}% confidence)`).join('\n')}\n\n`;
            }
            if (relationshipInsights) semanticContext += `STRUCTURE: ${relationshipInsights}\n`;
            if (conceptInsights) semanticContext += `ABSTRACTION: ${conceptInsights}\n`;
            if (preferenceInsights) semanticContext += `USER PREFERENCES:\n${preferenceInsights}\n`;
            if (metaInsights) semanticContext += `THINKING STYLE:\n${metaInsights}\n`;
            if (memoryInsights) semanticContext += `RELEVANT MEMORIES:\n${memoryInsights}\n`;
            
            try {
                // Use unified Claude API helper (Edge Function when authenticated)
                const result = await callClaudeAPI({
                    type: 'smart-expand',
                    nodeLabel: node.label,
                    nodeDescription: node.description || '',
                    pathContext: pathStr,
                    existingChildren: existingChildren.join(', '),
                    userProfile: profileInsights ? { summary: profileInsights } : null,
                    semanticContext: semanticContext
                });
                
                if (result.success && result.suggestions) {
                    // Enforce max 4 suggestions
                    const suggestions = result.suggestions.slice(0, 4);

                    // Capture Claude's child predictions as teacher knowledge
                    if (typeof TeacherKnowledge !== 'undefined' && suggestions.length > 0) {
                        TeacherKnowledge.capture('children', nodeText, {
                            parentLabel: node.label,
                            children: suggestions.map(s => ({
                                label: s.label || s,
                                confidence: s.confidence || 0.8
                            })),
                            context: pathStr
                        });
                    }

                    return {
                        mlSuggestions,
                        aiSuggestions: suggestions,
                        combined: true
                    };
                }

                return { mlSuggestions, aiSuggestions: [], combined: false };
                
            } catch (error) {
                console.error('Smart suggestions error:', error);
                return { mlSuggestions, aiSuggestions: [], combined: false };
            }
        }
        
        // Use Claude to enhance predictions with semantic analysis
        async enhanceWithClaude(text, store) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) return null;
            
            try {
                // Get category predictions from our model first
                const categoryPredictions = await this.predictCategory(text);
                
                // Get current structure summary
                const categories = this.categories.join(', ');
                
                // Get feedback stats to adjust Claude's approach
                let feedbackGuidance = '';
                try {
                    const stats = AIFeedback.getStats('category');
                    if (stats && stats.total >= 3) {
                        const rate = Math.round(stats.acceptanceRate * 100);
                        if (rate < 40) {
                            feedbackGuidance = '\n\nNOTE: User often overrides category predictions. Focus on providing good alternatives rather than a single confident answer.';
                        } else if (rate >= 70) {
                            feedbackGuidance = '\n\nNOTE: User generally accepts category predictions. Be confident in your categorization.';
                        }
                    }
                } catch (e) {}
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `You are helping categorize content for a personal mind map.

EXISTING CATEGORIES: ${categories}

NEW CONTENT: "${text}"

${categoryPredictions ? `LOCAL MODEL PREDICTIONS (confidence scores):
${categoryPredictions.slice(0, 3).map(p => `- ${p.category}: ${(p.probability * 100).toFixed(1)}%`).join('\n')}` : ''}${feedbackGuidance}

Analyze this content and provide:
1. The best matching existing category (or suggest a new one if none fit)
2. Suggested parent node within that category
3. Related concepts that could be sibling nodes
4. A brief reasoning for your categorization

Return as JSON:
{
  "category": "Category Name",
  "confidence": 0.0-1.0,
  "suggestedParent": "Parent Node Name",
  "relatedConcepts": ["concept1", "concept2"],
  "reasoning": "Brief explanation"
}`
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                const text_response = data.content[0].text;

                // Parse JSON from response
                const jsonMatch = text_response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);

                    // Capture Claude's prediction as teacher knowledge for distillation
                    if (typeof TeacherKnowledge !== 'undefined' && result.category) {
                        TeacherKnowledge.capture('category', text, {
                            category: result.category,
                            confidence: result.confidence || 0.8,
                            reasoning: result.reasoning
                        });
                    }

                    return result;
                }

                return null;

            } catch (error) {
                console.error('Claude enhancement error:', error);
                return null;
            }
        }
        
        // Save models to IndexedDB (full precision, all models)
        async saveModels() {
            try {
                const modelData = {
                    version: 3, // Bump version for new format
                    savedAt: Date.now(),
                    categories: this.categories,
                    commonPatterns: this.commonPatterns,
                    expansionPatterns: Array.from(this.expansionPatterns.entries()),
                    patternWeights: Array.from(this.patternWeights.entries()) // Incremental learning weights
                };
                
                // Helper to extract weights from a model
                const extractWeights = async (model) => {
                    if (!model) return null;
                    const weights = [];
                    for (const layer of model.layers) {
                        const layerWeights = layer.getWeights();
                        const extracted = [];
                        for (const w of layerWeights) {
                            const data = await w.data();
                            extracted.push({
                                shape: w.shape,
                                data: Array.from(data) // Full precision
                            });
                        }
                        weights.push(extracted);
                    }
                    return weights;
                };
                
                // Save all models with full precision
                modelData.categoryWeights = await extractWeights(this.categoryModel);
                modelData.connectionWeights = await extractWeights(this.connectionModel);
                modelData.predictionWeights = await extractWeights(this.predictionModel);
                
                // Save to IndexedDB
                const success = await NeuralDB.save('neural-models', modelData);
                
                if (success) {
                    const sizeKB = JSON.stringify(modelData).length / 1024;
                    console.log(`✓ Models saved to IndexedDB (${sizeKB.toFixed(1)}KB) - all 3 models with full precision`);
                } else {
                    console.warn('⚠️ Failed to save models to IndexedDB');
                }
                
                // Also sync to Supabase if logged in (non-blocking)
                if (typeof SupabaseSync !== 'undefined' && SupabaseSync.syncEnabled) {
                    SupabaseSync.saveNeuralModels(this).catch(err => 
                        console.warn('Cloud sync of neural models failed:', err)
                    );
                }
                
                // Clean up old localStorage data if present
                try {
                    if (localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY)) {
                        localStorage.removeItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                        console.log('✓ Cleaned up old localStorage model data');
                    }
                } catch (e) {}
                
            } catch (error) {
                console.error('Failed to save models:', error);
            }
        }
        
        // Load models from IndexedDB (with cloud fallback)
        async loadModels() {
            try {
                // Try IndexedDB first
                let modelData = await NeuralDB.load('neural-models');
                let localSavedAt = modelData?.savedAt || 0;
                
                // Fallback to localStorage for migration
                if (!modelData) {
                    const saved = localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                    if (saved) {
                        console.log('📦 Migrating model data from localStorage to IndexedDB...');
                        modelData = JSON.parse(saved);
                        localSavedAt = modelData?.savedAt || 0;
                    }
                }
                
                // Check Supabase for newer data if logged in
                if (typeof SupabaseSync !== 'undefined' && SupabaseSync.syncEnabled) {
                    try {
                        const cloudData = await SupabaseSync.loadNeuralModels();
                        if (cloudData?.modelData) {
                            const cloudSavedAt = cloudData.modelData.savedAt || cloudData.updatedAt || 0;
                            
                            // Use cloud data if it's newer or if we have no local data
                            if (!modelData || cloudSavedAt > localSavedAt) {
                                console.log(`☁️ Using cloud neural models (cloud: ${new Date(cloudSavedAt).toLocaleString()}, local: ${localSavedAt ? new Date(localSavedAt).toLocaleString() : 'none'})`);
                                modelData = cloudData.modelData;
                            } else {
                                console.log(`💾 Using local neural models (local: ${new Date(localSavedAt).toLocaleString()}, cloud: ${new Date(cloudSavedAt).toLocaleString()})`);
                            }
                        }
                    } catch (cloudError) {
                        console.warn('Could not check cloud for neural models:', cloudError);
                    }
                }
                
                if (!modelData) return false;
                
                this.categories = modelData.categories || [];
                this.commonPatterns = modelData.commonPatterns || [];
                
                // Load expansion patterns
                if (modelData.expansionPatterns) {
                    this.expansionPatterns = new Map(modelData.expansionPatterns);
                    console.log(`✓ Loaded ${this.expansionPatterns.size} expansion patterns`);
                }
                
                // Load pattern weights (incremental learning data)
                if (modelData.patternWeights) {
                    this.patternWeights = new Map(modelData.patternWeights);
                    console.log(`✓ Loaded ${this.patternWeights.size} pattern weights`);
                }
                
                // Helper to restore weights to a model
                const restoreWeights = (model, savedWeights) => {
                    if (!model || !savedWeights) return false;
                    let layerIndex = 0;
                    for (const layer of model.layers) {
                        const layerWeights = savedWeights[layerIndex];
                        if (layerWeights && layerWeights.length > 0) {
                            const tensors = layerWeights.map(w => 
                                tf.tensor(w.data, w.shape)
                            );
                            layer.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                        }
                        layerIndex++;
                    }
                    return true;
                };
                
                // Restore category model
                if (modelData.categoryWeights && this.categories.length > 0) {
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    restoreWeights(this.categoryModel, modelData.categoryWeights);
                    console.log('✓ Category model loaded');
                }
                
                // Restore connection model
                if (modelData.connectionWeights) {
                    this.connectionModel = this.buildConnectionModel();
                    restoreWeights(this.connectionModel, modelData.connectionWeights);
                    console.log('✓ Connection model loaded');
                }
                
                // Restore prediction model
                if (modelData.predictionWeights) {
                    this.predictionModel = this.buildPredictionModel();
                    restoreWeights(this.predictionModel, modelData.predictionWeights);
                    console.log('✓ Prediction model loaded');
                }
                
                // If we migrated from localStorage, save to IndexedDB and clean up
                if (!modelData.version) {
                    console.log('📦 Saving migrated data to IndexedDB...');
                    await this.saveModels();
                }
                
                const savedAt = modelData.savedAt ? new Date(modelData.savedAt).toLocaleString() : 'unknown';
                console.log(`✓ Neural network restored (last saved: ${savedAt})`);
                
                return true;
                
            } catch (error) {
                console.error('Failed to load models:', error);
                return false;
            }
        }
        
        // Save embeddings cache to IndexedDB
        async saveEmbeddings() {
            try {
                const data = {};
                this.embeddings.forEach((value, key) => {
                    data[key] = value;
                });
                await NeuralDB.save('embeddings', data);
            } catch (error) {
                console.error('Failed to save embeddings:', error);
            }
        }
        
        // Load embeddings cache from IndexedDB
        async loadEmbeddings() {
            try {
                // Try IndexedDB first
                let data = await NeuralDB.load('embeddings');
                
                // Fallback to localStorage
                if (!data) {
                    const saved = localStorage.getItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
                    if (saved) {
                        data = JSON.parse(saved);
                    }
                }
                
                if (data) {
                    Object.keys(data).forEach(key => {
                        this.embeddings.set(key, data[key]);
                    });
                    console.log(`✓ Loaded ${this.embeddings.size} cached embeddings`);
                }
            } catch (error) {
                console.error('Failed to load embeddings:', error);
            }
        }
        
        // Get model statistics
        getStats() {
            const incrementalStats = this.getIncrementalStats();
            return {
                isReady: this.isReady,
                isTraining: this.isTraining,
                trainingProgress: this.trainingProgress,
                categories: this.categories,
                hasCategoryModel: !!this.categoryModel,
                hasConnectionModel: !!this.connectionModel,
                hasPredictionModel: !!this.predictionModel,
                expansionPatterns: this.expansionPatterns.size,
                commonPatterns: this.commonPatterns.length,
                cachedEmbeddings: this.embeddings.size,
                loadError: this.loadError || null,
                // Incremental learning stats
                patternWeights: this.patternWeights.size,
                highConfidencePatterns: incrementalStats.highConfidencePatterns,
                avgPatternWeight: incrementalStats.avgWeight,
                pendingEmbeddings: incrementalStats.pendingEmbeddings
            };
        }
        
        // Clear all learned data
        async reset() {
            if (this.categoryModel) {
                this.categoryModel.dispose();
                this.categoryModel = null;
            }
            if (this.connectionModel) {
                this.connectionModel.dispose();
                this.connectionModel = null;
            }
            if (this.predictionModel) {
                this.predictionModel.dispose();
                this.predictionModel = null;
            }
            this.categories = [];
            this.commonPatterns = [];
            this.expansionPatterns.clear();
            this.patternWeights.clear(); // Clear incremental learning weights
            this.embeddings.clear();
            this.pendingEmbeddings = [];
            
            // Clear IndexedDB
            await NeuralDB.delete('neural-models');
            await NeuralDB.delete('embeddings');
            
            // Clean up old localStorage entries
            try {
                localStorage.removeItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                localStorage.removeItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
            } catch (e) {}
            
            console.log('✓ Neural network reset (IndexedDB and localStorage cleared)');
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // COGNITIVE GRAPH TRANSFORMER (CGT) - Advanced Mind Learning System
    // ═══════════════════════════════════════════════════════════════════
    
    /**
     * CognitiveGNN - Graph Neural Network for learning structural thought patterns
     * 
     * This learns the TOPOLOGY of how you think, not just content.
     * - Node embeddings encode position in semantic space
     * - Message passing learns relationship patterns
     * - Structural roles classify nodes (category, action, entity, etc.)
     */
    class CognitiveGNN {
        constructor() {
            this.nodeEmbeddings = new Map(); // nodeId → Float32Array(64)
            this.structuralFeatures = new Map(); // nodeId → structural feature vector
            this.roleClassifications = new Map(); // nodeId → {role, confidence}
            
            // GNN hyperparameters
            this.embeddingDim = 64;
            this.hiddenDim = 128;
            this.messagePassingLayers = 3;
            this.aggregationType = 'attention'; // 'mean', 'max', 'attention'
            
            // Learned weights (initialized, trained incrementally)
            this.weights = {
                messageTransform: null,    // Transform neighbor messages
                nodeUpdate: null,          // Update node embeddings
                attentionQuery: null,      // Attention Q matrix
                attentionKey: null,        // Attention K matrix
                roleClassifier: null,      // Classify structural roles
                initialized: false
            };
            
            // Structural roles the network can identify
            this.structuralRoles = [
                'root',           // Top-level organizing concept
                'category',       // Classification container (has typed children)
                'action',         // Task or activity
                'entity',         // Person, place, thing
                'attribute',      // Property or descriptor
                'temporal',       // Time-based node
                'collection',     // Group of similar items
                'reference',      // Link to external content
                'abstract',       // High-level concept
                'concrete'        // Specific, detailed item
            ];
            
            // Training data buffer
            this.trainingBuffer = [];
            this.maxBufferSize = 1000;
            
            // Stats
            this.stats = {
                nodesProcessed: 0,
                messagesAggregated: 0,
                rolesClassified: 0,
                trainingIterations: 0
            };
        }
        
        // Initialize weight matrices
        async initialize() {
            if (this.weights.initialized) return;
            
            try {
                // Check if TensorFlow is loaded
                if (typeof tf === 'undefined') {
                    console.warn('CGT: TensorFlow not loaded, deferring initialization');
                    return false;
                }
                
                // Initialize weight matrices with Xavier/Glorot initialization
                const glorot = (rows, cols) => {
                    const stddev = Math.sqrt(2.0 / (rows + cols));
                    return tf.randomNormal([rows, cols], 0, stddev);
                };
                
                this.weights.messageTransform = tf.variable(glorot(this.embeddingDim, this.hiddenDim));
                this.weights.nodeUpdate = tf.variable(glorot(this.hiddenDim + this.embeddingDim, this.embeddingDim));
                this.weights.attentionQuery = tf.variable(glorot(this.embeddingDim, this.embeddingDim));
                this.weights.attentionKey = tf.variable(glorot(this.embeddingDim, this.embeddingDim));
                this.weights.roleClassifier = tf.variable(glorot(this.embeddingDim + 8, this.structuralRoles.length)); // +8 for structural features
                
                this.weights.initialized = true;
                console.log('✓ CognitiveGNN weights initialized');
                
                // Try to load saved weights
                await this.loadWeights();
                
                return true;
            } catch (e) {
                console.error('CGT initialization failed:', e);
                return false;
            }
        }
        
        /**
         * Extract structural features for a node
         * These are topology-based features that don't depend on content
         */
        extractStructuralFeatures(node, graph) {
            const features = new Float32Array(8);
            
            // 1. Normalized depth (0-1 scale, assuming max depth ~10)
            features[0] = Math.min((node.level || 0) / 10, 1);
            
            // 2. Child count (normalized, log scale)
            const childCount = node.children?.length || 0;
            features[1] = Math.min(Math.log2(childCount + 1) / 5, 1);
            
            // 3. Sibling count (normalized)
            const siblings = this.getSiblingCount(node, graph);
            features[2] = Math.min(Math.log2(siblings + 1) / 4, 1);
            
            // 4. Subtree size (total descendants, normalized)
            const subtreeSize = this.getSubtreeSize(node);
            features[3] = Math.min(Math.log2(subtreeSize + 1) / 8, 1);
            
            // 5. Is leaf (no children)
            features[4] = childCount === 0 ? 1 : 0;
            
            // 6. Branching factor variance (how uniform is child distribution)
            features[5] = this.getBranchingVariance(node);
            
            // 7. Has link/attachment (reference node indicator)
            features[6] = (node.link || node.attachments?.length > 0) ? 1 : 0;
            
            // 8. Label complexity (word count, normalized)
            const wordCount = (node.label || '').split(/\s+/).length;
            features[7] = Math.min(wordCount / 10, 1);
            
            return features;
        }
        
        getSiblingCount(node, graph) {
            if (!node.parent) return 0;
            const parent = typeof graph.findNode === 'function' ? 
                graph.findNode(node.parent.id || node.parent) : null;
            return parent?.children?.length - 1 || 0;
        }
        
        getSubtreeSize(node) {
            let size = 1;
            if (node.children) {
                for (const child of node.children) {
                    size += this.getSubtreeSize(child);
                }
            }
            return size;
        }
        
        getBranchingVariance(node) {
            if (!node.children || node.children.length < 2) return 0;
            
            const childCounts = node.children.map(c => c.children?.length || 0);
            const mean = childCounts.reduce((a, b) => a + b, 0) / childCounts.length;
            const variance = childCounts.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / childCounts.length;
            
            // Normalize variance
            return Math.min(Math.sqrt(variance) / 5, 1);
        }
        
        /**
         * Initialize node embedding from content + structure
         * Combines semantic embedding (from USE) with structural features
         */
        async initializeNodeEmbedding(node, semanticEmbedding = null) {
            // If we have a semantic embedding, use it as base
            let baseEmbedding;
            
            if (semanticEmbedding && semanticEmbedding.length >= this.embeddingDim) {
                // Project semantic embedding (512-dim) down to our dimension (64)
                baseEmbedding = new Float32Array(this.embeddingDim);
                for (let i = 0; i < this.embeddingDim; i++) {
                    // Simple projection: take every 8th element (512/64 = 8)
                    baseEmbedding[i] = semanticEmbedding[i * 8] || 0;
                }
            } else {
                // Initialize from label hash + random
                baseEmbedding = new Float32Array(this.embeddingDim);
                const label = node.label || '';
                let hash = 0;
                for (let i = 0; i < label.length; i++) {
                    hash = ((hash << 5) - hash) + label.charCodeAt(i);
                    hash = hash & hash;
                }
                
                // Seeded pseudo-random initialization
                const seededRandom = (seed) => {
                    const x = Math.sin(seed) * 10000;
                    return x - Math.floor(x);
                };
                
                for (let i = 0; i < this.embeddingDim; i++) {
                    baseEmbedding[i] = (seededRandom(hash + i) - 0.5) * 0.1;
                }
            }
            
            this.nodeEmbeddings.set(node.id, baseEmbedding);
            return baseEmbedding;
        }
        
        /**
         * Message Passing - Core GNN operation
         * Each node aggregates information from its neighbors
         */
        async propagate(graph, iterations = null) {
            // Skip if TensorFlow not loaded
            if (typeof tf === 'undefined') {
                return;
            }
            
            if (!this.weights.initialized) {
                await this.initialize();
                if (!this.weights.initialized) return;
            }
            
            iterations = iterations || this.messagePassingLayers;
            const allNodes = this.collectAllNodes(graph);
            
            // Ensure all nodes have initial embeddings
            for (const node of allNodes) {
                if (!this.nodeEmbeddings.has(node.id)) {
                    await this.initializeNodeEmbedding(node);
                }
                
                // Also compute structural features
                if (!this.structuralFeatures.has(node.id)) {
                    this.structuralFeatures.set(node.id, this.extractStructuralFeatures(node, graph));
                }
            }
            
            // Build adjacency info
            const adjacency = this.buildAdjacency(allNodes);
            
            // Message passing iterations
            for (let iter = 0; iter < iterations; iter++) {
                const newEmbeddings = new Map();
                
                for (const node of allNodes) {
                    const neighbors = adjacency.get(node.id) || [];
                    
                    if (neighbors.length === 0) {
                        // No neighbors - keep current embedding
                        newEmbeddings.set(node.id, this.nodeEmbeddings.get(node.id));
                        continue;
                    }
                    
                    // Compute messages from all neighbors
                    const messages = [];
                    for (const neighborId of neighbors) {
                        const neighborEmb = this.nodeEmbeddings.get(neighborId);
                        if (neighborEmb) {
                            messages.push(this.computeMessage(neighborEmb));
                        }
                    }
                    
                    if (messages.length === 0) {
                        newEmbeddings.set(node.id, this.nodeEmbeddings.get(node.id));
                        continue;
                    }
                    
                    // Aggregate messages
                    const aggregated = this.aggregateMessages(messages, node.id);
                    
                    // Update node embedding
                    const currentEmb = this.nodeEmbeddings.get(node.id);
                    const updatedEmb = this.updateEmbedding(currentEmb, aggregated);
                    newEmbeddings.set(node.id, updatedEmb);
                    
                    this.stats.messagesAggregated += messages.length;
                }
                
                // Apply new embeddings
                for (const [id, emb] of newEmbeddings) {
                    this.nodeEmbeddings.set(id, emb);
                }
            }
            
            this.stats.nodesProcessed += allNodes.length;
        }
        
        collectAllNodes(graph) {
            const nodes = [];
            const traverse = (node) => {
                nodes.push(node);
                if (node.children) {
                    for (const child of node.children) {
                        traverse(child);
                    }
                }
            };
            
            if (graph.data) {
                traverse(graph.data);
            } else if (graph.id) {
                traverse(graph);
            }
            
            return nodes;
        }
        
        buildAdjacency(nodes) {
            const adj = new Map();
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            for (const node of nodes) {
                const neighbors = new Set();
                
                // Parent is a neighbor
                if (node.parent) {
                    const parentId = typeof node.parent === 'string' ? node.parent : node.parent.id;
                    if (parentId) neighbors.add(parentId);
                }
                
                // Children are neighbors
                if (node.children) {
                    for (const child of node.children) {
                        neighbors.add(child.id);
                    }
                }
                
                // Siblings are weak neighbors (for lateral connections)
                // We'll add these with lower weight later
                
                adj.set(node.id, Array.from(neighbors));
            }
            
            return adj;
        }
        
        /**
         * Compute message from neighbor embedding
         * Transforms neighbor info into a message
         */
        computeMessage(neighborEmbedding) {
            if (!this.weights.initialized || typeof tf === 'undefined') {
                return neighborEmbedding; // Pass through if not initialized
            }
            
            // Use TensorFlow for matrix multiplication
            return tf.tidy(() => {
                const embTensor = tf.tensor2d([Array.from(neighborEmbedding)]);
                const transformed = tf.matMul(embTensor, this.weights.messageTransform);
                return new Float32Array(transformed.dataSync());
            });
        }
        
        /**
         * Aggregate messages from all neighbors
         * Uses attention mechanism to weight different neighbors
         */
        aggregateMessages(messages, nodeId) {
            if (messages.length === 0) return new Float32Array(this.hiddenDim);
            
            if (this.aggregationType === 'mean') {
                // Simple mean aggregation
                const result = new Float32Array(messages[0].length);
                for (const msg of messages) {
                    for (let i = 0; i < msg.length; i++) {
                        result[i] += msg[i] / messages.length;
                    }
                }
                return result;
            } else if (this.aggregationType === 'max') {
                // Max pooling
                const result = new Float32Array(messages[0].length).fill(-Infinity);
                for (const msg of messages) {
                    for (let i = 0; i < msg.length; i++) {
                        result[i] = Math.max(result[i], msg[i]);
                    }
                }
                return result;
            } else {
                // Attention-weighted aggregation
                return this.attentionAggregate(messages, nodeId);
            }
        }
        
        attentionAggregate(messages, nodeId) {
            if (!this.weights.initialized || messages.length === 0 || typeof tf === 'undefined') {
                // Fallback to mean
                if (messages.length === 0) return new Float32Array(this.hiddenDim);
                const result = new Float32Array(messages[0].length);
                for (const msg of messages) {
                    for (let i = 0; i < msg.length; i++) {
                        result[i] += msg[i] / messages.length;
                    }
                }
                return result;
            }
            
            return tf.tidy(() => {
                const nodeEmb = this.nodeEmbeddings.get(nodeId);
                if (!nodeEmb) {
                    // Fallback
                    const result = new Float32Array(messages[0].length);
                    for (const msg of messages) {
                        for (let i = 0; i < msg.length; i++) {
                            result[i] += msg[i] / messages.length;
                        }
                    }
                    return result;
                }
                
                // Compute query from node embedding
                const query = tf.matMul(
                    tf.tensor2d([Array.from(nodeEmb)]), 
                    this.weights.attentionQuery
                );
                
                // Compute keys from messages (project back to embedding dim for attention)
                // Since messages are hiddenDim, we need to handle dimension mismatch
                // For simplicity, use mean of message as attention score base
                const scores = messages.map((msg, i) => {
                    const msgSum = msg.reduce((a, b) => a + b, 0);
                    const nodeSum = nodeEmb.reduce((a, b) => a + b, 0);
                    return msgSum * nodeSum; // Simple dot-product-like score
                });
                
                // Softmax
                const maxScore = Math.max(...scores);
                const expScores = scores.map(s => Math.exp(s - maxScore));
                const sumExp = expScores.reduce((a, b) => a + b, 0);
                const weights = expScores.map(e => e / sumExp);
                
                // Weighted sum
                const result = new Float32Array(messages[0].length);
                for (let i = 0; i < messages.length; i++) {
                    for (let j = 0; j < messages[i].length; j++) {
                        result[j] += messages[i][j] * weights[i];
                    }
                }
                
                return result;
            });
        }
        
        /**
         * Update node embedding with aggregated message
         */
        updateEmbedding(currentEmbedding, aggregatedMessage) {
            if (!this.weights.initialized || typeof tf === 'undefined') {
                return currentEmbedding;
            }
            
            return tf.tidy(() => {
                // Concatenate current embedding with aggregated message
                const combined = new Float32Array(this.embeddingDim + this.hiddenDim);
                combined.set(currentEmbedding, 0);
                combined.set(aggregatedMessage, this.embeddingDim);
                
                // Transform through update layer
                const combinedTensor = tf.tensor2d([Array.from(combined)]);
                const updated = tf.matMul(combinedTensor, this.weights.nodeUpdate);
                
                // Apply tanh activation
                const activated = tf.tanh(updated);
                
                // Residual connection: blend with original
                const residual = tf.tensor2d([Array.from(currentEmbedding)]);
                const output = tf.add(tf.mul(activated, 0.5), tf.mul(residual, 0.5));
                
                return new Float32Array(output.dataSync());
            });
        }
        
        /**
         * Classify the structural role of a node
         * Uses embedding + structural features to predict role
         */
        async classifyRole(node, graph) {
            // Skip if TensorFlow not loaded
            if (typeof tf === 'undefined') {
                return { role: 'unknown', confidence: 0, allScores: {} };
            }
            
            if (!this.weights.initialized) {
                await this.initialize();
            }
            
            const embedding = this.nodeEmbeddings.get(node.id);
            if (!embedding) {
                await this.initializeNodeEmbedding(node);
            }
            
            const structFeatures = this.structuralFeatures.get(node.id) || 
                this.extractStructuralFeatures(node, graph);
            
            // Combine embedding with structural features
            const combined = new Float32Array(this.embeddingDim + 8);
            combined.set(embedding || new Float32Array(this.embeddingDim), 0);
            combined.set(structFeatures, this.embeddingDim);
            
            // Classify
            const roleScores = tf.tidy(() => {
                const input = tf.tensor2d([Array.from(combined)]);
                const logits = tf.matMul(input, this.weights.roleClassifier);
                const probs = tf.softmax(logits);
                return Array.from(probs.dataSync());
            });
            
            // Find best role
            let bestRole = this.structuralRoles[0];
            let bestScore = roleScores[0];
            
            for (let i = 1; i < roleScores.length; i++) {
                if (roleScores[i] > bestScore) {
                    bestScore = roleScores[i];
                    bestRole = this.structuralRoles[i];
                }
            }
            
            const result = {
                role: bestRole,
                confidence: bestScore,
                allScores: Object.fromEntries(
                    this.structuralRoles.map((r, i) => [r, roleScores[i]])
                )
            };
            
            this.roleClassifications.set(node.id, result);
            this.stats.rolesClassified++;
            
            return result;
        }
        
        /**
         * Find structural holes - places where connections SHOULD exist
         * Based on embedding similarity without actual connection
         */
        async findStructuralHoles(graph, threshold = 0.7) {
            const allNodes = this.collectAllNodes(graph);
            const adjacency = this.buildAdjacency(allNodes);
            
            // Collect nodes with embeddings
            const nodesWithEmbeddings = [];
            const embeddings = [];
            
            for (const node of allNodes) {
                const emb = this.nodeEmbeddings.get(node.id);
                if (emb) {
                    nodesWithEmbeddings.push(node);
                    embeddings.push(Array.from(emb));
                }
            }
            
            if (embeddings.length < 2) return [];
            
            // Use GPU compute if available, otherwise CPU
            let pairs;
            if (typeof gpuCompute !== 'undefined' && gpuCompute.supported) {
                pairs = await gpuCompute.allPairsSimilarity(embeddings);
            } else {
                // CPU fallback
                pairs = [];
                for (let i = 0; i < embeddings.length; i++) {
                    for (let j = i + 1; j < embeddings.length; j++) {
                        const similarity = this.cosineSimilarity(embeddings[i], embeddings[j]);
                        if (similarity > 0) {
                            pairs.push({ i, j, similarity });
                        }
                    }
                }
            }
            
            // Filter by threshold and adjacency
            const holes = [];
            for (const pair of pairs) {
                if (pair.similarity < threshold) continue;
                
                const nodeA = nodesWithEmbeddings[pair.i];
                const nodeB = nodesWithEmbeddings[pair.j];
                
                // Skip if already connected
                const neighborsA = new Set(adjacency.get(nodeA.id) || []);
                if (neighborsA.has(nodeB.id)) continue;
                
                holes.push({
                    nodeA: { id: nodeA.id, label: nodeA.label },
                    nodeB: { id: nodeB.id, label: nodeB.label },
                    similarity: pair.similarity,
                    reason: `High semantic similarity (${(pair.similarity * 100).toFixed(0)}%) but no connection`
                });
            }
            
            // Sort by similarity (highest first)
            holes.sort((a, b) => b.similarity - a.similarity);
            
            return holes.slice(0, 10); // Return top 10
        }
        
        // Sync version for backward compatibility
        findStructuralHolesSync(graph, threshold = 0.7) {
            const holes = [];
            const allNodes = this.collectAllNodes(graph);
            const adjacency = this.buildAdjacency(allNodes);
            
            // Compare all pairs of non-adjacent nodes
            for (let i = 0; i < allNodes.length; i++) {
                const nodeA = allNodes[i];
                const embA = this.nodeEmbeddings.get(nodeA.id);
                if (!embA) continue;
                
                const neighborsA = new Set(adjacency.get(nodeA.id) || []);
                
                for (let j = i + 1; j < allNodes.length; j++) {
                    const nodeB = allNodes[j];
                    
                    // Skip if already connected
                    if (neighborsA.has(nodeB.id)) continue;
                    
                    const embB = this.nodeEmbeddings.get(nodeB.id);
                    if (!embB) continue;
                    
                    // Compute cosine similarity
                    const similarity = this.cosineSimilarity(embA, embB);
                    
                    if (similarity > threshold) {
                        holes.push({
                            nodeA: { id: nodeA.id, label: nodeA.label },
                            nodeB: { id: nodeB.id, label: nodeB.label },
                            similarity: similarity,
                            reason: `High semantic similarity (${(similarity * 100).toFixed(0)}%) but no connection`
                        });
                    }
                }
            }
            
            // Sort by similarity (highest first)
            holes.sort((a, b) => b.similarity - a.similarity);
            
            return holes.slice(0, 10); // Return top 10
        }
        
        cosineSimilarity(a, b) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude > 0 ? dotProduct / magnitude : 0;
        }
        
        /**
         * Save weights to IndexedDB
         */
        async saveWeights() {
            if (!this.weights.initialized) return;
            
            try {
                const weightData = {
                    messageTransform: Array.from(this.weights.messageTransform.dataSync()),
                    nodeUpdate: Array.from(this.weights.nodeUpdate.dataSync()),
                    attentionQuery: Array.from(this.weights.attentionQuery.dataSync()),
                    attentionKey: Array.from(this.weights.attentionKey.dataSync()),
                    roleClassifier: Array.from(this.weights.roleClassifier.dataSync()),
                    shapes: {
                        messageTransform: this.weights.messageTransform.shape,
                        nodeUpdate: this.weights.nodeUpdate.shape,
                        attentionQuery: this.weights.attentionQuery.shape,
                        attentionKey: this.weights.attentionKey.shape,
                        roleClassifier: this.weights.roleClassifier.shape
                    },
                    stats: this.stats
                };
                
                await NeuralDB.save('cognitive-gnn-weights', weightData);
                console.log('✓ CognitiveGNN weights saved');
            } catch (e) {
                console.error('Failed to save GNN weights:', e);
            }
        }
        
        /**
         * Load weights from IndexedDB
         */
        async loadWeights() {
            try {
                const saved = await NeuralDB.load('cognitive-gnn-weights');
                if (!saved) return false;
                
                // Restore weight tensors
                this.weights.messageTransform = tf.variable(
                    tf.tensor2d(saved.messageTransform, saved.shapes.messageTransform)
                );
                this.weights.nodeUpdate = tf.variable(
                    tf.tensor2d(saved.nodeUpdate, saved.shapes.nodeUpdate)
                );
                this.weights.attentionQuery = tf.variable(
                    tf.tensor2d(saved.attentionQuery, saved.shapes.attentionQuery)
                );
                this.weights.attentionKey = tf.variable(
                    tf.tensor2d(saved.attentionKey, saved.shapes.attentionKey)
                );
                this.weights.roleClassifier = tf.variable(
                    tf.tensor2d(saved.roleClassifier, saved.shapes.roleClassifier)
                );
                
                if (saved.stats) {
                    this.stats = saved.stats;
                }
                
                console.log('✓ CognitiveGNN weights loaded');
                return true;
            } catch (e) {
                console.error('Failed to load GNN weights:', e);
                return false;
            }
        }
        
        /**
         * Get embedding for a node
         */
        getEmbedding(nodeId) {
            return this.nodeEmbeddings.get(nodeId);
        }
        
        /**
         * Get all embeddings for export
         */
        getExportData() {
            const embeddings = {};
            this.nodeEmbeddings.forEach((emb, id) => {
                embeddings[id] = Array.from(emb);
            });
            
            const features = {};
            this.structuralFeatures.forEach((feat, id) => {
                features[id] = Array.from(feat);
            });
            
            const roles = {};
            this.roleClassifications.forEach((role, id) => {
                roles[id] = role;
            });
            
            return { embeddings, features, roles, stats: this.stats };
        }
        
        /**
         * Import embeddings from saved data
         */
        importData(data) {
            if (data.embeddings) {
                for (const [id, arr] of Object.entries(data.embeddings)) {
                    this.nodeEmbeddings.set(id, new Float32Array(arr));
                }
            }
            if (data.features) {
                for (const [id, arr] of Object.entries(data.features)) {
                    this.structuralFeatures.set(id, new Float32Array(arr));
                }
            }
            if (data.roles) {
                for (const [id, role] of Object.entries(data.roles)) {
                    this.roleClassifications.set(id, role);
                }
            }
            if (data.stats) {
                this.stats = { ...this.stats, ...data.stats };
            }
        }
    }
    
    /**
     * ActionSequenceEncoder - Learns temporal patterns of user behavior
     * Encodes sequences of actions to understand HOW you work
     */
    class ActionSequenceEncoder {
        constructor() {
            // Action vocabulary
            this.actionTypes = [
                'create',      // Created new node
                'expand',      // Expanded a node
                'collapse',    // Collapsed a node
                'select',      // Selected a node
                'edit_label',  // Edited node label
                'edit_desc',   // Edited description
                'delete',      // Deleted node
                'reparent',    // Moved node to new parent
                'reorder',     // Reordered siblings
                'navigate_up', // Navigated to parent
                'navigate_down', // Navigated to child
                'navigate_sibling', // Navigated to sibling
                'ai_expand',   // Used AI expand
                'ai_brainstorm', // Used AI brainstorm
                'search',      // Searched
                'attach',      // Added attachment
                'link',        // Added link
                'undo',        // Undo action
                'dive',        // Dive into context
                'surface'      // Surface from context
            ];
            
            this.actionHistory = []; // Last N actions
            this.maxHistorySize = 500;
            
            // Encoded action embeddings (learned)
            this.actionEmbeddings = new Map(); // actionType → Float32Array(32)
            this.embeddingDim = 32;
            
            // Temporal features
            this.sessionBoundaries = []; // Timestamps where sessions start
            this.sessionTimeout = 30 * 60 * 1000; // 30 minutes
            
            // Pattern stats
            this.patternCounts = new Map(); // "action1→action2" → count
            this.burstPatterns = []; // Sequences of rapid actions
            
            // Initialize action embeddings
            this.initializeEmbeddings();
        }
        
        initializeEmbeddings() {
            // Initialize each action type with a unique embedding
            for (let i = 0; i < this.actionTypes.length; i++) {
                const embedding = new Float32Array(this.embeddingDim);
                
                // One-hot base + random variation
                const baseIndex = i % this.embeddingDim;
                embedding[baseIndex] = 1.0;
                
                // Add some random variation
                for (let j = 0; j < this.embeddingDim; j++) {
                    embedding[j] += (Math.random() - 0.5) * 0.1;
                }
                
                this.actionEmbeddings.set(this.actionTypes[i], embedding);
            }
        }
        
        /**
         * Record an action
         */
        recordAction(actionType, nodeId, metadata = {}) {
            const timestamp = Date.now();
            
            // Check for session boundary
            const lastAction = this.actionHistory[this.actionHistory.length - 1];
            if (lastAction && timestamp - lastAction.timestamp > this.sessionTimeout) {
                this.sessionBoundaries.push(timestamp);
            }
            
            const action = {
                type: actionType,
                nodeId,
                timestamp,
                timeSinceLast: lastAction ? timestamp - lastAction.timestamp : 0,
                hourOfDay: new Date().getHours(),
                dayOfWeek: new Date().getDay(),
                ...metadata
            };
            
            this.actionHistory.push(action);
            
            // Trim history
            if (this.actionHistory.length > this.maxHistorySize) {
                this.actionHistory = this.actionHistory.slice(-this.maxHistorySize);
            }
            
            // Update transition patterns
            if (lastAction) {
                const pattern = `${lastAction.type}→${actionType}`;
                this.patternCounts.set(pattern, (this.patternCounts.get(pattern) || 0) + 1);
            }
            
            // Detect bursts (rapid sequences)
            this.detectBursts();
            
            return action;
        }
        
        /**
         * Detect burst patterns (rapid action sequences)
         */
        detectBursts() {
            const burstThreshold = 2000; // 2 seconds between actions
            const minBurstLength = 3;
            
            let currentBurst = [];
            
            for (let i = 1; i < this.actionHistory.length; i++) {
                const action = this.actionHistory[i];
                
                if (action.timeSinceLast < burstThreshold) {
                    if (currentBurst.length === 0) {
                        currentBurst.push(this.actionHistory[i - 1]);
                    }
                    currentBurst.push(action);
                } else {
                    if (currentBurst.length >= minBurstLength) {
                        this.burstPatterns.push({
                            actions: currentBurst.map(a => a.type),
                            startTime: currentBurst[0].timestamp,
                            duration: currentBurst[currentBurst.length - 1].timestamp - currentBurst[0].timestamp
                        });
                    }
                    currentBurst = [];
                }
            }
            
            // Keep only recent bursts
            const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
            this.burstPatterns = this.burstPatterns.filter(b => b.startTime > oneDayAgo);
        }
        
        /**
         * Encode an action into a vector
         */
        encodeAction(action) {
            const baseEmbedding = this.actionEmbeddings.get(action.type) || 
                new Float32Array(this.embeddingDim);
            
            // Add temporal features
            const encoded = new Float32Array(this.embeddingDim + 8);
            encoded.set(baseEmbedding, 0);
            
            // Temporal features
            encoded[this.embeddingDim] = Math.min(action.timeSinceLast / 10000, 1); // Normalized time gap
            encoded[this.embeddingDim + 1] = action.hourOfDay / 24; // Hour of day
            encoded[this.embeddingDim + 2] = action.dayOfWeek / 7; // Day of week
            encoded[this.embeddingDim + 3] = action.nodeDepth ? Math.min(action.nodeDepth / 10, 1) : 0;
            
            // Is this a burst action?
            encoded[this.embeddingDim + 4] = action.timeSinceLast < 2000 ? 1 : 0;
            
            // Session position (how far into session)
            const sessionStart = this.getSessionStart(action.timestamp);
            const sessionDuration = action.timestamp - sessionStart;
            encoded[this.embeddingDim + 5] = Math.min(sessionDuration / (60 * 60 * 1000), 1); // Max 1 hour
            
            return encoded;
        }
        
        getSessionStart(timestamp) {
            for (let i = this.sessionBoundaries.length - 1; i >= 0; i--) {
                if (this.sessionBoundaries[i] <= timestamp) {
                    return this.sessionBoundaries[i];
                }
            }
            return this.actionHistory[0]?.timestamp || timestamp;
        }
        
        /**
         * Get recent action sequence encoded
         */
        getRecentSequence(n = 20) {
            const recent = this.actionHistory.slice(-n);
            return recent.map(a => this.encodeAction(a));
        }
        
        /**
         * Predict likely next action based on patterns
         */
        predictNextAction() {
            if (this.actionHistory.length === 0) return null;
            
            const lastAction = this.actionHistory[this.actionHistory.length - 1];
            const predictions = [];
            
            // Find all transitions from current action type
            for (const [pattern, count] of this.patternCounts) {
                if (pattern.startsWith(lastAction.type + '→')) {
                    const nextAction = pattern.split('→')[1];
                    predictions.push({ action: nextAction, count });
                }
            }
            
            // Sort by count
            predictions.sort((a, b) => b.count - a.count);
            
            // Compute probabilities
            const total = predictions.reduce((sum, p) => sum + p.count, 0);
            
            return predictions.slice(0, 5).map(p => ({
                action: p.action,
                probability: p.count / total
            }));
        }
        
        /**
         * Detect cognitive state from recent actions
         */
        detectCognitiveState() {
            const recent = this.actionHistory.slice(-30);
            if (recent.length < 5) return { state: 'unknown', confidence: 0 };
            
            // Compute metrics
            const actionCounts = {};
            let totalTime = 0;
            let depthSum = 0;
            let depthCount = 0;
            
            for (const action of recent) {
                actionCounts[action.type] = (actionCounts[action.type] || 0) + 1;
                totalTime += action.timeSinceLast;
                if (action.nodeDepth !== undefined) {
                    depthSum += action.nodeDepth;
                    depthCount++;
                }
            }
            
            const avgTimeBetween = totalTime / recent.length;
            const avgDepth = depthCount > 0 ? depthSum / depthCount : 0;
            
            // Classify state
            const selectCount = actionCounts['select'] || 0;
            const createCount = actionCounts['create'] || 0;
            const editCount = (actionCounts['edit_label'] || 0) + (actionCounts['edit_desc'] || 0);
            const expandCount = actionCounts['expand'] || 0;
            const navigateCount = (actionCounts['navigate_up'] || 0) + 
                                  (actionCounts['navigate_down'] || 0) + 
                                  (actionCounts['navigate_sibling'] || 0);
            
            // Decision tree for cognitive state
            if (avgTimeBetween > 10000) {
                return {
                    state: 'contemplative',
                    confidence: 0.7,
                    indicators: ['Long pauses between actions'],
                    suggestion: 'You seem to be thinking deeply. Would a brainstorm help?'
                };
            }
            
            if (navigateCount > recent.length * 0.5) {
                return {
                    state: 'exploratory-searching',
                    confidence: 0.8,
                    indicators: ['High navigation rate', 'Low creation'],
                    suggestion: 'Looking for something? Try the search feature.'
                };
            }
            
            if (createCount > recent.length * 0.4 && avgDepth < 3) {
                return {
                    state: 'divergent-brainstorming',
                    confidence: 0.75,
                    indicators: ['Rapid creation', 'Shallow depth'],
                    suggestion: 'Great brainstorming flow! Consider going deeper on key ideas.'
                };
            }
            
            if (createCount > recent.length * 0.3 && avgDepth > 4) {
                return {
                    state: 'convergent-detailing',
                    confidence: 0.8,
                    indicators: ['Creation at depth', 'Focused branch'],
                    suggestion: 'Deep focus mode. All systems optimal.'
                };
            }
            
            if (editCount > recent.length * 0.4) {
                return {
                    state: 'refinement',
                    confidence: 0.75,
                    indicators: ['High edit rate', 'Polishing content'],
                    suggestion: 'Refinement mode. Looking good!'
                };
            }
            
            if (selectCount > recent.length * 0.6 && createCount < 2) {
                return {
                    state: 'review',
                    confidence: 0.7,
                    indicators: ['Browsing without creating'],
                    suggestion: 'Reviewing your map. See anything that needs attention?'
                };
            }
            
            return {
                state: 'mixed-productive',
                confidence: 0.6,
                indicators: ['Balanced activity'],
                suggestion: 'Productive session in progress.'
            };
        }
        
        /**
         * Export data
         */
        getExportData() {
            return {
                history: this.actionHistory.slice(-200), // Last 200 actions
                patterns: Object.fromEntries(this.patternCounts),
                bursts: this.burstPatterns.slice(-50),
                sessionBoundaries: this.sessionBoundaries.slice(-20)
            };
        }
        
        /**
         * Import data
         */
        importData(data) {
            if (data.history) {
                this.actionHistory = data.history;
            }
            if (data.patterns) {
                this.patternCounts = new Map(Object.entries(data.patterns));
            }
            if (data.bursts) {
                this.burstPatterns = data.bursts;
            }
            if (data.sessionBoundaries) {
                this.sessionBoundaries = data.sessionBoundaries;
            }
        }
    }
    
    /**
     * TrajectoryPredictor - Predicts sequences of likely future actions/nodes
     * The "wow" feature that predicts where your thinking is going
     */
    class TrajectoryPredictor {
        constructor(gnn, actionEncoder) {
            this.gnn = gnn;
            this.actionEncoder = actionEncoder;
            
            // Learned trajectory patterns
            this.trajectoryPatterns = new Map(); // startContext → [trajectories]
            
            // Prediction cache
            this.predictionCache = new Map();
            this.cacheTimeout = 30000; // 30 seconds
        }
        
        /**
         * Predict likely trajectory from current state
         */
        async predictTrajectory(currentNodeId, graph, steps = 5) {
            const cacheKey = `${currentNodeId}-${steps}`;
            const cached = this.predictionCache.get(cacheKey);
            if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.prediction;
            }
            
            const trajectory = [];
            let currentId = currentNodeId;
            let confidence = 1.0;
            
            for (let i = 0; i < steps; i++) {
                const prediction = await this.predictNextStep(currentId, graph, trajectory);
                
                if (!prediction || prediction.confidence < 0.2) break;
                
                confidence *= prediction.confidence;
                trajectory.push({
                    ...prediction,
                    cumulativeConfidence: confidence
                });
                
                // Update current for next iteration
                if (prediction.type === 'create_child') {
                    // Simulated new node
                    currentId = `predicted-${i}`;
                } else if (prediction.nodeId) {
                    currentId = prediction.nodeId;
                }
            }
            
            const result = { trajectory, startNodeId: currentNodeId };
            this.predictionCache.set(cacheKey, { prediction: result, timestamp: Date.now() });
            
            return result;
        }
        
        /**
         * Predict next single step
         */
        async predictNextStep(nodeId, graph, previousSteps = []) {
            const node = typeof graph.findNode === 'function' ? 
                graph.findNode(nodeId) : null;
            
            if (!node) return null;
            
            // Get node embedding and role
            const embedding = this.gnn.getEmbedding(nodeId);
            const role = this.gnn.roleClassifications.get(nodeId);
            
            // Get action predictions
            const actionPredictions = this.actionEncoder.predictNextAction();
            
            // Get structural context
            const hasChildren = node.children && node.children.length > 0;
            const childCount = node.children?.length || 0;
            const depth = node.level || 0;
            
            // Decision logic based on context
            const predictions = [];
            
            // If category with few children, likely to add more
            if (role?.role === 'category' && childCount < 5) {
                predictions.push({
                    type: 'create_child',
                    confidence: 0.7 * (role?.confidence || 0.5),
                    reason: 'Category typically has more items'
                });
            }
            
            // If at shallow depth with no children, likely to expand
            if (depth < 3 && !hasChildren) {
                predictions.push({
                    type: 'create_child',
                    confidence: 0.6,
                    reason: 'Shallow node often gets expanded'
                });
            }
            
            // If deep with children, might navigate up
            if (depth > 4 && hasChildren) {
                predictions.push({
                    type: 'navigate_up',
                    nodeId: node.parent?.id,
                    confidence: 0.5,
                    reason: 'Deep exploration often followed by surfacing'
                });
            }
            
            // Check sibling patterns
            if (node.parent) {
                const parent = typeof graph.findNode === 'function' ? 
                    graph.findNode(node.parent.id || node.parent) : null;
                if (parent && parent.children) {
                    const siblingIndex = parent.children.findIndex(c => c.id === nodeId);
                    if (siblingIndex < parent.children.length - 1) {
                        predictions.push({
                            type: 'navigate_sibling',
                            nodeId: parent.children[siblingIndex + 1].id,
                            confidence: 0.4,
                            reason: 'Sequential sibling navigation pattern'
                        });
                    }
                }
            }
            
            // Incorporate action sequence predictions
            if (actionPredictions && actionPredictions.length > 0) {
                const topAction = actionPredictions[0];
                predictions.push({
                    type: topAction.action,
                    confidence: topAction.probability * 0.8,
                    reason: `Historical pattern: ${(topAction.probability * 100).toFixed(0)}% after ${this.actionEncoder.actionHistory[this.actionEncoder.actionHistory.length - 1]?.type || 'start'}`
                });
            }
            
            // Sort by confidence
            predictions.sort((a, b) => b.confidence - a.confidence);
            
            return predictions[0] || null;
        }
        
        /**
         * Predict structural completion - what branches should exist
         */
        async predictStructuralCompletion(nodeId, graph) {
            const node = typeof graph.findNode === 'function' ? 
                graph.findNode(nodeId) : null;
            
            if (!node) return [];
            
            const role = this.gnn.roleClassifications.get(nodeId);
            const childLabels = (node.children || []).map(c => c.label);
            
            const suggestions = [];
            
            // Role-based completion
            if (role?.role === 'plannable') {
                const typical = ['Goals', 'Timeline', 'Resources', 'Risks', 'Milestones'];
                for (const item of typical) {
                    if (!childLabels.some(l => l.toLowerCase().includes(item.toLowerCase()))) {
                        suggestions.push({
                            label: item,
                            confidence: 0.6,
                            reason: `Common for ${role.role} structures`
                        });
                    }
                }
            }
            
            if (role?.role === 'category') {
                // Find similar categories and suggest based on their children
                const similar = await this.findSimilarNodes(nodeId, graph, 3);
                for (const sim of similar) {
                    if (sim.node.children) {
                        for (const child of sim.node.children) {
                            if (!childLabels.some(l => l.toLowerCase() === child.label.toLowerCase())) {
                                suggestions.push({
                                    label: child.label,
                                    confidence: sim.similarity * 0.5,
                                    reason: `Similar to "${sim.node.label}" which has this`
                                });
                            }
                        }
                    }
                }
            }
            
            // Deduplicate and sort
            const unique = new Map();
            for (const s of suggestions) {
                const key = s.label.toLowerCase();
                if (!unique.has(key) || unique.get(key).confidence < s.confidence) {
                    unique.set(key, s);
                }
            }
            
            return Array.from(unique.values())
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, 5);
        }
        
        /**
         * Find similar nodes by embedding
         */
        async findSimilarNodes(nodeId, graph, n = 5) {
            const embedding = this.gnn.getEmbedding(nodeId);
            if (!embedding) return [];
            
            const similarities = [];
            const allNodes = this.gnn.collectAllNodes(graph);
            
            for (const node of allNodes) {
                if (node.id === nodeId) continue;
                
                const otherEmb = this.gnn.getEmbedding(node.id);
                if (!otherEmb) continue;
                
                const similarity = this.gnn.cosineSimilarity(embedding, otherEmb);
                similarities.push({ node, similarity });
            }
            
            return similarities
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, n);
        }
    }
    
    /**
     * CognitiveGraphTransformer - Main orchestrator
     * Combines GNN, ActionEncoder, and TrajectoryPredictor
     */
    class CognitiveGraphTransformer {
        constructor() {
            this.gnn = new CognitiveGNN();
            this.actionEncoder = new ActionSequenceEncoder();
            this.trajectoryPredictor = new TrajectoryPredictor(this.gnn, this.actionEncoder);
            
            this.initialized = false;
            this.lastProcessTime = 0;
            this.processInterval = 5000; // Process graph every 5 seconds at most
        }
        
        async initialize() {
            if (this.initialized) return;
            
            try {
                await this.gnn.initialize();
                
                // Load saved data
                await this.loadState();
                
                this.initialized = true;
                console.log('✓ CognitiveGraphTransformer initialized');
                
                return true;
            } catch (e) {
                console.error('CGT initialization failed:', e);
                return false;
            }
        }
        
        /**
         * Process the graph - run GNN and update embeddings
         */
        async processGraph(store) {
            // Skip if TensorFlow not loaded
            if (typeof tf === 'undefined') {
                console.log('⚠ CGT: TensorFlow not loaded, deferring initialization');
                return;
            }
            
            // Throttle processing
            const now = Date.now();
            if (now - this.lastProcessTime < this.processInterval) return;
            this.lastProcessTime = now;
            
            if (!this.initialized) {
                await this.initialize();
            }
            
            try {
                // Run message passing
                await this.gnn.propagate(store);
                
                // Classify roles for all nodes
                const allNodes = this.gnn.collectAllNodes(store);
                for (const node of allNodes) {
                    await this.gnn.classifyRole(node, store);
                }
                
                console.log(`🧠 CGT processed ${allNodes.length} nodes`);
            } catch (e) {
                console.error('CGT processing failed:', e);
            }
        }
        
        /**
         * Record a user action
         */
        recordAction(actionType, nodeId, metadata = {}) {
            return this.actionEncoder.recordAction(actionType, nodeId, metadata);
        }
        
        /**
         * Get cognitive state
         */
        getCognitiveState() {
            return this.actionEncoder.detectCognitiveState();
        }
        
        /**
         * Predict trajectory
         */
        async predictTrajectory(nodeId, store, steps = 5) {
            if (!this.initialized) await this.initialize();
            return this.trajectoryPredictor.predictTrajectory(nodeId, store, steps);
        }
        
        /**
         * Find structural holes (GPU-accelerated when available)
         */
        async findStructuralHoles(store, threshold = 0.7) {
            return this.gnn.findStructuralHoles(store, threshold);
        }
        
        /**
         * Sync version for backward compatibility
         */
        findStructuralHolesSync(store, threshold = 0.7) {
            return this.gnn.findStructuralHolesSync(store, threshold);
        }
        
        /**
         * Get structural completion suggestions
         */
        async getCompletionSuggestions(nodeId, store) {
            if (!this.initialized) await this.initialize();
            return this.trajectoryPredictor.predictStructuralCompletion(nodeId, store);
        }
        
        /**
         * Get node role
         */
        getNodeRole(nodeId) {
            return this.gnn.roleClassifications.get(nodeId);
        }
        
        /**
         * Find similar nodes
         */
        async findSimilarNodes(nodeId, store, n = 5) {
            if (!this.initialized) await this.initialize();
            return this.trajectoryPredictor.findSimilarNodes(nodeId, store, n);
        }
        
        /**
         * Get insights for current state
         */
        async getInsights(store, selectedNodeId = null) {
            const insights = [];
            
            // Cognitive state insight
            const cogState = this.getCognitiveState();
            if (cogState.confidence > 0.6) {
                insights.push({
                    type: 'cognitive_state',
                    title: `Mode: ${cogState.state.replace(/-/g, ' ')}`,
                    description: cogState.suggestion,
                    confidence: cogState.confidence
                });
            }
            
            // Structural holes (GPU-accelerated when available)
            const holes = await this.findStructuralHoles(store, 0.75);
            if (holes.length > 0) {
                const top = holes[0];
                insights.push({
                    type: 'structural_hole',
                    title: 'Hidden Connection Found',
                    description: `"${top.nodeA.label}" and "${top.nodeB.label}" seem related but aren't connected`,
                    confidence: top.similarity,
                    action: { type: 'connect', nodeA: top.nodeA.id, nodeB: top.nodeB.id }
                });
            }
            
            // Selected node insights
            if (selectedNodeId) {
                const role = this.getNodeRole(selectedNodeId);
                if (role && role.confidence > 0.6) {
                    insights.push({
                        type: 'node_role',
                        title: `This looks like a ${role.role}`,
                        description: `Confidence: ${(role.confidence * 100).toFixed(0)}%`,
                        confidence: role.confidence
                    });
                }
                
                const completions = await this.getCompletionSuggestions(selectedNodeId, store);
                if (completions.length > 0) {
                    insights.push({
                        type: 'completion',
                        title: 'Suggested additions',
                        description: completions.map(c => c.label).join(', '),
                        confidence: completions[0].confidence,
                        suggestions: completions
                    });
                }
            }
            
            return insights;
        }
        
        /**
         * Save state
         */
        async saveState() {
            try {
                await this.gnn.saveWeights();
                
                await NeuralDB.save('cgt-state', {
                    gnnData: this.gnn.getExportData(),
                    actionData: this.actionEncoder.getExportData()
                });
                
                console.log('✓ CGT state saved');
            } catch (e) {
                console.error('Failed to save CGT state:', e);
            }
        }
        
        /**
         * Load state
         */
        async loadState() {
            try {
                const saved = await NeuralDB.load('cgt-state');
                if (saved) {
                    if (saved.gnnData) this.gnn.importData(saved.gnnData);
                    if (saved.actionData) this.actionEncoder.importData(saved.actionData);
                    console.log('✓ CGT state loaded');
                }
            } catch (e) {
                console.error('Failed to load CGT state:', e);
            }
        }
        
        /**
         * Export for backup
         */
        getExportData() {
            return {
                gnn: this.gnn.getExportData(),
                actions: this.actionEncoder.getExportData()
            };
        }
        
        /**
         * Import from backup
         */
        importData(data) {
            if (data.gnn) this.gnn.importData(data.gnn);
            if (data.actions) this.actionEncoder.importData(data.actions);
        }
        
        /**
         * Get stats
         */
        getStats() {
            return {
                gnn: this.gnn.stats,
                actions: {
                    historySize: this.actionEncoder.actionHistory.length,
                    uniquePatterns: this.actionEncoder.patternCounts.size,
                    bursts: this.actionEncoder.burstPatterns.length
                }
            };
        }
    }
    
    // Global CGT instance
    const cognitiveGT = new CognitiveGraphTransformer();
    
    // ═══════════════════════════════════════════════════════════════════
    // PHASE 4: CROSS-MAP TRANSFER & STYLE FINGERPRINTING
    // ═══════════════════════════════════════════════════════════════════
    
    /**
     * CognitiveStyleFingerprint - Captures your unique thinking signature
     * 
     * This learns HOW you think, not WHAT you think about.
     * The fingerprint is content-agnostic and transfers across any domain.
     */
    class CognitiveStyleFingerprint {
        constructor() {
            // Structural preferences
            this.structural = {
                preferredDepth: { sum: 0, count: 0 },        // How deep you typically go
                branchingFactor: { sum: 0, count: 0 },      // Avg children per node
                balanceTendency: 0,                          // -1 = chains, +1 = balanced trees
                expansionRate: { sum: 0, count: 0 },        // How quickly you expand
                reorganizationFrequency: 0,                  // How often you restructure
                treeVsChain: 0                               // -1 = linear chains, +1 = bushy trees
            };
            
            // Naming voice
            this.naming = {
                avgLabelLength: { sum: 0, count: 0 },
                avgWordCount: { sum: 0, count: 0 },
                verbVsNoun: 0,                               // -1 = noun-heavy, +1 = verb-heavy
                usesCamelCase: 0,
                usesCapitalization: 0,                       // 0-1 scale
                usesEmoji: 0,
                usesNumbers: 0,
                actionVerbFrequency: 0,                      // How often labels start with verbs
                questionFrequency: 0                         // How often labels are questions
            };
            
            // Work rhythm
            this.rhythm = {
                avgSessionLength: { sum: 0, count: 0 },     // Minutes
                avgNodesPerSession: { sum: 0, count: 0 },
                editToCreateRatio: { edits: 0, creates: 0 },
                burstVsSteady: 0,                            // -1 = steady, +1 = burst worker
                reflectionPauses: { sum: 0, count: 0 },     // Avg pause length
                peakProductivityHours: new Array(24).fill(0),
                weekdayVsWeekend: { weekday: 0, weekend: 0 }
            };
            
            // Domain patterns (what types of things you think about)
            this.domainSignatures = new Map(); // domain → frequency
            
            // Confidence (how much data we have)
            this.confidence = {
                structural: 0,
                naming: 0,
                rhythm: 0,
                overall: 0
            };
            
            // Version for migrations
            this.version = 1;
        }
        
        /**
         * Analyze a label to extract naming patterns
         */
        analyzeLabel(label) {
            if (!label || typeof label !== 'string') return null;
            
            const words = label.trim().split(/\s+/);
            const firstWord = words[0]?.toLowerCase() || '';
            
            // Common action verbs
            const actionVerbs = ['create', 'build', 'make', 'do', 'get', 'find', 'add', 'remove', 
                'update', 'check', 'review', 'plan', 'design', 'develop', 'implement', 'test',
                'write', 'read', 'send', 'receive', 'start', 'finish', 'complete', 'begin',
                'analyze', 'research', 'explore', 'define', 'identify', 'evaluate', 'assess',
                'organize', 'schedule', 'prepare', 'setup', 'configure', 'install', 'deploy'];
            
            return {
                length: label.length,
                wordCount: words.length,
                isVerb: actionVerbs.includes(firstWord) || firstWord.endsWith('ing'),
                isQuestion: label.includes('?'),
                hasEmoji: /\p{Emoji}/u.test(label),
                hasNumber: /\d/.test(label),
                isCamelCase: /^[a-z]+[A-Z]/.test(label),
                capitalization: (label.match(/[A-Z]/g) || []).length / Math.max(label.length, 1),
                startsWithCapital: /^[A-Z]/.test(label)
            };
        }
        
        /**
         * Learn from a node creation event
         */
        learnFromNodeCreation(node, parent, depth, siblings = 0) {
            // Structural learning
            this.structural.preferredDepth.sum += depth;
            this.structural.preferredDepth.count++;
            
            if (parent && parent.children) {
                this.structural.branchingFactor.sum += parent.children.length;
                this.structural.branchingFactor.count++;
            }
            
            // Update tree vs chain tendency
            if (depth > 3 && siblings < 2) {
                this.structural.treeVsChain -= 0.1; // Leaning toward chains
            } else if (depth < 3 && siblings > 2) {
                this.structural.treeVsChain += 0.1; // Leaning toward trees
            }
            this.structural.treeVsChain = Math.max(-1, Math.min(1, this.structural.treeVsChain));
            
            // Naming learning
            const analysis = this.analyzeLabel(node.label);
            if (analysis) {
                this.naming.avgLabelLength.sum += analysis.length;
                this.naming.avgLabelLength.count++;
                
                this.naming.avgWordCount.sum += analysis.wordCount;
                this.naming.avgWordCount.count++;
                
                // Update verb vs noun tendency
                if (analysis.isVerb) {
                    this.naming.verbVsNoun += 0.05;
                    this.naming.actionVerbFrequency = 
                        (this.naming.actionVerbFrequency * 0.95) + (1 * 0.05);
                } else {
                    this.naming.verbVsNoun -= 0.02;
                    this.naming.actionVerbFrequency = 
                        (this.naming.actionVerbFrequency * 0.95) + (0 * 0.05);
                }
                this.naming.verbVsNoun = Math.max(-1, Math.min(1, this.naming.verbVsNoun));
                
                if (analysis.isQuestion) {
                    this.naming.questionFrequency = 
                        (this.naming.questionFrequency * 0.95) + (1 * 0.05);
                }
                
                if (analysis.hasEmoji) {
                    this.naming.usesEmoji = (this.naming.usesEmoji * 0.9) + (1 * 0.1);
                }
                
                if (analysis.hasNumber) {
                    this.naming.usesNumbers = (this.naming.usesNumbers * 0.9) + (1 * 0.1);
                }
                
                this.naming.usesCapitalization = 
                    (this.naming.usesCapitalization * 0.95) + (analysis.capitalization * 0.05);
            }
            
            // Work rhythm - time of day
            const hour = new Date().getHours();
            this.rhythm.peakProductivityHours[hour]++;
            
            const dayOfWeek = new Date().getDay();
            if (dayOfWeek === 0 || dayOfWeek === 6) {
                this.rhythm.weekdayVsWeekend.weekend++;
            } else {
                this.rhythm.weekdayVsWeekend.weekday++;
            }
            
            this.rhythm.editToCreateRatio.creates++;
            
            // Update confidence
            this.updateConfidence();
        }
        
        /**
         * Learn from a node edit event
         */
        learnFromNodeEdit(node, editType) {
            this.rhythm.editToCreateRatio.edits++;
            this.updateConfidence();
        }
        
        /**
         * Learn from a reorganization event (reparent)
         */
        learnFromReorganization() {
            this.structural.reorganizationFrequency = 
                (this.structural.reorganizationFrequency * 0.95) + (1 * 0.05);
            this.updateConfidence();
        }
        
        /**
         * Learn from session end
         */
        learnFromSession(sessionDuration, nodesCreated) {
            this.rhythm.avgSessionLength.sum += sessionDuration / 60000; // Convert to minutes
            this.rhythm.avgSessionLength.count++;
            
            this.rhythm.avgNodesPerSession.sum += nodesCreated;
            this.rhythm.avgNodesPerSession.count++;
            
            this.updateConfidence();
        }
        
        /**
         * Update confidence scores based on data collected
         */
        updateConfidence() {
            // Structural confidence based on node count
            const structuralSamples = this.structural.preferredDepth.count;
            this.confidence.structural = Math.min(1, structuralSamples / 50);
            
            // Naming confidence based on label count
            const namingSamples = this.naming.avgLabelLength.count;
            this.confidence.naming = Math.min(1, namingSamples / 30);
            
            // Rhythm confidence based on sessions
            const rhythmSamples = this.rhythm.avgSessionLength.count;
            this.confidence.rhythm = Math.min(1, rhythmSamples / 5);
            
            // Overall confidence
            this.confidence.overall = (
                this.confidence.structural * 0.4 +
                this.confidence.naming * 0.4 +
                this.confidence.rhythm * 0.2
            );
        }
        
        /**
         * Get the computed fingerprint values
         */
        getFingerprint() {
            return {
                structural: {
                    avgDepth: this.structural.preferredDepth.count > 0 
                        ? this.structural.preferredDepth.sum / this.structural.preferredDepth.count 
                        : 2,
                    avgBranching: this.structural.branchingFactor.count > 0
                        ? this.structural.branchingFactor.sum / this.structural.branchingFactor.count
                        : 3,
                    treeVsChain: this.structural.treeVsChain,
                    reorganizationRate: this.structural.reorganizationFrequency
                },
                naming: {
                    avgLength: this.naming.avgLabelLength.count > 0
                        ? this.naming.avgLabelLength.sum / this.naming.avgLabelLength.count
                        : 15,
                    avgWords: this.naming.avgWordCount.count > 0
                        ? this.naming.avgWordCount.sum / this.naming.avgWordCount.count
                        : 2,
                    verbTendency: this.naming.verbVsNoun,
                    actionVerbRate: this.naming.actionVerbFrequency,
                    questionRate: this.naming.questionFrequency,
                    emojiRate: this.naming.usesEmoji,
                    capitalizationRate: this.naming.usesCapitalization
                },
                rhythm: {
                    avgSessionMinutes: this.rhythm.avgSessionLength.count > 0
                        ? this.rhythm.avgSessionLength.sum / this.rhythm.avgSessionLength.count
                        : 30,
                    avgNodesPerSession: this.rhythm.avgNodesPerSession.count > 0
                        ? this.rhythm.avgNodesPerSession.sum / this.rhythm.avgNodesPerSession.count
                        : 10,
                    editCreateRatio: this.rhythm.editToCreateRatio.creates > 0
                        ? this.rhythm.editToCreateRatio.edits / this.rhythm.editToCreateRatio.creates
                        : 0.5,
                    peakHours: this.getPeakHours(),
                    weekdayBias: this.getWeekdayBias()
                },
                confidence: this.confidence
            };
        }
        
        getPeakHours() {
            const hours = this.rhythm.peakProductivityHours;
            const indexed = hours.map((count, hour) => ({ hour, count }));
            indexed.sort((a, b) => b.count - a.count);
            return indexed.slice(0, 3).map(h => h.hour);
        }
        
        getWeekdayBias() {
            const total = this.rhythm.weekdayVsWeekend.weekday + this.rhythm.weekdayVsWeekend.weekend;
            if (total === 0) return 0;
            return (this.rhythm.weekdayVsWeekend.weekday / total) - 0.71; // 5/7 ≈ 0.71
        }
        
        /**
         * Get a human-readable style description
         */
        getStyleDescription() {
            const fp = this.getFingerprint();
            const descriptions = [];
            
            // Structural style
            if (fp.structural.avgDepth > 4) {
                descriptions.push('Deep thinker');
            } else if (fp.structural.avgDepth < 2) {
                descriptions.push('Broad thinker');
            }
            
            if (fp.structural.treeVsChain > 0.3) {
                descriptions.push('Branching explorer');
            } else if (fp.structural.treeVsChain < -0.3) {
                descriptions.push('Linear processor');
            }
            
            // Naming style
            if (fp.naming.verbTendency > 0.3) {
                descriptions.push('Action-oriented');
            } else if (fp.naming.verbTendency < -0.3) {
                descriptions.push('Concept-focused');
            }
            
            if (fp.naming.avgWords > 4) {
                descriptions.push('Descriptive');
            } else if (fp.naming.avgWords < 2) {
                descriptions.push('Concise');
            }
            
            // Rhythm
            if (fp.rhythm.editCreateRatio > 1) {
                descriptions.push('Refiner');
            } else if (fp.rhythm.editCreateRatio < 0.3) {
                descriptions.push('Rapid builder');
            }
            
            return descriptions.length > 0 ? descriptions : ['Developing style...'];
        }
        
        /**
         * Export fingerprint data
         */
        export() {
            return {
                version: this.version,
                structural: this.structural,
                naming: this.naming,
                rhythm: this.rhythm,
                confidence: this.confidence
            };
        }
        
        /**
         * Import fingerprint data
         */
        import(data) {
            if (!data) return;
            if (data.structural) this.structural = { ...this.structural, ...data.structural };
            if (data.naming) this.naming = { ...this.naming, ...data.naming };
            if (data.rhythm) this.rhythm = { ...this.rhythm, ...data.rhythm };
            if (data.confidence) this.confidence = data.confidence;
        }
        
        /**
         * Save to IndexedDB
         */
        async save() {
            try {
                await NeuralDB.save('cognitive-style-fingerprint', this.export());
            } catch (e) {
                console.error('Failed to save fingerprint:', e);
            }
        }
        
        /**
         * Load from IndexedDB
         */
        async load() {
            try {
                const data = await NeuralDB.load('cognitive-style-fingerprint');
                if (data) {
                    this.import(data);
                    console.log('✓ Cognitive style fingerprint loaded');
                }
            } catch (e) {
                console.error('Failed to load fingerprint:', e);
            }
        }
    }
    
    /**
     * UniversalPatternLibrary - Stores abstract patterns that transcend content
     * 
     * These are structural templates that work regardless of domain.
     * "Planning" → [objectives, timeline, resources, constraints]
     * "Analysis" → [problem, causes, evidence, solutions]
     */
    class UniversalPatternLibrary {
        constructor() {
            // Core pattern templates (seeded with common structures)
            this.patterns = new Map();
            
            // User-learned patterns (from their actual usage)
            this.learnedPatterns = new Map();
            
            // Pattern usage statistics
            this.patternUsage = new Map();
            
            // Initialize with universal seed patterns
            this.initializeSeedPatterns();
        }
        
        initializeSeedPatterns() {
            // These are domain-agnostic structural templates
            this.patterns.set('planning', {
                name: 'Planning',
                description: 'Structured approach to achieving a goal',
                slots: [
                    { role: 'objective', examples: ['Goals', 'Objectives', 'Target', 'Aim'] },
                    { role: 'timeline', examples: ['Timeline', 'Schedule', 'Milestones', 'Phases'] },
                    { role: 'resources', examples: ['Resources', 'Requirements', 'Tools', 'Budget'] },
                    { role: 'constraints', examples: ['Constraints', 'Risks', 'Blockers', 'Challenges'] },
                    { role: 'actions', examples: ['Next Steps', 'Action Items', 'Tasks', 'To-Do'] }
                ],
                triggers: ['plan', 'project', 'initiative', 'campaign', 'launch', 'strategy']
            });
            
            this.patterns.set('analysis', {
                name: 'Analysis',
                description: 'Breaking down a problem or topic',
                slots: [
                    { role: 'subject', examples: ['Problem', 'Topic', 'Question', 'Issue'] },
                    { role: 'components', examples: ['Factors', 'Causes', 'Elements', 'Parts'] },
                    { role: 'evidence', examples: ['Evidence', 'Data', 'Examples', 'Cases'] },
                    { role: 'conclusion', examples: ['Conclusions', 'Solutions', 'Recommendations', 'Insights'] }
                ],
                triggers: ['analyze', 'analysis', 'research', 'investigate', 'study', 'examine']
            });
            
            this.patterns.set('comparison', {
                name: 'Comparison',
                description: 'Evaluating options against criteria',
                slots: [
                    { role: 'options', examples: ['Option A', 'Option B', 'Alternative 1', 'Choice 1'] },
                    { role: 'criteria', examples: ['Criteria', 'Factors', 'Considerations', 'Metrics'] },
                    { role: 'analysis', examples: ['Pros/Cons', 'Trade-offs', 'Comparison', 'Evaluation'] },
                    { role: 'decision', examples: ['Decision', 'Recommendation', 'Verdict', 'Choice'] }
                ],
                triggers: ['compare', 'vs', 'versus', 'choose', 'decide', 'options', 'alternatives']
            });
            
            this.patterns.set('process', {
                name: 'Process',
                description: 'Sequential steps to achieve an outcome',
                slots: [
                    { role: 'trigger', examples: ['Trigger', 'Input', 'Start', 'When'] },
                    { role: 'steps', examples: ['Step 1', 'Phase 1', 'First', 'Then'] },
                    { role: 'output', examples: ['Output', 'Result', 'Outcome', 'End State'] },
                    { role: 'feedback', examples: ['Feedback', 'Iteration', 'Improvement', 'Review'] }
                ],
                triggers: ['process', 'workflow', 'procedure', 'how to', 'steps', 'guide']
            });
            
            this.patterns.set('entity', {
                name: 'Entity',
                description: 'Describing a thing, person, or concept',
                slots: [
                    { role: 'definition', examples: ['Definition', 'What', 'Overview', 'Summary'] },
                    { role: 'properties', examples: ['Properties', 'Attributes', 'Characteristics', 'Features'] },
                    { role: 'relationships', examples: ['Relationships', 'Connections', 'Related To', 'Links'] },
                    { role: 'context', examples: ['Context', 'History', 'Background', 'Origin'] }
                ],
                triggers: ['about', 'what is', 'define', 'concept', 'idea', 'thing']
            });
            
            this.patterns.set('brainstorm', {
                name: 'Brainstorm',
                description: 'Generating and organizing ideas',
                slots: [
                    { role: 'theme', examples: ['Theme', 'Topic', 'Focus', 'Question'] },
                    { role: 'ideas', examples: ['Ideas', 'Options', 'Possibilities', 'Concepts'] },
                    { role: 'grouping', examples: ['Categories', 'Themes', 'Clusters', 'Groups'] },
                    { role: 'priorities', examples: ['Top Ideas', 'Priorities', 'Best', 'Selected'] }
                ],
                triggers: ['brainstorm', 'ideas', 'ideation', 'creative', 'possibilities', 'explore']
            });
            
            this.patterns.set('learning', {
                name: 'Learning',
                description: 'Acquiring knowledge or skills',
                slots: [
                    { role: 'topic', examples: ['Topic', 'Subject', 'Skill', 'Area'] },
                    { role: 'resources', examples: ['Resources', 'Materials', 'Courses', 'Books'] },
                    { role: 'practice', examples: ['Practice', 'Exercises', 'Projects', 'Apply'] },
                    { role: 'progress', examples: ['Progress', 'Milestones', 'Goals', 'Assessment'] }
                ],
                triggers: ['learn', 'study', 'course', 'skill', 'training', 'education']
            });
            
            this.patterns.set('problem-solving', {
                name: 'Problem Solving',
                description: 'Systematic approach to resolving issues',
                slots: [
                    { role: 'problem', examples: ['Problem', 'Issue', 'Challenge', 'Pain Point'] },
                    { role: 'root-cause', examples: ['Root Cause', 'Why', 'Source', 'Origin'] },
                    { role: 'solutions', examples: ['Solutions', 'Options', 'Approaches', 'Fixes'] },
                    { role: 'implementation', examples: ['Implementation', 'Action Plan', 'Next Steps', 'Execute'] }
                ],
                triggers: ['problem', 'issue', 'fix', 'solve', 'resolve', 'trouble']
            });
        }
        
        /**
         * Detect which pattern(s) a node might match
         */
        detectPattern(label, description = '') {
            const text = `${label} ${description}`.toLowerCase();
            const matches = [];
            
            for (const [id, pattern] of this.patterns) {
                let score = 0;
                
                // Check trigger words
                for (const trigger of pattern.triggers) {
                    if (text.includes(trigger)) {
                        score += 0.3;
                    }
                }
                
                // Check slot examples
                for (const slot of pattern.slots) {
                    for (const example of slot.examples) {
                        if (text.includes(example.toLowerCase())) {
                            score += 0.1;
                        }
                    }
                }
                
                if (score > 0.2) {
                    matches.push({ patternId: id, pattern, score });
                }
            }
            
            // Also check learned patterns
            for (const [id, pattern] of this.learnedPatterns) {
                let score = 0;
                
                if (pattern.triggers) {
                    for (const trigger of pattern.triggers) {
                        if (text.includes(trigger.toLowerCase())) {
                            score += 0.4; // Learned patterns get higher weight
                        }
                    }
                }
                
                if (score > 0.2) {
                    matches.push({ patternId: `learned:${id}`, pattern, score, isLearned: true });
                }
            }
            
            matches.sort((a, b) => b.score - a.score);
            return matches;
        }
        
        /**
         * Learn a new pattern from user behavior
         */
        learnPattern(parentLabel, childLabels, metadata = {}) {
            // Create a pattern signature
            const signature = this.createSignature(childLabels);
            
            // Check if we already have a similar pattern
            const existingId = this.findSimilarPattern(signature);
            
            if (existingId) {
                // Reinforce existing pattern
                const existing = this.learnedPatterns.get(existingId);
                existing.frequency = (existing.frequency || 1) + 1;
                existing.lastUsed = Date.now();
                
                // Add parent label as a trigger
                if (!existing.triggers.includes(parentLabel.toLowerCase())) {
                    existing.triggers.push(parentLabel.toLowerCase());
                }
            } else {
                // Create new learned pattern
                const patternId = `user_${Date.now()}`;
                this.learnedPatterns.set(patternId, {
                    name: `Pattern from "${parentLabel}"`,
                    slots: childLabels.map(label => ({
                        role: this.inferRole(label),
                        examples: [label]
                    })),
                    triggers: [parentLabel.toLowerCase()],
                    frequency: 1,
                    created: Date.now(),
                    lastUsed: Date.now(),
                    metadata
                });
            }
        }
        
        createSignature(labels) {
            // Create a structural signature from labels
            return labels.map(l => this.inferRole(l)).sort().join('|');
        }
        
        findSimilarPattern(signature) {
            for (const [id, pattern] of this.learnedPatterns) {
                const existingSignature = pattern.slots.map(s => s.role).sort().join('|');
                if (this.signatureSimilarity(signature, existingSignature) > 0.6) {
                    return id;
                }
            }
            return null;
        }
        
        signatureSimilarity(sig1, sig2) {
            const roles1 = new Set(sig1.split('|'));
            const roles2 = new Set(sig2.split('|'));
            const intersection = new Set([...roles1].filter(x => roles2.has(x)));
            const union = new Set([...roles1, ...roles2]);
            return intersection.size / union.size;
        }
        
        inferRole(label) {
            const lower = label.toLowerCase();
            
            // Time-related
            if (/time|schedule|date|when|deadline|milestone|phase/.test(lower)) return 'temporal';
            
            // Goal-related
            if (/goal|objective|target|aim|purpose|vision|mission/.test(lower)) return 'objective';
            
            // Resource-related
            if (/resource|tool|budget|cost|money|team|people/.test(lower)) return 'resource';
            
            // Risk/constraint
            if (/risk|constraint|blocker|challenge|issue|problem/.test(lower)) return 'constraint';
            
            // Action-related
            if (/step|action|task|do|next|todo/.test(lower)) return 'action';
            
            // Idea-related
            if (/idea|option|alternative|possibility/.test(lower)) return 'idea';
            
            // Default to generic
            return 'item';
        }
        
        /**
         * Get suggestions based on detected pattern
         */
        getSuggestions(parentLabel, existingChildren = []) {
            const matches = this.detectPattern(parentLabel);
            if (matches.length === 0) return [];
            
            const bestMatch = matches[0];
            const existingLower = new Set(existingChildren.map(c => c.toLowerCase()));
            
            const suggestions = [];
            
            for (const slot of bestMatch.pattern.slots) {
                // Skip if we already have something similar
                const hasMatch = slot.examples.some(ex => 
                    existingLower.has(ex.toLowerCase()) ||
                    [...existingLower].some(e => e.includes(ex.toLowerCase()) || ex.toLowerCase().includes(e))
                );
                
                if (!hasMatch) {
                    suggestions.push({
                        label: slot.examples[0],
                        role: slot.role,
                        alternatives: slot.examples.slice(1),
                        patternSource: bestMatch.patternId,
                        confidence: bestMatch.score
                    });
                }
            }
            
            return suggestions;
        }
        
        /**
         * Record that a pattern was used
         */
        recordUsage(patternId) {
            const count = this.patternUsage.get(patternId) || 0;
            this.patternUsage.set(patternId, count + 1);
        }
        
        /**
         * Export library data
         */
        export() {
            return {
                learnedPatterns: Object.fromEntries(this.learnedPatterns),
                patternUsage: Object.fromEntries(this.patternUsage)
            };
        }
        
        /**
         * Import library data
         */
        import(data) {
            if (data.learnedPatterns) {
                this.learnedPatterns = new Map(Object.entries(data.learnedPatterns));
            }
            if (data.patternUsage) {
                this.patternUsage = new Map(Object.entries(data.patternUsage));
            }
        }
        
        async save() {
            try {
                await NeuralDB.save('universal-pattern-library', this.export());
            } catch (e) {
                console.error('Failed to save pattern library:', e);
            }
        }
        
        async load() {
            try {
                const data = await NeuralDB.load('universal-pattern-library');
                if (data) {
                    this.import(data);
                    console.log(`✓ Pattern library loaded (${this.learnedPatterns.size} learned patterns)`);
                }
            } catch (e) {
                console.error('Failed to load pattern library:', e);
            }
        }
    }
    
    /**
     * TransferEngine - Applies learned patterns to new contexts
     * 
     * The magic: recognizes "this looks like X" and offers to apply
     * the structure you used before.
     */
    class TransferEngine {
        constructor(patternLibrary, styleFingerprint) {
            this.patternLibrary = patternLibrary;
            this.styleFingerprint = styleFingerprint;
            
            // Cache of recent transfers
            this.recentTransfers = [];
            this.maxRecentTransfers = 20;
            
            // Structural memories (maps node structures for similarity)
            this.structuralMemories = new Map(); // nodeLabel → structure snapshot
        }
        
        /**
         * Record a node's structure for future transfer
         */
        recordStructure(node) {
            if (!node.children || node.children.length < 2) return;
            
            const snapshot = {
                label: node.label,
                childLabels: node.children.map(c => c.label),
                childCount: node.children.length,
                depth: node.level || 0,
                timestamp: Date.now()
            };
            
            // Store by normalized label
            const key = this.normalizeLabel(node.label);
            this.structuralMemories.set(key, snapshot);
            
            // Also learn as a pattern
            this.patternLibrary.learnPattern(node.label, snapshot.childLabels, {
                depth: snapshot.depth,
                originalNodeId: node.id
            });
        }
        
        normalizeLabel(label) {
            return label.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        /**
         * Find similar structures for potential transfer
         */
        findSimilarStructures(label, limit = 5) {
            const normalizedLabel = this.normalizeLabel(label);
            const similarities = [];
            
            for (const [key, snapshot] of this.structuralMemories) {
                if (key === normalizedLabel) continue; // Skip self
                
                const similarity = this.computeLabelSimilarity(normalizedLabel, key);
                if (similarity > 0.3) {
                    similarities.push({
                        label: snapshot.label,
                        childLabels: snapshot.childLabels,
                        similarity,
                        timestamp: snapshot.timestamp
                    });
                }
            }
            
            // Sort by similarity
            similarities.sort((a, b) => b.similarity - a.similarity);
            return similarities.slice(0, limit);
        }
        
        computeLabelSimilarity(label1, label2) {
            // Simple word overlap + semantic hints
            const words1 = new Set(label1.split(' '));
            const words2 = new Set(label2.split(' '));
            
            // Jaccard similarity
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);
            const jaccard = intersection.size / union.size;
            
            // Boost for similar word stems
            let stemBoost = 0;
            for (const w1 of words1) {
                for (const w2 of words2) {
                    if (w1.length > 3 && w2.length > 3) {
                        if (w1.substring(0, 4) === w2.substring(0, 4)) {
                            stemBoost += 0.1;
                        }
                    }
                }
            }
            
            return Math.min(1, jaccard + stemBoost);
        }
        
        /**
         * Generate transfer suggestions for a node
         */
        getTransferSuggestions(node, existingChildren = []) {
            const suggestions = [];
            
            // 1. Check universal patterns
            const patternSuggestions = this.patternLibrary.getSuggestions(
                node.label, 
                existingChildren.map(c => c.label || c)
            );
            
            for (const ps of patternSuggestions) {
                suggestions.push({
                    type: 'pattern',
                    label: this.personalizeLabel(ps.label),
                    originalLabel: ps.label,
                    alternatives: ps.alternatives.map(a => this.personalizeLabel(a)),
                    source: ps.patternSource,
                    confidence: ps.confidence * 0.8,
                    reason: `Common "${ps.patternSource}" pattern`
                });
            }
            
            // 2. Check similar structures
            const similarStructures = this.findSimilarStructures(node.label);
            
            for (const sim of similarStructures) {
                const existingLower = new Set(existingChildren.map(c => 
                    (c.label || c).toLowerCase()
                ));
                
                for (const childLabel of sim.childLabels) {
                    if (!existingLower.has(childLabel.toLowerCase())) {
                        suggestions.push({
                            type: 'transfer',
                            label: this.personalizeLabel(childLabel),
                            originalLabel: childLabel,
                            source: sim.label,
                            confidence: sim.similarity * 0.9,
                            reason: `Similar to your "${sim.label}"`
                        });
                    }
                }
            }
            
            // Deduplicate and sort
            const seen = new Set();
            const unique = suggestions.filter(s => {
                const key = s.label.toLowerCase();
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
            
            unique.sort((a, b) => b.confidence - a.confidence);
            return unique.slice(0, 8);
        }
        
        /**
         * Personalize a label based on user's style fingerprint
         */
        personalizeLabel(label) {
            const fp = this.styleFingerprint.getFingerprint();
            let result = label;
            
            // Apply naming preferences if we have enough confidence
            if (fp.confidence.naming < 0.3) return result;
            
            // Verb tendency
            if (fp.naming.verbTendency > 0.3) {
                // User prefers action verbs - try to verbify
                result = this.verbifyLabel(result);
            }
            
            // Capitalization
            if (fp.naming.capitalizationRate < 0.1) {
                // User prefers lowercase
                result = result.toLowerCase();
            } else if (fp.naming.capitalizationRate > 0.3) {
                // User prefers title case
                result = this.toTitleCase(result);
            }
            
            // Length preference
            const avgWords = fp.naming.avgWords;
            const currentWords = result.split(/\s+/).length;
            
            if (avgWords < 2 && currentWords > 2) {
                // User prefers concise - shorten
                result = result.split(/\s+/).slice(0, 2).join(' ');
            }
            
            return result;
        }
        
        verbifyLabel(label) {
            const words = label.split(/\s+/);
            const firstWord = words[0].toLowerCase();
            
            // Common noun → verb mappings
            const verbMappings = {
                'goals': 'Define goals',
                'objective': 'Set objective',
                'objectives': 'Set objectives',
                'timeline': 'Create timeline',
                'schedule': 'Plan schedule',
                'resources': 'Gather resources',
                'budget': 'Set budget',
                'risks': 'Identify risks',
                'constraints': 'List constraints',
                'tasks': 'Define tasks',
                'steps': 'Outline steps',
                'ideas': 'Generate ideas',
                'options': 'Explore options',
                'analysis': 'Perform analysis',
                'review': 'Conduct review',
                'summary': 'Write summary',
                'plan': 'Create plan',
                'strategy': 'Develop strategy'
            };
            
            if (verbMappings[firstWord]) {
                return verbMappings[firstWord];
            }
            
            return label;
        }
        
        toTitleCase(str) {
            return str.replace(/\w\S*/g, txt => 
                txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
            );
        }
        
        /**
         * Record a successful transfer (user accepted suggestion)
         */
        recordTransfer(suggestion, targetNode) {
            this.recentTransfers.push({
                suggestion,
                targetNodeId: targetNode.id,
                targetLabel: targetNode.label,
                timestamp: Date.now()
            });
            
            if (this.recentTransfers.length > this.maxRecentTransfers) {
                this.recentTransfers.shift();
            }
            
            // Reinforce the pattern
            if (suggestion.source) {
                this.patternLibrary.recordUsage(suggestion.source);
            }
        }
        
        /**
         * Export engine data
         */
        export() {
            return {
                structuralMemories: Object.fromEntries(this.structuralMemories),
                recentTransfers: this.recentTransfers
            };
        }
        
        /**
         * Import engine data
         */
        import(data) {
            if (data.structuralMemories) {
                this.structuralMemories = new Map(Object.entries(data.structuralMemories));
            }
            if (data.recentTransfers) {
                this.recentTransfers = data.recentTransfers;
            }
        }
        
        async save() {
            try {
                await NeuralDB.save('transfer-engine', this.export());
            } catch (e) {
                console.error('Failed to save transfer engine:', e);
            }
        }
        
        async load() {
            try {
                const data = await NeuralDB.load('transfer-engine');
                if (data) {
                    this.import(data);
                    console.log(`✓ Transfer engine loaded (${this.structuralMemories.size} structural memories)`);
                }
            } catch (e) {
                console.error('Failed to load transfer engine:', e);
            }
        }
    }
    
    /**
     * StyleTransferSystem - Main orchestrator for Phase 4
     * 
     * Combines fingerprinting, pattern library, and transfer engine
     * into a unified system.
     */
    class StyleTransferSystem {
        constructor() {
            this.fingerprint = new CognitiveStyleFingerprint();
            this.patternLibrary = new UniversalPatternLibrary();
            this.transferEngine = new TransferEngine(this.patternLibrary, this.fingerprint);
            
            this.initialized = false;
            
            // Session tracking
            this.sessionStart = Date.now();
            this.sessionNodeCount = 0;
        }
        
        async initialize() {
            if (this.initialized) return;
            
            await this.fingerprint.load();
            await this.patternLibrary.load();
            await this.transferEngine.load();
            
            this.initialized = true;
            console.log('✓ StyleTransferSystem initialized');
        }
        
        /**
         * Learn from node creation
         */
        learnFromCreation(node, parent, store) {
            const path = store.getPath(node.id);
            const depth = path.length - 1;
            const siblings = parent?.children?.length || 0;
            
            this.fingerprint.learnFromNodeCreation(node, parent, depth, siblings);
            this.sessionNodeCount++;
            
            // If parent has multiple children, record its structure
            if (parent && parent.children && parent.children.length >= 3) {
                this.transferEngine.recordStructure(parent);
            }
        }
        
        /**
         * Learn from node edit
         */
        learnFromEdit(node, editType) {
            this.fingerprint.learnFromNodeEdit(node, editType);
        }
        
        /**
         * Learn from reorganization
         */
        learnFromReorg() {
            this.fingerprint.learnFromReorganization();
        }
        
        /**
         * Get transfer suggestions for a node
         */
        getSuggestions(node, existingChildren = []) {
            return this.transferEngine.getTransferSuggestions(node, existingChildren);
        }
        
        /**
         * Record that a suggestion was accepted
         */
        recordAcceptedSuggestion(suggestion, node) {
            this.transferEngine.recordTransfer(suggestion, node);
        }
        
        /**
         * Get user's style fingerprint
         */
        getStyleFingerprint() {
            return this.fingerprint.getFingerprint();
        }
        
        /**
         * Get human-readable style description
         */
        getStyleDescription() {
            return this.fingerprint.getStyleDescription();
        }
        
        /**
         * Get pattern library stats
         */
        getPatternStats() {
            return {
                seedPatterns: this.patternLibrary.patterns.size,
                learnedPatterns: this.patternLibrary.learnedPatterns.size,
                structuralMemories: this.transferEngine.structuralMemories.size,
                recentTransfers: this.transferEngine.recentTransfers.length
            };
        }
        
        /**
         * End session and record stats
         */
        endSession() {
            const duration = Date.now() - this.sessionStart;
            this.fingerprint.learnFromSession(duration, this.sessionNodeCount);
            
            // Reset for next session
            this.sessionStart = Date.now();
            this.sessionNodeCount = 0;
        }
        
        /**
         * Save all data
         */
        async save() {
            await this.fingerprint.save();
            await this.patternLibrary.save();
            await this.transferEngine.save();
        }
        
        /**
         * Export all data
         */
        export() {
            return {
                fingerprint: this.fingerprint.export(),
                patternLibrary: this.patternLibrary.export(),
                transferEngine: this.transferEngine.export()
            };
        }
        
        /**
         * Import all data
         */
        import(data) {
            if (data.fingerprint) this.fingerprint.import(data.fingerprint);
            if (data.patternLibrary) this.patternLibrary.import(data.patternLibrary);
            if (data.transferEngine) this.transferEngine.import(data.transferEngine);
        }
    }
    
    // Global StyleTransferSystem instance
    const styleTransfer = new StyleTransferSystem();
    
    // ═══════════════════════════════════════════════════════════════════
    // WebGPU COMPUTE ENGINE - GPU-accelerated similarity search
    // ═══════════════════════════════════════════════════════════════════
    
    /**
     * WebGPU Compute Engine
     * 
     * Uses GPU compute shaders for massively parallel operations:
     * - Cosine similarity (pairwise comparisons)
     * - Batch embedding distance calculations
     * - Pattern matching at scale
     * 
     * Falls back to optimized CPU/SIMD when WebGPU unavailable
     */
    class WebGPUCompute {
        constructor() {
            this.device = null;
            this.adapter = null;
            this.initialized = false;
            this.supported = false;
            
            // Shader modules
            this.cosineSimilarityShader = null;
            this.batchDistanceShader = null;
            this.topKShader = null;
            
            // Performance tracking
            this.stats = {
                gpuComputeTime: 0,
                cpuFallbackTime: 0,
                operationCount: 0,
                lastBatchSize: 0
            };
            
            // Reusable buffers (to avoid allocation overhead)
            this.bufferCache = new Map();
            this.maxCachedBufferSize = 50 * 1024 * 1024; // 50MB cache limit
            this.currentCacheSize = 0;
        }
        
        /**
         * Initialize WebGPU
         */
        async initialize() {
            if (this.initialized) return this.supported;
            
            try {
                // Check WebGPU support
                if (!navigator.gpu) {
                    console.log('WebGPU not supported - using CPU fallback');
                    this.initialized = true;
                    this.supported = false;
                    return false;
                }
                
                // Request adapter
                this.adapter = await navigator.gpu.requestAdapter({
                    powerPreference: 'high-performance'
                });
                
                if (!this.adapter) {
                    console.log('No WebGPU adapter found - using CPU fallback');
                    this.initialized = true;
                    this.supported = false;
                    return false;
                }
                
                // Request device
                this.device = await this.adapter.requestDevice({
                    requiredFeatures: [],
                    requiredLimits: {
                        maxStorageBufferBindingSize: this.adapter.limits.maxStorageBufferBindingSize,
                        maxComputeWorkgroupSizeX: 256,
                        maxComputeWorkgroupSizeY: 1,
                        maxComputeWorkgroupSizeZ: 1
                    }
                });
                
                // Handle device loss
                this.device.lost.then((info) => {
                    console.error('WebGPU device lost:', info.message);
                    this.supported = false;
                    this.device = null;
                });
                
                // Create shader modules
                await this.createShaderModules();
                
                this.initialized = true;
                this.supported = true;
                
                console.log('✓ WebGPU Compute Engine initialized');
                console.log(`  Adapter: ${this.adapter.info?.device || 'Unknown GPU'}`);
                console.log(`  Max buffer: ${(this.adapter.limits.maxStorageBufferBindingSize / 1024 / 1024).toFixed(0)}MB`);
                
                return true;
                
            } catch (e) {
                console.warn('WebGPU initialization failed:', e);
                this.initialized = true;
                this.supported = false;
                return false;
            }
        }
        
        /**
         * Create compute shader modules
         */
        async createShaderModules() {
            // Cosine Similarity Shader - computes pairwise similarity matrix
            // Each workgroup handles one row of the output matrix
            const cosineSimilarityCode = `
                struct Params {
                    numVectors: u32,
                    vectorDim: u32,
                    queryIndex: u32,
                    padding: u32
                }
                
                @group(0) @binding(0) var<storage, read> vectors: array<f32>;
                @group(0) @binding(1) var<storage, read_write> output: array<f32>;
                @group(0) @binding(2) var<uniform> params: Params;
                
                // Shared memory for reduction
                var<workgroup> sharedDot: array<f32, 256>;
                var<workgroup> sharedNormA: array<f32, 256>;
                var<workgroup> sharedNormB: array<f32, 256>;
                
                @compute @workgroup_size(256)
                fn main(
                    @builtin(global_invocation_id) globalId: vec3<u32>,
                    @builtin(local_invocation_id) localId: vec3<u32>,
                    @builtin(workgroup_id) workgroupId: vec3<u32>
                ) {
                    let targetIdx = workgroupId.x;
                    let tid = localId.x;
                    let dim = params.vectorDim;
                    let queryIdx = params.queryIndex;
                    
                    if (targetIdx >= params.numVectors) {
                        return;
                    }
                    
                    // Each thread processes a portion of the vector
                    var dot: f32 = 0.0;
                    var normA: f32 = 0.0;
                    var normB: f32 = 0.0;
                    
                    // Stride through dimension
                    for (var i = tid; i < dim; i = i + 256u) {
                        let a = vectors[queryIdx * dim + i];
                        let b = vectors[targetIdx * dim + i];
                        dot = dot + a * b;
                        normA = normA + a * a;
                        normB = normB + b * b;
                    }
                    
                    // Store in shared memory
                    sharedDot[tid] = dot;
                    sharedNormA[tid] = normA;
                    sharedNormB[tid] = normB;
                    
                    workgroupBarrier();
                    
                    // Parallel reduction
                    for (var s = 128u; s > 0u; s = s >> 1u) {
                        if (tid < s) {
                            sharedDot[tid] = sharedDot[tid] + sharedDot[tid + s];
                            sharedNormA[tid] = sharedNormA[tid] + sharedNormA[tid + s];
                            sharedNormB[tid] = sharedNormB[tid] + sharedNormB[tid + s];
                        }
                        workgroupBarrier();
                    }
                    
                    // Thread 0 writes result
                    if (tid == 0u) {
                        let finalDot = sharedDot[0];
                        let finalNormA = sqrt(sharedNormA[0]);
                        let finalNormB = sqrt(sharedNormB[0]);
                        
                        var similarity: f32 = 0.0;
                        if (finalNormA > 0.0 && finalNormB > 0.0) {
                            similarity = finalDot / (finalNormA * finalNormB);
                        }
                        
                        output[targetIdx] = similarity;
                    }
                }
            `;
            
            // Batch distance shader - all-pairs similarity matrix
            const batchDistanceCode = `
                struct Params {
                    numVectors: u32,
                    vectorDim: u32,
                    padding1: u32,
                    padding2: u32
                }
                
                @group(0) @binding(0) var<storage, read> vectors: array<f32>;
                @group(0) @binding(1) var<storage, read_write> output: array<f32>;
                @group(0) @binding(2) var<uniform> params: Params;
                
                @compute @workgroup_size(16, 16)
                fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {
                    let i = globalId.x;
                    let j = globalId.y;
                    let n = params.numVectors;
                    let dim = params.vectorDim;
                    
                    if (i >= n || j >= n || i >= j) {
                        return;
                    }
                    
                    // Compute cosine similarity between vectors i and j
                    var dot: f32 = 0.0;
                    var normI: f32 = 0.0;
                    var normJ: f32 = 0.0;
                    
                    for (var k = 0u; k < dim; k = k + 1u) {
                        let a = vectors[i * dim + k];
                        let b = vectors[j * dim + k];
                        dot = dot + a * b;
                        normI = normI + a * a;
                        normJ = normJ + b * b;
                    }
                    
                    var similarity: f32 = 0.0;
                    if (normI > 0.0 && normJ > 0.0) {
                        similarity = dot / (sqrt(normI) * sqrt(normJ));
                    }
                    
                    // Store in both positions (symmetric matrix)
                    output[i * n + j] = similarity;
                    output[j * n + i] = similarity;
                }
            `;
            
            // Top-K finder shader
            const topKCode = `
                struct Params {
                    numValues: u32,
                    k: u32,
                    threshold: f32,
                    padding: u32
                }
                
                @group(0) @binding(0) var<storage, read> values: array<f32>;
                @group(0) @binding(1) var<storage, read_write> topIndices: array<u32>;
                @group(0) @binding(2) var<storage, read_write> topValues: array<f32>;
                @group(0) @binding(3) var<uniform> params: Params;
                
                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {
                    let tid = globalId.x;
                    let n = params.numValues;
                    let k = params.k;
                    let threshold = params.threshold;
                    
                    if (tid >= k) {
                        return;
                    }
                    
                    // Simple insertion sort to find top-k
                    // Each thread finds the (tid+1)th largest value
                    var count: u32 = 0u;
                    var targetValue: f32 = -1.0;
                    var targetIndex: u32 = 0u;
                    
                    for (var i = 0u; i < n; i = i + 1u) {
                        let val = values[i];
                        if (val >= threshold) {
                            var rank: u32 = 0u;
                            for (var j = 0u; j < n; j = j + 1u) {
                                if (values[j] > val || (values[j] == val && j < i)) {
                                    rank = rank + 1u;
                                }
                            }
                            if (rank == tid) {
                                targetValue = val;
                                targetIndex = i;
                                break;
                            }
                        }
                    }
                    
                    topIndices[tid] = targetIndex;
                    topValues[tid] = targetValue;
                }
            `;
            
            try {
                this.cosineSimilarityShader = this.device.createShaderModule({
                    code: cosineSimilarityCode,
                    label: 'Cosine Similarity Shader'
                });
                
                this.batchDistanceShader = this.device.createShaderModule({
                    code: batchDistanceCode,
                    label: 'Batch Distance Shader'
                });
                
                this.topKShader = this.device.createShaderModule({
                    code: topKCode,
                    label: 'Top-K Shader'
                });
                
                console.log('✓ WebGPU compute shaders compiled');
            } catch (e) {
                console.error('Shader compilation failed:', e);
                throw e;
            }
        }
        
        /**
         * Compute cosine similarity between a query vector and all target vectors
         * Returns array of similarities
         */
        async cosineSimilarityBatch(queryVector, targetVectors) {
            if (!this.supported || !this.device) {
                return this.cosineSimilarityCPU(queryVector, targetVectors);
            }
            
            const startTime = performance.now();
            const numTargets = targetVectors.length;
            const dim = queryVector.length;
            
            if (numTargets === 0) return [];
            
            try {
                // Flatten all vectors (query first, then targets)
                const allVectors = new Float32Array((numTargets + 1) * dim);
                allVectors.set(queryVector, 0);
                for (let i = 0; i < numTargets; i++) {
                    allVectors.set(targetVectors[i], (i + 1) * dim);
                }
                
                // Create buffers
                const vectorBuffer = this.device.createBuffer({
                    size: allVectors.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    label: 'Vector Buffer'
                });
                
                const outputBuffer = this.device.createBuffer({
                    size: (numTargets + 1) * 4, // f32 per target
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                    label: 'Output Buffer'
                });
                
                const readBuffer = this.device.createBuffer({
                    size: (numTargets + 1) * 4,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                    label: 'Read Buffer'
                });
                
                const paramsBuffer = this.device.createBuffer({
                    size: 16, // 4 u32s
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    label: 'Params Buffer'
                });
                
                // Write data
                this.device.queue.writeBuffer(vectorBuffer, 0, allVectors);
                this.device.queue.writeBuffer(paramsBuffer, 0, new Uint32Array([
                    numTargets + 1, // numVectors
                    dim,            // vectorDim
                    0,              // queryIndex (first vector)
                    0               // padding
                ]));
                
                // Create pipeline
                const pipeline = this.device.createComputePipeline({
                    layout: 'auto',
                    compute: {
                        module: this.cosineSimilarityShader,
                        entryPoint: 'main'
                    }
                });
                
                // Create bind group
                const bindGroup = this.device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: vectorBuffer } },
                        { binding: 1, resource: { buffer: outputBuffer } },
                        { binding: 2, resource: { buffer: paramsBuffer } }
                    ]
                });
                
                // Dispatch compute
                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(numTargets + 1); // One workgroup per target
                passEncoder.end();
                
                // Copy output to read buffer
                commandEncoder.copyBufferToBuffer(
                    outputBuffer, 0,
                    readBuffer, 0,
                    (numTargets + 1) * 4
                );
                
                // Submit
                this.device.queue.submit([commandEncoder.finish()]);
                
                // Read results
                await readBuffer.mapAsync(GPUMapMode.READ);
                const results = new Float32Array(readBuffer.getMappedRange().slice(0));
                readBuffer.unmap();
                
                // Cleanup
                vectorBuffer.destroy();
                outputBuffer.destroy();
                readBuffer.destroy();
                paramsBuffer.destroy();
                
                // Skip first result (query vs itself)
                const similarities = Array.from(results.slice(1));
                
                // Update stats
                this.stats.gpuComputeTime += performance.now() - startTime;
                this.stats.operationCount++;
                this.stats.lastBatchSize = numTargets;
                
                return similarities;
                
            } catch (e) {
                console.warn('GPU compute failed, falling back to CPU:', e);
                return this.cosineSimilarityCPU(queryVector, targetVectors);
            }
        }
        
        /**
         * Compute all-pairs similarity matrix
         * Returns flattened upper triangular matrix
         */
        async allPairsSimilarity(vectors) {
            if (!this.supported || !this.device || vectors.length < 2) {
                return this.allPairsSimilarityCPU(vectors);
            }
            
            const startTime = performance.now();
            const n = vectors.length;
            const dim = vectors[0].length;
            
            // For small n, CPU might be faster
            if (n < 20) {
                return this.allPairsSimilarityCPU(vectors);
            }
            
            try {
                // Flatten vectors
                const flatVectors = new Float32Array(n * dim);
                for (let i = 0; i < n; i++) {
                    flatVectors.set(vectors[i], i * dim);
                }
                
                // Create buffers
                const vectorBuffer = this.device.createBuffer({
                    size: flatVectors.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                });
                
                const outputBuffer = this.device.createBuffer({
                    size: n * n * 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
                });
                
                const readBuffer = this.device.createBuffer({
                    size: n * n * 4,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                });
                
                const paramsBuffer = this.device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                
                // Write data
                this.device.queue.writeBuffer(vectorBuffer, 0, flatVectors);
                this.device.queue.writeBuffer(paramsBuffer, 0, new Uint32Array([n, dim, 0, 0]));
                
                // Create pipeline
                const pipeline = this.device.createComputePipeline({
                    layout: 'auto',
                    compute: {
                        module: this.batchDistanceShader,
                        entryPoint: 'main'
                    }
                });
                
                const bindGroup = this.device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: vectorBuffer } },
                        { binding: 1, resource: { buffer: outputBuffer } },
                        { binding: 2, resource: { buffer: paramsBuffer } }
                    ]
                });
                
                // Dispatch - 16x16 workgroups
                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(
                    Math.ceil(n / 16),
                    Math.ceil(n / 16)
                );
                passEncoder.end();
                
                commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, n * n * 4);
                this.device.queue.submit([commandEncoder.finish()]);
                
                await readBuffer.mapAsync(GPUMapMode.READ);
                const matrix = new Float32Array(readBuffer.getMappedRange().slice(0));
                readBuffer.unmap();
                
                // Cleanup
                vectorBuffer.destroy();
                outputBuffer.destroy();
                readBuffer.destroy();
                paramsBuffer.destroy();
                
                // Convert to pairs array
                const pairs = [];
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const similarity = matrix[i * n + j];
                        if (similarity > 0) {
                            pairs.push({ i, j, similarity });
                        }
                    }
                }
                
                this.stats.gpuComputeTime += performance.now() - startTime;
                this.stats.operationCount++;
                this.stats.lastBatchSize = n * n;
                
                return pairs;
                
            } catch (e) {
                console.warn('GPU all-pairs failed, falling back to CPU:', e);
                return this.allPairsSimilarityCPU(vectors);
            }
        }
        
        /**
         * Find top-K most similar vectors to query
         */
        async topKSimilar(queryVector, targetVectors, k = 10, threshold = 0.5) {
            // Get all similarities first
            const similarities = await this.cosineSimilarityBatch(queryVector, targetVectors);
            
            // Create indexed array and sort (CPU is fine for this part)
            const indexed = similarities.map((sim, idx) => ({ idx, sim }))
                .filter(x => x.sim >= threshold)
                .sort((a, b) => b.sim - a.sim)
                .slice(0, k);
            
            return indexed;
        }
        
        /**
         * Find structural holes - pairs of vectors that are similar but might be unconnected
         */
        async findStructuralHoles(embeddings, nodeIds, threshold = 0.7) {
            const pairs = await this.allPairsSimilarity(embeddings);
            
            // Filter by threshold and return with node IDs
            return pairs
                .filter(p => p.similarity >= threshold)
                .map(p => ({
                    nodeA: nodeIds[p.i],
                    nodeB: nodeIds[p.j],
                    similarity: p.similarity
                }))
                .sort((a, b) => b.similarity - a.similarity);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // CPU FALLBACK IMPLEMENTATIONS (SIMD-optimized where possible)
        // ═══════════════════════════════════════════════════════════════
        
        /**
         * CPU fallback for cosine similarity batch
         * Uses loop unrolling for better performance
         */
        cosineSimilarityCPU(queryVector, targetVectors) {
            const startTime = performance.now();
            const results = [];
            const qLen = queryVector.length;
            
            // Pre-compute query norm
            let qNorm = 0;
            for (let i = 0; i < qLen; i++) {
                qNorm += queryVector[i] * queryVector[i];
            }
            qNorm = Math.sqrt(qNorm);
            
            if (qNorm === 0) {
                return targetVectors.map(() => 0);
            }
            
            for (const target of targetVectors) {
                let dot = 0;
                let tNorm = 0;
                
                // Unroll loop by 4
                const len4 = qLen - (qLen % 4);
                for (let i = 0; i < len4; i += 4) {
                    dot += queryVector[i] * target[i]
                         + queryVector[i+1] * target[i+1]
                         + queryVector[i+2] * target[i+2]
                         + queryVector[i+3] * target[i+3];
                    tNorm += target[i] * target[i]
                           + target[i+1] * target[i+1]
                           + target[i+2] * target[i+2]
                           + target[i+3] * target[i+3];
                }
                
                // Handle remainder
                for (let i = len4; i < qLen; i++) {
                    dot += queryVector[i] * target[i];
                    tNorm += target[i] * target[i];
                }
                
                tNorm = Math.sqrt(tNorm);
                results.push(tNorm > 0 ? dot / (qNorm * tNorm) : 0);
            }
            
            this.stats.cpuFallbackTime += performance.now() - startTime;
            return results;
        }
        
        /**
         * CPU fallback for all-pairs similarity
         */
        allPairsSimilarityCPU(vectors) {
            const startTime = performance.now();
            const n = vectors.length;
            const pairs = [];
            
            // Pre-compute all norms
            const norms = vectors.map(v => {
                let norm = 0;
                for (let i = 0; i < v.length; i++) {
                    norm += v[i] * v[i];
                }
                return Math.sqrt(norm);
            });
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (norms[i] === 0 || norms[j] === 0) {
                        continue;
                    }
                    
                    let dot = 0;
                    const vi = vectors[i];
                    const vj = vectors[j];
                    const len = vi.length;
                    
                    // Unroll by 4
                    const len4 = len - (len % 4);
                    for (let k = 0; k < len4; k += 4) {
                        dot += vi[k] * vj[k]
                             + vi[k+1] * vj[k+1]
                             + vi[k+2] * vj[k+2]
                             + vi[k+3] * vj[k+3];
                    }
                    for (let k = len4; k < len; k++) {
                        dot += vi[k] * vj[k];
                    }
                    
                    const similarity = dot / (norms[i] * norms[j]);
                    if (similarity > 0) {
                        pairs.push({ i, j, similarity });
                    }
                }
            }
            
            this.stats.cpuFallbackTime += performance.now() - startTime;
            return pairs;
        }
        
        /**
         * Get performance statistics
         */
        getStats() {
            return {
                ...this.stats,
                supported: this.supported,
                gpuInfo: this.adapter?.info || null,
                avgGpuTime: this.stats.operationCount > 0 
                    ? (this.stats.gpuComputeTime / this.stats.operationCount).toFixed(2) + 'ms'
                    : 'N/A'
            };
        }
        
        /**
         * Benchmark GPU vs CPU
         */
        async benchmark(vectorCount = 100, vectorDim = 384) {
            console.log(`\n🔬 WebGPU Benchmark: ${vectorCount} vectors × ${vectorDim} dimensions`);
            
            // Generate random test vectors
            const vectors = [];
            for (let i = 0; i < vectorCount; i++) {
                const v = new Float32Array(vectorDim);
                for (let j = 0; j < vectorDim; j++) {
                    v[j] = Math.random() * 2 - 1;
                }
                vectors.push(v);
            }
            
            const query = vectors[0];
            const targets = vectors.slice(1);
            
            // CPU benchmark
            const cpuStart = performance.now();
            const cpuResult = this.cosineSimilarityCPU(query, targets);
            const cpuTime = performance.now() - cpuStart;
            
            // GPU benchmark (if available)
            let gpuTime = null;
            let gpuResult = null;
            
            if (this.supported) {
                const gpuStart = performance.now();
                gpuResult = await this.cosineSimilarityBatch(query, targets);
                gpuTime = performance.now() - gpuStart;
            }
            
            // All-pairs CPU
            const cpuAllStart = performance.now();
            this.allPairsSimilarityCPU(vectors.slice(0, Math.min(50, vectorCount)));
            const cpuAllTime = performance.now() - cpuAllStart;
            
            // All-pairs GPU
            let gpuAllTime = null;
            if (this.supported) {
                const gpuAllStart = performance.now();
                await this.allPairsSimilarity(vectors.slice(0, Math.min(50, vectorCount)));
                gpuAllTime = performance.now() - gpuAllStart;
            }
            
            const results = {
                vectorCount,
                vectorDim,
                batchSimilarity: {
                    cpu: cpuTime.toFixed(2) + 'ms',
                    gpu: gpuTime ? gpuTime.toFixed(2) + 'ms' : 'N/A',
                    speedup: gpuTime ? (cpuTime / gpuTime).toFixed(2) + 'x' : 'N/A'
                },
                allPairs: {
                    cpu: cpuAllTime.toFixed(2) + 'ms',
                    gpu: gpuAllTime ? gpuAllTime.toFixed(2) + 'ms' : 'N/A',
                    speedup: gpuAllTime ? (cpuAllTime / gpuAllTime).toFixed(2) + 'x' : 'N/A'
                }
            };
            
            console.log('Results:', results);
            return results;
        }
        
        /**
         * Cleanup resources
         */
        destroy() {
            this.bufferCache.forEach(buf => buf.destroy());
            this.bufferCache.clear();
            this.device = null;
            this.adapter = null;
            this.initialized = false;
            this.supported = false;
        }
    }
    
    // Global WebGPU Compute instance
    const gpuCompute = new WebGPUCompute();
    
    // ═══════════════════════════════════════════════════════════════════
    // REAL SEMANTIC ENGINE - Transformers.js Integration
    // ═══════════════════════════════════════════════════════════════════
    
    /**
     * SemanticEngine - Real transformer-based embeddings
     * 
     * Uses Hugging Face Transformers.js to run actual neural networks
     * in the browser. This provides REAL semantic understanding:
     * - "project" and "initiative" are recognized as similar
     * - "budget" and "cost" cluster together
     * - Actual meaning, not keyword matching
     * 
     * Model: all-MiniLM-L6-v2 (22MB, 384-dimensional embeddings)
     */
    class SemanticEngine {
        constructor() {
            this.pipeline = null;
            this.tokenizer = null;
            this.model = null;
            
            this.initialized = false;
            this.initializing = false;
            this.loadProgress = 0;
            
            // Embedding cache (nodeId → embedding)
            this.embeddingCache = new Map();
            
            // Batch queue for efficient processing
            this.batchQueue = [];
            this.batchTimeout = null;
            this.batchSize = 16;
            this.batchDelayMs = 100;
            
            // Model configuration
            this.modelId = 'Xenova/all-MiniLM-L6-v2';
            this.embeddingDim = 384;
            
            // Stats
            this.stats = {
                embeddingsGenerated: 0,
                cacheHits: 0,
                avgInferenceTime: 0,
                totalInferenceTime: 0
            };
            
            // Callbacks for progress updates
            this.onProgress = null;
            this.onReady = null;
        }
        
        /**
         * Initialize the transformer model
         */
        async initialize() {
            if (this.initialized) return true;
            if (this.initializing) {
                // Wait for ongoing initialization
                return new Promise((resolve) => {
                    const check = setInterval(() => {
                        if (this.initialized) {
                            clearInterval(check);
                            resolve(true);
                        }
                    }, 100);
                });
            }
            
            this.initializing = true;
            
            try {
                console.log('🧠 Loading Transformers.js semantic model...');
                
                // Dynamic import of transformers.js
                const { pipeline, env } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                
                // Configure for browser
                env.allowLocalModels = false;
                env.useBrowserCache = true;
                
                // Create feature extraction pipeline with progress callback
                this.pipeline = await pipeline('feature-extraction', this.modelId, {
                    progress_callback: (progress) => {
                        if (progress.status === 'downloading') {
                            this.loadProgress = Math.round((progress.loaded / progress.total) * 100) || 0;
                            console.log(`📥 Downloading model: ${this.loadProgress}%`);
                            if (this.onProgress) {
                                this.onProgress(this.loadProgress, 'downloading');
                            }
                        } else if (progress.status === 'ready') {
                            console.log('✓ Model ready');
                        }
                    },
                    quantized: true // Use quantized model for faster inference
                });
                
                this.initialized = true;
                this.initializing = false;
                this.loadProgress = 100;
                
                console.log('✓ SemanticEngine initialized with', this.modelId);
                console.log(`  Embedding dimension: ${this.embeddingDim}`);
                
                if (this.onReady) {
                    this.onReady();
                }
                
                return true;
                
            } catch (e) {
                console.error('SemanticEngine initialization failed:', e);
                this.initializing = false;
                return false;
            }
        }
        
        /**
         * Generate embedding for a single text
         */
        async embed(text, options = {}) {
            if (!this.initialized) {
                const ready = await this.initialize();
                if (!ready) return null;
            }
            
            const cacheKey = options.cacheKey || text;
            
            // Check cache
            if (this.embeddingCache.has(cacheKey) && !options.forceRecompute) {
                this.stats.cacheHits++;
                return this.embeddingCache.get(cacheKey);
            }
            
            try {
                const startTime = performance.now();
                
                // Run inference
                const output = await this.pipeline(text, {
                    pooling: 'mean',
                    normalize: true
                });
                
                // Extract embedding array
                const embedding = Array.from(output.data);
                
                // Update stats
                const inferenceTime = performance.now() - startTime;
                this.stats.totalInferenceTime += inferenceTime;
                this.stats.embeddingsGenerated++;
                this.stats.avgInferenceTime = this.stats.totalInferenceTime / this.stats.embeddingsGenerated;
                
                // Cache result
                this.embeddingCache.set(cacheKey, embedding);
                
                return embedding;
                
            } catch (e) {
                console.error('Embedding generation failed:', e);
                return null;
            }
        }
        
        /**
         * Generate embeddings for multiple texts (batched)
         */
        async embedBatch(texts, options = {}) {
            if (!this.initialized) {
                const ready = await this.initialize();
                if (!ready) return texts.map(() => null);
            }
            
            const results = [];
            const toCompute = [];
            const toComputeIndices = [];
            
            // Check cache first
            for (let i = 0; i < texts.length; i++) {
                const cacheKey = options.cacheKeys?.[i] || texts[i];
                if (this.embeddingCache.has(cacheKey) && !options.forceRecompute) {
                    results[i] = this.embeddingCache.get(cacheKey);
                    this.stats.cacheHits++;
                } else {
                    toCompute.push(texts[i]);
                    toComputeIndices.push(i);
                    results[i] = null;
                }
            }
            
            // Compute missing embeddings
            if (toCompute.length > 0) {
                const startTime = performance.now();
                
                // Process in batches
                for (let i = 0; i < toCompute.length; i += this.batchSize) {
                    const batch = toCompute.slice(i, i + this.batchSize);
                    const batchIndices = toComputeIndices.slice(i, i + this.batchSize);
                    
                    try {
                        // Run batch inference
                        const outputs = await this.pipeline(batch, {
                            pooling: 'mean',
                            normalize: true
                        });
                        
                        // Extract embeddings
                        for (let j = 0; j < batch.length; j++) {
                            const embedding = Array.from(outputs[j].data);
                            const originalIndex = batchIndices[j];
                            const cacheKey = options.cacheKeys?.[originalIndex] || texts[originalIndex];
                            
                            results[originalIndex] = embedding;
                            this.embeddingCache.set(cacheKey, embedding);
                        }
                    } catch (e) {
                        console.error('Batch embedding failed:', e);
                        // Fill with nulls for failed batch
                        for (const idx of batchIndices) {
                            results[idx] = null;
                        }
                    }
                }
                
                const inferenceTime = performance.now() - startTime;
                this.stats.totalInferenceTime += inferenceTime;
                this.stats.embeddingsGenerated += toCompute.length;
                this.stats.avgInferenceTime = this.stats.totalInferenceTime / this.stats.embeddingsGenerated;
            }
            
            return results;
        }
        
        /**
         * Queue a text for embedding (batched processing)
         */
        queueEmbed(text, cacheKey, callback) {
            this.batchQueue.push({ text, cacheKey, callback });
            
            // Clear existing timeout
            if (this.batchTimeout) {
                clearTimeout(this.batchTimeout);
            }
            
            // Process when batch is full or after delay
            if (this.batchQueue.length >= this.batchSize) {
                this.processBatchQueue();
            } else {
                this.batchTimeout = setTimeout(() => {
                    this.processBatchQueue();
                }, this.batchDelayMs);
            }
        }
        
        /**
         * Process queued embeddings
         */
        async processBatchQueue() {
            if (this.batchQueue.length === 0) return;
            
            const batch = this.batchQueue.splice(0, this.batchSize);
            const texts = batch.map(b => b.text);
            const cacheKeys = batch.map(b => b.cacheKey);
            
            const embeddings = await this.embedBatch(texts, { cacheKeys });
            
            // Call callbacks
            for (let i = 0; i < batch.length; i++) {
                if (batch[i].callback) {
                    batch[i].callback(embeddings[i]);
                }
            }
        }
        
        /**
         * Compute cosine similarity between two embeddings
         */
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dot = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dot += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude > 0 ? dot / magnitude : 0;
        }
        
        /**
         * Find most similar texts to a query
         */
        async findSimilar(queryText, candidateTexts, topK = 5, threshold = 0.5) {
            const queryEmbedding = await this.embed(queryText);
            if (!queryEmbedding) return [];
            
            const candidateEmbeddings = await this.embedBatch(candidateTexts);
            
            const similarities = [];
            for (let i = 0; i < candidateTexts.length; i++) {
                if (candidateEmbeddings[i]) {
                    const sim = this.cosineSimilarity(queryEmbedding, candidateEmbeddings[i]);
                    if (sim >= threshold) {
                        similarities.push({
                            index: i,
                            text: candidateTexts[i],
                            similarity: sim
                        });
                    }
                }
            }
            
            // Sort by similarity and return top K
            similarities.sort((a, b) => b.similarity - a.similarity);
            return similarities.slice(0, topK);
        }
        
        /**
         * Cluster texts using K-means on embeddings
         */
        async clusterTexts(texts, numClusters = 5) {
            const embeddings = await this.embedBatch(texts);
            const validEmbeddings = [];
            const validIndices = [];
            
            for (let i = 0; i < embeddings.length; i++) {
                if (embeddings[i]) {
                    validEmbeddings.push(embeddings[i]);
                    validIndices.push(i);
                }
            }
            
            if (validEmbeddings.length < numClusters) {
                return null;
            }
            
            // Simple K-means clustering
            const clusters = this.kMeans(validEmbeddings, numClusters);
            
            // Map back to original indices
            const result = new Array(texts.length).fill(-1);
            for (let i = 0; i < validIndices.length; i++) {
                result[validIndices[i]] = clusters.assignments[i];
            }
            
            return {
                assignments: result,
                centroids: clusters.centroids,
                inertia: clusters.inertia
            };
        }
        
        /**
         * K-means clustering implementation
         */
        kMeans(embeddings, k, maxIter = 50) {
            const n = embeddings.length;
            if (n === 0 || !embeddings[0]) {
                return { centroids: [], assignments: [], inertia: 0 };
            }
            const dim = embeddings[0].length;
            
            // Initialize centroids randomly
            const centroidIndices = [];
            while (centroidIndices.length < k) {
                const idx = Math.floor(Math.random() * n);
                if (!centroidIndices.includes(idx)) {
                    centroidIndices.push(idx);
                }
            }
            let centroids = centroidIndices.map(i => [...embeddings[i]]);
            
            let assignments = new Array(n).fill(0);
            let inertia = Infinity;
            
            for (let iter = 0; iter < maxIter; iter++) {
                // Assign points to nearest centroid
                const newAssignments = [];
                let newInertia = 0;
                
                for (let i = 0; i < n; i++) {
                    let minDist = Infinity;
                    let minCluster = 0;
                    
                    for (let c = 0; c < k; c++) {
                        const dist = this.euclideanDistance(embeddings[i], centroids[c]);
                        if (dist < minDist) {
                            minDist = dist;
                            minCluster = c;
                        }
                    }
                    
                    newAssignments.push(minCluster);
                    newInertia += minDist * minDist;
                }
                
                // Check for convergence
                if (JSON.stringify(assignments) === JSON.stringify(newAssignments)) {
                    break;
                }
                
                assignments = newAssignments;
                inertia = newInertia;
                
                // Update centroids
                const clusterSums = Array(k).fill(null).map(() => new Array(dim).fill(0));
                const clusterCounts = new Array(k).fill(0);
                
                for (let i = 0; i < n; i++) {
                    const c = assignments[i];
                    clusterCounts[c]++;
                    for (let d = 0; d < dim; d++) {
                        clusterSums[c][d] += embeddings[i][d];
                    }
                }
                
                for (let c = 0; c < k; c++) {
                    if (clusterCounts[c] > 0) {
                        for (let d = 0; d < dim; d++) {
                            centroids[c][d] = clusterSums[c][d] / clusterCounts[c];
                        }
                    }
                }
            }
            
            return { assignments, centroids, inertia };
        }
        
        euclideanDistance(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) {
                const diff = a[i] - b[i];
                sum += diff * diff;
            }
            return Math.sqrt(sum);
        }
        
        /**
         * Get embedding for a node (with description context)
         */
        async embedNode(node) {
            const text = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            return this.embed(text, { cacheKey: `node:${node.id}` });
        }
        
        /**
         * Embed all nodes in the graph
         */
        async embedGraph(rootNode) {
            const allNodes = this.collectAllNodes(rootNode);
            const texts = allNodes.map(n => 
                n.description ? `${n.label}. ${n.description}` : n.label
            );
            const cacheKeys = allNodes.map(n => `node:${n.id}`);
            
            const embeddings = await this.embedBatch(texts, { cacheKeys });
            
            const nodeEmbeddings = new Map();
            for (let i = 0; i < allNodes.length; i++) {
                if (embeddings[i]) {
                    nodeEmbeddings.set(allNodes[i].id, embeddings[i]);
                }
            }
            
            return nodeEmbeddings;
        }
        
        collectAllNodes(node, result = []) {
            if (!node) return result;
            result.push(node);
            if (node.children) {
                for (const child of node.children) {
                    this.collectAllNodes(child, result);
                }
            }
            return result;
        }
        
        /**
         * Find semantically similar nodes (GPU-accelerated when available)
         */
        async findSimilarNodes(queryNodeId, store, topK = 5, threshold = 0.6) {
            const allNodes = this.collectAllNodes(store.data);
            const queryNode = allNodes.find(n => n.id === queryNodeId);
            if (!queryNode) return [];
            
            // Get all embeddings
            const embeddings = await this.embedGraph(store.data);
            const queryEmbedding = embeddings.get(queryNodeId);
            if (!queryEmbedding) return [];
            
            // Prepare for similarity search
            const otherNodes = allNodes.filter(n => n.id !== queryNodeId);
            const otherEmbeddings = otherNodes.map(n => embeddings.get(n.id)).filter(e => e);
            const validNodes = otherNodes.filter(n => embeddings.get(n.id));
            
            // Use GPU if available
            let similarities;
            if (typeof gpuCompute !== 'undefined' && gpuCompute.supported && otherEmbeddings.length > 20) {
                similarities = await gpuCompute.cosineSimilarityBatch(queryEmbedding, otherEmbeddings);
            } else {
                similarities = otherEmbeddings.map(e => this.cosineSimilarity(queryEmbedding, e));
            }
            
            // Build results
            const results = [];
            for (let i = 0; i < validNodes.length; i++) {
                if (similarities[i] >= threshold) {
                    results.push({
                        node: validNodes[i],
                        similarity: similarities[i]
                    });
                }
            }
            
            results.sort((a, b) => b.similarity - a.similarity);
            return results.slice(0, topK);
        }
        
        /**
         * Find structural holes using real semantic similarity
         */
        async findSemanticStructuralHoles(store, threshold = 0.7) {
            const allNodes = this.collectAllNodes(store.data);
            if (allNodes.length < 2) return [];
            
            // Build adjacency
            const adjacency = new Map();
            const buildAdj = (node, parentId = null) => {
                if (!adjacency.has(node.id)) adjacency.set(node.id, new Set());
                if (parentId) {
                    adjacency.get(node.id).add(parentId);
                    if (!adjacency.has(parentId)) adjacency.set(parentId, new Set());
                    adjacency.get(parentId).add(node.id);
                }
                if (node.children) {
                    for (const child of node.children) {
                        buildAdj(child, node.id);
                    }
                }
            };
            buildAdj(store.data);
            
            // Get embeddings
            const embeddings = await this.embedGraph(store.data);
            const nodesWithEmbeddings = allNodes.filter(n => embeddings.get(n.id));
            const embeddingArray = nodesWithEmbeddings.map(n => embeddings.get(n.id));
            
            if (embeddingArray.length < 2) return [];
            
            // Use GPU for all-pairs similarity
            let pairs;
            if (typeof gpuCompute !== 'undefined' && gpuCompute.supported && embeddingArray.length > 10) {
                pairs = await gpuCompute.allPairsSimilarity(embeddingArray);
            } else {
                pairs = [];
                for (let i = 0; i < embeddingArray.length; i++) {
                    for (let j = i + 1; j < embeddingArray.length; j++) {
                        const sim = this.cosineSimilarity(embeddingArray[i], embeddingArray[j]);
                        if (sim > 0) pairs.push({ i, j, similarity: sim });
                    }
                }
            }
            
            // Filter by threshold and not-connected
            const holes = [];
            for (const pair of pairs) {
                if (pair.similarity < threshold) continue;
                
                const nodeA = nodesWithEmbeddings[pair.i];
                const nodeB = nodesWithEmbeddings[pair.j];
                
                // Check if connected
                const neighborsA = adjacency.get(nodeA.id) || new Set();
                if (neighborsA.has(nodeB.id)) continue;
                
                holes.push({
                    nodeA: { id: nodeA.id, label: nodeA.label },
                    nodeB: { id: nodeB.id, label: nodeB.label },
                    similarity: pair.similarity,
                    reason: `Semantically similar (${(pair.similarity * 100).toFixed(0)}%) but unconnected`
                });
            }
            
            holes.sort((a, b) => b.similarity - a.similarity);
            return holes.slice(0, 10);
        }
        
        /**
         * Detect topic clusters in the graph
         */
        async detectTopicClusters(store, numClusters = 'auto') {
            const allNodes = this.collectAllNodes(store.data);
            if (allNodes.length < 3) return null;
            
            const texts = allNodes.map(n => 
                n.description ? `${n.label}. ${n.description}` : n.label
            );
            
            // Auto-detect number of clusters
            if (numClusters === 'auto') {
                numClusters = Math.max(2, Math.min(10, Math.floor(Math.sqrt(allNodes.length / 2))));
            }
            
            const clustering = await this.clusterTexts(texts, numClusters);
            if (!clustering || !clustering.assignments || clustering.assignments.length === 0) {
                return null;
            }
            
            // Build cluster info
            const clusters = [];
            for (let c = 0; c < numClusters; c++) {
                const clusterNodes = allNodes.filter((_, i) => clustering.assignments[i] === c);
                if (clusterNodes.length === 0) continue;
                
                // Find representative label (most central node)
                const clusterTexts = clusterNodes.map(n => n.label);
                const commonWords = this.findCommonWords(clusterTexts);
                
                clusters.push({
                    id: c,
                    nodes: clusterNodes,
                    size: clusterNodes.length,
                    label: commonWords.slice(0, 3).join(', ') || `Cluster ${c + 1}`,
                    centroid: clustering.centroids ? clustering.centroids[c] : null
                });
            }
            
            return clusters.sort((a, b) => b.size - a.size);
        }
        
        findCommonWords(texts) {
            const wordCounts = new Map();
            const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'my', 'your', 'our', 'their', 'its']);
            
            for (const text of texts) {
                const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 2 && !stopWords.has(w));
                for (const word of words) {
                    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
                }
            }
            
            return [...wordCounts.entries()]
                .sort((a, b) => b[1] - a[1])
                .map(([word]) => word);
        }
        
        /**
         * Get statistics
         */
        getStats() {
            return {
                ...this.stats,
                cacheSize: this.embeddingCache.size,
                initialized: this.initialized,
                modelId: this.modelId,
                embeddingDim: this.embeddingDim
            };
        }
        
        /**
         * Export cache for persistence
         */
        exportCache() {
            return Object.fromEntries(this.embeddingCache);
        }
        
        /**
         * Import cache
         */
        importCache(data) {
            if (data) {
                for (const [key, value] of Object.entries(data)) {
                    this.embeddingCache.set(key, value);
                }
            }
        }
        
        /**
         * Save to IndexedDB
         */
        async save() {
            try {
                await NeuralDB.save('semantic-engine-cache', {
                    cache: this.exportCache(),
                    stats: this.stats
                });
            } catch (e) {
                console.error('Failed to save semantic cache:', e);
            }
        }
        
        /**
         * Load from IndexedDB
         */
        async load() {
            try {
                const data = await NeuralDB.load('semantic-engine-cache');
                if (data) {
                    this.importCache(data.cache);
                    if (data.stats) {
                        this.stats = { ...this.stats, ...data.stats };
                    }
                    console.log(`✓ Semantic cache loaded (${this.embeddingCache.size} embeddings)`);
                }
            } catch (e) {
                console.error('Failed to load semantic cache:', e);
            }
        }
        
        /**
         * Clear cache
         */
        clearCache() {
            this.embeddingCache.clear();
            this.stats = {
                embeddingsGenerated: 0,
                cacheHits: 0,
                avgInferenceTime: 0,
                totalInferenceTime: 0
            };
        }
    }
    
    // Global SemanticEngine instance
    const semanticEngine = new SemanticEngine();

    // ═══════════════════════════════════════════════════════════════════
    // CODE RAG SYSTEM - Retrieval-Augmented Generation for Codebase
    // ═══════════════════════════════════════════════════════════════════
    // Enables AI to understand and reference the actual MYND codebase
    // by chunking, embedding, and retrieving relevant code sections
    class CodeRAG {
        constructor() {
            this.chunks = [];
            this.embeddings = new Map(); // chunkId -> embedding vector
            this.encoder = null;
            this.initialized = false;
            this.isProcessing = false;
            this.STORAGE_KEY = 'mynd_code_rag';
            this.VERSION = '1.0'; // Increment to force re-chunking
        }

        // Initialize the system
        async initialize() {
            if (this.initialized || this.isProcessing) return this.initialized;
            this.isProcessing = true;

            console.log('📚 Initializing CodeRAG system...');

            try {
                // Try to load cached chunks and embeddings
                const cached = this.loadFromStorage();
                if (cached && cached.version === this.VERSION && cached.chunks.length > 0) {
                    this.chunks = cached.chunks;
                    cached.embeddings.forEach(([id, vec]) => this.embeddings.set(id, vec));
                    console.log(`✓ CodeRAG loaded ${this.chunks.length} cached chunks`);
                    this.initialized = true;
                    this.isProcessing = false;
                    return true;
                }

                // Need to chunk and embed the codebase
                console.log('📚 Chunking codebase (first run)...');
                await this.processCodebase();

                this.initialized = true;
                this.isProcessing = false;
                console.log(`✓ CodeRAG ready with ${this.chunks.length} chunks`);
                return true;

            } catch (error) {
                console.warn('CodeRAG initialization failed:', error);
                this.isProcessing = false;
                return false;
            }
        }

        // Set encoder (shared from neuralNet)
        setEncoder(encoder) {
            this.encoder = encoder;
        }

        // Process the entire codebase
        async processCodebase() {
            // Get the current page's HTML (the entire app)
            const code = document.documentElement.outerHTML;

            // Extract just the script content
            const scriptMatch = code.match(/<script>([\s\S]*?)<\/script>\s*<!--\s*External modules/);
            const scriptCode = scriptMatch ? scriptMatch[1] : code;

            // Chunk the code
            this.chunks = this.chunkCode(scriptCode);
            console.log(`📚 Created ${this.chunks.length} code chunks`);

            // Generate embeddings
            await this.embedChunks();

            // Save to storage
            this.saveToStorage();
        }

        // Parse code into semantic chunks
        chunkCode(code) {
            const chunks = [];
            const lines = code.split('\n');
            let chunkId = 0;

            // Pattern matchers for different code structures
            const patterns = {
                // Major section headers: // ═══════════ SECTION NAME ═══════════
                section: /\/\/\s*═+\s*(.+?)\s*═+/,
                // Class definitions
                classStart: /^\s*class\s+(\w+)/,
                // Function declarations (various forms)
                functionDecl: /^\s*(?:async\s+)?function\s+(\w+)\s*\(/,
                // Method/arrow function in object
                objectMethod: /^\s*(?:async\s+)?(\w+)\s*(?::\s*(?:async\s+)?function)?\s*\(|^\s*(\w+)\s*:\s*(?:async\s+)?\(/,
                // Arrow function assignment
                arrowFunc: /^\s*(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/,
                // Object/const declaration
                constDecl: /^\s*(?:const|let|var)\s+(\w+)\s*=\s*\{/,
            };

            let currentSection = 'Global';
            let currentClass = null;
            let braceDepth = 0;
            let inMultilineComment = false;

            // First pass: identify section headers and major structures
            const sections = [];
            let currentSectionStart = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // Track multiline comments
                if (line.includes('/*')) inMultilineComment = true;
                if (line.includes('*/')) inMultilineComment = false;
                if (inMultilineComment) continue;

                // Check for section header
                const sectionMatch = line.match(patterns.section);
                if (sectionMatch) {
                    // Save previous section
                    if (i > currentSectionStart + 5) {
                        sections.push({
                            name: currentSection,
                            startLine: currentSectionStart,
                            endLine: i - 1
                        });
                    }
                    currentSection = sectionMatch[1].trim();
                    currentSectionStart = i;
                }
            }
            // Add final section
            sections.push({
                name: currentSection,
                startLine: currentSectionStart,
                endLine: lines.length - 1
            });

            // Second pass: extract meaningful chunks from each section
            for (const section of sections) {
                const sectionLines = lines.slice(section.startLine, section.endLine + 1);
                const sectionCode = sectionLines.join('\n');

                // Skip very small sections
                if (sectionLines.length < 10) continue;

                // Extract functions and classes from this section
                const functionChunks = this.extractFunctions(sectionCode, section.name, section.startLine);
                chunks.push(...functionChunks);

                // Also create a section overview chunk
                const overviewLines = sectionLines.slice(0, Math.min(50, sectionLines.length));
                chunks.push({
                    id: `section-${chunkId++}`,
                    type: 'section',
                    name: section.name,
                    section: section.name,
                    startLine: section.startLine,
                    endLine: Math.min(section.startLine + 50, section.endLine),
                    code: overviewLines.join('\n'),
                    summary: `Section: ${section.name} (${section.endLine - section.startLine} lines)`
                });
            }

            return chunks;
        }

        // Extract functions from a code section
        extractFunctions(code, sectionName, baseLineNumber) {
            const chunks = [];
            const lines = code.split('\n');
            let chunkId = 0;

            // Regex patterns for function detection
            const funcPatterns = [
                // Standard function
                /(?:async\s+)?function\s+(\w+)\s*\([^)]*\)\s*\{/g,
                // Class method
                /^\s*(?:async\s+)?(\w+)\s*\([^)]*\)\s*\{/gm,
                // Arrow function assignment
                /(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\([^)]*\)\s*=>/g,
                // Object method
                /(\w+)\s*:\s*(?:async\s+)?function\s*\([^)]*\)\s*\{/g,
                /(\w+)\s*:\s*(?:async\s*)?\([^)]*\)\s*=>\s*\{/g,
            ];

            // Find function boundaries by matching braces
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // Check for function start
                let funcName = null;
                let funcMatch = null;

                // Try different patterns
                const stdFunc = line.match(/(?:async\s+)?function\s+(\w+)\s*\(/);
                const classMethod = line.match(/^\s*(?:async\s+)?(\w+)\s*\([^)]*\)\s*\{/);
                const arrowFunc = line.match(/(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s*)?\(/);
                const objMethod = line.match(/(\w+)\s*:\s*(?:async\s+)?(?:function)?\s*\(/);

                if (stdFunc) funcName = stdFunc[1];
                else if (classMethod && !line.includes('if') && !line.includes('for') && !line.includes('while')) funcName = classMethod[1];
                else if (arrowFunc) funcName = arrowFunc[1];
                else if (objMethod && !line.trim().startsWith('//')) funcName = objMethod[1];

                if (funcName && funcName.length > 1 && !['if', 'for', 'while', 'switch', 'catch', 'try'].includes(funcName)) {
                    // Find the end of this function by counting braces
                    let braceCount = 0;
                    let started = false;
                    let endLine = i;

                    for (let j = i; j < Math.min(i + 200, lines.length); j++) {
                        const checkLine = lines[j];
                        for (const char of checkLine) {
                            if (char === '{') { braceCount++; started = true; }
                            if (char === '}') braceCount--;
                        }
                        if (started && braceCount === 0) {
                            endLine = j;
                            break;
                        }
                    }

                    // Extract function code (limit to 100 lines for embedding efficiency)
                    const funcLines = lines.slice(i, Math.min(endLine + 1, i + 100));
                    const funcCode = funcLines.join('\n');

                    // Only keep substantial functions
                    if (funcLines.length >= 3) {
                        chunks.push({
                            id: `func-${sectionName.replace(/\s+/g, '-')}-${funcName}-${chunkId++}`,
                            type: 'function',
                            name: funcName,
                            section: sectionName,
                            startLine: baseLineNumber + i,
                            endLine: baseLineNumber + endLine,
                            code: funcCode,
                            summary: `Function ${funcName} in ${sectionName}`
                        });
                    }

                    // Skip past this function
                    i = endLine;
                }
            }

            return chunks;
        }

        // Generate embeddings for all chunks
        async embedChunks() {
            if (!this.encoder && !neuralNet?.encoder) {
                console.warn('CodeRAG: No encoder available, skipping embeddings');
                return;
            }

            const encoder = this.encoder || neuralNet.encoder;
            console.log(`📚 Embedding ${this.chunks.length} code chunks...`);

            // Process in batches to avoid memory issues
            const batchSize = 20;
            for (let i = 0; i < this.chunks.length; i += batchSize) {
                const batch = this.chunks.slice(i, i + batchSize);
                const texts = batch.map(chunk => {
                    // Create searchable text from chunk
                    return `${chunk.name} ${chunk.section} ${chunk.type}: ${chunk.code.substring(0, 500)}`;
                });

                try {
                    const embeddings = await encoder.embed(texts);
                    const vectors = await embeddings.array();
                    embeddings.dispose();

                    batch.forEach((chunk, idx) => {
                        this.embeddings.set(chunk.id, vectors[idx]);
                    });

                    // Progress update
                    if ((i + batchSize) % 100 === 0 || i + batchSize >= this.chunks.length) {
                        console.log(`📚 Embedded ${Math.min(i + batchSize, this.chunks.length)}/${this.chunks.length} chunks`);
                    }
                } catch (error) {
                    console.warn(`CodeRAG embedding batch ${i} failed:`, error);
                }
            }
        }

        // Search for relevant code chunks
        async search(query, topK = 5) {
            if (!this.initialized || this.chunks.length === 0) {
                return [];
            }

            const encoder = this.encoder || neuralNet?.encoder;
            if (!encoder) return [];

            try {
                // Embed the query
                const queryEmbedding = await encoder.embed([query]);
                const queryVector = (await queryEmbedding.array())[0];
                queryEmbedding.dispose();

                // Calculate similarities
                const results = [];
                for (const chunk of this.chunks) {
                    const chunkVector = this.embeddings.get(chunk.id);
                    if (!chunkVector) continue;

                    const similarity = this.cosineSimilarity(queryVector, chunkVector);
                    results.push({ ...chunk, similarity });
                }

                // Sort by similarity and return top K
                results.sort((a, b) => b.similarity - a.similarity);
                return results.slice(0, topK);

            } catch (error) {
                console.warn('CodeRAG search failed:', error);
                return [];
            }
        }

        // Get formatted context for Claude
        async getContext(query, maxChunks = 3, maxChars = 4000) {
            const results = await this.search(query, maxChunks * 2);

            if (results.length === 0) {
                return null;
            }

            // Filter to high-relevance results
            const relevant = results.filter(r => r.similarity > 0.25).slice(0, maxChunks);

            if (relevant.length === 0) {
                return null;
            }

            let context = `\n📚 RELEVANT CODEBASE SECTIONS:\n`;
            let totalChars = 0;

            for (const chunk of relevant) {
                const header = `\n[${chunk.type.toUpperCase()}: ${chunk.name}] (${chunk.section}, lines ${chunk.startLine}-${chunk.endLine}, ${Math.round(chunk.similarity * 100)}% relevant)\n`;
                const codeSnippet = chunk.code.substring(0, Math.min(chunk.code.length, (maxChars - totalChars) / relevant.length));

                if (totalChars + header.length + codeSnippet.length > maxChars) {
                    break;
                }

                context += header + '```javascript\n' + codeSnippet + '\n```\n';
                totalChars += header.length + codeSnippet.length;
            }

            return context;
        }

        // Cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;

            let dotProduct = 0;
            let normA = 0;
            let normB = 0;

            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }

            const denominator = Math.sqrt(normA) * Math.sqrt(normB);
            return denominator === 0 ? 0 : dotProduct / denominator;
        }

        // Save to localStorage
        saveToStorage() {
            try {
                const data = {
                    version: this.VERSION,
                    chunks: this.chunks,
                    embeddings: Array.from(this.embeddings.entries())
                };
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                console.log('📚 CodeRAG saved to storage');
            } catch (error) {
                console.warn('CodeRAG save failed:', error);
                // Try saving without embeddings if too large
                try {
                    const data = {
                        version: this.VERSION,
                        chunks: this.chunks,
                        embeddings: []
                    };
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                } catch (e) {
                    console.warn('CodeRAG save failed completely:', e);
                }
            }
        }

        // Load from localStorage
        loadFromStorage() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                if (!data) return null;
                return JSON.parse(data);
            } catch (error) {
                console.warn('CodeRAG load failed:', error);
                return null;
            }
        }

        // Get stats for UI
        getStats() {
            return {
                initialized: this.initialized,
                totalChunks: this.chunks.length,
                embeddedChunks: this.embeddings.size,
                sections: [...new Set(this.chunks.map(c => c.section))].length,
                functions: this.chunks.filter(c => c.type === 'function').length
            };
        }

        // Clear and reprocess
        async reprocess() {
            this.chunks = [];
            this.embeddings.clear();
            this.initialized = false;
            localStorage.removeItem(this.STORAGE_KEY);
            return this.initialize();
        }
    }

    // Global CodeRAG instance
    const codeRAG = new CodeRAG();

    // ═══════════════════════════════════════════════════════════════════
    // CODE KNOWLEDGE SYSTEM - Self-Aware Codebase Understanding
    // ═══════════════════════════════════════════════════════════════════
    // Links map concepts to actual code implementations, building a
    // knowledge graph that enables true self-awareness of the codebase
    class CodeKnowledge {
        constructor() {
            this.links = new Map();           // nodeId -> [codeChunkIds]
            this.reverseLinks = new Map();    // codeChunkId -> [nodeIds]
            this.knowledgeGraph = new Map();  // conceptId -> {related: [], implementations: [], dependencies: []}
            this.learnedAssociations = [];    // [{concept, code, confidence, reinforcements}]
            this.initialized = false;
            this.STORAGE_KEY = 'mynd_code_knowledge';
            this.VERSION = '1.0';
        }

        // Initialize the knowledge system
        async initialize() {
            if (this.initialized) return true;

            console.log('🧠 Initializing CodeKnowledge system...');

            try {
                // Load cached knowledge
                const cached = this.loadFromStorage();
                if (cached && cached.version === this.VERSION) {
                    this.links = new Map(cached.links);
                    this.reverseLinks = new Map(cached.reverseLinks);
                    this.knowledgeGraph = new Map(cached.knowledgeGraph);
                    this.learnedAssociations = cached.learnedAssociations || [];
                    console.log(`✓ CodeKnowledge loaded: ${this.links.size} concept-code links`);
                    this.initialized = true;
                    return true;
                }

                // Build fresh knowledge if CodeRAG is ready
                if (codeRAG.initialized && codeRAG.chunks.length > 0) {
                    await this.buildKnowledgeGraph();
                    this.initialized = true;
                    console.log(`✓ CodeKnowledge built: ${this.links.size} concept-code links`);
                    return true;
                }

                console.log('⏳ CodeKnowledge waiting for CodeRAG...');
                return false;

            } catch (error) {
                console.warn('CodeKnowledge initialization failed:', error);
                return false;
            }
        }

        // Build the knowledge graph by linking concepts to code
        async buildKnowledgeGraph() {
            console.log('🧠 Building knowledge graph...');

            // Get all nodes from the current map
            const allNodes = store ? store.getAllNodes() : [];
            if (allNodes.length === 0) {
                console.log('⏳ No nodes in store yet');
                return;
            }

            // Technical concept keywords that should link to code
            const technicalKeywords = [
                'neural', 'network', 'ai', 'machine learning', 'embedding',
                '3d', 'three.js', 'visualization', 'animation', 'render',
                'camera', 'scene', 'node', 'expand', 'collapse',
                'store', 'data', 'save', 'load', 'indexeddb', 'localstorage',
                'api', 'claude', 'chat', 'voice', 'speech',
                'theme', 'css', 'style', 'color', 'ui',
                'physics', 'spring', 'position', 'layout',
                'encoder', 'tensor', 'model', 'predict',
                'memory', 'semantic', 'pattern', 'learn',
                'pwa', 'service worker', 'offline'
            ];

            // Process each node
            for (const node of allNodes) {
                const nodeText = `${node.label} ${node.description || ''}`.toLowerCase();

                // Check if this is a technical node
                const isTechnical = technicalKeywords.some(kw => nodeText.includes(kw));

                if (isTechnical) {
                    // Find relevant code chunks
                    const searchQuery = `${node.label} ${node.description || ''}`;
                    const relevantChunks = await codeRAG.search(searchQuery, 5);

                    // Filter to high-confidence matches
                    const strongMatches = relevantChunks.filter(c => c.similarity > 0.35);

                    if (strongMatches.length > 0) {
                        // Create links
                        const chunkIds = strongMatches.map(c => c.id);
                        this.links.set(node.id, {
                            chunks: chunkIds,
                            confidence: strongMatches[0].similarity,
                            label: node.label
                        });

                        // Create reverse links
                        for (const chunk of strongMatches) {
                            if (!this.reverseLinks.has(chunk.id)) {
                                this.reverseLinks.set(chunk.id, []);
                            }
                            this.reverseLinks.get(chunk.id).push({
                                nodeId: node.id,
                                label: node.label,
                                similarity: chunk.similarity
                            });
                        }

                        // Build knowledge graph entry
                        this.knowledgeGraph.set(node.id, {
                            label: node.label,
                            description: node.description,
                            implementations: strongMatches.map(c => ({
                                name: c.name,
                                section: c.section,
                                type: c.type,
                                lines: `${c.startLine}-${c.endLine}`,
                                similarity: c.similarity
                            })),
                            related: [], // Will be filled by cross-referencing
                            dependencies: this.extractDependencies(strongMatches)
                        });
                    }
                }
            }

            // Cross-reference to find related concepts
            this.buildRelationships();

            // Save to storage
            this.saveToStorage();

            console.log(`🧠 Knowledge graph complete: ${this.knowledgeGraph.size} concepts mapped`);
        }

        // Extract code dependencies from chunks
        extractDependencies(chunks) {
            const deps = new Set();
            const depPatterns = [
                /(?:const|let|var)\s+\w+\s*=\s*(?:new\s+)?(\w+)/g,  // Variable assignments
                /(\w+)\.(\w+)\s*\(/g,                                // Method calls
                /import.*from\s+['"]([^'"]+)['"]/g,                  // Imports
                /await\s+(\w+)\./g                                   // Async calls
            ];

            for (const chunk of chunks) {
                const code = chunk.code || '';
                for (const pattern of depPatterns) {
                    let match;
                    const regex = new RegExp(pattern.source, pattern.flags);
                    while ((match = regex.exec(code)) !== null) {
                        if (match[1] && match[1].length > 2) {
                            deps.add(match[1]);
                        }
                    }
                }
            }

            return Array.from(deps).slice(0, 20); // Limit to top 20
        }

        // Build relationships between concepts based on shared code
        buildRelationships() {
            const conceptsByChunk = new Map();

            // Group concepts by their code chunks
            for (const [nodeId, linkData] of this.links) {
                for (const chunkId of linkData.chunks) {
                    if (!conceptsByChunk.has(chunkId)) {
                        conceptsByChunk.set(chunkId, []);
                    }
                    conceptsByChunk.get(chunkId).push(nodeId);
                }
            }

            // Find related concepts (share code)
            for (const [nodeId, graphEntry] of this.knowledgeGraph) {
                const linkData = this.links.get(nodeId);
                if (!linkData) continue;

                const relatedSet = new Set();
                for (const chunkId of linkData.chunks) {
                    const sharedConcepts = conceptsByChunk.get(chunkId) || [];
                    for (const relatedId of sharedConcepts) {
                        if (relatedId !== nodeId) {
                            relatedSet.add(relatedId);
                        }
                    }
                }

                graphEntry.related = Array.from(relatedSet).map(id => {
                    const entry = this.knowledgeGraph.get(id);
                    return entry ? entry.label : id;
                });
            }
        }

        // Learn a new association (reinforcement learning style)
        learnAssociation(concept, codeChunkId, feedback = 1) {
            // Find existing association
            const existing = this.learnedAssociations.find(
                a => a.concept === concept && a.codeChunkId === codeChunkId
            );

            if (existing) {
                // Reinforce existing association
                existing.reinforcements++;
                existing.confidence = Math.min(1, existing.confidence + (feedback * 0.1));
                existing.lastSeen = Date.now();
            } else {
                // Create new association
                this.learnedAssociations.push({
                    concept,
                    codeChunkId,
                    confidence: 0.5 + (feedback * 0.1),
                    reinforcements: 1,
                    createdAt: Date.now(),
                    lastSeen: Date.now()
                });
            }

            // Decay old associations
            this.decayAssociations();

            // Save
            this.saveToStorage();
        }

        // Decay associations that haven't been reinforced
        decayAssociations() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;

            this.learnedAssociations = this.learnedAssociations.filter(a => {
                const daysSinceLastSeen = (now - a.lastSeen) / dayMs;
                a.confidence *= Math.pow(0.95, daysSinceLastSeen); // 5% decay per day
                return a.confidence > 0.1; // Remove very weak associations
            });
        }

        // Get knowledge context for a query
        async getContext(query, maxItems = 5) {
            if (!this.initialized) return null;

            // Search for relevant concepts
            const relevantConcepts = [];

            for (const [nodeId, graphEntry] of this.knowledgeGraph) {
                const conceptText = `${graphEntry.label} ${graphEntry.description || ''}`.toLowerCase();
                const queryLower = query.toLowerCase();

                // Simple keyword matching + learned associations
                const keywords = queryLower.split(/\s+/);
                const matchScore = keywords.filter(kw =>
                    kw.length > 2 && conceptText.includes(kw)
                ).length / keywords.length;

                if (matchScore > 0.2) {
                    relevantConcepts.push({
                        ...graphEntry,
                        nodeId,
                        matchScore
                    });
                }
            }

            // Sort by match score
            relevantConcepts.sort((a, b) => b.matchScore - a.matchScore);
            const topConcepts = relevantConcepts.slice(0, maxItems);

            if (topConcepts.length === 0) return null;

            // Build context string
            let context = '\n🧠 SELF-AWARENESS CONTEXT (concept → code mapping):\n';

            for (const concept of topConcepts) {
                context += `\n[CONCEPT: ${concept.label}]\n`;
                if (concept.description) {
                    context += `  Purpose: ${concept.description.substring(0, 100)}\n`;
                }

                if (concept.implementations.length > 0) {
                    context += `  Implemented in:\n`;
                    for (const impl of concept.implementations.slice(0, 2)) {
                        context += `    • ${impl.type} "${impl.name}" (${impl.section}, lines ${impl.lines})\n`;
                    }
                }

                if (concept.related.length > 0) {
                    context += `  Related concepts: ${concept.related.slice(0, 3).join(', ')}\n`;
                }

                if (concept.dependencies.length > 0) {
                    context += `  Uses: ${concept.dependencies.slice(0, 5).join(', ')}\n`;
                }
            }

            return context;
        }

        // Get implementation details for a specific concept
        getImplementation(conceptLabel) {
            for (const [nodeId, graphEntry] of this.knowledgeGraph) {
                if (graphEntry.label.toLowerCase().includes(conceptLabel.toLowerCase())) {
                    return graphEntry;
                }
            }
            return null;
        }

        // Get all concepts that use a specific code section
        getConceptsForCode(sectionName) {
            const concepts = [];
            for (const [nodeId, graphEntry] of this.knowledgeGraph) {
                const usesSection = graphEntry.implementations.some(
                    i => i.section.toLowerCase().includes(sectionName.toLowerCase())
                );
                if (usesSection) {
                    concepts.push(graphEntry.label);
                }
            }
            return concepts;
        }

        // Save to localStorage
        saveToStorage() {
            try {
                const data = {
                    version: this.VERSION,
                    links: Array.from(this.links.entries()),
                    reverseLinks: Array.from(this.reverseLinks.entries()),
                    knowledgeGraph: Array.from(this.knowledgeGraph.entries()),
                    learnedAssociations: this.learnedAssociations
                };
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.warn('CodeKnowledge save failed:', error);
            }
        }

        // Load from localStorage
        loadFromStorage() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                return data ? JSON.parse(data) : null;
            } catch (error) {
                console.warn('CodeKnowledge load failed:', error);
                return null;
            }
        }

        // Get stats for debugging
        getStats() {
            return {
                initialized: this.initialized,
                conceptsMapped: this.knowledgeGraph.size,
                totalLinks: this.links.size,
                learnedAssociations: this.learnedAssociations.length,
                avgConfidence: this.learnedAssociations.length > 0
                    ? this.learnedAssociations.reduce((sum, a) => sum + a.confidence, 0) / this.learnedAssociations.length
                    : 0
            };
        }

        // Rebuild knowledge graph
        async rebuild() {
            this.links.clear();
            this.reverseLinks.clear();
            this.knowledgeGraph.clear();
            localStorage.removeItem(this.STORAGE_KEY);
            this.initialized = false;
            return this.initialize();
        }
    }

    // Global CodeKnowledge instance
    const codeKnowledge = new CodeKnowledge();

    // ═══════════════════════════════════════════════════════════════════
    // CODE PRETRAINING SYSTEM - Deep Codebase Understanding
    // ═══════════════════════════════════════════════════════════════════
    // Pre-analyzes the entire codebase to build comprehensive understanding
    // without requiring user interactions. Runs once on first load.
    const CodePretraining = {
        STORAGE_KEY: 'mynd_code_pretrained',
        VERSION: '1.0',
        initialized: false,
        knowledge: null,

        // Pre-trained knowledge structure
        defaultKnowledge: {
            // High-level system descriptions
            systems: {},
            // Function registry with purposes
            functions: {},
            // Call graph (who calls whom)
            callGraph: {},
            // Reverse call graph (who is called by whom)
            calledBy: {},
            // System dependencies
            dependencies: {},
            // Global variables and their purposes
            globals: {},
            // Section summaries
            sections: {},
            // Architecture overview
            architecture: null
        },

        async initialize() {
            if (this.initialized) return this.knowledge;

            console.log('🎓 Initializing CodePretraining...');

            try {
                // Try to load cached knowledge
                const cached = this.loadFromStorage();
                if (cached && cached.version === this.VERSION) {
                    this.knowledge = cached.knowledge;
                    this.initialized = true;
                    console.log(`✓ Pre-trained knowledge loaded: ${Object.keys(this.knowledge.functions).length} functions mapped`);
                    return this.knowledge;
                }

                // Generate fresh pre-training
                console.log('🎓 Pre-training on codebase (first run)...');
                await this.pretrain();
                this.initialized = true;
                console.log(`✓ Pre-training complete: ${Object.keys(this.knowledge.functions).length} functions, ${Object.keys(this.knowledge.systems).length} systems`);
                return this.knowledge;

            } catch (error) {
                console.warn('CodePretraining initialization failed:', error);
                this.knowledge = { ...this.defaultKnowledge };
                return this.knowledge;
            }
        },

        async pretrain() {
            this.knowledge = { ...this.defaultKnowledge };

            // Use CodeRAG chunks as the basis
            if (!codeRAG.initialized || codeRAG.chunks.length === 0) {
                console.warn('CodePretraining: CodeRAG not ready');
                return;
            }

            // 1. Analyze all sections
            this.analyzeSections();

            // 2. Build function registry
            this.buildFunctionRegistry();

            // 3. Build call graph
            this.buildCallGraph();

            // 4. Identify systems and their purposes
            this.identifySystems();

            // 5. Map dependencies
            this.mapDependencies();

            // 6. Generate architecture overview
            this.generateArchitectureOverview();

            // Save
            this.saveToStorage();
        },

        analyzeSections() {
            const sectionChunks = codeRAG.chunks.filter(c => c.type === 'section');

            for (const chunk of sectionChunks) {
                this.knowledge.sections[chunk.name] = {
                    name: chunk.name,
                    lines: `${chunk.startLine}-${chunk.endLine}`,
                    summary: this.generateSectionSummary(chunk),
                    functions: []
                };
            }
        },

        generateSectionSummary(chunk) {
            // Generate a smart summary based on section name and content
            const name = chunk.name.toLowerCase();
            const summaries = {
                'neural intelligence': 'On-device machine learning system using TensorFlow.js Universal Sentence Encoder for semantic understanding, pattern learning, and intelligent suggestions',
                'semantic memory': 'Long-term context awareness system that remembers past interactions and surfaces relevant memories',
                'ai chat manager': 'Conversational AI interface that processes user messages, builds context, and executes actions on the mind map',
                'theme manager': 'Visual theming system supporting multiple color schemes with CSS variable manipulation',
                'store': 'Central data management for the mind map tree structure with CRUD operations and persistence',
                'three.js': '3D visualization engine rendering nodes as spheres with physics-based animations',
                'mobile sheet': 'Mobile-optimized bottom sheet UI with gesture-based interactions',
                'voice': 'Speech recognition and voice memo capture using Web Speech API',
                'link manager': 'URL capture and metadata extraction for web content integration',
                'goal system': 'Goal tracking and progress visualization features',
                'physics': 'Spring-based animation system for smooth node movements',
                'camera': 'Camera controls including auto-follow, zoom-to-fit, and arc animations',
                'pwa': 'Progressive Web App features including service worker and offline support',
                'indexeddb': 'Client-side database for persistent storage of maps and neural data',
                'supabase': 'Cloud sync and authentication backend integration',
                'preference': 'User preference learning from accepted/rejected suggestions',
                'teacher knowledge': 'Knowledge distillation from Claude API to improve local predictions',
                'cognitive': 'Advanced graph transformer for structural pattern recognition',
                'webgpu': 'GPU-accelerated similarity computations when available'
            };

            for (const [key, summary] of Object.entries(summaries)) {
                if (name.includes(key)) return summary;
            }

            return `Code section handling ${chunk.name} functionality`;
        },

        buildFunctionRegistry() {
            const funcChunks = codeRAG.chunks.filter(c => c.type === 'function');

            for (const chunk of funcChunks) {
                const purpose = this.inferFunctionPurpose(chunk);
                const params = this.extractParameters(chunk.code);
                const returnType = this.inferReturnType(chunk.code);

                this.knowledge.functions[chunk.name] = {
                    name: chunk.name,
                    section: chunk.section,
                    lines: `${chunk.startLine}-${chunk.endLine}`,
                    purpose: purpose,
                    parameters: params,
                    returns: returnType,
                    isAsync: chunk.code.includes('async'),
                    complexity: this.estimateComplexity(chunk.code)
                };

                // Add to section's function list
                if (this.knowledge.sections[chunk.section]) {
                    this.knowledge.sections[chunk.section].functions.push(chunk.name);
                }
            }
        },

        inferFunctionPurpose(chunk) {
            const name = chunk.name.toLowerCase();
            const code = chunk.code.toLowerCase();

            // Pattern matching for common purposes
            const patterns = [
                [/^get|^fetch|^load|^read/, 'Retrieves data'],
                [/^set|^update|^save|^write|^store/, 'Stores/updates data'],
                [/^add|^create|^insert|^new/, 'Creates new items'],
                [/^delete|^remove|^clear/, 'Removes items'],
                [/^init|^setup|^start|^boot/, 'Initializes system'],
                [/^render|^draw|^display|^show/, 'Renders UI elements'],
                [/^handle|^on[A-Z]|^process/, 'Handles events'],
                [/^validate|^check|^verify|^is[A-Z]/, 'Validates data'],
                [/^format|^transform|^convert|^parse/, 'Transforms data'],
                [/^calculate|^compute|^estimate/, 'Performs calculations'],
                [/^find|^search|^query|^filter/, 'Searches/filters data'],
                [/^animate|^transition|^tween/, 'Handles animations'],
                [/^expand|^collapse|^toggle/, 'Toggles visibility/state'],
                [/^embed|^encode|^vector/, 'Generates embeddings'],
                [/^predict|^classify|^suggest/, 'Makes predictions'],
                [/^train|^learn|^update.*weight/, 'Trains models'],
                [/^focus|^select|^highlight/, 'Manages selection/focus'],
                [/^zoom|^pan|^camera/, 'Controls camera/viewport'],
                [/^export|^download|^share/, 'Exports data'],
                [/^import|^upload|^paste/, 'Imports data']
            ];

            for (const [pattern, purpose] of patterns) {
                if (pattern.test(name)) {
                    return `${purpose} - ${chunk.section}`;
                }
            }

            return `${chunk.section} functionality`;
        },

        extractParameters(code) {
            const match = code.match(/(?:function\s+\w+|(?:async\s+)?(?:\w+\s*[:=]\s*)?(?:async\s*)?\(?)?\(([^)]*)\)/);
            if (!match || !match[1]) return [];

            return match[1].split(',')
                .map(p => p.trim())
                .filter(p => p && !p.startsWith('//'))
                .map(p => p.split('=')[0].trim());
        },

        inferReturnType(code) {
            if (code.includes('return null') || code.includes('return;')) return 'void/null';
            if (code.includes('return true') || code.includes('return false')) return 'boolean';
            if (code.includes('return []') || code.includes('return results') || code.includes('.map(')) return 'array';
            if (code.includes('return {')) return 'object';
            if (code.includes('return `') || code.includes("return '") || code.includes('return "')) return 'string';
            if (/return\s+\d/.test(code)) return 'number';
            if (code.includes('async')) return 'Promise';
            return 'unknown';
        },

        estimateComplexity(code) {
            let complexity = 1;
            complexity += (code.match(/if\s*\(/g) || []).length;
            complexity += (code.match(/for\s*\(/g) || []).length * 2;
            complexity += (code.match(/while\s*\(/g) || []).length * 2;
            complexity += (code.match(/switch\s*\(/g) || []).length;
            complexity += (code.match(/\?\s*.*:/g) || []).length;
            complexity += (code.match(/catch\s*\(/g) || []).length;

            if (complexity <= 3) return 'low';
            if (complexity <= 8) return 'medium';
            return 'high';
        },

        buildCallGraph() {
            for (const [funcName, funcData] of Object.entries(this.knowledge.functions)) {
                const chunk = codeRAG.chunks.find(c => c.name === funcName);
                if (!chunk) continue;

                const calls = this.extractFunctionCalls(chunk.code, funcName);
                this.knowledge.callGraph[funcName] = calls;

                // Build reverse graph
                for (const calledFunc of calls) {
                    if (!this.knowledge.calledBy[calledFunc]) {
                        this.knowledge.calledBy[calledFunc] = [];
                    }
                    if (!this.knowledge.calledBy[calledFunc].includes(funcName)) {
                        this.knowledge.calledBy[calledFunc].push(funcName);
                    }
                }
            }
        },

        extractFunctionCalls(code, selfName) {
            const calls = new Set();
            const knownFuncs = Object.keys(this.knowledge.functions);

            // Match function calls: funcName( or obj.funcName(
            const callPattern = /(?:^|[^.\w])(\w+)\s*\(/g;
            let match;
            while ((match = callPattern.exec(code)) !== null) {
                const calledName = match[1];
                if (calledName !== selfName &&
                    knownFuncs.includes(calledName) &&
                    !['if', 'for', 'while', 'switch', 'catch', 'function', 'return', 'new', 'typeof'].includes(calledName)) {
                    calls.add(calledName);
                }
            }

            return Array.from(calls);
        },

        identifySystems() {
            // Group functions by their high-level system
            const systemPatterns = {
                'Neural Network': ['PersonalNeuralNet', 'neuralNet', 'encoder', 'embed', 'predict', 'train', 'getEmbedding'],
                '3D Visualization': ['initScene', 'createNode', 'render', 'animate', 'THREE', 'camera', 'scene', 'sphere'],
                'Data Store': ['store', 'save', 'load', 'findNode', 'addNode', 'deleteNode', 'updateNode'],
                'AI Chat': ['chatManager', 'callAI', 'sendMessage', 'processMessage'],
                'Voice Input': ['voiceAI', 'speechRecognition', 'startRecording', 'transcribe'],
                'Theme System': ['themeManager', 'setTheme', 'applyTheme', 'updateColors'],
                'Animation': ['expandNode', 'collapseNode', 'animateCamera', 'spring', 'tween'],
                'Memory Systems': ['semanticMemory', 'preferenceTracker', 'userProfile'],
                'Code Understanding': ['codeRAG', 'codeKnowledge', 'CodePretraining']
            };

            for (const [systemName, keywords] of Object.entries(systemPatterns)) {
                const relatedFuncs = Object.entries(this.knowledge.functions)
                    .filter(([name, data]) =>
                        keywords.some(kw =>
                            name.toLowerCase().includes(kw.toLowerCase()) ||
                            data.section.toLowerCase().includes(kw.toLowerCase())
                        )
                    )
                    .map(([name]) => name);

                if (relatedFuncs.length > 0) {
                    this.knowledge.systems[systemName] = {
                        name: systemName,
                        functions: relatedFuncs,
                        description: this.generateSystemDescription(systemName),
                        entryPoints: this.findEntryPoints(relatedFuncs)
                    };
                }
            }
        },

        generateSystemDescription(systemName) {
            const descriptions = {
                'Neural Network': 'On-device ML using TensorFlow.js for semantic understanding, pattern learning, category prediction, and intelligent suggestions. Learns from user behavior without sending data to servers.',
                '3D Visualization': 'Three.js-powered 3D mind map rendering. Nodes are spheres connected by lines, with physics-based spring animations for smooth interactions.',
                'Data Store': 'Central data management handling the hierarchical tree structure. Supports CRUD operations, persistence to IndexedDB/localStorage, and cloud sync.',
                'AI Chat': 'Conversational interface powered by Claude API. Builds rich context from the map, neural insights, and memories to provide intelligent responses and execute actions.',
                'Voice Input': 'Web Speech API integration for voice-to-text capture. Supports real-time transcription and voice memo processing.',
                'Theme System': 'Dynamic theming with CSS variables. Supports multiple color schemes with instant switching and persistence.',
                'Animation': 'Spring physics-based animation system for node expand/collapse, camera movements, and UI transitions.',
                'Memory Systems': 'Long-term learning systems including semantic memory (past interactions), preference tracking (suggestion feedback), and user profiling.',
                'Code Understanding': 'Self-aware code analysis systems including CodeRAG (retrieval), CodeKnowledge (concept mapping), and CodePretraining (deep understanding).'
            };
            return descriptions[systemName] || `System handling ${systemName} functionality`;
        },

        findEntryPoints(functions) {
            // Entry points are functions that are called but don't call other system functions
            return functions.filter(f => {
                const callers = this.knowledge.calledBy[f] || [];
                const externalCallers = callers.filter(c => !functions.includes(c));
                return externalCallers.length > 0 || callers.length === 0;
            }).slice(0, 5);
        },

        mapDependencies() {
            for (const [systemName, systemData] of Object.entries(this.knowledge.systems)) {
                const deps = new Set();

                for (const funcName of systemData.functions) {
                    const calls = this.knowledge.callGraph[funcName] || [];
                    for (const calledFunc of calls) {
                        // Find which system the called function belongs to
                        for (const [otherSystem, otherData] of Object.entries(this.knowledge.systems)) {
                            if (otherSystem !== systemName && otherData.functions.includes(calledFunc)) {
                                deps.add(otherSystem);
                            }
                        }
                    }
                }

                this.knowledge.dependencies[systemName] = Array.from(deps);
            }
        },

        generateArchitectureOverview() {
            const totalFuncs = Object.keys(this.knowledge.functions).length;
            const totalSections = Object.keys(this.knowledge.sections).length;
            const totalSystems = Object.keys(this.knowledge.systems).length;

            this.knowledge.architecture = {
                summary: `MYND is a ${totalFuncs}-function monolithic web app organized into ${totalSections} sections and ${totalSystems} logical systems.`,
                coreFlow: [
                    '1. User interacts (click, voice, type)',
                    '2. Event handlers process input',
                    '3. Data Store updates map structure',
                    '4. 3D Visualization re-renders',
                    '5. Neural Network learns from interaction',
                    '6. AI Chat available for complex operations'
                ],
                keyIntegrations: [
                    'TensorFlow.js Universal Sentence Encoder for embeddings',
                    'Three.js for 3D rendering',
                    'Claude API for conversational AI',
                    'IndexedDB for persistent storage',
                    'Supabase for cloud sync (optional)'
                ],
                uniqueFeatures: [
                    'On-device ML that learns user patterns',
                    'Self-aware codebase understanding',
                    '3D spatial mind mapping',
                    'Voice-first capture',
                    'Privacy-focused local processing'
                ]
            };
        },

        // Get comprehensive context for AI
        getContext(query, maxSystems = 3) {
            if (!this.initialized || !this.knowledge) return null;

            const queryLower = query.toLowerCase();
            let context = '\n🎓 PRE-TRAINED CODEBASE KNOWLEDGE:\n';

            // Find relevant systems
            const relevantSystems = [];
            for (const [name, system] of Object.entries(this.knowledge.systems)) {
                const score = this.scoreRelevance(queryLower, name, system);
                if (score > 0) {
                    relevantSystems.push({ name, system, score });
                }
            }

            relevantSystems.sort((a, b) => b.score - a.score);
            const topSystems = relevantSystems.slice(0, maxSystems);

            if (topSystems.length === 0) {
                // Return architecture overview if no specific match
                context += `\n${this.knowledge.architecture.summary}\n`;
                context += `\nCore systems: ${Object.keys(this.knowledge.systems).join(', ')}\n`;
                return context;
            }

            for (const { name, system } of topSystems) {
                context += `\n[SYSTEM: ${name}]\n`;
                context += `  ${system.description}\n`;
                context += `  Functions: ${system.functions.length} (entry points: ${system.entryPoints.join(', ')})\n`;

                const deps = this.knowledge.dependencies[name];
                if (deps && deps.length > 0) {
                    context += `  Depends on: ${deps.join(', ')}\n`;
                }

                // Add a few key function details
                const keyFuncs = system.entryPoints.slice(0, 3);
                for (const funcName of keyFuncs) {
                    const func = this.knowledge.functions[funcName];
                    if (func) {
                        context += `    • ${funcName}(${func.parameters.join(', ')}): ${func.purpose}\n`;
                    }
                }
            }

            return context;
        },

        scoreRelevance(query, systemName, system) {
            let score = 0;
            const nameLower = systemName.toLowerCase();
            const descLower = system.description.toLowerCase();

            // Direct name match
            if (query.includes(nameLower)) score += 5;

            // Keyword matching
            const keywords = query.split(/\s+/);
            for (const kw of keywords) {
                if (kw.length > 2) {
                    if (nameLower.includes(kw)) score += 2;
                    if (descLower.includes(kw)) score += 1;
                    if (system.functions.some(f => f.toLowerCase().includes(kw))) score += 1;
                }
            }

            return score;
        },

        // Get specific function details
        getFunctionDetails(funcName) {
            return this.knowledge?.functions[funcName] || null;
        },

        // Get call chain for a function
        getCallChain(funcName, depth = 2) {
            const chain = { name: funcName, calls: [], calledBy: [] };

            if (depth > 0) {
                const calls = this.knowledge?.callGraph[funcName] || [];
                chain.calls = calls.slice(0, 5);

                const calledBy = this.knowledge?.calledBy[funcName] || [];
                chain.calledBy = calledBy.slice(0, 5);
            }

            return chain;
        },

        saveToStorage() {
            try {
                const data = {
                    version: this.VERSION,
                    knowledge: this.knowledge,
                    timestamp: Date.now()
                };
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                console.log('🎓 Pre-trained knowledge saved');
            } catch (error) {
                console.warn('CodePretraining save failed:', error);
            }
        },

        loadFromStorage() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                return data ? JSON.parse(data) : null;
            } catch (error) {
                return null;
            }
        },

        getStats() {
            return {
                initialized: this.initialized,
                systems: Object.keys(this.knowledge?.systems || {}).length,
                functions: Object.keys(this.knowledge?.functions || {}).length,
                sections: Object.keys(this.knowledge?.sections || {}).length,
                callGraphEdges: Object.values(this.knowledge?.callGraph || {}).flat().length
            };
        },

        // Force re-pretrain
        async rebuild() {
            localStorage.removeItem(this.STORAGE_KEY);
            this.initialized = false;
            this.knowledge = null;
            return this.initialize();
        }
    };

    // Global neural network instance
    const neuralNet = new PersonalNeuralNet();

    // ═══════════════════════════════════════════════════════════════════
    // CODE ANALYZER - Self-Improvement Analysis System
    // ═══════════════════════════════════════════════════════════════════
    // Comprehensive analysis system that identifies every possible area
    // for incremental improvement, making MYND stronger over time.
    const CodeAnalyzer = {
        STORAGE_KEY: 'mynd_code_analysis',
        VERSION: '1.0',
        initialized: false,
        analysis: null,

        // Analysis categories with weights (higher = more impactful)
        CATEGORIES: {
            PERFORMANCE: { name: 'Performance', weight: 9, icon: '⚡' },
            ARCHITECTURE: { name: 'Architecture', weight: 8, icon: '🏗️' },
            SECURITY: { name: 'Security', weight: 10, icon: '🔒' },
            CODE_QUALITY: { name: 'Code Quality', weight: 7, icon: '✨' },
            MAINTAINABILITY: { name: 'Maintainability', weight: 6, icon: '🔧' },
            SCALABILITY: { name: 'Scalability', weight: 7, icon: '📈' },
            UX_ENHANCEMENT: { name: 'UX Enhancement', weight: 8, icon: '🎨' },
            FEATURE_GAP: { name: 'Feature Gap', weight: 6, icon: '🎯' },
            DEAD_CODE: { name: 'Dead Code', weight: 4, icon: '💀' },
            TECH_DEBT: { name: 'Technical Debt', weight: 5, icon: '💳' },
            OPTIMIZATION: { name: 'Optimization', weight: 7, icon: '🚀' },
            MODULARIZATION: { name: 'Modularization', weight: 6, icon: '📦' },
            ERROR_HANDLING: { name: 'Error Handling', weight: 8, icon: '🛡️' },
            ACCESSIBILITY: { name: 'Accessibility', weight: 7, icon: '♿' },
            TESTING: { name: 'Testing', weight: 5, icon: '🧪' },
            ML_INTELLIGENCE: { name: 'ML Intelligence', weight: 10, icon: '🧠' }
        },

        // Default analysis structure
        defaultAnalysis: {
            improvements: [],          // All identified improvements
            byCategory: {},           // Grouped by category
            byPriority: {             // Grouped by priority
                critical: [],
                high: [],
                medium: [],
                low: []
            },
            byEffort: {               // Grouped by implementation effort
                quick: [],            // < 1 hour
                moderate: [],         // 1-4 hours
                significant: [],      // 1-2 days
                major: []             // > 2 days
            },
            metrics: {
                totalImprovements: 0,
                completedImprovements: 0,
                technicalDebtScore: 0,
                healthScore: 0
            },
            timestamp: null
        },

        async initialize() {
            if (this.initialized) return this.analysis;

            console.log('🔍 Initializing CodeAnalyzer...');

            try {
                // Try to load cached analysis
                const cached = this.loadFromStorage();
                if (cached && cached.version === this.VERSION) {
                    // Check if analysis is recent (within 24 hours)
                    const age = Date.now() - cached.timestamp;
                    if (age < 24 * 60 * 60 * 1000) {
                        this.analysis = cached.analysis;
                        this.initialized = true;
                        console.log(`✓ CodeAnalyzer loaded: ${this.analysis.metrics.totalImprovements} improvements identified`);
                        return this.analysis;
                    }
                }

                // Generate fresh analysis
                console.log('🔍 Analyzing codebase for improvements...');
                await this.analyze();
                this.initialized = true;
                console.log(`✓ CodeAnalyzer complete: ${this.analysis.metrics.totalImprovements} improvements found`);
                return this.analysis;

            } catch (error) {
                console.warn('CodeAnalyzer initialization failed:', error);
                this.analysis = { ...this.defaultAnalysis };
                return this.analysis;
            }
        },

        async analyze() {
            this.analysis = { ...this.defaultAnalysis };
            this.analysis.timestamp = Date.now();

            // Initialize category containers
            for (const cat of Object.keys(this.CATEGORIES)) {
                this.analysis.byCategory[cat] = [];
            }

            // Wait for CodePretraining to be ready
            if (!CodePretraining.initialized) {
                await CodePretraining.initialize();
            }

            // Run all analysis passes
            this.analyzeComplexity();
            this.analyzeCoupling();
            this.analyzeDeadCode();
            this.analyzePerformance();
            this.analyzeArchitecture();
            this.analyzeSecurity();
            this.analyzeErrorHandling();
            this.analyzeModularization();
            this.analyzeFeatureGaps();
            this.analyzeAccessibility();
            this.analyzeTechDebt();
            this.analyzeOptimizations();
            this.analyzeUXEnhancements();
            this.analyzeTestability();
            this.analyzeMaintainability();
            this.analyzeMLCapabilities();

            // Calculate metrics
            this.calculateMetrics();

            // Sort improvements by priority score
            this.analysis.improvements.sort((a, b) => b.priorityScore - a.priorityScore);

            // Save analysis
            this.saveToStorage();

            return this.analysis;
        },

        // Add an improvement finding
        addImprovement(category, title, description, options = {}) {
            const catInfo = this.CATEGORIES[category];
            const {
                priority = 'medium',       // critical, high, medium, low
                effort = 'moderate',       // quick, moderate, significant, major
                location = null,           // file:line or function name
                currentCode = null,        // problematic code snippet
                suggestedFix = null,       // suggested improvement
                impact = null,             // what improves when fixed
                dependencies = [],         // other improvements this depends on
                tags = []                  // additional categorization
            } = options;

            // Calculate priority score
            const priorityWeights = { critical: 4, high: 3, medium: 2, low: 1 };
            const effortWeights = { quick: 4, moderate: 3, significant: 2, major: 1 };
            const priorityScore = (catInfo.weight * priorityWeights[priority] * effortWeights[effort]) / 10;

            const improvement = {
                id: `imp_${Date.now()}_${Math.random().toString(36).substring(7)}`,
                category,
                categoryName: catInfo.name,
                categoryIcon: catInfo.icon,
                title,
                description,
                priority,
                effort,
                priorityScore,
                location,
                currentCode,
                suggestedFix,
                impact,
                dependencies,
                tags,
                status: 'identified',  // identified, in_progress, completed, deferred
                createdAt: Date.now(),
                completedAt: null
            };

            this.analysis.improvements.push(improvement);
            this.analysis.byCategory[category].push(improvement);
            this.analysis.byPriority[priority].push(improvement);
            this.analysis.byEffort[effort].push(improvement);

            return improvement;
        },

        // ═══════════════════════════════════════════════════════════════════
        // ANALYSIS PASSES - Each focuses on a different improvement type
        // ═══════════════════════════════════════════════════════════════════

        analyzeComplexity() {
            if (!CodePretraining.knowledge?.functions) return;

            // Find high-complexity functions
            const highComplexity = Object.entries(CodePretraining.knowledge.functions)
                .filter(([_, data]) => data.complexity === 'high')
                .map(([name, data]) => ({ name, ...data }));

            for (const func of highComplexity.slice(0, 15)) {
                this.addImprovement('CODE_QUALITY',
                    `Refactor complex function: ${func.name}`,
                    `Function ${func.name} has high cyclomatic complexity. Consider breaking it into smaller, focused functions.`,
                    {
                        priority: 'medium',
                        effort: 'moderate',
                        location: `${func.section}: ${func.lines}`,
                        impact: 'Improved readability, easier testing, reduced bug surface',
                        tags: ['complexity', 'refactoring']
                    }
                );
            }

            // Find deeply nested code patterns
            const deepNesting = ['if', 'for', 'while'].join('|');
            // This would require actual code analysis - placeholder for now
        },

        analyzeCoupling() {
            if (!CodePretraining.knowledge?.dependencies) return;

            // Find systems with high coupling
            for (const [system, deps] of Object.entries(CodePretraining.knowledge.dependencies)) {
                if (deps.length >= 4) {
                    this.addImprovement('ARCHITECTURE',
                        `Reduce coupling in ${system} system`,
                        `${system} depends on ${deps.length} other systems (${deps.join(', ')}). High coupling makes changes risky and testing difficult.`,
                        {
                            priority: 'medium',
                            effort: 'significant',
                            impact: 'Better isolation, easier testing, safer modifications',
                            tags: ['coupling', 'architecture']
                        }
                    );
                }
            }

            // Find functions called by many others (high fan-in = potential bottleneck)
            if (CodePretraining.knowledge?.calledBy) {
                const highFanIn = Object.entries(CodePretraining.knowledge.calledBy)
                    .filter(([_, callers]) => callers.length >= 10)
                    .sort((a, b) => b[1].length - a[1].length);

                for (const [funcName, callers] of highFanIn.slice(0, 5)) {
                    this.addImprovement('MAINTAINABILITY',
                        `Critical function: ${funcName} (${callers.length} callers)`,
                        `This function is called by ${callers.length} other functions. Changes here have wide impact. Consider adding extra validation and tests.`,
                        {
                            priority: 'high',
                            effort: 'moderate',
                            impact: 'Reduced risk when modifying core functions',
                            tags: ['critical-path', 'high-impact']
                        }
                    );
                }
            }
        },

        analyzeDeadCode() {
            if (!CodePretraining.knowledge?.functions || !CodePretraining.knowledge?.calledBy) return;

            // Find functions that are never called
            const uncalled = [];
            for (const funcName of Object.keys(CodePretraining.knowledge.functions)) {
                const callers = CodePretraining.knowledge.calledBy[funcName] || [];
                // Exclude entry points and event handlers
                if (callers.length === 0 &&
                    !funcName.startsWith('on') &&
                    !funcName.startsWith('handle') &&
                    !funcName.includes('init') &&
                    !funcName.includes('setup') &&
                    !funcName.includes('render')) {
                    uncalled.push(funcName);
                }
            }

            if (uncalled.length > 0) {
                this.addImprovement('DEAD_CODE',
                    `Review ${uncalled.length} potentially unused functions`,
                    `These functions have no detected callers: ${uncalled.slice(0, 10).join(', ')}${uncalled.length > 10 ? '...' : ''}. They may be dead code or called dynamically.`,
                    {
                        priority: 'low',
                        effort: 'moderate',
                        impact: 'Smaller codebase, reduced maintenance burden',
                        tags: ['cleanup', 'dead-code']
                    }
                );
            }
        },

        analyzePerformance() {
            // Check for known performance patterns
            const perfPatterns = [
                {
                    pattern: 'requestAnimationFrame',
                    check: 'throttle',
                    title: 'Optimize animation frame usage',
                    desc: 'Ensure all animations use requestAnimationFrame with proper throttling'
                },
                {
                    pattern: 'addEventListener',
                    check: 'passive',
                    title: 'Add passive event listeners',
                    desc: 'Touch and wheel events should use passive: true for better scroll performance'
                },
                {
                    pattern: 'querySelector',
                    check: 'cache',
                    title: 'Cache DOM queries',
                    desc: 'Repeated DOM queries should be cached to avoid layout thrashing'
                }
            ];

            // Neural net performance
            this.addImprovement('PERFORMANCE',
                'Lazy-load TensorFlow.js Universal Sentence Encoder',
                'The USE model is ~50MB. Consider lazy-loading it only when first needed, not on initial page load.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Faster initial page load, reduced bandwidth for casual users',
                    tags: ['loading', 'lazy-load', 'neural']
                }
            );

            // 3D rendering performance
            this.addImprovement('PERFORMANCE',
                'Implement Three.js level-of-detail (LOD)',
                'Use simpler geometries for distant nodes to improve rendering performance with large maps.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Better FPS with 1000+ nodes',
                    tags: ['3d', 'rendering', 'threejs']
                }
            );

            // Memory management
            this.addImprovement('PERFORMANCE',
                'Implement virtual scrolling for large node lists',
                'The info panel and search results should use virtual scrolling when showing many items.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Smoother UI with large maps',
                    tags: ['memory', 'scrolling', 'virtualization']
                }
            );

            // WebWorker offloading
            this.addImprovement('PERFORMANCE',
                'Move embedding computations to Web Worker',
                'Neural network embeddings block the main thread. Moving to a Web Worker would keep UI responsive.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Non-blocking AI operations, smoother interactions',
                    tags: ['webworker', 'neural', 'async']
                }
            );
        },

        analyzeArchitecture() {
            // Monolithic file concern
            this.addImprovement('ARCHITECTURE',
                'Modularize the monolithic index.html',
                'The entire application is in a single 40,000+ line file. Consider splitting into ES modules for better maintainability.',
                {
                    priority: 'high',
                    effort: 'major',
                    impact: 'Easier navigation, better code organization, tree-shaking opportunities',
                    suggestedFix: 'Split into: core.js, neural.js, three-scene.js, store.js, ui-components.js, ai-chat.js',
                    tags: ['modularization', 'es-modules']
                }
            );

            // State management
            this.addImprovement('ARCHITECTURE',
                'Implement centralized state management',
                'State is scattered across multiple objects (store, neuralNet, chatManager, etc.). A centralized store with subscriptions would reduce bugs.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Predictable state updates, easier debugging, undo/redo support',
                    suggestedFix: 'Consider a simple pub/sub pattern or a lightweight state library',
                    tags: ['state-management', 'architecture']
                }
            );

            // Event system
            this.addImprovement('ARCHITECTURE',
                'Create unified event bus',
                'Components communicate through direct function calls. An event bus would decouple systems better.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Looser coupling, easier to add new features',
                    tags: ['events', 'decoupling']
                }
            );

            // Plugin architecture
            this.addImprovement('FEATURE_GAP',
                'Add plugin/extension architecture',
                'Allow users to add custom functionality through a plugin system.',
                {
                    priority: 'low',
                    effort: 'major',
                    impact: 'Extensibility, community contributions',
                    tags: ['plugins', 'extensibility']
                }
            );
        },

        analyzeSecurity() {
            // API key exposure
            this.addImprovement('SECURITY',
                'Move API key handling to backend proxy',
                'Claude API key is exposed in client-side code. Use a backend proxy to protect the key.',
                {
                    priority: 'critical',
                    effort: 'significant',
                    impact: 'Prevents API key theft and abuse',
                    suggestedFix: 'Create a serverless function (Vercel/Netlify) to proxy API calls',
                    tags: ['api-key', 'security', 'backend']
                }
            );

            // Input sanitization
            this.addImprovement('SECURITY',
                'Add input sanitization for node content',
                'User input should be sanitized before storage and display to prevent XSS.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Prevents XSS attacks if map data is shared',
                    tags: ['xss', 'sanitization', 'input']
                }
            );

            // Content Security Policy
            this.addImprovement('SECURITY',
                'Implement Content Security Policy headers',
                'Add CSP headers to prevent unauthorized script execution.',
                {
                    priority: 'medium',
                    effort: 'quick',
                    impact: 'Additional layer of XSS protection',
                    tags: ['csp', 'headers']
                }
            );

            // localStorage encryption
            this.addImprovement('SECURITY',
                'Encrypt sensitive localStorage data',
                'Neural network data and user preferences are stored unencrypted. Consider encrypting sensitive data.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Privacy protection if device is compromised',
                    tags: ['encryption', 'storage', 'privacy']
                }
            );
        },

        analyzeErrorHandling() {
            // Global error handler
            this.addImprovement('ERROR_HANDLING',
                'Add comprehensive global error handler',
                'Unhandled errors should be caught, logged, and reported gracefully to users.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Better user experience when errors occur, easier debugging',
                    suggestedFix: 'Add window.onerror and window.onunhandledrejection handlers',
                    tags: ['errors', 'logging', 'ux']
                }
            );

            // Retry logic
            this.addImprovement('ERROR_HANDLING',
                'Implement retry logic for API calls',
                'Network failures should trigger automatic retries with exponential backoff.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'More resilient to temporary network issues',
                    tags: ['network', 'retry', 'resilience']
                }
            );

            // Offline detection
            this.addImprovement('ERROR_HANDLING',
                'Improve offline detection and feedback',
                'Better detect offline state and queue operations for when connection returns.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Seamless offline experience',
                    tags: ['offline', 'pwa', 'resilience']
                }
            );
        },

        analyzeModularization() {
            if (!CodePretraining.knowledge?.sections) return;

            // Find large sections that could be split
            for (const [name, section] of Object.entries(CodePretraining.knowledge.sections)) {
                const funcCount = section.functions?.length || 0;
                if (funcCount > 30) {
                    this.addImprovement('MODULARIZATION',
                        `Split large section: ${name} (${funcCount} functions)`,
                        `This section has ${funcCount} functions. Consider splitting into smaller, focused modules.`,
                        {
                            priority: 'medium',
                            effort: 'significant',
                            impact: 'Better code organization, easier navigation',
                            tags: ['section', 'splitting']
                        }
                    );
                }
            }
        },

        analyzeFeatureGaps() {
            // Undo/Redo
            this.addImprovement('FEATURE_GAP',
                'Implement multi-level undo/redo',
                'Currently only single-level undo exists. Full undo history would improve user confidence.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Users can experiment freely without fear of losing work',
                    tags: ['undo', 'history', 'ux']
                }
            );

            // Search & Filter
            this.addImprovement('FEATURE_GAP',
                'Add advanced search with filters',
                'Allow searching by date, category, color, and using boolean operators.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Power users can find content faster',
                    tags: ['search', 'filtering']
                }
            );

            // Export formats
            this.addImprovement('FEATURE_GAP',
                'Add more export formats',
                'Support markdown, OPML, CSV, and image export for better interoperability.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Better integration with other tools',
                    tags: ['export', 'interoperability']
                }
            );

            // Templates
            this.addImprovement('FEATURE_GAP',
                'Add map templates',
                'Pre-built templates for common use cases (project planning, brainstorming, goal setting).',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Faster onboarding, inspire new use cases',
                    tags: ['templates', 'onboarding']
                }
            );

            // Collaboration
            this.addImprovement('FEATURE_GAP',
                'Enhance real-time collaboration features',
                'Add cursor presence, user avatars, and conflict resolution for multi-user editing.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Better team collaboration experience',
                    tags: ['collaboration', 'real-time']
                }
            );

            // Keyboard shortcuts
            this.addImprovement('FEATURE_GAP',
                'Add customizable keyboard shortcuts',
                'Let users define their own keyboard shortcuts for common actions.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Power user productivity',
                    tags: ['keyboard', 'customization']
                }
            );
        },

        analyzeAccessibility() {
            this.addImprovement('ACCESSIBILITY',
                'Add ARIA labels to 3D scene',
                'The Three.js canvas needs ARIA labels and keyboard navigation for screen readers.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Makes app usable for visually impaired users',
                    tags: ['aria', 'screen-reader', 'a11y']
                }
            );

            this.addImprovement('ACCESSIBILITY',
                'Improve keyboard navigation',
                'Ensure all interactive elements are keyboard-focusable with visible focus indicators.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Better keyboard-only navigation',
                    tags: ['keyboard', 'focus', 'a11y']
                }
            );

            this.addImprovement('ACCESSIBILITY',
                'Add high contrast mode',
                'Provide a high contrast theme option for users with low vision.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Better visibility for low-vision users',
                    tags: ['contrast', 'theme', 'a11y']
                }
            );

            this.addImprovement('ACCESSIBILITY',
                'Support reduced motion preference',
                'Respect prefers-reduced-motion media query to disable animations.',
                {
                    priority: 'medium',
                    effort: 'quick',
                    impact: 'Comfortable for users with vestibular disorders',
                    tags: ['motion', 'animations', 'a11y']
                }
            );
        },

        analyzeTechDebt() {
            // Global variables
            this.addImprovement('TECH_DEBT',
                'Reduce global variable usage',
                'Many variables are declared in global scope. Encapsulate in modules or classes.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Fewer naming conflicts, better testability',
                    tags: ['globals', 'scope', 'cleanup']
                }
            );

            // Magic numbers
            this.addImprovement('TECH_DEBT',
                'Extract magic numbers to named constants',
                'Hardcoded values like animation durations, sizes should be named constants.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Easier to adjust behavior, self-documenting code',
                    tags: ['constants', 'readability']
                }
            );

            // Inconsistent naming
            this.addImprovement('TECH_DEBT',
                'Standardize naming conventions',
                'Mix of camelCase, snake_case, and PascalCase. Standardize across codebase.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Consistent, predictable code style',
                    tags: ['naming', 'style', 'consistency']
                }
            );

            // TODO comments
            this.addImprovement('TECH_DEBT',
                'Address TODO comments in code',
                'Search for TODO/FIXME/HACK comments and either resolve or create tracking issues.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Cleaner codebase, no forgotten tasks',
                    tags: ['todos', 'cleanup']
                }
            );
        },

        analyzeOptimizations() {
            // Bundle optimization
            this.addImprovement('OPTIMIZATION',
                'Implement code splitting',
                'Split the bundle so features load on-demand (neural, chat, advanced features).',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Faster initial load, reduced bandwidth',
                    tags: ['bundling', 'lazy-load']
                }
            );

            // Image optimization
            this.addImprovement('OPTIMIZATION',
                'Optimize asset loading',
                'Use WebP format, lazy-load images, and implement responsive images.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Faster load times, less data usage',
                    tags: ['images', 'assets']
                }
            );

            // Service worker caching
            this.addImprovement('OPTIMIZATION',
                'Improve service worker caching strategy',
                'Implement smarter caching with cache-first for static assets, network-first for API.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Better offline experience, faster repeat visits',
                    tags: ['pwa', 'caching', 'offline']
                }
            );

            // IndexedDB optimization
            this.addImprovement('OPTIMIZATION',
                'Optimize IndexedDB operations',
                'Batch writes, use indexes effectively, implement data compaction.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Faster data operations, less storage use',
                    tags: ['indexeddb', 'storage', 'database']
                }
            );
        },

        analyzeUXEnhancements() {
            // Onboarding
            this.addImprovement('UX_ENHANCEMENT',
                'Add interactive onboarding tour',
                'Guide new users through key features with an interactive walkthrough.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Better new user retention, faster learning curve',
                    tags: ['onboarding', 'tutorial', 'ux']
                }
            );

            // Loading states
            this.addImprovement('UX_ENHANCEMENT',
                'Improve loading state feedback',
                'Show skeleton loaders and progress indicators during async operations.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Less perceived latency, clearer feedback',
                    tags: ['loading', 'feedback', 'ux']
                }
            );

            // Drag and drop
            this.addImprovement('UX_ENHANCEMENT',
                'Enhance drag and drop experience',
                'Add visual guides, drop zones, and better feedback during node dragging.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'More intuitive node organization',
                    tags: ['dnd', 'interaction', 'ux']
                }
            );

            // Context menus
            this.addImprovement('UX_ENHANCEMENT',
                'Add right-click context menus',
                'Quick actions via right-click on nodes and empty space.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Faster access to common actions',
                    tags: ['context-menu', 'interaction']
                }
            );

            // Minimap
            this.addImprovement('UX_ENHANCEMENT',
                'Add minimap for large maps',
                'Show a small overview of the entire map for easier navigation.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Better orientation in large maps',
                    tags: ['minimap', 'navigation']
                }
            );

            // Touch gestures
            this.addImprovement('UX_ENHANCEMENT',
                'Improve touch gesture support',
                'Better pinch-to-zoom, swipe gestures, and touch-friendly hit targets.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Better mobile/tablet experience',
                    tags: ['touch', 'mobile', 'gestures']
                }
            );
        },

        analyzeTestability() {
            this.addImprovement('TESTING',
                'Add unit test suite',
                'Implement unit tests for core functions using Jest or similar.',
                {
                    priority: 'high',
                    effort: 'major',
                    impact: 'Catch bugs early, safer refactoring',
                    tags: ['unit-tests', 'jest', 'testing']
                }
            );

            this.addImprovement('TESTING',
                'Add integration tests',
                'Test key user flows end-to-end (add node, move node, AI chat).',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Ensure features work together correctly',
                    tags: ['integration', 'e2e', 'testing']
                }
            );

            this.addImprovement('TESTING',
                'Add visual regression tests',
                'Capture screenshots and detect unintended visual changes.',
                {
                    priority: 'low',
                    effort: 'moderate',
                    impact: 'Catch styling bugs automatically',
                    tags: ['visual', 'regression', 'testing']
                }
            );
        },

        analyzeMaintainability() {
            // Documentation
            this.addImprovement('MAINTAINABILITY',
                'Add JSDoc comments to core functions',
                'Document parameters, return types, and usage examples for key functions.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Easier for new developers to understand code',
                    tags: ['jsdoc', 'documentation']
                }
            );

            // Type safety
            this.addImprovement('MAINTAINABILITY',
                'Add TypeScript type definitions',
                'Create .d.ts files or convert to TypeScript for better type safety.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Catch type errors at compile time, better IDE support',
                    tags: ['typescript', 'types', 'safety']
                }
            );

            // Code formatting
            this.addImprovement('MAINTAINABILITY',
                'Add ESLint and Prettier configuration',
                'Enforce consistent code style automatically.',
                {
                    priority: 'low',
                    effort: 'quick',
                    impact: 'Consistent code style, fewer style debates',
                    tags: ['linting', 'formatting', 'style']
                }
            );
        },

        analyzeMLCapabilities() {
            // ═══════════════════════════════════════════════════════════════════
            // ML INTELLIGENCE - How MYND learns and can improve its learning
            // ═══════════════════════════════════════════════════════════════════

            // === EMBEDDING & REPRESENTATION LEARNING ===

            this.addImprovement('ML_INTELLIGENCE',
                'Upgrade to more powerful embedding model',
                'Current Universal Sentence Encoder is good but limited. Consider fine-tuning on mind-mapping domain or using more recent models like E5, BGE, or sentence-transformers for better semantic understanding.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Better semantic similarity, more accurate predictions, improved retrieval',
                    suggestedFix: 'Evaluate @xenova/transformers for browser-based alternatives or fine-tune USE on mind-map data',
                    tags: ['embeddings', 'nlp', 'representation-learning']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add multi-modal embeddings',
                'Currently only text is embedded. Add image/visual embeddings for linked content, screenshots, and visual patterns in the 3D map layout.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Understand visual patterns, support image-based nodes',
                    tags: ['multimodal', 'vision', 'embeddings']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement hierarchical embeddings',
                'Create embeddings that capture the tree structure, not just text. A node\'s embedding should incorporate its position in the hierarchy and relationships.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Better structure-aware predictions, improved parent suggestions',
                    suggestedFix: 'Combine text embeddings with positional encodings from graph structure',
                    tags: ['graph-embeddings', 'hierarchy', 'structure']
                }
            );

            // === NEURAL NETWORK ARCHITECTURE ===

            this.addImprovement('ML_INTELLIGENCE',
                'Add attention mechanism to PersonalNeuralNet',
                'Current network uses simple dense layers. Adding self-attention would help capture relationships between concepts and improve context understanding.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Better pattern recognition, more nuanced predictions',
                    suggestedFix: 'Implement multi-head attention layer before classification',
                    tags: ['attention', 'transformer', 'architecture']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement Graph Neural Network for node relationships',
                'Current predictions don\'t fully leverage graph structure. A GNN would naturally propagate information through the node hierarchy for better predictions.',
                {
                    priority: 'high',
                    effort: 'major',
                    impact: 'Structure-aware learning, better parent/sibling predictions',
                    suggestedFix: 'Use message-passing GNN layers (GraphSAGE or GAT) on the node tree',
                    tags: ['gnn', 'graph-learning', 'message-passing']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add recurrent memory for session context',
                'Current predictions are stateless per-query. An LSTM/GRU layer could remember session context for more coherent suggestions across a work session.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'More contextual suggestions, remembers session flow',
                    tags: ['rnn', 'memory', 'session-context']
                }
            );

            // === TRAINING & LEARNING STRATEGIES ===

            this.addImprovement('ML_INTELLIGENCE',
                'Implement online learning with replay buffer',
                'Current training is batch-based. Implement experience replay to continuously learn from interactions without forgetting older patterns.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Continuous improvement, no catastrophic forgetting',
                    suggestedFix: 'Add prioritized experience replay buffer with importance sampling',
                    tags: ['online-learning', 'replay-buffer', 'continual-learning']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add meta-learning for faster adaptation',
                'Implement MAML-style meta-learning so the network can quickly adapt to new users or dramatically changed map structures with few examples.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Faster personalization for new users, better adaptation',
                    tags: ['meta-learning', 'few-shot', 'adaptation']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement curriculum learning',
                'Train on progressively harder examples. Start with clear-cut categorizations, then gradually introduce edge cases and ambiguous nodes.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'More robust learning, better handling of edge cases',
                    tags: ['curriculum-learning', 'training-strategy']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add active learning for uncertainty sampling',
                'When the model is uncertain, proactively ask users for feedback on those specific predictions to maximize learning efficiency.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Faster learning with fewer examples, better calibration',
                    suggestedFix: 'Track prediction entropy and trigger feedback requests above threshold',
                    tags: ['active-learning', 'uncertainty', 'feedback']
                }
            );

            // === REINFORCEMENT LEARNING ===

            this.addImprovement('ML_INTELLIGENCE',
                'Implement reward shaping for suggestion quality',
                'Current feedback is binary (accepted/rejected). Implement richer reward signals: time-to-accept, subsequent edits, node survival rate.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'More nuanced learning from user behavior',
                    suggestedFix: 'Track suggestion lifecycle and compute delayed rewards',
                    tags: ['reward-shaping', 'reinforcement-learning']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add bandit algorithms for exploration/exploitation',
                'Balance showing confident predictions vs. exploring new suggestion types using UCB or Thompson Sampling.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Better discovery of user preferences, avoid stale suggestions',
                    tags: ['bandits', 'exploration', 'recommendation']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement policy gradient for action sequences',
                'Learn optimal sequences of suggestions (not just individual ones) using policy gradient methods.',
                {
                    priority: 'low',
                    effort: 'major',
                    impact: 'Coherent multi-step assistance',
                    tags: ['policy-gradient', 'sequence-learning', 'rl']
                }
            );

            // === KNOWLEDGE DISTILLATION & TRANSFER ===

            this.addImprovement('ML_INTELLIGENCE',
                'Enhance Claude-to-local knowledge distillation',
                'Current TeacherKnowledge captures examples but doesn\'t transfer reasoning. Implement soft-label distillation with temperature scaling.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'Local model learns Claude\'s reasoning patterns, not just outputs',
                    suggestedFix: 'Capture Claude\'s confidence distributions and train with KL divergence loss',
                    tags: ['distillation', 'transfer-learning', 'teacher-student']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add cross-user transfer learning',
                'Learn general patterns from aggregate (anonymized) user data to bootstrap new users faster.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Better cold-start experience, shared intelligence',
                    tags: ['transfer-learning', 'federated', 'cold-start']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement domain adaptation for different map types',
                'Detect map domain (work, personal, creative) and adapt predictions accordingly using domain-adversarial training.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Better predictions across different use cases',
                    tags: ['domain-adaptation', 'multi-task']
                }
            );

            // === MEMORY & RETRIEVAL ===

            this.addImprovement('ML_INTELLIGENCE',
                'Upgrade semantic memory with learned retrieval',
                'Current retrieval uses cosine similarity. Train a retrieval model that learns which memories are actually useful for predictions.',
                {
                    priority: 'high',
                    effort: 'significant',
                    impact: 'More relevant memory surfacing, better context',
                    suggestedFix: 'Implement Dense Passage Retrieval (DPR) style dual encoder',
                    tags: ['retrieval', 'memory', 'learned-retrieval']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add episodic memory for interaction patterns',
                'Remember sequences of actions, not just individual nodes. Learn patterns like "after creating X, user usually creates Y".',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Anticipate user workflows, proactive suggestions',
                    tags: ['episodic-memory', 'sequence-patterns']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement memory consolidation during idle time',
                'When app is idle, consolidate and compress memories, identify patterns, and pre-compute useful representations.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'Better use of idle time, improved recall',
                    tags: ['memory-consolidation', 'background-learning']
                }
            );

            // === UNCERTAINTY & CALIBRATION ===

            this.addImprovement('ML_INTELLIGENCE',
                'Add Bayesian uncertainty estimation',
                'Current confidence scores aren\'t well-calibrated. Implement MC Dropout or ensemble methods for better uncertainty quantification.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Know when to ask for help, better trust calibration',
                    suggestedFix: 'Add dropout at inference time and average multiple forward passes',
                    tags: ['uncertainty', 'bayesian', 'calibration']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement confidence calibration with temperature scaling',
                'Post-hoc calibrate confidence scores so 80% confidence means 80% accuracy.',
                {
                    priority: 'medium',
                    effort: 'quick',
                    impact: 'Trustworthy confidence scores',
                    tags: ['calibration', 'temperature-scaling']
                }
            );

            // === INTERPRETABILITY & EXPLAINABILITY ===

            this.addImprovement('ML_INTELLIGENCE',
                'Add attention visualization for predictions',
                'Show users which words/nodes the model focused on when making a prediction, building trust and understanding.',
                {
                    priority: 'medium',
                    effort: 'moderate',
                    impact: 'User understanding, debuggability, trust',
                    tags: ['explainability', 'attention-viz', 'transparency']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement prediction explanations',
                'Generate natural language explanations for why a category or connection was suggested.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'User trust, learning from the AI',
                    suggestedFix: 'Use attention weights + templates or small explanation model',
                    tags: ['explanations', 'nlg', 'trust']
                }
            );

            // === SELF-IMPROVEMENT LOOP ===

            this.addImprovement('ML_INTELLIGENCE',
                'Implement automated model evaluation pipeline',
                'Continuously measure prediction accuracy, track drift, and alert when performance degrades.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Catch problems early, data-driven improvement',
                    suggestedFix: 'Track rolling accuracy, A/B test model changes',
                    tags: ['evaluation', 'monitoring', 'mlops']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add hyperparameter auto-tuning',
                'Automatically adjust learning rate, batch size, and architecture based on performance metrics.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Optimal training configuration',
                    suggestedFix: 'Implement simple grid search or Bayesian optimization',
                    tags: ['hyperparameter-tuning', 'automl']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Create ML improvement roadmap tracker',
                'Build a system that tracks which ML improvements have been made, their impact, and suggests next priorities based on measured gains.',
                {
                    priority: 'high',
                    effort: 'moderate',
                    impact: 'Systematic self-improvement, measurable progress',
                    tags: ['meta', 'tracking', 'roadmap']
                }
            );

            // === ADVANCED CAPABILITIES ===

            this.addImprovement('ML_INTELLIGENCE',
                'Add contrastive learning for better representations',
                'Learn embeddings by contrasting similar vs dissimilar nodes, improving clustering and similarity search.',
                {
                    priority: 'medium',
                    effort: 'significant',
                    impact: 'Better node grouping, improved similarity',
                    suggestedFix: 'Implement SimCLR-style contrastive loss on node pairs',
                    tags: ['contrastive-learning', 'self-supervised']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement causal inference for connection suggestions',
                'Move beyond correlation to understand causal relationships between concepts for smarter connection suggestions.',
                {
                    priority: 'low',
                    effort: 'major',
                    impact: 'Deeper understanding of concept relationships',
                    tags: ['causal-inference', 'reasoning']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Add generative capabilities for node content',
                'Beyond predictions, generate node labels, descriptions, and expansions using fine-tuned language models.',
                {
                    priority: 'medium',
                    effort: 'major',
                    impact: 'Creative assistance, content generation',
                    suggestedFix: 'Fine-tune small LM (GPT-2/DistilGPT) on map content patterns',
                    tags: ['generative', 'llm', 'content-creation']
                }
            );

            this.addImprovement('ML_INTELLIGENCE',
                'Implement neural architecture search for optimal model',
                'Automatically discover the best neural network architecture for the specific patterns in user data.',
                {
                    priority: 'low',
                    effort: 'major',
                    impact: 'Optimal model for each user\'s patterns',
                    tags: ['nas', 'automl', 'architecture-search']
                }
            );
        },

        // ═══════════════════════════════════════════════════════════════════
        // METRICS & REPORTING
        // ═══════════════════════════════════════════════════════════════════

        calculateMetrics() {
            const improvements = this.analysis.improvements;

            this.analysis.metrics.totalImprovements = improvements.length;
            this.analysis.metrics.completedImprovements = improvements.filter(i => i.status === 'completed').length;

            // Calculate technical debt score (higher = more debt)
            const priorityPoints = { critical: 10, high: 5, medium: 2, low: 1 };
            const debtScore = improvements
                .filter(i => i.status !== 'completed')
                .reduce((sum, i) => sum + priorityPoints[i.priority], 0);

            this.analysis.metrics.technicalDebtScore = debtScore;

            // Calculate health score (0-100, higher = healthier)
            const maxPossibleDebt = improvements.length * 10;
            const healthScore = maxPossibleDebt > 0
                ? Math.round(100 - (debtScore / maxPossibleDebt * 100))
                : 100;

            this.analysis.metrics.healthScore = healthScore;
        },

        // Get improvements for AI context
        getContext(query, maxItems = 10) {
            if (!this.initialized || !this.analysis) return null;

            const queryLower = query.toLowerCase();
            let context = '\n🔍 SELF-IMPROVEMENT ANALYSIS:\n';

            // Check if query is about improvements
            const improvementKeywords = ['improve', 'better', 'enhance', 'optimize', 'fix', 'upgrade', 'faster', 'cleaner', 'refactor', 'security', 'performance', 'debt', 'todo', 'suggestion'];
            const isAboutImprovements = improvementKeywords.some(kw => queryLower.includes(kw));

            if (!isAboutImprovements && !queryLower.includes('self') && !queryLower.includes('code')) {
                // Return just summary for non-improvement queries
                context += `Health Score: ${this.analysis.metrics.healthScore}/100\n`;
                context += `${this.analysis.metrics.totalImprovements} improvements identified across ${Object.keys(this.CATEGORIES).length} categories.\n`;
                return context;
            }

            // Add metrics
            context += `\n📊 Codebase Health: ${this.analysis.metrics.healthScore}/100\n`;
            context += `Technical Debt Score: ${this.analysis.metrics.technicalDebtScore}\n`;
            context += `Total Improvements: ${this.analysis.metrics.totalImprovements}\n`;

            // Find relevant improvements
            let relevantImprovements = this.analysis.improvements;

            // Filter by query keywords
            const keywords = queryLower.split(/\s+/).filter(w => w.length > 3);
            if (keywords.length > 0) {
                relevantImprovements = relevantImprovements.filter(imp => {
                    const impText = `${imp.title} ${imp.description} ${imp.tags.join(' ')}`.toLowerCase();
                    return keywords.some(kw => impText.includes(kw));
                });
            }

            // If no specific matches, show top by priority
            if (relevantImprovements.length === 0) {
                relevantImprovements = this.analysis.improvements;
            }

            // Group by priority for output
            const critical = relevantImprovements.filter(i => i.priority === 'critical').slice(0, 3);
            const high = relevantImprovements.filter(i => i.priority === 'high').slice(0, 4);
            const medium = relevantImprovements.filter(i => i.priority === 'medium').slice(0, 3);

            if (critical.length > 0) {
                context += `\n🚨 CRITICAL:\n`;
                critical.forEach(i => context += `  ${i.categoryIcon} ${i.title}\n`);
            }

            if (high.length > 0) {
                context += `\n⚠️ HIGH PRIORITY:\n`;
                high.forEach(i => context += `  ${i.categoryIcon} ${i.title}\n`);
            }

            if (medium.length > 0) {
                context += `\n📋 MEDIUM PRIORITY:\n`;
                medium.forEach(i => context += `  ${i.categoryIcon} ${i.title}\n`);
            }

            // Category summary
            context += `\nBy Category:\n`;
            for (const [cat, items] of Object.entries(this.analysis.byCategory)) {
                if (items.length > 0) {
                    const catInfo = this.CATEGORIES[cat];
                    context += `  ${catInfo.icon} ${catInfo.name}: ${items.length} items\n`;
                }
            }

            return context;
        },

        // Get detailed improvement by ID or title
        getImprovement(identifier) {
            if (!this.analysis) return null;

            return this.analysis.improvements.find(i =>
                i.id === identifier ||
                i.title.toLowerCase().includes(identifier.toLowerCase())
            );
        },

        // Get all improvements for a category
        getCategoryImprovements(category) {
            return this.analysis?.byCategory[category] || [];
        },

        // Get quick wins (high impact, low effort)
        getQuickWins() {
            if (!this.analysis) return [];

            return this.analysis.improvements
                .filter(i => i.effort === 'quick' && ['critical', 'high'].includes(i.priority))
                .slice(0, 10);
        },

        // Get full improvement report
        getFullReport() {
            if (!this.analysis) return 'Analysis not initialized';

            let report = `# MYND Self-Improvement Analysis Report\n`;
            report += `Generated: ${new Date(this.analysis.timestamp).toLocaleString()}\n\n`;

            report += `## 📊 Summary\n`;
            report += `- **Health Score:** ${this.analysis.metrics.healthScore}/100\n`;
            report += `- **Technical Debt Score:** ${this.analysis.metrics.technicalDebtScore}\n`;
            report += `- **Total Improvements:** ${this.analysis.metrics.totalImprovements}\n`;
            report += `- **Completed:** ${this.analysis.metrics.completedImprovements}\n\n`;

            // By priority
            report += `## 🎯 By Priority\n`;
            for (const priority of ['critical', 'high', 'medium', 'low']) {
                const items = this.analysis.byPriority[priority];
                if (items.length > 0) {
                    report += `### ${priority.toUpperCase()} (${items.length})\n`;
                    items.forEach(i => {
                        report += `- ${i.categoryIcon} **${i.title}** [${i.effort}]\n`;
                        report += `  ${i.description}\n`;
                    });
                    report += '\n';
                }
            }

            // By category
            report += `## 📁 By Category\n`;
            for (const [cat, items] of Object.entries(this.analysis.byCategory)) {
                if (items.length > 0) {
                    const catInfo = this.CATEGORIES[cat];
                    report += `### ${catInfo.icon} ${catInfo.name} (${items.length})\n`;
                    items.forEach(i => {
                        report += `- **${i.title}** [${i.priority}/${i.effort}]\n`;
                    });
                    report += '\n';
                }
            }

            return report;
        },

        // Mark improvement as completed
        completeImprovement(identifier) {
            const improvement = this.getImprovement(identifier);
            if (improvement) {
                improvement.status = 'completed';
                improvement.completedAt = Date.now();
                this.calculateMetrics();
                this.saveToStorage();
                return true;
            }
            return false;
        },

        // Storage
        saveToStorage() {
            try {
                const data = {
                    version: this.VERSION,
                    analysis: this.analysis,
                    timestamp: Date.now()
                };
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
                console.log('🔍 CodeAnalyzer saved');
            } catch (error) {
                console.warn('CodeAnalyzer save failed:', error);
            }
        },

        loadFromStorage() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                return data ? JSON.parse(data) : null;
            } catch (error) {
                return null;
            }
        },

        getStats() {
            return {
                initialized: this.initialized,
                ...this.analysis?.metrics,
                categories: Object.keys(this.CATEGORIES).length
            };
        },

        // Force re-analyze
        async rebuild() {
            localStorage.removeItem(this.STORAGE_KEY);
            this.initialized = false;
            this.analysis = null;
            return this.initialize();
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // TEACHER KNOWLEDGE - Knowledge distillation from Claude
    // ═══════════════════════════════════════════════════════════════════
    // Captures Claude's predictions as "soft targets" for training the local model
    // This allows the local neural network to learn from Claude's reasoning
    const TeacherKnowledge = {
        STORAGE_KEY: 'mynd_teacher_knowledge',
        MAX_EXAMPLES: 500, // Keep last 500 teacher examples

        // Store a teacher example (Claude's prediction)
        capture(type, input, prediction) {
            const example = {
                type,           // 'category', 'children', 'connection'
                input,          // The input text/context
                prediction,     // Claude's prediction with confidence
                timestamp: Date.now()
            };

            try {
                const stored = this.getAll();
                stored.push(example);

                // Keep only the most recent examples
                while (stored.length > this.MAX_EXAMPLES) stored.shift();

                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(stored));
                console.log(`📚 Teacher knowledge captured: ${type}`);

                return true;
            } catch (e) {
                console.warn('Failed to store teacher knowledge:', e);
                return false;
            }
        },

        // Get all teacher examples
        getAll() {
            try {
                return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
            } catch (e) {
                return [];
            }
        },

        // Get teacher examples by type
        getByType(type) {
            return this.getAll().filter(ex => ex.type === type);
        },

        // Get teacher examples for training (with embeddings if available)
        async getTrainingExamples(type, neuralNet) {
            const examples = this.getByType(type);
            if (examples.length === 0) return [];

            const trainingExamples = [];

            for (const ex of examples) {
                if (type === 'category' && ex.prediction?.category) {
                    // Get embedding for the input text
                    const embedding = await neuralNet.getEmbedding(ex.input);
                    if (embedding) {
                        trainingExamples.push({
                            embedding,
                            category: ex.prediction.category,
                            confidence: ex.prediction.confidence || 0.8,
                            isTeacher: true // Mark as teacher example
                        });
                    }
                }
            }

            return trainingExamples;
        },

        // Clear old examples
        prune(maxAge = 7 * 24 * 60 * 60 * 1000) { // Default: 7 days
            const cutoff = Date.now() - maxAge;
            const stored = this.getAll();
            const fresh = stored.filter(ex => ex.timestamp > cutoff);

            if (fresh.length < stored.length) {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(fresh));
                console.log(`📚 Pruned ${stored.length - fresh.length} old teacher examples`);
            }
        },

        // Get stats
        getStats() {
            const all = this.getAll();
            const byType = {};
            for (const ex of all) {
                byType[ex.type] = (byType[ex.type] || 0) + 1;
            }
            return {
                total: all.length,
                byType,
                oldestTimestamp: all[0]?.timestamp,
                newestTimestamp: all[all.length - 1]?.timestamp
            };
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // AI FEEDBACK TRACKING - Learns from user responses to suggestions
    // ═══════════════════════════════════════════════════════════════════
    const AIFeedback = {
        pending: new Map(),

        // Cache for feedback weights (invalidated when new feedback is stored)
        _feedbackWeightsCache: null,
        _feedbackWeightsCacheTime: 0,
        _feedbackCacheMaxAge: 30000, // Cache valid for 30 seconds

        // Log when AI makes a suggestion
        suggest(type, content, context = {}) {
            const id = crypto.randomUUID();
            this.pending.set(id, {
                id,
                type, // 'category', 'node', 'connection', 'expansion'
                content,
                context: {
                    parentId: context.parentId || (typeof currentContextId !== 'undefined' ? currentContextId : null),
                    timestamp: Date.now()
                }
            });
            
            // Auto-expire after 2 minutes
            setTimeout(() => {
                if (this.pending.has(id)) {
                    this.resolve(id, 'ignored');
                }
            }, 2 * 60 * 1000);
            
            return id;
        },
        
        // Log user's response
        resolve(suggestionId, action, modification = null) {
            const suggestion = this.pending.get(suggestionId);
            if (!suggestion) return;

            const feedback = {
                ...suggestion,
                action, // 'accepted', 'modified', 'rejected', 'ignored'
                modification,
                responseTime: Date.now() - suggestion.context.timestamp
            };

            this.pending.delete(suggestionId);
            this.store(feedback);

            // Log for debugging
            console.log(`📊 AI Feedback: ${feedback.type} → ${action}`,
                action === 'modified' ? `(chose: ${modification})` : '');

            // Trigger IMMEDIATE online learning (fast, single-sample update)
            if (action !== 'ignored') {
                this.triggerOnlineLearning(feedback);
            }

            // === SEMANTIC MEMORY BRIDGE ===
            // Notify MetaLearner about AI feedback patterns
            if (typeof metaLearner !== 'undefined' && action !== 'ignored') {
                metaLearner.trackAIFeedback(feedback);
            }

            // Create semantic memory for significant feedback
            if (typeof semanticMemory !== 'undefined' && action !== 'ignored') {
                this.createFeedbackMemory(feedback);
            }

            // Trigger BATCH learning if enough feedback has accumulated
            this.checkAndTriggerLearning(feedback);
        },

        // Create a semantic memory from feedback
        createFeedbackMemory(feedback) {
            const { type, action, content, modification, context } = feedback;

            // Build memory context string
            let memoryContext = '';
            if (type === 'category') {
                if (action === 'accepted') {
                    memoryContext = `User accepted AI suggestion to categorize "${context?.nodeLabel || 'content'}" as "${content?.predicted}"`;
                } else if (action === 'modified') {
                    memoryContext = `User changed category from "${content?.predicted}" to "${modification}" for "${context?.nodeLabel || 'content'}"`;
                } else if (action === 'rejected') {
                    memoryContext = `User rejected AI category suggestion "${content?.predicted}" for "${context?.nodeLabel || 'content'}"`;
                }
            }

            if (memoryContext) {
                const eventType = action === 'accepted' ? 'suggestion_accepted' : 'suggestion_rejected';
                semanticMemory.addMemory(eventType, memoryContext, {
                    feedbackType: type,
                    action,
                    predicted: content?.predicted,
                    chosen: modification || content?.predicted,
                    confidence: content?.confidence
                }).catch(err => console.warn('Failed to create feedback memory:', err));
            }
        },

        // Trigger immediate online learning (non-blocking)
        triggerOnlineLearning(feedback) {
            if (typeof neuralNet === 'undefined' || !neuralNet.isReady) return;

            // Call asynchronously so it doesn't block UI
            neuralNet.learnFromFeedback(feedback).catch(err => {
                console.warn('Online learning failed:', err);
            });
        },

        // Check if incremental learning should be triggered
        feedbackSinceLastTrain: 0,
        lastTrainTime: 0,

        checkAndTriggerLearning(feedback) {
            // Only trigger on meaningful feedback (not ignored)
            if (feedback.action === 'ignored') return;

            this.feedbackSinceLastTrain++;

            // Check if we should trigger learning
            const now = Date.now();
            const timeSinceLastTrain = now - this.lastTrainTime;
            const threshold = CONFIG.NEURAL_NET.feedbackBatchThreshold;
            const minInterval = CONFIG.NEURAL_NET.feedbackMinInterval;

            if (this.feedbackSinceLastTrain >= threshold &&
                timeSinceLastTrain >= minInterval) {

                console.log(`🧠 Triggering incremental learning (${this.feedbackSinceLastTrain} new feedback items)`);

                // Reset counters
                this.feedbackSinceLastTrain = 0;
                this.lastTrainTime = now;

                // Trigger learning asynchronously (non-blocking)
                this.triggerIncrementalLearning();
            }
        },

        async triggerIncrementalLearning() {
            // Get reference to neural network and store
            if (typeof neuralNet === 'undefined' || !neuralNet.isReady) {
                console.log('🧠 Neural network not ready, skipping incremental learning');
                return;
            }

            if (neuralNet.isTraining) {
                console.log('🧠 Training already in progress, skipping');
                return;
            }

            try {
                // Get the current store from app
                const store = window.app?.store;
                if (!store) {
                    console.log('🧠 Store not available, skipping incremental learning');
                    return;
                }

                // Perform incremental training with feedback weights
                console.log('🧠 Starting incremental learning from feedback...');
                const result = await neuralNet.train(store);

                if (result) {
                    console.log('✓ Incremental learning complete');
                } else {
                    console.log('⚠ Incremental learning skipped (not enough data)');
                }
            } catch (error) {
                console.error('❌ Incremental learning failed:', error);
            }
        },
        
        // Store feedback locally
        store(feedback) {
            const feedbackData = {
                type: feedback.type,
                action: feedback.action,
                predicted: feedback.content?.predicted,
                chosen: feedback.modification || feedback.content?.predicted,
                responseTime: feedback.responseTime,
                timestamp: feedback.context.timestamp
            };

            // Invalidate feedback weights cache when new feedback is stored
            this._feedbackWeightsCache = null;

            try {
                const key = 'mynd_ai_feedback';
                const stored = JSON.parse(localStorage.getItem(key) || '[]');
                stored.push(feedbackData);
                // Keep last 200 interactions
                while (stored.length > 200) stored.shift();
                localStorage.setItem(key, JSON.stringify(stored));
            } catch (e) {
                console.warn('Failed to store AI feedback locally:', e);
            }
            
            // Also sync to Supabase if logged in (non-blocking)
            if (typeof SupabaseSync !== 'undefined' && SupabaseSync.syncEnabled) {
                SupabaseSync.saveAIFeedback(feedbackData).catch(err => 
                    console.warn('Cloud sync of AI feedback failed:', err)
                );
            }
        },
        
        // Get stats for a suggestion type
        getStats(type = null) {
            try {
                const stored = JSON.parse(localStorage.getItem('mynd_ai_feedback') || '[]');
                const filtered = type ? stored.filter(f => f.type === type) : stored;
                
                if (filtered.length === 0) return null;
                
                const stats = {
                    total: filtered.length,
                    accepted: filtered.filter(f => f.action === 'accepted').length,
                    modified: filtered.filter(f => f.action === 'modified').length,
                    rejected: filtered.filter(f => f.action === 'rejected').length,
                    ignored: filtered.filter(f => f.action === 'ignored').length
                };
                
                stats.acceptanceRate = (stats.accepted + stats.modified * 0.5) / stats.total;
                stats.avgResponseTime = filtered.reduce((sum, f) => sum + (f.responseTime || 0), 0) / filtered.length;
                
                return stats;
            } catch (e) {
                return null;
            }
        },
        
        // Debug: Log stats to console
        debug() {
            const stats = this.getStats('category');
            if (!stats) {
                console.log('📊 AI Feedback: No data yet');
                return;
            }

            console.log('📊 AI Feedback Stats (Category Predictions):');
            console.log(`   Total: ${stats.total}`);
            console.log(`   Accepted: ${stats.accepted} (${Math.round(stats.accepted/stats.total*100)}%)`);
            console.log(`   Modified: ${stats.modified} (${Math.round(stats.modified/stats.total*100)}%)`);
            console.log(`   Rejected: ${stats.rejected} (${Math.round(stats.rejected/stats.total*100)}%)`);
            console.log(`   Ignored: ${stats.ignored} (${Math.round(stats.ignored/stats.total*100)}%)`);
            console.log(`   Acceptance Rate: ${Math.round(stats.acceptanceRate*100)}%`);
            console.log(`   Avg Response Time: ${Math.round(stats.avgResponseTime/1000)}s`);

            return stats;
        },

        // Get all stored feedback for training
        getFeedback() {
            try {
                return JSON.parse(localStorage.getItem('mynd_ai_feedback') || '[]');
            } catch (e) {
                return [];
            }
        },

        // Generate training weights from feedback history
        // Returns Map<patternKey, {weight, confidence, samples}>
        // Uses caching to avoid recomputing on every call
        getFeedbackWeights() {
            // Check if we have a valid cache
            const now = Date.now();
            if (this._feedbackWeightsCache &&
                (now - this._feedbackWeightsCacheTime) < this._feedbackCacheMaxAge) {
                return this._feedbackWeightsCache;
            }

            const feedback = this.getFeedback();
            const patternStats = new Map();

            // Aggregate feedback by pattern (predicted content)
            for (const item of feedback) {
                if (!item.predicted) continue;

                const key = item.predicted.toLowerCase().trim();
                if (!patternStats.has(key)) {
                    patternStats.set(key, {
                        accepted: 0,
                        modified: 0,
                        rejected: 0,
                        ignored: 0,
                        total: 0,
                        chosen: [] // What user actually chose when modified
                    });
                }

                const stats = patternStats.get(key);
                stats[item.action]++;
                stats.total++;

                // Track what user chose instead
                if (item.action === 'modified' && item.chosen && item.chosen !== item.predicted) {
                    stats.chosen.push(item.chosen);
                }
            }

            // Convert stats to training weights
            const weights = new Map();

            for (const [pattern, stats] of patternStats) {
                if (stats.total < 2) continue; // Need at least 2 samples for confidence

                // Calculate acceptance score: accepted=1.0, modified=0.5, rejected=-0.5, ignored=0
                const positiveSignal = stats.accepted + (stats.modified * 0.5);
                const negativeSignal = stats.rejected * 0.5;
                const acceptanceRate = (positiveSignal - negativeSignal) / stats.total;

                // Weight ranges from 0.2 (heavily rejected) to 2.0 (heavily accepted)
                // Neutral (50% acceptance) = 1.0
                const weight = Math.max(0.2, Math.min(2.0, 1.0 + acceptanceRate));

                // Confidence based on sample size (more samples = higher confidence)
                const confidence = Math.min(1.0, stats.total / 10);

                weights.set(pattern, {
                    weight,
                    confidence,
                    samples: stats.total,
                    acceptanceRate: (stats.accepted + stats.modified) / stats.total,
                    rejectionRate: stats.rejected / stats.total
                });

                // Also boost patterns that users chose instead
                for (const chosen of stats.chosen) {
                    const chosenKey = chosen.toLowerCase().trim();
                    if (!weights.has(chosenKey)) {
                        weights.set(chosenKey, {
                            weight: 1.5, // User-chosen alternatives get boosted
                            confidence: 0.7,
                            samples: 1,
                            acceptanceRate: 1.0,
                            rejectionRate: 0,
                            userChosen: true
                        });
                    } else {
                        const existing = weights.get(chosenKey);
                        existing.weight = Math.min(2.0, existing.weight + 0.2);
                        existing.userChosen = true;
                    }
                }
            }

            // Update cache
            this._feedbackWeightsCache = weights;
            this._feedbackWeightsCacheTime = Date.now();

            console.log(`📊 Generated ${weights.size} feedback weights for training (cached)`);
            return weights;
        },

        // Get feedback-based boost for a specific pattern
        getPatternBoost(pattern) {
            const weights = this.getFeedbackWeights();
            const key = pattern.toLowerCase().trim();
            return weights.get(key) || { weight: 1.0, confidence: 0, samples: 0 };
        }
    };
    
    // Expose for debugging: window.AIFeedback.debug()
    window.AIFeedback = AIFeedback;
    
    // ═══════════════════════════════════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════
    const Utils = {
        // Smoother easing functions for transitions
        easing: {
            smoothStep: t => t * t * (3 - 2 * t),
            smootherStep: t => t * t * t * (t * (t * 6 - 15) + 10),
            outCubic: t => 1 - Math.pow(1 - t, 3),
            outQuart: t => 1 - Math.pow(1 - t, 4)
        },
        
        // Check if theme is dark
        isDarkTheme() {
            const theme = document.documentElement.getAttribute('data-theme') || 'obsidian';
            return ['obsidian'].includes(theme);
        }
    };
    
    // Get colors based on current theme
    function getThemeColors() {
        const theme = document.documentElement.getAttribute('data-theme') || 'obsidian';
        return CONFIG.THEME_COLORS[theme] || CONFIG.THEME_COLORS.sandstone;
    }
    
    // Map a color from one palette to another by index
    function remapColor(color, fromPalette, toPalette) {
        const index = fromPalette.findIndex(c => c.toLowerCase() === color.toLowerCase());
        if (index >= 0 && index < toPalette.length) {
            return toPalette[index];
        }
        // If not found in palette, return null to signal we need special handling
        return null;
    }
    
    // Update all node colors for theme change
    function updateNodeColorsForTheme(oldTheme, newTheme) {
        const fromPalette = CONFIG.THEME_COLORS[oldTheme] || CONFIG.THEME_COLORS.coral;
        const toPalette = CONFIG.THEME_COLORS[newTheme] || CONFIG.THEME_COLORS.coral;
        
        if (typeof nodes === 'undefined' || !nodes) return;
        
        // First pass: build a map of old colors to new colors
        // This ensures nodes with the same old color get the same new color
        const colorMap = new Map();
        let unmappedColorIndex = 1; // Start at 1 to skip root color
        
        nodes.forEach((mesh) => {
            const oldColor = mesh.userData.color?.toLowerCase();
            if (!oldColor || colorMap.has(oldColor)) return;
            
            // Try to find exact match in palette
            const mappedColor = remapColor(mesh.userData.color, fromPalette, toPalette);
            if (mappedColor) {
                colorMap.set(oldColor, mappedColor);
            } else {
                // Assign next available color from new palette (skipping root color at index 0)
                colorMap.set(oldColor, toPalette[unmappedColorIndex % toPalette.length]);
                unmappedColorIndex++;
                // Reset to 1 if we've gone through all colors (skip 0 which is root)
                if (unmappedColorIndex >= toPalette.length) unmappedColorIndex = 1;
            }
        });
        
        // Second pass: apply the color mapping
        nodes.forEach((mesh) => {
            let newColor;
            
            // Root node always gets the first color of the new palette
            if (mesh.userData.id === 'mynd') {
                newColor = toPalette[0];
            } else {
                const oldColor = mesh.userData.color?.toLowerCase();
                newColor = colorMap.get(oldColor) || toPalette[1];
            }
            
            // Always update colors when switching themes
            mesh.userData.color = newColor;
            mesh.material.color.set(newColor);
            mesh.material.emissive.set(newColor);
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            // Update connection line color
            if (mesh.userData.connectionLine) {
                mesh.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update stored data
            store.updateNode(mesh.userData.id, { color: newColor });
        });
        
        // Also update label colors if switching between light/dark themes
        const wasLight = !['obsidian'].includes(oldTheme);
        const isLight = !['obsidian'].includes(newTheme);
        if (wasLight !== isLight) {
            updateLabelsForTheme();
        }
    }
    
    // Update color pickers for current theme
    function updateColorPickers() {
        const colors = getThemeColors();
        const colorGrid = document.getElementById('color-grid');
        const infoColorPicker = document.getElementById('info-color-picker');
        
        if (colorGrid) {
            colorGrid.innerHTML = colors.map(color => 
                `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
            ).join('');
        }
        
        if (infoColorPicker) {
            infoColorPicker.innerHTML = colors.slice(0, 12).map(color => 
                `<span style="background:${color}" data-color="${color}"></span>`
            ).join('');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // EVENT BUS
    // ═══════════════════════════════════════════════════════════════════
    class EventBus {
        constructor() { this.listeners = new Map(); }
        on(event, cb) { 
            if (!this.listeners.has(event)) this.listeners.set(event, new Set()); 
            this.listeners.get(event).add(cb); 
            return () => this.off(event, cb); 
        }
        off(event, cb) { this.listeners.get(event)?.delete(cb); }
        emit(event, data) { this.listeners.get(event)?.forEach(cb => cb(data)); }
    }
    const bus = new EventBus();

    // ═══════════════════════════════════════════════════════════════════
    // DATA STORE
    // ═══════════════════════════════════════════════════════════════════
    const defaultData = {
        id: 'mynd',
        label: 'My Mind',
        color: '#A8D5E5',
        description: '',
        children: []
    };

    class Store {
        constructor() {
            this.data = this.load();
            this.selectedNodeId = null;
            this.expandedNodes = new Set();
            this.undoStack = [];
            this.maxUndoSteps = 50;
        }
        
        load() {
            try {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate basic structure
                    if (parsed && parsed.id && parsed.label) {
                        return parsed;
                    }
                    console.warn('Invalid saved data structure, using defaults');
                }
            } catch (e) {
                console.warn('Failed to parse saved data, using defaults:', e.message);
            }
            return JSON.parse(JSON.stringify(defaultData));
        }
        
        save() {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.data));
                bus.emit('data:saved');
                
                // Sync to cloud (debounced)
                if (SupabaseSync.syncEnabled) {
                    SupabaseSync.scheduleSave(this.exportData(), this.data?.label || 'My Mind');
                }
            } catch (e) {
                console.warn('Failed to save data:', e.message);
            }
        }
        
        saveSnapshot(name = 'change') {
            this.undoStack.push({
                data: JSON.parse(JSON.stringify(this.data)),
                expandedNodes: new Set(this.expandedNodes),
                actionName: name
            });
            if (this.undoStack.length > this.maxUndoSteps) this.undoStack.shift();
            bus.emit('undo:changed');
        }
        
        undo() {
            if (this.undoStack.length === 0) return { success: false };
            const snapshot = this.undoStack.pop();
            this.data = snapshot.data;
            this.expandedNodes = snapshot.expandedNodes;
            this.save();
            bus.emit('data:undone', { actionName: snapshot.actionName });
            bus.emit('undo:changed');
            return { success: true, actionName: snapshot.actionName };
        }
        
        canUndo() {
            return this.undoStack.length > 0;
        }
        
        findNode(id, node = this.data) {
            if (node.id === id) return node;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }
        
        findParent(id, node = this.data, parent = null) {
            if (node.id === id) return parent;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findParent(id, child, node);
                    if (found !== undefined) return found;
                }
            }
            return undefined;
        }
        
        getPath(id) {
            const path = [];
            const build = (node, target, current = []) => {
                current.push(node);
                if (node.id === target) {
                    path.push(...current);
                    return true;
                }
                if (node.children) {
                    for (const child of node.children) {
                        if (build(child, target, [...current])) return true;
                    }
                }
                return false;
            };
            build(this.data, id);
            return path;
        }
        
        getAllNodes(node = this.data, result = []) {
            result.push(node);
            if (node.children) {
                node.children.forEach(c => this.getAllNodes(c, result));
            }
            return result;
        }
        
        searchNodes(query) {
            const q = query.toLowerCase();
            return this.getAllNodes().filter(n => 
                n.label.toLowerCase().includes(q) || 
                (n.description && n.description.toLowerCase().includes(q))
            );
        }
        
        addNode(parentId, nodeData) {
            const parent = this.findNode(parentId);
            if (!parent) return null;
            
            this.saveSnapshot('Add node');
            if (!parent.children) parent.children = [];
            
            const newNode = {
                id: nodeData.id || `node-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                label: nodeData.label || 'New Node',
                color: nodeData.color || parent.color,
                description: nodeData.description || '',
                source: nodeData.source || 'user',
                createdAt: nodeData.createdAt || new Date().toISOString(),
                children: []
            };
            
            // Include link data if present
            if (nodeData.link) {
                newNode.link = nodeData.link;
                newNode.source = nodeData.source || 'link';
            }
            
            // Include importance if specified
            if (nodeData.importance) {
                newNode.importance = nodeData.importance;
            }
            
            parent.children.push(newNode);
            this.expandedNodes.add(parentId);
            this.save();
            bus.emit('node:added', { parent, node: newNode });
            return newNode;
        }
        
        updateNode(id, updates) {
            const node = this.findNode(id);
            if (!node) return null;
            
            this.saveSnapshot('Edit node');
            Object.assign(node, updates);
            this.save();
            bus.emit('node:updated', { node });
            return node;
        }
        
        deleteNode(id) {
            if (id === this.data.id) return false;
            
            const parent = this.findParent(id);
            if (!parent || !parent.children) return false;
            
            const index = parent.children.findIndex(c => c.id === id);
            if (index === -1) return false;
            
            this.saveSnapshot('Delete node');
            const deleted = parent.children.splice(index, 1)[0];
            this.save();
            bus.emit('node:deleted', { parentId: parent.id, node: deleted });
            return true;
        }
        
        moveNode(nodeId, newParentId) {
            // Can't move root
            if (nodeId === this.data.id) return false;
            // Can't move to itself
            if (nodeId === newParentId) return false;
            
            const node = this.findNode(nodeId);
            const oldParent = this.findParent(nodeId);
            const newParent = this.findNode(newParentId);
            
            if (!node || !oldParent || !newParent) return false;
            
            // Can't move to a descendant
            const isDescendant = (parent, targetId) => {
                if (parent.id === targetId) return true;
                for (const child of (parent.children || [])) {
                    if (isDescendant(child, targetId)) return true;
                }
                return false;
            };
            if (isDescendant(node, newParentId)) return false;
            
            this.saveSnapshot('Move node');
            
            // Remove from old parent
            const index = oldParent.children.findIndex(c => c.id === nodeId);
            if (index === -1) return false;
            oldParent.children.splice(index, 1);
            
            // Add to new parent
            if (!newParent.children) newParent.children = [];
            newParent.children.push(node);
            
            this.save();
            bus.emit('node:moved', { nodeId, oldParentId: oldParent.id, newParentId });
            return true;
        }
        
        // Reorder node within its siblings (direction: -1 for earlier, +1 for later)
        reorderNode(nodeId, direction) {
            const parent = this.findParent(nodeId);
            if (!parent || !parent.children || parent.children.length < 2) return false;
            
            const index = parent.children.findIndex(c => c.id === nodeId);
            if (index === -1) return false;
            
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= parent.children.length) return false;
            
            this.saveSnapshot('Reorder node');
            
            // Swap positions
            const temp = parent.children[index];
            parent.children[index] = parent.children[newIndex];
            parent.children[newIndex] = temp;
            
            this.save();
            bus.emit('node:reordered', { nodeId, oldIndex: index, newIndex });
            return true;
        }
        
        // Move node to specific position in siblings
        reorderNodeToPosition(nodeId, position) {
            const parent = this.findParent(nodeId);
            if (!parent || !parent.children) return false;
            
            const currentIndex = parent.children.findIndex(c => c.id === nodeId);
            if (currentIndex === -1) return false;
            
            const targetIndex = position === 'first' ? 0 : 
                               position === 'last' ? parent.children.length - 1 :
                               typeof position === 'number' ? Math.max(0, Math.min(position, parent.children.length - 1)) :
                               currentIndex;
            
            if (targetIndex === currentIndex) return false;
            
            this.saveSnapshot('Reorder node');
            
            // Remove from current position
            const [node] = parent.children.splice(currentIndex, 1);
            // Insert at new position
            parent.children.splice(targetIndex, 0, node);
            
            this.save();
            bus.emit('node:reordered', { nodeId, oldIndex: currentIndex, newIndex: targetIndex });
            return true;
        }
        
        reset(rootLabel = 'My Mind') {
            const newData = JSON.parse(JSON.stringify(defaultData));
            newData.label = rootLabel;
            this.data = newData;
            this.expandedNodes.clear();
            this.undoStack = [];
            this.save();
            bus.emit('data:reset');
        }
        
        exportJSON() {
            // Synchronous fallback - just map data
            return JSON.stringify({ version: 2, map: this.data }, null, 2);
        }
        
        // Comprehensive async export including all neural learning data
        async exportFullJSON() {
            const exportData = {
                version: 3, // New comprehensive format
                exportedAt: Date.now(),
                map: this.data,
                neural: {
                    // Core neural network data
                    modelData: null,
                    embeddings: null,
                    expansionPatterns: null,
                    patternWeights: null,
                    categories: null,
                    commonPatterns: null
                },
                userProfile: null,
                metaLearner: null,
                conceptAbstractor: null,
                semanticMemory: null
            };
            
            try {
                // 1. Get neural network model data from IndexedDB
                const modelData = await NeuralDB.load('neural-models');
                if (modelData) {
                    exportData.neural.modelData = modelData;
                }
                
                // 2. Get embeddings from IndexedDB
                const embeddingsData = await NeuralDB.load('embeddings');
                if (embeddingsData) {
                    exportData.neural.embeddings = embeddingsData;
                }
                
                // 3. Get live neural network state
                if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                    // Convert Maps to objects for JSON serialization
                    if (neuralNet.expansionPatterns && neuralNet.expansionPatterns.size > 0) {
                        exportData.neural.expansionPatterns = Object.fromEntries(neuralNet.expansionPatterns);
                    }
                    if (neuralNet.patternWeights && neuralNet.patternWeights.size > 0) {
                        exportData.neural.patternWeights = Object.fromEntries(neuralNet.patternWeights);
                    }
                    if (neuralNet.embeddings && neuralNet.embeddings.size > 0) {
                        // Convert embedding Map (key -> Float32Array) to serializable format
                        const embeddingsObj = {};
                        neuralNet.embeddings.forEach((value, key) => {
                            embeddingsObj[key] = Array.from(value);
                        });
                        exportData.neural.embeddings = embeddingsObj;
                    }
                    if (neuralNet.categories && neuralNet.categories.length > 0) {
                        exportData.neural.categories = neuralNet.categories;
                    }
                    if (neuralNet.commonPatterns && neuralNet.commonPatterns.length > 0) {
                        exportData.neural.commonPatterns = neuralNet.commonPatterns;
                    }
                }
                
                // 4. Get user profile data
                const userProfileData = await NeuralDB.load('user-profile');
                if (userProfileData) {
                    exportData.userProfile = userProfileData;
                } else if (typeof userProfile !== 'undefined' && userProfile.loaded) {
                    exportData.userProfile = {
                        depthStats: userProfile.depthStats,
                        namingStats: userProfile.namingStats,
                        categoryStats: userProfile.categoryStats,
                        timeStats: userProfile.timeStats
                    };
                }
                
                // 5. Get meta learner data
                const metaLearnerData = await NeuralDB.load('meta-learner');
                if (metaLearnerData) {
                    exportData.metaLearner = metaLearnerData;
                } else if (typeof metaLearner !== 'undefined' && metaLearner.loaded) {
                    // Serialize Maps in explorationStyle and branchCommitment
                    const explorationStyle = { ...metaLearner.explorationStyle };
                    if (explorationStyle.branchRevisits instanceof Map) {
                        explorationStyle.branchRevisits = Object.fromEntries(explorationStyle.branchRevisits);
                    }
                    
                    const branchCommitment = { ...metaLearner.branchCommitment };
                    if (branchCommitment.branchDepths instanceof Map) {
                        branchCommitment.branchDepths = Object.fromEntries(branchCommitment.branchDepths);
                    }
                    
                    exportData.metaLearner = {
                        buildingStyle: metaLearner.buildingStyle,
                        explorationStyle: explorationStyle,
                        refinementStyle: metaLearner.refinementStyle,
                        decisionStyle: metaLearner.decisionStyle,
                        sessionRhythm: metaLearner.sessionRhythm,
                        branchCommitment: branchCommitment,
                        cognitivePatterns: metaLearner.cognitivePatterns,
                        insights: metaLearner.insights
                    };
                }
                
                // 6. Get concept abstractor data
                const conceptData = await NeuralDB.load('concept-abstractions');
                if (conceptData) {
                    exportData.conceptAbstractor = conceptData;
                } else if (typeof conceptAbstractor !== 'undefined' && conceptAbstractor.loaded) {
                    exportData.conceptAbstractor = {
                        schemas: conceptAbstractor.schemas instanceof Map ? 
                            Object.fromEntries(conceptAbstractor.schemas) : conceptAbstractor.schemas,
                        clusters: conceptAbstractor.clusters instanceof Map ? 
                            Object.fromEntries(conceptAbstractor.clusters) : conceptAbstractor.clusters,
                        hierarchyPatterns: conceptAbstractor.hierarchyPatterns instanceof Map ? 
                            Object.fromEntries(conceptAbstractor.hierarchyPatterns) : conceptAbstractor.hierarchyPatterns,
                        conceptClusters: conceptAbstractor.conceptClusters instanceof Map ?
                            Object.fromEntries(conceptAbstractor.conceptClusters) : conceptAbstractor.conceptClusters,
                        stats: conceptAbstractor.stats
                    };
                }
                
                // 7. Get semantic memory
                const semanticData = await NeuralDB.load('semantic-memories');
                if (semanticData) {
                    exportData.semanticMemory = semanticData;
                } else if (typeof semanticMemory !== 'undefined' && semanticMemory.loaded) {
                    exportData.semanticMemory = {
                        memories: semanticMemory.memories,
                        lastDecay: Date.now()
                    };
                }
                
                // 8. Get neural patterns from Supabase sync cache
                const neuralPatterns = await NeuralDB.load('neural-patterns');
                if (neuralPatterns) {
                    exportData.neural.cloudPatterns = neuralPatterns;
                }
                
                // 9. Get Cognitive Graph Transformer data
                if (typeof cognitiveGT !== 'undefined' && cognitiveGT.initialized) {
                    exportData.cognitiveGT = cognitiveGT.getExportData();
                }
                
                // 10. Get Style Transfer System data
                if (typeof styleTransfer !== 'undefined' && styleTransfer.initialized) {
                    exportData.styleTransfer = styleTransfer.export();
                }
                
                console.log('📦 Export complete:', {
                    mapNodes: this.countNodes(this.data),
                    attachments: this.countAttachments(this.data),
                    hasNeuralModels: !!exportData.neural.modelData,
                    hasEmbeddings: !!exportData.neural.embeddings,
                    hasPatterns: !!exportData.neural.patternWeights,
                    hasUserProfile: !!exportData.userProfile,
                    hasMetaLearner: !!exportData.metaLearner,
                    hasConceptAbstractor: !!exportData.conceptAbstractor,
                    hasSemanticMemory: !!exportData.semanticMemory,
                    hasCGT: !!exportData.cognitiveGT,
                    hasStyleTransfer: !!exportData.styleTransfer
                });
                
            } catch (e) {
                console.warn('Could not export some neural data:', e);
            }
            
            return JSON.stringify(exportData, null, 2);
        }
        
        // Count nodes in tree
        countNodes(node) {
            if (!node) return 0;
            let count = 1;
            if (node.children) {
                for (const child of node.children) {
                    count += this.countNodes(child);
                }
            }
            return count;
        }
        
        // Count attachments in tree
        countAttachments(node) {
            if (!node) return 0;
            let count = node.attachments?.length || 0;
            if (node.children) {
                for (const child of node.children) {
                    count += this.countAttachments(child);
                }
            }
            return count;
        }
        
        importJSON(json) {
            // Synchronous wrapper - calls async version
            const parsed = JSON.parse(json);
            
            // Handle all formats
            let mapData;
            if (parsed.version >= 2 && parsed.map) {
                mapData = parsed.map;
            } else if (parsed.id && parsed.label) {
                mapData = parsed;
            } else {
                throw new Error('Invalid format');
            }
            
            if (!mapData.id || !mapData.label) throw new Error('Invalid map format');
            
            this.saveSnapshot('Import');
            this.data = mapData;
            this.expandedNodes.clear();
            this.save();
            
            // Async restoration of neural data
            this.importNeuralData(parsed).then(() => {
                console.log('✓ Neural data restoration complete');
            }).catch(e => {
                console.warn('Neural data restoration had errors:', e);
            });
            
            bus.emit('data:imported');
            return true;
        }
        
        // Async method to restore all neural learning data
        async importNeuralData(parsed) {
            const version = parsed.version || 1;
            const neuralData = parsed.neural;
            const userProfileData = parsed.userProfile;
            const metaLearnerData = parsed.metaLearner;
            const conceptAbstractorData = parsed.conceptAbstractor;
            const semanticMemoryData = parsed.semanticMemory;
            
            let restoredCount = 0;
            
            try {
                // 1. Restore neural network models
                if (neuralData?.modelData) {
                    await NeuralDB.save('neural-models', neuralData.modelData);
                    // Also save to localStorage for legacy compatibility
                    localStorage.setItem(CONFIG.NEURAL_NET.STORAGE_KEY, JSON.stringify(neuralData.modelData));
                    console.log('✓ Neural model data restored');
                    restoredCount++;
                }
                
                // 2. Restore embeddings
                if (neuralData?.embeddings) {
                    await NeuralDB.save('embeddings', neuralData.embeddings);
                    localStorage.setItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY, JSON.stringify(neuralData.embeddings));
                    console.log('✓ Neural embeddings restored');
                    restoredCount++;
                }
                
                // 3. Restore pattern weights and expansion patterns to live neural net
                if (typeof neuralNet !== 'undefined') {
                    if (neuralData?.patternWeights) {
                        neuralNet.patternWeights = new Map(Object.entries(neuralData.patternWeights));
                        console.log(`✓ Restored ${neuralNet.patternWeights.size} pattern weights`);
                        restoredCount++;
                    }
                    if (neuralData?.expansionPatterns) {
                        neuralNet.expansionPatterns = new Map(Object.entries(neuralData.expansionPatterns));
                        console.log(`✓ Restored ${neuralNet.expansionPatterns.size} expansion patterns`);
                        restoredCount++;
                    }
                    if (neuralData?.categories) {
                        neuralNet.categories = neuralData.categories;
                        console.log(`✓ Restored ${neuralNet.categories.length} categories`);
                        restoredCount++;
                    }
                    if (neuralData?.commonPatterns) {
                        neuralNet.commonPatterns = neuralData.commonPatterns;
                        restoredCount++;
                    }
                    
                    // Reload models from storage
                    if (neuralNet.isReady) {
                        await neuralNet.loadModels();
                        await neuralNet.loadEmbeddings();
                    }
                }
                
                // 4. Restore user profile
                if (userProfileData) {
                    await NeuralDB.save('user-profile', userProfileData);
                    if (typeof userProfile !== 'undefined') {
                        if (userProfileData.depthStats) userProfile.depthStats = { ...userProfile.depthStats, ...userProfileData.depthStats };
                        if (userProfileData.namingStats) userProfile.namingStats = { ...userProfile.namingStats, ...userProfileData.namingStats };
                        if (userProfileData.categoryStats) userProfile.categoryStats = { ...userProfile.categoryStats, ...userProfileData.categoryStats };
                        if (userProfileData.timeStats) userProfile.timeStats = { ...userProfile.timeStats, ...userProfileData.timeStats };
                    }
                    console.log('✓ User profile restored');
                    restoredCount++;
                }
                
                // 5. Restore meta learner
                if (metaLearnerData) {
                    await NeuralDB.save('meta-learner', metaLearnerData);
                    if (typeof metaLearner !== 'undefined') {
                        if (metaLearnerData.buildingStyle) metaLearner.buildingStyle = { ...metaLearner.buildingStyle, ...metaLearnerData.buildingStyle };
                        if (metaLearnerData.explorationStyle) {
                            const explorationStyle = { ...metaLearnerData.explorationStyle };
                            // Convert branchRevisits back to Map if it's an object
                            if (explorationStyle.branchRevisits && !(explorationStyle.branchRevisits instanceof Map)) {
                                explorationStyle.branchRevisits = new Map(Object.entries(explorationStyle.branchRevisits));
                            }
                            metaLearner.explorationStyle = { ...metaLearner.explorationStyle, ...explorationStyle };
                        }
                        if (metaLearnerData.refinementStyle) metaLearner.refinementStyle = { ...metaLearner.refinementStyle, ...metaLearnerData.refinementStyle };
                        if (metaLearnerData.decisionStyle) metaLearner.decisionStyle = { ...metaLearner.decisionStyle, ...metaLearnerData.decisionStyle };
                        if (metaLearnerData.sessionRhythm) metaLearner.sessionRhythm = { ...metaLearner.sessionRhythm, ...metaLearnerData.sessionRhythm };
                        if (metaLearnerData.branchCommitment) {
                            const branchCommitment = { ...metaLearnerData.branchCommitment };
                            if (branchCommitment.branchDepths && !(branchCommitment.branchDepths instanceof Map)) {
                                branchCommitment.branchDepths = new Map(Object.entries(branchCommitment.branchDepths));
                            }
                            metaLearner.branchCommitment = { ...metaLearner.branchCommitment, ...branchCommitment };
                        }
                        if (metaLearnerData.cognitivePatterns) metaLearner.cognitivePatterns = { ...metaLearner.cognitivePatterns, ...metaLearnerData.cognitivePatterns };
                        if (metaLearnerData.insights) metaLearner.insights = metaLearnerData.insights;
                    }
                    console.log('✓ Meta learner restored');
                    restoredCount++;
                }
                
                // 6. Restore concept abstractor
                if (conceptAbstractorData) {
                    await NeuralDB.save('concept-abstractions', conceptAbstractorData);
                    if (typeof conceptAbstractor !== 'undefined') {
                        if (conceptAbstractorData.schemas) {
                            conceptAbstractor.schemas = conceptAbstractorData.schemas instanceof Map ? 
                                conceptAbstractorData.schemas : new Map(Object.entries(conceptAbstractorData.schemas));
                        }
                        if (conceptAbstractorData.clusters) {
                            conceptAbstractor.clusters = conceptAbstractorData.clusters instanceof Map ?
                                conceptAbstractorData.clusters : new Map(Object.entries(conceptAbstractorData.clusters));
                        }
                        if (conceptAbstractorData.hierarchyPatterns) {
                            conceptAbstractor.hierarchyPatterns = conceptAbstractorData.hierarchyPatterns instanceof Map ?
                                conceptAbstractorData.hierarchyPatterns : new Map(Object.entries(conceptAbstractorData.hierarchyPatterns));
                        }
                        if (conceptAbstractorData.conceptClusters) {
                            conceptAbstractor.conceptClusters = conceptAbstractorData.conceptClusters instanceof Map ?
                                conceptAbstractorData.conceptClusters : new Map(Object.entries(conceptAbstractorData.conceptClusters));
                        }
                        if (conceptAbstractorData.stats) conceptAbstractor.stats = conceptAbstractorData.stats;
                    }
                    console.log('✓ Concept abstractor restored');
                    restoredCount++;
                }
                
                // 7. Restore semantic memory
                if (semanticMemoryData) {
                    await NeuralDB.save('semantic-memories', semanticMemoryData);
                    if (typeof semanticMemory !== 'undefined') {
                        if (semanticMemoryData.memories) {
                            semanticMemory.memories = semanticMemoryData.memories;
                        }
                    }
                    console.log(`✓ Semantic memory restored (${semanticMemoryData.memories?.length || 0} memories)`);
                    restoredCount++;
                }
                
                // 8. Restore cloud neural patterns
                if (neuralData?.cloudPatterns) {
                    await NeuralDB.save('neural-patterns', neuralData.cloudPatterns);
                    restoredCount++;
                }
                
                // 9. Restore Cognitive Graph Transformer data
                const cognitiveGTData = parsed.cognitiveGT;
                if (cognitiveGTData) {
                    if (typeof cognitiveGT !== 'undefined') {
                        cognitiveGT.importData(cognitiveGTData);
                        console.log('✓ Cognitive Graph Transformer restored');
                        restoredCount++;
                    }
                }
                
                // 10. Restore Style Transfer System data
                const styleTransferData = parsed.styleTransfer;
                if (styleTransferData) {
                    if (typeof styleTransfer !== 'undefined') {
                        styleTransfer.import(styleTransferData);
                        console.log('✓ Style Transfer System restored');
                        restoredCount++;
                    }
                }
                
                console.log(`📦 Import complete: restored ${restoredCount} neural data components`);
                
            } catch (e) {
                console.error('Error restoring neural data:', e);
                throw e;
            }
        }
        
        // Export just the map data (for cloud sync)
        exportData() {
            return JSON.parse(JSON.stringify(this.data));
        }
        
        // Import just the map data (from cloud sync)
        importData(mapData, skipSync = false) {
            if (!mapData || !mapData.id) {
                console.error('Invalid map data for import');
                return false;
            }
            
            this.saveSnapshot('Cloud sync');
            this.data = mapData;
            this.expandedNodes.clear();
            
            // Save locally but skip cloud sync to avoid loop
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.data));
                bus.emit('data:saved');
            } catch (e) {
                console.warn('Failed to save data:', e.message);
            }
            
            bus.emit('data:imported');
            return true;
        }
    }
    
    const store = new Store();

    // Expose store globally for external modules (like goal-system.js)
    window.store = store;

    // ═══════════════════════════════════════════════════════════════════
    // CONNECTION MANAGER - Batched Connection Updates for Performance
    // ═══════════════════════════════════════════════════════════════════
    const ConnectionManager = {
        pendingUpdates: new Set(),
        
        // Queue a connection for update (called during animation)
        queueUpdate(childMesh) {
            this.pendingUpdates.add(childMesh);
        },
        
        // Process all pending updates in a single batch
        processBatch() {
            if (this.pendingUpdates.size === 0) return;
            
            this.pendingUpdates.forEach(childMesh => {
                const line = childMesh.userData.connectionLine;
                if (!line || !childMesh.userData.parent) return;
                
                const parentMesh = nodes.get(childMesh.userData.parent.id);
                if (!parentMesh) return;
                
                const points = [parentMesh.position.clone(), childMesh.position.clone()];
                line.geometry.setFromPoints(points);
            });
            
            this.pendingUpdates.clear();
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // LABEL SYSTEM - Smart Decluttering with Camera Movement Detection
    // ═══════════════════════════════════════════════════════════════════
    const LabelSystem = {
        lastCameraPosition: null,
        lastCameraTarget: null,
        needsUpdate: true,
        frameCounter: 0,
        
        // Initialize tracking vectors (called after scene init)
        init(camera, controls) {
            this.lastCameraPosition = camera.position.clone();
            this.lastCameraTarget = controls.target.clone();
        },
        
        // Check if camera has moved significantly
        checkCameraMovement(camera, controls) {
            if (!this.lastCameraPosition) return;
            
            const posDiff = camera.position.distanceToSquared(this.lastCameraPosition);
            const targetDiff = controls.target.distanceToSquared(this.lastCameraTarget);
            
            if (posDiff > 0.01 || targetDiff > 0.01) {
                this.lastCameraPosition.copy(camera.position);
                this.lastCameraTarget.copy(controls.target);
                this.needsUpdate = true;
            }
        },
        
        // Mark labels as needing update (call when nodes change)
        markDirty() {
            this.needsUpdate = true;
        },
        
        // Run decluttering - only when needed
        update(camera, nodesMap) {
            this.frameCounter++;
            
            // Only run every N frames unless marked dirty
            if (!this.needsUpdate && this.frameCounter % CONFIG.LABELS.declutterInterval !== 0) {
                return;
            }
            
            this.needsUpdate = false;
            const cfg = CONFIG.LABELS;
            const visibleLabels = [];
            
            nodesMap.forEach(mesh => {
                if (!mesh.visible || !mesh.userData.labelSprite) return;
                
                const sprite = mesh.userData.labelSprite;
                const pos = mesh.position.clone().project(camera);
                
                // Behind camera
                if (pos.z > 1) {
                    sprite.material.opacity = Math.max(0, sprite.material.opacity - cfg.fadeSpeed);
                    return;
                }
                
                const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                const dist = camera.position.distanceTo(mesh.position);
                const textLength = (mesh.userData.label || '').length;
                const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                
                const depth = mesh.userData.depth || 0;
                const isSelected = mesh.userData.selected;
                const isRoot = mesh.userData.level === 0;
                const priority = isSelected ? cfg.selectedPriority : 
                                (isRoot ? cfg.rootPriority : cfg.basePriority - depth * cfg.depthPenalty);
                
                visibleLabels.push({
                    sprite,
                    x: screenX,
                    y: screenY,
                    width: labelWidth,
                    height: labelHeight,
                    priority,
                    baseOpacity: mesh.userData.labelBaseOpacity || 1,
                    shouldShow: true
                });
            });
            
            // Sort by priority (highest first)
            visibleLabels.sort((a, b) => b.priority - a.priority);
            
            // Hide overlapping labels (lower priority ones)
            for (let i = 0; i < visibleLabels.length; i++) {
                if (!visibleLabels[i].shouldShow) continue;
                
                for (let j = i + 1; j < visibleLabels.length; j++) {
                    if (!visibleLabels[j].shouldShow) continue;
                    
                    const a = visibleLabels[i];
                    const b = visibleLabels[j];
                    
                    const overlapX = Math.abs(a.x - b.x) < (a.width + b.width) / 2 + cfg.padding;
                    const overlapY = Math.abs(a.y - b.y) < (a.height + b.height) / 2 + cfg.padding;
                    
                    if (overlapX && overlapY) {
                        visibleLabels[j].shouldShow = false;
                    }
                }
            }
            
            // Apply smooth fade transitions
            visibleLabels.forEach(label => {
                const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
                const currentOpacity = label.sprite.material.opacity;
                label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * cfg.fadeSpeed;
                if (label.sprite.material.opacity < cfg.minOpacity) {
                    label.sprite.material.opacity = 0;
                }
            });
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // UTILITIES
    // ═══════════════════════════════════════════════════════════════════
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    
    function throttle(fn, delay) {
        let lastCall = 0;
        let timeoutId = null;
        return function(...args) {
            const now = Date.now();
            const remaining = delay - (now - lastCall);
            if (remaining <= 0) {
                if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
                lastCall = now;
                fn.apply(this, args);
            } else if (!timeoutId) {
                timeoutId = setTimeout(() => {
                    lastCall = Date.now();
                    timeoutId = null;
                    fn.apply(this, args);
                }, remaining);
            }
        };
    }
    
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    function easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    // ═══════════════════════════════════════════════════════════════════
    // HAPTIC FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const haptic = {
        light: () => navigator.vibrate?.(10),
        medium: () => navigator.vibrate?.(20),
        heavy: () => navigator.vibrate?.([30, 50, 30]),
        success: () => navigator.vibrate?.([10, 50, 10, 50, 10]),
        error: () => navigator.vibrate?.([50, 100, 50])
    };

    // ═══════════════════════════════════════════════════════════════════
    // AUDIO FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const audio = {
        ctx: null,
        getCtx() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            return this.ctx;
        },
        play(freq, duration = 0.1, type = 'sine', volume = 0.1) {
            try {
                const ctx = this.getCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = volume;
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {}
        },
        pop: () => audio.play(600, 0.08),
        expand: () => audio.play(800, 0.1),
        collapse: () => audio.play(400, 0.1),
        select: () => audio.play(500, 0.05),
        add: () => audio.play(700, 0.08),
        success: () => { audio.play(523, 0.1); setTimeout(() => audio.play(659, 0.1), 100); },
        error: () => audio.play(200, 0.2)
    };

    // ═══════════════════════════════════════════════════════════════════
    // CELEBRATION SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    function createCelebration(x, y, color = '#7c3aed', count = 6) {
        const container = document.body;
        
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.className = 'celebration-particle';
            
            const size = 3 + Math.random() * 4;
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
            const velocity = 40 + Math.random() * 60;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity;
            
            particle.style.cssText = `
                left: ${x}px;
                top: ${y}px;
                width: ${size}px;
                height: ${size}px;
                background: ${color};
                opacity: 0.7;
            `;
            
            container.appendChild(particle);
            
            let px = x, py = y, opacity = 0.7;
            const gravity = 100;
            const startTime = performance.now();
            const duration = 400 + Math.random() * 200;
            
            function animate(time) {
                const elapsed = (time - startTime) / 1000;
                const progress = Math.min(elapsed / (duration / 1000), 1);
                
                px += vx * 0.016;
                py += vy * 0.016 + gravity * elapsed * 0.016;
                opacity = 0.7 * (1 - progress);
                
                particle.style.left = px + 'px';
                particle.style.top = py + 'px';
                particle.style.opacity = opacity;
                particle.style.transform = `scale(${1 - progress * 0.3})`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // TOAST NOTIFICATIONS
    // ═══════════════════════════════════════════════════════════════════
    function showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: '✓',
            error: '✕',
            info: 'i'
        };
        
        toast.innerHTML = `<span>${icons[type] || ''}</span> ${escapeHTML(message)}`;
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('exiting');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }
    
    // Custom confirm modal (replaces browser confirm())
    function showConfirm(options = {}) {
        return new Promise((resolve) => {
            const {
                title = 'Confirm',
                message = 'Are you sure?',
                confirmText = 'Confirm',
                cancelText = 'Cancel',
                danger = false
            } = options;
            
            const modal = document.getElementById('confirm-modal');
            const titleEl = document.getElementById('confirm-modal-title');
            const messageEl = document.getElementById('confirm-modal-message');
            const iconEl = document.getElementById('confirm-modal-icon');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            confirmBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;
            
            // Style icon and confirm button based on danger
            iconEl.className = 'confirm-modal-icon' + (danger ? ' danger' : '');
            confirmBtn.className = 'confirm-btn confirm-btn-confirm' + (danger ? '' : ' primary');
            
            // Show modal
            modal.classList.add('active');
            
            // Focus cancel button (safer default)
            setTimeout(() => cancelBtn.focus(), 50);
            
            // Cleanup function
            const cleanup = () => {
                modal.classList.remove('active');
                confirmBtn.removeEventListener('click', handleConfirm);
                cancelBtn.removeEventListener('click', handleCancel);
                document.removeEventListener('keydown', handleKeydown);
            };
            
            const handleConfirm = () => {
                cleanup();
                resolve(true);
            };
            
            const handleCancel = () => {
                cleanup();
                resolve(false);
            };
            
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    handleCancel();
                } else if (e.key === 'Enter' && document.activeElement === confirmBtn) {
                    e.preventDefault();
                    handleConfirm();
                }
            };
            
            confirmBtn.addEventListener('click', handleConfirm);
            cancelBtn.addEventListener('click', handleCancel);
            document.addEventListener('keydown', handleKeydown);
        });
    }
    
    // Show AI response in a modal (for respond action)
    function showAIResponse(message, offerToAdd = false, originalQuery = '') {
        // Remove any existing AI response modal
        const existing = document.getElementById('ai-response-modal');
        if (existing) existing.remove();
        
        const modal = document.createElement('div');
        modal.id = 'ai-response-modal';
        modal.innerHTML = `
            <div class="ai-response-backdrop"></div>
            <div class="ai-response-content">
                <div class="ai-response-header">
                    <span class="ai-response-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                        </svg>
                    </span>
                    <span>AI Response</span>
                    <button class="ai-response-close" aria-label="Close">×</button>
                </div>
                <div class="ai-response-body">
                    ${escapeHTML(message).replace(/\n/g, '<br>')}
                </div>
                ${offerToAdd ? `
                <div class="ai-response-actions">
                    <button class="ai-response-btn secondary" data-action="dismiss">Dismiss</button>
                    <button class="ai-response-btn primary" data-action="add">Add to Map</button>
                </div>
                ` : `
                <div class="ai-response-actions">
                    <button class="ai-response-btn primary" data-action="dismiss">Got it</button>
                </div>
                `}
            </div>
        `;
        
        // Add styles if not already present
        if (!document.getElementById('ai-response-styles')) {
            const styles = document.createElement('style');
            styles.id = 'ai-response-styles';
            styles.textContent = `
                #ai-response-modal {
                    position: fixed;
                    inset: 0;
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                    animation: fadeIn 0.2s ease;
                }
                .ai-response-backdrop {
                    position: absolute;
                    inset: 0;
                    background: rgba(0,0,0,0.5);
                    backdrop-filter: blur(4px);
                }
                .ai-response-content {
                    position: relative;
                    background: var(--panel-bg, #1a1a2e);
                    border: 1px solid var(--border-color, #333);
                    border-radius: 16px;
                    max-width: 500px;
                    width: 100%;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
                    animation: slideUp 0.3s ease;
                }
                .ai-response-header {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    padding: 16px 20px;
                    border-bottom: 1px solid var(--border-color, #333);
                    font-weight: 600;
                    color: var(--text-primary, #fff);
                }
                .ai-response-icon {
                    font-size: 1.2em;
                }
                .ai-response-close {
                    margin-left: auto;
                    background: none;
                    border: none;
                    color: var(--text-secondary, #888);
                    font-size: 24px;
                    cursor: pointer;
                    padding: 0;
                    line-height: 1;
                    transition: color 0.2s;
                }
                .ai-response-close:hover {
                    color: var(--text-primary, #fff);
                }
                .ai-response-body {
                    padding: 20px;
                    color: var(--text-primary, #fff);
                    line-height: 1.6;
                    overflow-y: auto;
                    font-size: 15px;
                }
                .ai-response-actions {
                    display: flex;
                    gap: 12px;
                    padding: 16px 20px;
                    border-top: 1px solid var(--border-color, #333);
                    justify-content: flex-end;
                }
                .ai-response-btn {
                    padding: 10px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                .ai-response-btn.primary {
                    background: var(--accent-color, #4ECDC4);
                    color: #000;
                    border: none;
                }
                .ai-response-btn.primary:hover {
                    filter: brightness(1.1);
                    transform: translateY(-1px);
                }
                .ai-response-btn.secondary {
                    background: transparent;
                    color: var(--text-secondary, #888);
                    border: 1px solid var(--border-color, #444);
                }
                .ai-response-btn.secondary:hover {
                    background: var(--border-color, #333);
                    color: var(--text-primary, #fff);
                }
                @keyframes slideUp {
                    from { opacity: 0; transform: translateY(20px); }
                    to { opacity: 1; transform: translateY(0); }
                }
            `;
            document.head.appendChild(styles);
        }
        
        document.body.appendChild(modal);
        
        // Handle button clicks
        const closeModal = () => {
            modal.style.animation = 'fadeIn 0.2s ease reverse';
            setTimeout(() => modal.remove(), 200);
        };
        
        modal.querySelector('.ai-response-close').onclick = closeModal;
        modal.querySelector('.ai-response-backdrop').onclick = closeModal;
        
        modal.querySelectorAll('.ai-response-btn').forEach(btn => {
            btn.onclick = async () => {
                if (btn.dataset.action === 'add') {
                    // Create a node with the AI response
                    const label = originalQuery.length > 30 
                        ? originalQuery.substring(0, 30) + '...' 
                        : originalQuery || 'AI Response';
                    
                    const parentId = selectedNode?.userData.id || store.data.id;
                    const newNode = store.addNode(parentId, {
                        label: label.charAt(0).toUpperCase() + label.slice(1),
                        description: message,
                        color: null
                    });
                    
                    if (newNode) {
                        buildScene();
                        setTimeout(() => {
                            const mesh = nodes.get(newNode.id);
                            if (mesh) {
                                selectNode(mesh);
                                focusOnNode(mesh);
                            }
                        }, 100);
                        showToast('Added to map', 'success');
                    }
                }
                closeModal();
            };
        });
        
        // Close on Escape
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }

    // ═══════════════════════════════════════════════════════════════════
    // THEME MANAGER
    // ═══════════════════════════════════════════════════════════════════
    const themeManager = {
        current: 'obsidian',
        themes: ['sandstone', 'coral', 'ember', 'frost', 'obsidian'],
        
        init() {
            const saved = localStorage.getItem(CONFIG.THEME_KEY);
            if (saved && this.themes.includes(saved)) {
                this.set(saved, true); // Skip color update on init
            } else {
                // Default to obsidian for new users
                this.set('obsidian', true);
            }
        },
        
        set(theme, skipColorUpdate = false) {
            const oldTheme = this.current;
            this.current = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem(CONFIG.THEME_KEY, theme);
            
            // Update theme picker UI
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.toggle('active', opt.dataset.theme === theme);
            });
            
            // Update node colors when switching themes (different palettes)
            if (!skipColorUpdate && oldTheme !== theme) {
                updateNodeColorsForTheme(oldTheme, theme);
            }
            
            bus.emit('theme:changed', { theme, oldTheme });
        },
        
        toggle() {
            const currentIndex = this.themes.indexOf(this.current);
            const nextIndex = (currentIndex + 1) % this.themes.length;
            this.set(this.themes[nextIndex]);
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // THREE.JS SCENE
    // ═══════════════════════════════════════════════════════════════════
    let scene, camera, renderer, controls;
    let nodes = new Map();
    let connections = [];
    let selectedNode = null;
    let currentContextId = null;
    let focusMode = false;
    let particleSystem = null;
    let cameraTargetGoal = new THREE.Vector3(0, 0, 0);
    let userInteracting = false;
    
    // Cluster visualization state
    let currentClusterData = null;
    let clusterColorsActive = false;
    let originalNodeColors = new Map();
    
    /**
     * Add a new node as a child of the selected node (or root if none selected)
     */
    function addNodeToSelected(label, options = {}) {
        if (!label || !label.trim()) {
            showToast('Please enter a node name', 'warning');
            return null;
        }
        
        let targetId = 'root';
        
        // Use selected node if available
        if (selectedNode && selectedNode.userData) {
            targetId = selectedNode.userData.id;
        }
        
        // Create the new node
        const newNode = store.addChild(targetId, {
            label: label.trim(),
            description: options.description || '',
            color: options.color || (selectedNode?.userData?.color) || '#fb923c',
            source: 'manual'
        });
        
        if (newNode) {
            // Refresh the graph
            bus.emit('graph:refresh');
            
            // If parent was collapsed, expand it
            if (selectedNode && !selectedNode.userData.isExpanded) {
                expandNode(selectedNode);
            }
            
            showToast(`Added "${label}"`, 'success');
            audio.add();
            
            return newNode;
        } else {
            showToast('Failed to add node', 'error');
            return null;
        }
    }
    
    // Make it globally accessible
    window.addNodeToSelected = addNodeToSelected;
    
    // Cluster color palette
    const CLUSTER_COLORS = [
        0x22c55e, // green
        0x3b82f6, // blue
        0xf59e0b, // amber
        0xef4444, // red
        0x8b5cf6, // purple
        0xec4899, // pink
        0x06b6d4, // cyan
        0x84cc16, // lime
        0xf97316, // orange
        0x14b8a6  // teal
    ];
    
    /**
     * Apply cluster colors to nodes in the 3D scene
     */
    function applyClusterColors(clusters) {
        if (!clusters || clusters.length === 0) return;
        
        // Save original colors if not already saved
        if (originalNodeColors.size === 0) {
            nodes.forEach((mesh, nodeId) => {
                if (mesh.material && mesh.material.color) {
                    originalNodeColors.set(nodeId, mesh.material.color.getHex());
                }
            });
        }
        
        // Build node → cluster map
        const nodeClusterMap = new Map();
        clusters.forEach((cluster, clusterIndex) => {
            cluster.nodes.forEach(node => {
                nodeClusterMap.set(node.id, clusterIndex);
            });
        });
        
        // Apply colors
        nodes.forEach((mesh, nodeId) => {
            const clusterIndex = nodeClusterMap.get(nodeId);
            if (clusterIndex !== undefined && mesh.material) {
                const color = CLUSTER_COLORS[clusterIndex % CLUSTER_COLORS.length];
                mesh.material.color.setHex(color);
                mesh.material.emissive.setHex(color);
                mesh.material.emissiveIntensity = 0.3;
            }
        });
        
        clusterColorsActive = true;
        currentClusterData = clusters;
    }
    
    /**
     * Reset node colors to original colors (before clustering)
     */
    function resetClusterColors() {
        if (!clusterColorsActive && originalNodeColors.size === 0) return;
        
        // Restore original colors from saved map
        if (originalNodeColors.size > 0) {
            nodes.forEach((mesh, nodeId) => {
                if (mesh.material) {
                    const originalColor = originalNodeColors.get(nodeId);
                    if (originalColor !== undefined) {
                        mesh.material.color.setHex(originalColor);
                        mesh.material.emissive.setHex(originalColor);
                        mesh.material.emissiveIntensity = 0.15;
                    }
                }
            });
        } else {
            // Fallback: restore from store data
            nodes.forEach((mesh, nodeId) => {
                if (mesh.material && mesh.userData) {
                    const nodeData = store.findNode(nodeId);
                    if (nodeData && nodeData.color) {
                        const color = new THREE.Color(nodeData.color);
                        mesh.material.color.copy(color);
                        mesh.material.emissive.copy(color);
                        mesh.material.emissiveIntensity = 0.15;
                    }
                }
            });
        }
        
        clusterColorsActive = false;
        currentClusterData = null;
        originalNodeColors.clear();
        
        if (typeof showToast !== 'undefined') {
            showToast('Colors restored', 'success');
        }
    }
    
    /**
     * Highlight only nodes in a specific cluster
     */
    function highlightCluster(clusterIndex) {
        if (!currentClusterData) return;
        
        const cluster = currentClusterData[clusterIndex];
        if (!cluster) return;
        
        const clusterNodeIds = new Set(cluster.nodes.map(n => n.id));
        
        nodes.forEach((mesh, nodeId) => {
            if (mesh.material) {
                if (clusterNodeIds.has(nodeId)) {
                    // Highlight cluster nodes
                    mesh.material.opacity = 1;
                    mesh.material.emissiveIntensity = 0.5;
                    mesh.scale.setScalar(1.2);
                } else {
                    // Dim other nodes
                    mesh.material.opacity = 0.2;
                    mesh.material.emissiveIntensity = 0.05;
                    mesh.scale.setScalar(0.8);
                }
            }
        });
        
        // Dim connections not in cluster
        connections.forEach(conn => {
            if (conn.material) {
                const startInCluster = clusterNodeIds.has(conn.userData?.startId);
                const endInCluster = clusterNodeIds.has(conn.userData?.endId);
                conn.material.opacity = (startInCluster && endInCluster) ? 0.6 : 0.05;
            }
        });
    }
    
    /**
     * Reset cluster highlighting (restore all visibility)
     */
    function resetClusterHighlight() {
        nodes.forEach((mesh, nodeId) => {
            if (mesh.material) {
                mesh.material.opacity = 1;
                mesh.material.emissiveIntensity = clusterColorsActive ? 0.3 : 0.15;
                mesh.scale.setScalar(1);
            }
        });
        
        connections.forEach(conn => {
            if (conn.material) {
                conn.material.opacity = 0.6; // Match original createConnection opacity
            }
        });
    }
    
    // Camera arc animation
    let cameraArcAnimation = null;
    let autoCameraEnabled = true;

    // Neural network training control
    let neuralTrainingEnabled = true;  // User toggle
    let neuralTrainingPaused = false;  // Auto-pause during heavy operations

    function isNeuralTrainingAllowed() {
        return neuralTrainingEnabled && !neuralTrainingPaused;
    }

    function initScene() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const isMobile = window.innerWidth <= 768;
        camera.position.set(0, isMobile ? 18 : 14, isMobile ? 50 : 40);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Add click handler for node selection
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        
        // Prevent context menu on canvas for right-click drag reparenting
        renderer.domElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.12;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 8;
        controls.maxDistance = 1125; // 50% more than 750
        controls.enablePan = true;
        controls.panSpeed = 0.8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.enableZoom = false; // Disable default zoom, we handle it custom
        
        // Track user interaction with controls
        controls.addEventListener('start', () => { 
            userInteracting = true; 
            // Don't cancel arc animation - let it complete
        });
        controls.addEventListener('end', () => { 
            userInteracting = false;
            cameraTargetGoal.copy(controls.target); // Sync after interaction
        });
        
        // Zoom to pointer - custom zoom behavior
        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Cancel any arc animation
            cameraArcAnimation = null;
            
            // Get mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a ray from camera through mouse position
            const zoomRaycaster = new THREE.Raycaster();
            zoomRaycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            // Find point on a plane at the target distance
            const targetDistance = camera.position.distanceTo(controls.target);
            const zoomPoint = zoomRaycaster.ray.at(targetDistance, new THREE.Vector3());
            
            // Calculate zoom factor
            const zoomSpeed = 0.001;
            const zoomDelta = event.deltaY * zoomSpeed;
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, currentDistance * (1 + zoomDelta)));
            
            // Move target towards zoom point while zooming in, away while zooming out
            const zoomFactor = 1 - (newDistance / currentDistance);
            const targetShift = new THREE.Vector3().subVectors(zoomPoint, controls.target).multiplyScalar(zoomFactor * 0.5);
            controls.target.add(targetShift);
            cameraTargetGoal.copy(controls.target); // Sync the goal
            
            // Update camera distance
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            
            controls.update();
        }, { passive: false });
        
        // Pinch-to-zoom for mobile
        let initialPinchDistance = null;
        let initialCameraDistance = null;
        
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraDistance = camera.position.distanceTo(controls.target);
            }
        }, { passive: true });
        
        renderer.domElement.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2 && initialPinchDistance !== null) {
                event.preventDefault();
                
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const pinchRatio = initialPinchDistance / currentPinchDistance;
                const newDistance = Math.max(
                    controls.minDistance, 
                    Math.min(controls.maxDistance, initialCameraDistance * pinchRatio)
                );
                
                // Update camera distance
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                
                controls.update();
            }
        }, { passive: false });
        
        // Double-tap detection for zoom to fit
        let lastTapTime = 0;
        let lastTapX = 0;
        let lastTapY = 0;
        const doubleTapThreshold = 300; // ms
        const doubleTapDistance = 50; // pixels
        
        renderer.domElement.addEventListener('touchend', (event) => {
            initialPinchDistance = null;
            initialCameraDistance = null;
            
            // Only detect double-tap for single finger taps
            if (event.changedTouches.length === 1) {
                const touch = event.changedTouches[0];
                const now = Date.now();
                const timeDiff = now - lastTapTime;
                const distX = Math.abs(touch.clientX - lastTapX);
                const distY = Math.abs(touch.clientY - lastTapY);
                
                if (timeDiff < doubleTapThreshold && distX < doubleTapDistance && distY < doubleTapDistance) {
                    // Double tap detected - check if it's on empty space
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    const tapRaycaster = new THREE.Raycaster();
                    tapRaycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                    const visibleNodes = Array.from(nodes.values()).filter(n => n.visible);
                    const intersects = tapRaycaster.intersectObjects(visibleNodes);
                    
                    if (intersects.length === 0) {
                        // Double-tapped on empty space - zoom to fit entire map
                        console.log('Double-tap on empty space - zooming to fit');
                        zoomToFitMap(0);
                    }
                    
                    lastTapTime = 0; // Reset to prevent triple-tap
                } else {
                    lastTapTime = now;
                    lastTapX = touch.clientX;
                    lastTapY = touch.clientY;
                }
            }
        }, { passive: true });
        
        // Ambient particles disabled for performance
        // createAmbientParticles();
        
        // Lighting - bright for accurate colors
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.3);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);
        
        // Build initial scene
        currentContextId = store.data.id;
        
        // Initialize label system with camera tracking
        LabelSystem.init(camera, controls);
        
        buildScene();
        
        // Auto-train neural net on initial load (after small delay to not block rendering)
        setTimeout(async () => {
            if (typeof neuralNet !== 'undefined' && store.data && store.data.children && store.data.children.length > 0) {
                console.log('Auto-training neural net on map load...');
                
                // Initialize neural network if not ready
                if (!neuralNet.isReady && !neuralNet.isInitializing) {
                    console.log('Initializing neural network first...');
                    const initialized = await neuralNet.initialize();
                    if (!initialized) {
                        console.warn('Neural network initialization failed, skipping auto-train');
                        return;
                    }
                }
                
                // Wait for any in-progress initialization
                if (neuralNet.isInitializing) {
                    console.log('Waiting for neural network initialization...');
                    await new Promise(resolve => {
                        const checkReady = setInterval(() => {
                            if (neuralNet.isReady || !neuralNet.isInitializing) {
                                clearInterval(checkReady);
                                resolve();
                            }
                        }, 100);
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            clearInterval(checkReady);
                            resolve();
                        }, 10000);
                    });
                }
                
                if (neuralNet.isReady && isNeuralTrainingAllowed()) {
                    neuralNet.train(store).then(() => {
                        console.log('Neural net auto-trained successfully');
                        // Update UI to reflect trained status
                        if (typeof NeuralUI !== 'undefined') {
                            NeuralUI.updateStatus();
                        }
                    }).catch(err => {
                        console.warn('Neural net auto-training failed:', err);
                    });
                } else if (!neuralNet.isReady) {
                    console.warn('Neural network not ready, skipping auto-train');
                } else {
                    console.log('Neural training disabled, skipping auto-train');
                }
            }
        }, 500);
        
        // Resize handler
        window.addEventListener('resize', throttle(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, 100));
        
        // End session when user leaves
        window.addEventListener('beforeunload', () => {
            userProfile.endSession();
            metaLearner.endSession();
            preferenceTracker.finalizePendingSession();
        });
        
        // Initialize animation controller for performance throttling
        AnimationController.init();

        // Expose key functions and objects globally for external modules (like goal-system.js)
        window.THREE = THREE;
        window.nodes = nodes;
        window.buildScene = buildScene;
        window.selectNode = selectNode;
        window.focusOnNode = focusOnNode;
        window.scene = scene;
        window.camera = camera;
        window.controls = controls;

        // Start animation loop
        animate();
    }

    function createAmbientParticles() {
        const particleCount = 200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            
            // Subtle purple/blue tints
            colors[i * 3] = 0.5 + Math.random() * 0.3;
            colors[i * 3 + 1] = 0.3 + Math.random() * 0.3;
            colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
            
            sizes[i] = 0.5 + Math.random() * 1.5;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }

    // Count all descendants of a node
    function countDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        let count = data.children.length;
        data.children.forEach(child => {
            count += countDescendants(child);
        });
        return count;
    }
    
    // Count visible (expanded) descendants
    function countVisibleDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        if (!store.expandedNodes.has(data.id)) return 0;
        
        let count = data.children.length;
        data.children.forEach(child => {
            count += countVisibleDescendants(child);
        });
        return count;
    }
    
    // Get max depth of expanded descendants
    function getExpandedDepth(data, currentDepth = 0) {
        if (!data.children || data.children.length === 0) return currentDepth;
        if (!store.expandedNodes.has(data.id)) return currentDepth;
        
        let maxDepth = currentDepth;
        data.children.forEach(child => {
            const childDepth = getExpandedDepth(child, currentDepth + 1);
            if (childDepth > maxDepth) maxDepth = childDepth;
        });
        return maxDepth;
    }

    // SECTOR-BASED LAYOUT: Each branch owns an angular sector, children stay within parent's sector
    function calculatePositions(data, parentPos = [0, 0, 0], level = 0, sectorStart = 0, sectorEnd = Math.PI * 2, total = 1, index = 0, parentBranchAngle = 0) {
        data.level = level;

        // Size based on level - smaller for deeper nodes
        if (level === 0) data.size = CONFIG.NODE_SIZES.root;
        else if (level === 1) data.size = CONFIG.NODE_SIZES.level1;
        else if (level === 2) data.size = CONFIG.NODE_SIZES.level2;
        else data.size = Math.max(0.25, CONFIG.NODE_SIZES.default - (level - 3) * 0.06);

        // Check descendants for spacing
        const isExpanded = store.expandedNodes.has(data.id);
        const visibleDescendants = countVisibleDescendants(data);
        const expandedDepth = getExpandedDepth(data);

        // Calculate this node's angle (center of its sector)
        const sectorWidth = sectorEnd - sectorStart;
        const sectorCenter = sectorStart + sectorWidth / 2;

        // Store sector bounds for children to inherit
        data.sectorStart = sectorStart;
        data.sectorEnd = sectorEnd;

        // GOLDEN RATIO based positioning
        const PHI = 1.618033988749895; // Golden ratio
        const PHI_INV = 1 / PHI;       // ≈ 0.618

        // Position calculation - branch lengths follow GOLDEN RATIO
        let baseRadius;
        if (level === 0) {
            baseRadius = 0;
        } else {
            // All levels use golden ratio decay from a base length
            // Level 1 and 2 are equal, then decay by φ for each subsequent level
            const baseBranchLength = 18; // Shorter base for level 1 & 2

            if (level <= 2) {
                baseRadius = baseBranchLength;
            } else {
                // Level 3+: Golden ratio decay from level 2
                // Level 3: base/φ, Level 4: base/φ², etc.
                baseRadius = baseBranchLength * Math.pow(PHI_INV, level - 2);
            }

            // Small boost for expanded nodes with descendants
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.sqrt(visibleDescendants) * 0.4;
            }
            if (expandedDepth > 0) {
                baseRadius += Math.sqrt(expandedDepth) * 0.5;
            }

            // RADIAL VARIATION for siblings - spread them at different distances
            // This prevents stacking when sectors are narrow
            if (total > 1 && level > 1) {
                const radialSpread = 4; // Amount to vary radius among siblings
                const radialOffset = (index - (total - 1) / 2) * (radialSpread / Math.max(total - 1, 1));
                baseRadius += radialOffset;
            }

            // Minimum radius
            baseRadius = Math.max(baseRadius, 5);
        }

        if (level === 0) {
            data.position = [0, 0, 0];
            data.basePosition = [0, 0, 0];
            data.expandedPosition = [0, 0, 0];
            data.branchAngle = 0;
        } else {
            // Position at center of this node's sector
            const angle = sectorCenter;

            // Helix effect - ONLY for level 1 branches
            const baseHelixAmp = CONFIG.LAYOUT.helixAmplitude || 12.0;

            let verticalOffset = 0;

            // For spherical distribution, we need helixAmp accessible for radius calc
            let helixAmp = 0;

            // Level 2+: Siblings spread equally UP and DOWN from parent center
            let siblingVerticalOffset = 0;
            if (level > 1 && total > 1) {
                // Large vertical spread for level 2, exponential decay after
                const baseVerticalSpread = 15.0;
                // Exponential decay: halves each level after level 2
                const levelFactor = Math.pow(0.5, level - 2); // 1, 0.5, 0.25, 0.125...
                const siblingSpacing = baseVerticalSpread * levelFactor;
                // This spreads equally above and below parent's Y position
                siblingVerticalOffset = (index - (total - 1) / 2) * siblingSpacing;
            }

            // Position nodes
            if (level === 1) {
                // FIBONACCI SPHERE DISTRIBUTION
                // Uses golden angle to create optimal even spacing on a sphere
                // Inspired by sunflower seed patterns (phyllotaxis)
                const PHI = (1 + Math.sqrt(5)) / 2; // Golden ratio ≈ 1.618
                const goldenAngle = 2 * Math.PI / (PHI * PHI); // ≈ 137.5° in radians

                // Sphere dimensions
                const sphereHeight = baseHelixAmp * 10.0; // Total height of sphere
                const sphereRadius = baseRadius * 4.0; // Max horizontal radius at equator

                // Y position: evenly spaced from top (+1) to bottom (-1) with epsilon offset
                // Epsilon prevents clustering at poles
                const epsilon = 0.5;
                const normalizedY = total > 1
                    ? 1 - ((index + epsilon) / (total - 1 + 2 * epsilon)) * 2
                    : 0;
                const y = normalizedY * sphereHeight;

                // Horizontal radius: use oblate spheroid with minimum radius at poles
                // This prevents poles from being too compressed
                // Pure sphere: r = R * sqrt(1 - y²) goes from 0 to R
                // Modified: r = R * (minR + (1-minR) * sqrt(1 - y²)) ensures minimum spread
                const minRadiusFactor = 0.4; // Poles have at least 40% of max radius
                const sphereFactor = Math.sqrt(1 - normalizedY * normalizedY);
                const horizontalRadius = sphereRadius * (minRadiusFactor + (1 - minRadiusFactor) * sphereFactor);

                // Angle: golden angle increment for each node (creates optimal spiral)
                const theta = goldenAngle * index;

                // Expanded position (full distance)
                data.expandedPosition = [
                    Math.cos(theta) * horizontalRadius,
                    y,
                    Math.sin(theta) * horizontalRadius
                ];

                // Collapsed position (25% of expanded distance - much closer to root)
                const collapsedRadius = horizontalRadius * 0.25;
                const collapsedY = y * 0.25;
                data.collapsedPosition = [
                    Math.cos(theta) * collapsedRadius,
                    collapsedY,
                    Math.sin(theta) * collapsedRadius
                ];

                // Use collapsed position as default (expanded when children are shown)
                const isExpanded = store.expandedNodes.has(data.id);
                data.basePosition = isExpanded ? [...data.expandedPosition] : [...data.collapsedPosition];

                // Store sphere info and branch angle for children
                data.sphereMaxY = sphereHeight;
                data.branchAngle = theta; // Store the actual angle used
                helixAmp = sphereHeight;
            } else {
                // Level 2+: Continue in parent's branch direction (not from root!)
                // Use the parent's branch angle so branches extend outward consistently
                let radialAngle;
                if (level === 2) {
                    // Level 2: branch from level 1, use parent's theta (direction from root)
                    radialAngle = parentBranchAngle;
                } else {
                    // Level 3+: continue in the same direction as parent was going
                    radialAngle = parentBranchAngle;
                }

                // Add angular spread for siblings - larger for level 2, decay for deeper
                const baseSpreadAngle = Math.PI * 0.75; // 135° total spread for level 2
                const spreadDecay = Math.pow(0.6, level - 2); // 1, 0.6, 0.36...
                const siblingSpreadAngle = baseSpreadAngle * spreadDecay;
                const angularOffset = total > 1
                    ? ((index / (total - 1)) - 0.5) * siblingSpreadAngle
                    : 0;
                const finalAngle = radialAngle + angularOffset;

                // Branch length: still use spherical math for consistency
                const sphereMaxY = baseHelixAmp * 10.0;
                const parentY = parentPos[1];
                const normalizedParentY = sphereMaxY > 0 ? Math.abs(parentY) / sphereMaxY : 0;
                const clampedNormalizedY = Math.min(normalizedParentY, 0.99);
                const sphereMultiplier = Math.sqrt(1 - clampedNormalizedY * clampedNormalizedY);
                const sphericalBranchLength = baseRadius * (1 + sphereMultiplier * 3.0);

                data.basePosition = [
                    parentPos[0] + Math.cos(finalAngle) * sphericalBranchLength,
                    parentPos[1] + siblingVerticalOffset,
                    parentPos[2] + Math.sin(finalAngle) * sphericalBranchLength
                ];

                // Store the actual angle used for this branch (for children to inherit)
                data.branchAngle = finalAngle;
            }

            // For level 2+, set expanded position (level 1 already has it set)
            if (level > 1) {
                data.expandedPosition = [...data.basePosition];
            }
            data.position = [...data.basePosition];
        }

        // If node has a custom position (from move mode), use it instead
        if (data.customPosition && level > 0) {
            data.position = [data.customPosition.x, data.customPosition.y, data.customPosition.z];
            data.basePosition = [...data.position];
            data.expandedPosition = [...data.position];
        }

        // Recursively process children - DIVIDE THIS NODE'S SECTOR AMONG CHILDREN
        // Children are confined to parent's angular sector (no crossover!)
        if (data.children) {
            // Calculate weights for children based on their descendants
            // Level 0 (root) children get EQUAL weights for even angular distribution
            const childWeights = data.children.map(child => {
                if (level === 0) {
                    return 1; // Equal weight for level 1 siblings - even angular spread
                }
                const descendants = countVisibleDescendants(child);
                return 1 + Math.sqrt(descendants) * 0.8; // Weight: 1 base + sqrt of descendants
            });

            const totalWeight = childWeights.reduce((a, b) => a + b, 0);

            // For level 0 (root), children get the full circle divided among them
            // For deeper levels, EXPAND the sector to give children more room
            // This prevents cramping at deeper levels while maintaining general direction
            let availableSector, childSectorStart;

            // Golden ratio for sector expansion
            const PHI = 1.618033988749895;

            if (level === 0) {
                // Root: full circle for level 1 children with EQUAL angular spacing
                availableSector = Math.PI * 2;
                childSectorStart = -Math.PI;
            } else if (level === 1) {
                // Level 1 nodes: their children (level 2) get 135° spread
                const baseSectorSpread = Math.PI * 0.75; // 135 degrees
                availableSector = baseSectorSpread;

                // Center the sector on the parent's sector center
                const sectorCenter = sectorStart + sectorWidth / 2;
                childSectorStart = sectorCenter - availableSector / 2;
            } else {
                // Level 2+: Hyperbolic decay from 135° base
                // spread = base / (1 + k * (level - 1))
                // Level 2 parent -> Level 3 children: 135° / 1.5
                // Level 3 parent -> Level 4 children: 135° / 2.0
                const baseSectorSpread = Math.PI * 0.75; // 135 degrees
                const decayRate = 0.5;
                const levelFactor = 1 + decayRate * (level - 1);
                const targetSpread = baseSectorSpread / levelFactor;

                availableSector = Math.max(targetSpread, Math.PI * 0.15); // Min 27° spread

                // Center the sector on the parent's sector center
                const sectorCenter = sectorStart + sectorWidth / 2;
                childSectorStart = sectorCenter - availableSector / 2;
            }

            data.children.forEach((child, i) => {
                // Calculate this child's sector width proportionally to its weight
                const childSectorWidth = (childWeights[i] / totalWeight) * availableSector;
                const childSectorEnd = childSectorStart + childSectorWidth;

                calculatePositions(
                    child,
                    data.position,
                    level + 1,
                    childSectorStart,
                    childSectorEnd,
                    data.children.length,
                    i,
                    data.branchAngle || 0  // Pass parent's branch angle to children
                );

                // Move to next child's sector start
                childSectorStart = childSectorEnd;
            });
        }

        return data;
    }

    function createNodeMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            emissive: new THREE.Color(color),
            emissiveIntensity: 0.3,
            roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 1
        });
    }

    function createLabelSprite(text, color, hasLink = false) {
        const labelText = text || 'Untitled';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = CONFIG.LABELS.fontSize;
        const padding = CONFIG.LABELS.spritePadding;
        
        // Add extra width for link icon if needed
        const linkIconSize = hasLink ? 16 : 0;
        const linkPadding = hasLink ? 6 : 0;
        
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        const textWidth = ctx.measureText(labelText).width;
        const width = textWidth + padding * 2 + linkIconSize + linkPadding;
        const height = fontSize + padding * 1.4;
        
        canvas.width = width * 2;
        canvas.height = height * 2;
        ctx.scale(2, 2);
        
        // Background - check for dark themes
        const theme = document.documentElement.getAttribute('data-theme') || 'obsidian';
        const isDark = ['obsidian'].includes(theme);
        
        ctx.fillStyle = isDark ? 'rgba(18, 18, 26, 0.9)' : 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(1, 1, width - 2, height - 2, 14);
        ctx.fill();
        ctx.stroke();
        
        // Link icon if has link
        if (hasLink) {
            ctx.save();
            ctx.strokeStyle = color || '#6366f1';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            
            const iconX = padding + 2;
            const iconY = height / 2;
            const iconSize = 10;
            
            // Draw link icon (two interlocking chain links)
            ctx.beginPath();
            ctx.moveTo(iconX + 3, iconY - 2);
            ctx.lineTo(iconX + 6, iconY - 5);
            ctx.arc(iconX + 8, iconY - 3, 3, -Math.PI * 0.75, Math.PI * 0.25);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(iconX + 9, iconY + 2);
            ctx.lineTo(iconX + 6, iconY + 5);
            ctx.arc(iconX + 4, iconY + 3, 3, Math.PI * 0.25, -Math.PI * 0.75, true);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Text
        ctx.fillStyle = isDark ? '#ffffff' : '#1f2937';
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Calculate text position accounting for link icon on left
        const leftOffset = hasLink ? (linkIconSize + linkPadding) : 0;
        const textX = padding + leftOffset + (textWidth / 2);
        
        ctx.fillText(labelText, textX, height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: true,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        const aspect = width / height;
        sprite.userData.aspect = aspect;
        sprite.userData.labelWidth = width;
        const spriteHeight = 0.5;
        sprite.scale.set(spriteHeight * aspect, spriteHeight, 1);
        
        return sprite;
    }
    
    // Create context badge sprite (separate from label) - pulsing light
    function createContextBadge() {
        const canvas = document.createElement('canvas');
        const size = 64;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const centerX = size / 2;
        const centerY = size / 2;
        
        // Tight, defined light with minimal glow
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.4, 'rgba(230, 85, 70, 1)');
        gradient.addColorStop(0.7, 'rgba(200, 55, 45, 0.95)');
        gradient.addColorStop(0.85, 'rgba(180, 45, 40, 0.5)');
        gradient.addColorStop(1, 'rgba(160, 40, 35, 0)');
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.userData.isContextBadge = true;
        sprite.userData.pulsePhase = Math.random() * Math.PI * 2;
        sprite.userData.baseScale = 0.28;
        sprite.scale.set(0.28, 0.28, 1);
        
        return sprite;
    }
    
    // Remove context badge from a node
    function removeContextIndicator(mesh) {
        if (mesh.userData.contextBadge) {
            const badge = mesh.userData.contextBadge;
            mesh.remove(badge);
            badge.material.map?.dispose();
            badge.material.dispose();
            mesh.userData.contextBadge = null;
            mesh.userData.needsContext = false;
        }
    }

    function createNodeMesh(data, parent = null) {
        // Geometry
        const geometry = new THREE.SphereGeometry(data.size, 32, 32);
        const material = createNodeMaterial(data.color);
        const mesh = new THREE.Mesh(geometry, material);
        
        // Position
        const isExpanded = store.expandedNodes.has(data.id);
        const startPos = isExpanded && data.expandedPosition ? data.expandedPosition : data.position;
        mesh.position.set(...startPos);
        
        // User data
        mesh.userData = { ...data, parent };
        mesh.userData.isExpanded = isExpanded;
        mesh.userData.baseSize = 1; // Store base scale for importance adjustment
        mesh.userData.importance = data.importance || 1;
        
        // Apply importance scale
        const importanceScale = data.importance || 1;
        mesh.scale.set(importanceScale, importanceScale, importanceScale);
        mesh.userData.baseScale = importanceScale; // Store for selection animation
        
        mesh.userData.spring = {
            velocity: new THREE.Vector3(),
            target: new THREE.Vector3(...startPos),
            scaleVelocity: 0,
            scaleTarget: importanceScale,
            floatOffset: Math.random() * Math.PI * 2,
            floatSpeed: 0.15 + Math.random() * 0.1
        };
        
        // Outline
        const outlineGeometry = new THREE.SphereGeometry(data.size * 1.03, 32, 32);
        const outlineMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color(data.color).multiplyScalar(0.3),
            side: THREE.BackSide,
            transparent: true,
            opacity: 1
        });
        const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
        outline.position.copy(mesh.position);
        outline.scale.set(importanceScale, importanceScale, importanceScale);
        scene.add(outline);
        mesh.userData.outlineMesh = outline;

        // Goal node glow effect - pulsing aura for goal/destination nodes
        if (data.type === 'goal') {
            mesh.userData.isGoal = true;

            // Increase emissive intensity for goal nodes
            mesh.material.emissiveIntensity = 0.6;

            // Create outer glow ring
            const glowGeometry = new THREE.RingGeometry(data.size * 1.4, data.size * 1.8, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x8B5CF6, // Purple glow
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
            glowRing.rotation.x = Math.PI / 2; // Face camera
            glowRing.position.copy(mesh.position);
            glowRing.scale.set(importanceScale, importanceScale, importanceScale);
            scene.add(glowRing);
            mesh.userData.glowRing = glowRing;

            // Create inner target ring
            const targetGeometry = new THREE.RingGeometry(data.size * 1.1, data.size * 1.2, 32);
            const targetMaterial = new THREE.MeshBasicMaterial({
                color: 0xA78BFA, // Lighter purple
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const targetRing = new THREE.Mesh(targetGeometry, targetMaterial);
            targetRing.rotation.x = Math.PI / 2;
            targetRing.position.copy(mesh.position);
            targetRing.scale.set(importanceScale, importanceScale, importanceScale);
            scene.add(targetRing);
            mesh.userData.targetRing = targetRing;

            // Store glow animation phase
            mesh.userData.glowPhase = Math.random() * Math.PI * 2;
        }

        // Label - with link indicator if this node has a link
        const hasLink = !!data.link;
        const label = createLabelSprite(data.label, data.color, hasLink);
        const labelOffset = data.level === 0 ? -data.size - 0.6 : -data.size - 0.35;
        label.position.set(0, labelOffset, 0);
        label.visible = true;  // All labels visible by default
        mesh.add(label);
        mesh.userData.labelSprite = label;

        // Context badge DISABLED - removes pulsing question indicators for cleaner map view and better performance
        // const needsContext = data.level > 0 && (!data.description || data.description.trim() === '');
        mesh.userData.needsContext = false;
        
        // Store link data if present
        if (data.link) {
            mesh.userData.link = data.link;
        }
        
        scene.add(mesh);
        
        // Visibility for collapsed nodes
        const parentIsExpanded = parent && store.expandedNodes.has(parent.id);
        if (data.level >= 2 && !parentIsExpanded) {
            mesh.visible = false;
            outline.visible = false;
            label.visible = false;
            if (mesh.userData.contextBadge) {
                mesh.userData.contextBadge.visible = false;
            }
            if (mesh.userData.glowRing) {
                mesh.userData.glowRing.visible = false;
            }
            if (mesh.userData.targetRing) {
                mesh.userData.targetRing.visible = false;
            }
            mesh.userData.collapsed = true;
        }
        
        // Connection to parent
        if (parent) {
            const connection = createConnection(parent, data, mesh);
            if (connection) {
                mesh.userData.connectionLine = connection;
                if (data.level >= 2 && !parentIsExpanded) {
                    connection.visible = false;
                }
            }
        }
        
        nodes.set(data.id, mesh);
        
        // Create children
        if (data.children) {
            data.children.forEach(child => createNodeMesh(child, data));
        }
        
        return mesh;
    }

    function createConnection(parentData, childData, childMesh) {
        const parentMesh = nodes.get(parentData.id);
        if (!parentMesh) return null;
        
        // Straight line from parent to child
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        const material = new THREE.LineBasicMaterial({
            color: new THREE.Color(childData.color).multiplyScalar(0.6),
            transparent: true,
            opacity: 0.6,
            linewidth: 2
        });
        
        const line = new THREE.Line(geometry, material);
        
        // Store connection metadata for cluster highlighting
        line.userData = {
            startId: parentData.id,
            endId: childData.id
        };
        
        scene.add(line);
        connections.push(line);
        
        return line;
    }

    function updateConnection(childMesh, parentMesh) {
        const line = childMesh.userData.connectionLine;
        if (!line) return;
        
        // Straight line update
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        line.geometry.setFromPoints(points);
    }

    function buildScene() {
        // Clear existing
        nodes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.userData.outlineMesh) {
                scene.remove(mesh.userData.outlineMesh);
                mesh.userData.outlineMesh.geometry.dispose();
                mesh.userData.outlineMesh.material.dispose();
            }
            // Clean up goal node glow effects
            if (mesh.userData.glowRing) {
                scene.remove(mesh.userData.glowRing);
                mesh.userData.glowRing.geometry.dispose();
                mesh.userData.glowRing.material.dispose();
            }
            if (mesh.userData.targetRing) {
                scene.remove(mesh.userData.targetRing);
                mesh.userData.targetRing.geometry.dispose();
                mesh.userData.targetRing.material.dispose();
            }
            if (mesh.userData.labelSprite) {
                mesh.userData.labelSprite.material.map?.dispose();
                mesh.userData.labelSprite.material.dispose();
            }
            mesh.geometry.dispose();
            mesh.material.dispose();
        });
        
        connections.forEach(conn => {
            scene.remove(conn);
            conn.geometry.dispose();
            conn.material.dispose();
        });
        
        nodes.clear();
        connections.length = 0;
        selectedNode = null;
        
        // Reset cluster visualization state
        clusterColorsActive = false;
        currentClusterData = null;
        originalNodeColors.clear();
        
        // Get context node
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) {
            currentContextId = store.data.id;
            return buildScene();
        }
        
        // Calculate positions and create meshes
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        createNodeMesh(processedData);
        
        // Restore expanded state
        store.expandedNodes.forEach(nodeId => {
            const mesh = nodes.get(nodeId);
            if (mesh && mesh.userData.children?.length > 0) {
                expandNode(mesh, false);
            }
        });
        
        updateDepthIndicator();
        
        // Mark labels for declutter recalculation
        LabelSystem.markDirty();
        
        // Request a render for the new scene
        AnimationController.requestRender();
    }
    
    // Smoothly update node positions without rebuilding scene
    function updateNodePositions() {
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) return;
        
        // Recalculate positions
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        
        // Update spring targets for existing visible nodes
        function updatePositionsRecursive(data) {
            const mesh = nodes.get(data.id);
            if (mesh && mesh.visible) {
                const newPos = new THREE.Vector3(data.position[0], data.position[1], data.position[2]);
                mesh.userData.spring.target.copy(newPos);
                mesh.userData.basePosition = [...data.position];
            }
            
            if (data.children) {
                data.children.forEach(child => updatePositionsRecursive(child));
            }
        }
        
        updatePositionsRecursive(processedData);
    }

    function updateLabelsForTheme() {
        // Just update label sprite textures without rebuilding the scene
        nodes.forEach(mesh => {
            if (mesh.userData.labelSprite) {
                const oldSprite = mesh.userData.labelSprite;
                const newSprite = createLabelSprite(mesh.userData.label, mesh.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                
                // Labels are children of mesh, not scene
                mesh.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                
                mesh.add(newSprite);
                mesh.userData.labelSprite = newSprite;
            }
        });
    }
    
    // Update a single node's label
    function updateNodeLabel(mesh, newLabel) {
        if (!mesh) return;
        mesh.userData.label = newLabel;
        
        if (mesh.userData.labelSprite) {
            const oldSprite = mesh.userData.labelSprite;
            const newSprite = createLabelSprite(newLabel, mesh.userData.color);
            newSprite.position.copy(oldSprite.position);
            newSprite.scale.copy(oldSprite.scale);
            newSprite.visible = oldSprite.visible;
            
            mesh.remove(oldSprite);
            oldSprite.material.map?.dispose();
            oldSprite.material.dispose();
            
            mesh.add(newSprite);
            mesh.userData.labelSprite = newSprite;
        }
    }

    function expandNode(mesh, animate = true) {
        if (!mesh.userData.children?.length) return;
        if (mesh.userData.isExpanded) return;
        
        // Track expansion in user profile
        const nodeData = store.findNode(mesh.userData.id);
        if (nodeData) {
            userProfile.trackNodeExpanded(nodeData, store);
        }
        
        // CGT: Record expand action
        cognitiveGT.recordAction('expand', mesh.userData.id, { 
            nodeDepth: mesh.userData.level || 0,
            childCount: mesh.userData.children?.length || 0
        });
        
        mesh.userData.isExpanded = true;
        store.expandedNodes.add(mesh.userData.id);
        
        // Store old positions of all visible nodes before rebuild
        const oldPositions = new Map();
        nodes.forEach((m, id) => {
            if (m.visible) {
                oldPositions.set(id, m.position.clone());
            }
        });
        
        // Rebuild scene to recalculate positions with proper spacing
        buildScene();
        
        // Re-get the mesh after rebuild
        const newMesh = nodes.get(mesh.userData.id);
        if (newMesh && animate) {
            // Restore old positions for existing nodes so they animate smoothly
            oldPositions.forEach((oldPos, id) => {
                const m = nodes.get(id);
                if (m && m.visible) {
                    m.position.copy(oldPos);
                    if (m.userData.outlineMesh) {
                        m.userData.outlineMesh.position.copy(oldPos);
                    }
                }
            });
            
            // Start children from parent position for animation
            newMesh.userData.children?.forEach((childData, index) => {
                const childMesh = nodes.get(childData.id);
                if (childMesh) {
                    const parentPos = newMesh.position.clone();
                    childMesh.position.copy(parentPos);
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.position.copy(parentPos);
                    if (childMesh.userData.glowRing) childMesh.userData.glowRing.position.copy(parentPos);
                    if (childMesh.userData.targetRing) childMesh.userData.targetRing.position.copy(parentPos);
                    const importance = childMesh.userData.importance || 1;
                    childMesh.scale.set(0.5 * importance, 0.5 * importance, 0.5 * importance);
                    childMesh.material.opacity = 0.3;

                    // Hide connection line initially - show after node starts moving
                    if (childMesh.userData.connectionLine) {
                        childMesh.userData.connectionLine.visible = false;
                        // Show connection line after a short delay (when node is partway there)
                        setTimeout(() => {
                            if (childMesh.userData.connectionLine && childMesh.visible) {
                                childMesh.userData.connectionLine.visible = true;
                            }
                        }, 100 + index * 30); // Stagger slightly
                    }
                }
            });
        }
        
        if (animate) {
            audio.expand();
            haptic.light();
        }
    }
    
    function expandAllDescendants(mesh, animate = true, isFirst = true) {
        if (!mesh.userData.children?.length) return;
        
        // First expand this node's direct children
        if (!mesh.userData.isExpanded) {
            expandNode(mesh, animate && isFirst);
        }
        
        // Then recursively expand all descendants with staggered delay
        mesh.userData.children.forEach((childData, i) => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.userData.children?.length > 0) {
                setTimeout(() => {
                    expandAllDescendants(childMesh, animate, false);
                }, animate ? 80 * (i + 1) : 0);
            }
        });
        
        if (animate && isFirst) {
            showToast('Expanded all descendants', 'info');
        }
    }

    function collapseNode(mesh, animate = true, depth = 0) {
        if (!mesh.userData.children?.length) return 0;
        if (!mesh.userData.isExpanded) return 0;
        
        // CGT: Record collapse action (only for top-level collapse, not recursive)
        if (depth === 0) {
            cognitiveGT.recordAction('collapse', mesh.userData.id, { 
                nodeDepth: mesh.userData.level || 0,
                childCount: mesh.userData.children?.length || 0
            });
        }
        
        mesh.userData.isExpanded = false;
        store.expandedNodes.delete(mesh.userData.id);
        
        const parentPos = mesh.position.clone();
        const childCount = mesh.userData.children.length;
        const staggerDelay = CONFIG.TIMING.collapseStagger;
        const hideDelay = CONFIG.TIMING.collapseHideDelay;
        
        // First recursively collapse all grandchildren and get max delay
        let maxNestedDelay = 0;
        mesh.userData.children.forEach((childData) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            if (childMesh.userData.isExpanded) {
                const nestedDelay = collapseNode(childMesh, animate, depth + 1);
                maxNestedDelay = Math.max(maxNestedDelay, nestedDelay);
            }
        });
        
        // Wait for nested collapses to finish, then collapse this level
        const baseDelay = maxNestedDelay;
        const thisLevelDuration = childCount * staggerDelay + hideDelay;
        
        mesh.userData.children.forEach((childData, index) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            childMesh.userData.collapsed = true;
            childMesh.userData.collapseId = Date.now(); // Track this collapse operation
            const thisCollapseId = childMesh.userData.collapseId;
            
            const itemDelay = baseDelay + index * staggerDelay;
            
            if (animate) {
                setTimeout(() => {
                    // Only proceed if this collapse wasn't cancelled by an expand
                    if (childMesh.userData.collapseId !== thisCollapseId) return;

                    // Hide label and connection line immediately when animation starts
                    if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                    if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = false;
                    if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;

                    // Animate back to parent position
                    childMesh.userData.spring.target.copy(parentPos);
                    childMesh.userData.spring.scaleTarget = 0.1;
                }, itemDelay);

                // Hide node after animation completes
                setTimeout(() => {
                    // Only hide if this collapse wasn't cancelled
                    if (childMesh.userData.collapseId !== thisCollapseId) return;
                    if (!childMesh.userData.collapsed) return;

                    childMesh.visible = false;
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                    if (childMesh.userData.glowRing) childMesh.userData.glowRing.visible = false;
                    if (childMesh.userData.targetRing) childMesh.userData.targetRing.visible = false;
                }, itemDelay + hideDelay);
            } else {
                childMesh.visible = false;
                if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = false;
                if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;
                if (childMesh.userData.glowRing) childMesh.userData.glowRing.visible = false;
                if (childMesh.userData.targetRing) childMesh.userData.targetRing.visible = false;
            }
        });
        
        if (animate && depth === 0) {
            audio.collapse();
            haptic.light();

            // If this is a level 1 node, retract it closer to root
            if (mesh.userData.level === 1 && mesh.userData.collapsedPosition) {
                const totalDuration = baseDelay + thisLevelDuration;
                setTimeout(() => {
                    const collapsedPos = mesh.userData.collapsedPosition;
                    const targetVec = new THREE.Vector3(collapsedPos[0], collapsedPos[1], collapsedPos[2]);
                    mesh.userData.spring.target.copy(targetVec);
                }, totalDuration);
            }

            // Smoothly update positions after collapse animation (don't rebuild)
            const totalDuration = baseDelay + thisLevelDuration + 100;
            setTimeout(() => updateNodePositions(), totalDuration);
        }
        
        // Return total time for this level and nested
        return baseDelay + thisLevelDuration;
    }

    function toggleExpand(mesh) {
        if (mesh.userData.isExpanded) {
            collapseNode(mesh);
        } else {
            expandNode(mesh);
        }
    }

    function selectNode(mesh, isDoubleClick = false) {
        const nodeId = mesh.userData.id;
        const wasAlreadySelected = selectedNode === mesh;
        
        // Deselect previous
        if (selectedNode && selectedNode !== mesh) {
            selectedNode.userData.selected = false;
        }
        
        // Check for link node double-click - open URL
        if (isDoubleClick && mesh.userData.link?.url) {
            window.open(mesh.userData.link.url, '_blank');
            showToast('Opening link...', 'info');
            // Still select the node but don't expand
            selectedNode = mesh;
            mesh.userData.selected = true;
            store.selectedNodeId = mesh.userData.id;
            audio.select();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Expand/collapse logic:
        // - Single click on collapsed node: expand direct children only
        // - Single click on expanded node: just select (no collapse)
        // - Second click on already-selected expanded node: collapse
        // - Double click: expand all layers of children
        if (mesh.userData.children?.length > 0) {
            if (isDoubleClick) {
                // Double click: expand all descendants
                expandAllDescendants(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else if (!mesh.userData.isExpanded) {
                // Single click on collapsed: expand direct children only
                expandNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else if (wasAlreadySelected) {
                // Second click on already-selected expanded node: collapse
                collapseNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            }
            // Otherwise: just select the expanded node (don't collapse)
        }
        
        selectedNode = mesh;
        mesh.userData.selected = true;
        store.selectedNodeId = mesh.userData.id;
        
        // Skip camera animation if auto-camera is disabled
        if (!autoCameraEnabled) {
            audio.select();
            haptic.light();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Start smooth camera animation - horizontal arc rotation
        // Use spring target position (final position) rather than current animated position
        const nodePos = mesh.userData.spring?.target?.clone() || mesh.position.clone();
        
        // Check if node has children - zoom out more if it does
        const nodeData = store.findNode(mesh.userData.id);
        const hasChildren = nodeData?.children?.length > 0;
        const childCount = nodeData?.children?.length || 0;
        
        // Get current camera spherical coordinates relative to current target
        const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
        const currentRadius = currentOffset.length();
        const currentTheta = Math.atan2(currentOffset.x, currentOffset.z); // horizontal angle
        const currentPhi = Math.acos(Math.max(-1, Math.min(1, currentOffset.y / currentRadius))); // vertical angle
        
        // Calculate target angle - where the node is
        const nodeAngle = Math.atan2(nodePos.x, nodePos.z);
        const nodeDist2D = Math.sqrt(nodePos.x * nodePos.x + nodePos.z * nodePos.z);
        
        // End target - look directly at the selected node (centered)
        const endTarget = nodePos.clone();
        cameraTargetGoal.copy(endTarget);
        
        // Calculate end camera angle - offset so root node appears to the RIGHT of selected node
        // Subtract angle offset so we're viewing from an angle, not straight through the root
        const endTheta = nodeDist2D > 0.5 ? nodeAngle - Math.PI * 0.35 : currentTheta;
        
        // Zoom out more if node has children - scale based on child count
        // Zoom IN more if node is deeper (smaller) - so we can actually see it
        const isMobile = window.innerWidth <= 768;
        const nodeLevel = mesh.userData.level || 0;
        const baseRadius = isMobile ? 22 : 18;
        
        // Depth zoom: deeper nodes need closer camera (subtract from radius)
        // Level 0 = no bonus, Level 1 = -2, Level 2 = -4, Level 3+ = -6
        const depthZoomBonus = Math.min(nodeLevel * 2, 6);
        
        const childZoomBonus = hasChildren ? Math.min(childCount * 4, 20) : 0; // up to 20 extra for many children
        const endRadius = Math.max(10, baseRadius + childZoomBonus - depthZoomBonus, nodeDist2D + 14 + childZoomBonus - depthZoomBonus);
        const endPhi = Math.PI * 0.35; // consistent downward viewing angle
        
        // Calculate shortest angle difference for arc boost
        let angleDiff = endTheta - currentTheta;
        if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        // Arc boost - how much to zoom out at midpoint (more for bigger rotations)
        const arcBoost = Math.abs(angleDiff) > 0.5 ? 3 : 1;
        
        cameraArcAnimation = {
            startTime: performance.now(),
            duration: 800, // Faster, smoother
            startTarget: controls.target.clone(),
            endTarget: endTarget,
            startTheta: currentTheta,
            endTheta: endTheta,
            startPhi: currentPhi,
            endPhi: endPhi,
            startRadius: currentRadius,
            endRadius: endRadius,
            arcBoost: arcBoost,
            useSpherical: true,
            startCameraPos: camera.position.clone()
        };
        
        audio.select();
        haptic.light();
        
        bus.emit('node:selected', { data: mesh.userData });
    }

    function deselectNode() {
        if (selectedNode) {
            selectedNode.userData.selected = false;
            selectedNode = null;
            store.selectedNodeId = null;
        }
        bus.emit('node:deselected');
    }

    function diveIntoNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node || !node.children?.length) return;
        
        currentContextId = nodeId;
        buildScene();
        
        // Camera animation
        const mesh = nodes.get(nodeId);
        if (mesh) {
            const targetPos = new THREE.Vector3(0, 8, 25);
            const startPos = camera.position.clone();
            const duration = 800;
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = easeOutCubic(progress);
                
                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.set(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            animateCamera();
        }
        
        audio.expand();
        haptic.medium();
        showToast(`Diving into "${node.label}"`, 'info');
    }

    function surfaceUp() {
        const currentNode = store.findNode(currentContextId);
        if (!currentNode || currentContextId === store.data.id) return;
        
        const parent = store.findParent(currentContextId);
        if (!parent) {
            currentContextId = store.data.id;
        } else {
            currentContextId = parent.id;
        }
        
        buildScene();
        audio.collapse();
        haptic.medium();
    }

    function updateDepthIndicator() {
        const indicator = document.getElementById('depth-indicator');
        const pathEl = document.getElementById('depth-path');
        
        if (currentContextId === store.data.id) {
            indicator.classList.remove('active');
            return;
        }
        
        const path = store.getPath(currentContextId);
        if (path.length === 0) {
            indicator.classList.remove('active');
            return;
        }
        
        pathEl.innerHTML = path.map((n, i) => {
            const isLast = i === path.length - 1;
            return `<span class="depth-item ${isLast ? 'current' : ''}">${escapeHTML(n.label)}</span>` +
                   (isLast ? '' : '<span style="margin: 0 4px;">›</span>');
        }).join('');
        
        indicator.classList.add('active');
    }

    function resetCamera() {
        const isMobile = window.innerWidth <= 768;
        const targetPos = new THREE.Vector3(0, isMobile ? 12 : 8, isMobile ? 35 : 25);
        const startPos = camera.position.clone();
        const duration = 600;
        const startTime = Date.now();
        
        // Reset camera target goal to origin
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function zoomToFitMap(extraZoom = 0) {
        // Calculate bounds of all visible nodes
        let maxDist = 0;
        nodes.forEach(mesh => {
            if (mesh.visible) {
                const dist = mesh.position.length();
                maxDist = Math.max(maxDist, dist);
            }
        });
        
        const isMobile = window.innerWidth <= 768;
        // Zoom out enough to see all nodes plus some padding - more on mobile
        const targetDist = Math.max(maxDist * (isMobile ? 3 : 2.5) + extraZoom, isMobile ? 50 : 30);
        const targetPos = new THREE.Vector3(0, targetDist * 0.4, targetDist);
        const startPos = camera.position.clone();
        const duration = isMobile ? 1500 : 800; // Slower on mobile
        const startTime = Date.now();
        
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }
    
    // Expose to global scope for sheet tools
    window.zoomToFitMap = zoomToFitMap;
    
    // Focus camera on a specific node without full selection animation
    function focusOnNode(mesh) {
        if (!mesh) return;
        
        const nodePos = mesh.userData.spring?.target?.clone() || mesh.position.clone();
        
        // Smoothly move camera target to node
        cameraTargetGoal.copy(nodePos);
        
        // Calculate ideal camera position - maintain current viewing angle but center on node
        const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
        const currentRadius = currentOffset.length();
        
        // Deeper nodes need closer camera
        const nodeLevel = mesh.userData.level || 0;
        const depthZoomBonus = Math.min(nodeLevel * 2, 6);
        const idealRadius = Math.max(10, 20 - depthZoomBonus);
        
        // Animate camera to look at node
        const startTarget = controls.target.clone();
        const startPos = camera.position.clone();
        const endTarget = nodePos.clone();
        const endPos = nodePos.clone().add(currentOffset.normalize().multiplyScalar(Math.min(currentRadius, idealRadius)));
        
        const duration = 400;
        const startTime = Date.now();
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            controls.target.lerpVectors(startTarget, endTarget, ease);
            camera.position.lerpVectors(startPos, endPos, ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function expandAll() {
        const isMobile = window.innerWidth <= 768;

        // Pause neural training during heavy operation
        neuralTrainingPaused = true;

        // Start zooming out immediately
        zoomToFitMap(isMobile ? 25 : 15);

        // Get all nodes that need expanding
        const toExpand = [];
        nodes.forEach(mesh => {
            if (mesh.userData.children?.length && !mesh.userData.isExpanded) {
                toExpand.push(mesh);
            }
        });

        if (toExpand.length === 0) {
            showToast('All nodes already expanded', 'info');
            neuralTrainingPaused = false;
            return;
        }

        // Play sound at START of expansion
        audio.expand();

        // Sort by level (shallowest first)
        toExpand.sort((a, b) => (a.userData.level || 0) - (b.userData.level || 0));

        // OPTIMIZED EXPANSION: Mark all as expanded first, then ONE rebuild
        // This avoids rebuilding the entire scene for each node!

        // Store old positions before any changes
        const oldPositions = new Map();
        nodes.forEach((m, id) => {
            if (m.visible) {
                oldPositions.set(id, m.position.clone());
            }
        });

        // Mark ALL nodes as expanded (no rebuild yet)
        toExpand.forEach(mesh => {
            mesh.userData.isExpanded = true;
            store.expandedNodes.add(mesh.userData.id);
        });

        // ONE rebuild to calculate all new positions
        buildScene();

        // Collect all newly visible nodes (children that just appeared)
        const newlyVisible = [];
        nodes.forEach((mesh, id) => {
            if (mesh.visible && !oldPositions.has(id)) {
                newlyVisible.push(mesh);
                // Start hidden for animation
                mesh.visible = false;
                if (mesh.userData.outlineMesh) mesh.userData.outlineMesh.visible = false;
                if (mesh.userData.labelSprite) mesh.userData.labelSprite.visible = false;
            }
        });

        // Restore old positions for smooth transition
        oldPositions.forEach((oldPos, id) => {
            const m = nodes.get(id);
            if (m && m.visible) {
                m.position.copy(oldPos);
                if (m.userData.outlineMesh) m.userData.outlineMesh.position.copy(oldPos);
            }
        });

        // Sort new nodes by level for reveal order
        newlyVisible.sort((a, b) => (a.userData.level || 0) - (b.userData.level || 0));

        // Reveal nodes ONE AT A TIME with staggered animation
        const baseDelay = isMobile ? 30 : 15;
        const staggerTime = newlyVisible.length > 500 ? baseDelay * 0.5 :
                           newlyVisible.length > 200 ? baseDelay * 0.75 : baseDelay;

        let revealIndex = 0;
        function revealNext() {
            if (revealIndex >= newlyVisible.length) {
                // Done - final zoom and resume training
                neuralTrainingPaused = false;
                if (autoCameraEnabled) {
                    setTimeout(() => zoomToFitMap(10), 300);
                }
                return;
            }

            const mesh = newlyVisible[revealIndex];

            // Find parent position for spawn point
            const parentId = mesh.userData.parent;
            const parentMesh = parentId ? nodes.get(parentId) : null;
            const spawnPos = parentMesh ? parentMesh.position.clone() : new THREE.Vector3(0, 0, 0);

            // Start from parent position, small scale
            mesh.position.copy(spawnPos);
            if (mesh.userData.outlineMesh) mesh.userData.outlineMesh.position.copy(spawnPos);

            const importance = mesh.userData.importance || 1;
            mesh.scale.set(0.3 * importance, 0.3 * importance, 0.3 * importance);
            mesh.material.opacity = 0.5;

            // Make visible
            mesh.visible = true;
            if (mesh.userData.outlineMesh) mesh.userData.outlineMesh.visible = true;
            if (mesh.userData.labelSprite) mesh.userData.labelSprite.visible = true;

            revealIndex++;

            // Schedule next reveal
            setTimeout(revealNext, staggerTime);
        }

        // Start revealing
        revealNext();

        const estimatedTime = Math.round((newlyVisible.length * staggerTime) / 1000);
        showToast(`Expanding ${newlyVisible.length} nodes (~${estimatedTime}s)...`, 'success');
    }

    function collapseAll() {
        const isMobile = window.innerWidth <= 768;

        // Pause neural training during heavy operation
        neuralTrainingPaused = true;

        // Collect all nodes that will be hidden (level 2+)
        const toHide = [];
        nodes.forEach(mesh => {
            if (mesh.visible && (mesh.userData.level || 0) >= 2) {
                toHide.push(mesh);
            }
        });

        // Collect all expanded nodes that need to be marked collapsed
        const toCollapse = [];
        nodes.forEach(mesh => {
            if (mesh.userData.isExpanded && (mesh.userData.level || 0) >= 1) {
                toCollapse.push(mesh);
            }
        });

        if (toHide.length === 0 && toCollapse.length === 0) {
            showToast('Already collapsed', 'info');
            neuralTrainingPaused = false;
            return;
        }

        // Play sound at START of collapse
        audio.collapse();

        // Sort nodes to hide by level descending (deepest first)
        toHide.sort((a, b) => (b.userData.level || 0) - (a.userData.level || 0));

        // OPTIMIZED COLLAPSE: Hide nodes one at a time, then ONE rebuild
        const baseDelay = isMobile ? 20 : 10;
        const staggerTime = toHide.length > 500 ? baseDelay * 0.5 :
                           toHide.length > 200 ? baseDelay * 0.75 : baseDelay;

        let hideIndex = 0;
        function hideNext() {
            if (hideIndex >= toHide.length) {
                // All nodes hidden - now mark as collapsed and rebuild once
                toCollapse.forEach(mesh => {
                    mesh.userData.isExpanded = false;
                    store.expandedNodes.delete(mesh.userData.id);
                });

                // ONE rebuild
                buildScene();

                // Done
                neuralTrainingPaused = false;
                if (autoCameraEnabled) {
                    setTimeout(() => zoomToFitMap(0), 300);
                }
                return;
            }

            const mesh = toHide[hideIndex];

            // Animate shrink/fade
            const importance = mesh.userData.importance || 1;
            mesh.scale.set(0.2 * importance, 0.2 * importance, 0.2 * importance);
            mesh.material.opacity = 0.2;

            // Hide after brief delay
            setTimeout(() => {
                mesh.visible = false;
                if (mesh.userData.outlineMesh) mesh.userData.outlineMesh.visible = false;
                if (mesh.userData.labelSprite) mesh.userData.labelSprite.visible = false;
            }, 50);

            hideIndex++;

            // Schedule next hide
            setTimeout(hideNext, staggerTime);
        }

        // Start hiding
        hideNext();

        const estimatedTime = Math.round((toHide.length * staggerTime) / 1000);
        showToast(`Collapsing ${toHide.length} nodes (~${estimatedTime}s)...`, 'success');
    }

    // Label decluttering - hide labels that overlap with others
    function declutterLabels() {
        const visibleLabels = [];
        const padding = 12; // pixels of padding between labels
        
        // Collect all visible labels with their screen positions
        nodes.forEach(mesh => {
            if (!mesh.visible || !mesh.userData.labelSprite) return;
            
            const sprite = mesh.userData.labelSprite;
            const pos = mesh.position.clone();
            pos.project(camera);
            
            // Skip if behind camera
            if (pos.z > 1) {
                sprite.material.opacity = 0;
                return;
            }
            
            // Convert to screen coordinates
            const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            
            // Get approximate label size in screen pixels based on text length
            const dist = camera.position.distanceTo(mesh.position);
            const textLength = (mesh.userData.label || '').length;
            const cfg = CONFIG.LABELS;
            const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            
            // Priority: selected nodes > closer to camera > root > by depth
            // CLOSER nodes should ALWAYS win over farther nodes
            const depth = mesh.userData.depth || 0;
            const isSelected = mesh.userData.selected;
            const isRoot = mesh.userData.id === 'root';
            
            // Distance priority: closer = higher priority (inverse relationship)
            // Max distance we care about is ~50 units, normalize to 0-100 range
            const distancePriority = Math.max(0, 100 - dist * 2);
            
            const priority = isSelected ? 1000 : // Selected always wins
                            (isRoot ? 500 + distancePriority : // Root gets bonus
                            distancePriority); // Everything else based on distance
            
            visibleLabels.push({
                sprite,
                mesh,
                x: screenX,
                y: screenY,
                width: labelWidth,
                height: labelHeight,
                priority,
                baseOpacity: mesh.userData.labelBaseOpacity || 1,
                shouldShow: true
            });
        });
        
        // Sort by priority (higher priority labels get shown first)
        visibleLabels.sort((a, b) => b.priority - a.priority);
        
        // Check for overlaps and hide lower priority labels
        for (let i = 0; i < visibleLabels.length; i++) {
            if (!visibleLabels[i].shouldShow) continue;
            
            const labelA = visibleLabels[i];
            
            for (let j = i + 1; j < visibleLabels.length; j++) {
                if (!visibleLabels[j].shouldShow) continue;
                
                const labelB = visibleLabels[j];
                
                // Check for rectangle overlap
                const overlapX = Math.abs(labelA.x - labelB.x) < (labelA.width + labelB.width) / 2 + padding;
                const overlapY = Math.abs(labelA.y - labelB.y) < (labelA.height + labelB.height) / 2 + padding;
                
                if (overlapX && overlapY) {
                    // Hide the lower priority label (labelB since array is sorted)
                    visibleLabels[j].shouldShow = false;
                }
            }
        }
        
        // Apply visibility with smooth fade
        visibleLabels.forEach(label => {
            const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
            const currentOpacity = label.sprite.material.opacity;
            // Smooth transition
            label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * 0.12;
            // Clamp very small values to 0
            if (label.sprite.material.opacity < 0.03) {
                label.sprite.material.opacity = 0;
            }
        });
    }

    // Animation loop - modularized and optimized
    function animate() {
        requestAnimationFrame(animate);
        
        // Check if we should render this frame (throttling)
        const currentTime = performance.now();
        if (!AnimationController.shouldRenderFrame(currentTime)) {
            return;
        }
        
        const time = Date.now() * 0.001;
        const cfg = CONFIG.ANIMATION;
        
        // Particles removed for performance
        
        // Track animating nodes for idle detection
        let animatingCount = 0;
        
        // Spring physics for nodes
        nodes.forEach(mesh => {
            if (!mesh.visible) return;
            
            const spring = mesh.userData.spring;
            if (!spring) return;
            
            // Check if node is still animating (position or scale)
            const posDiff = mesh.position.distanceTo(spring.target);
            const scaleDiff = Math.abs(mesh.scale.x - spring.scaleTarget);
            const isAnimating = posDiff > cfg.animatingThreshold || scaleDiff > cfg.animatingThreshold;
            
            if (isAnimating) animatingCount++;
            
            // Adaptive lerp - slower for longer distances (smoother repositioning)
            const lerpFactor = posDiff > 3 ? cfg.springLerpSlow : 
                              (posDiff > 1.5 ? cfg.springLerpMedium : cfg.springLerpBase);
            
            // Smooth position lerp
            if (posDiff > cfg.positionThreshold) {
                mesh.position.lerp(spring.target, lerpFactor);
            } else if (posDiff > 0) {
                mesh.position.copy(spring.target);
            }
            
            // Outline follows
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.position.copy(mesh.position);
            }
            
            // Smooth scale lerp
            const currentScale = mesh.scale.x;
            if (scaleDiff > cfg.scaleThreshold) {
                const newScale = currentScale + (spring.scaleTarget - currentScale) * cfg.scaleLerp;
                mesh.scale.set(newScale, newScale, newScale);
            } else {
                mesh.scale.set(spring.scaleTarget, spring.scaleTarget, spring.scaleTarget);
            }
            
            if (mesh.userData.outlineMesh) {
                const s = mesh.scale.x * 1.03;
                mesh.userData.outlineMesh.scale.set(s, s, s);
            }
            
            // Opacity for new nodes
            if (mesh.material.opacity < 1) {
                mesh.material.opacity = Math.min(1, mesh.material.opacity + 0.1);
            }
            
            // Queue connection updates for batch processing
            if (isAnimating && mesh.userData.connectionLine && mesh.userData.parent) {
                ConnectionManager.queueUpdate(mesh);
            }
            
            // Label visibility and scale (less frequent updates)
            if (mesh.userData.labelSprite) {
                const dist = camera.position.distanceTo(mesh.position);
                
                // Base scale calculation (less frequent)
                if (!mesh.userData.lastLabelUpdate || time - mesh.userData.lastLabelUpdate > CONFIG.TIMING.labelUpdateInterval / 1000) {
                    mesh.userData.lastLabelUpdate = time;
                    mesh.userData.labelBaseScale = 0.6 * Math.max(0.5, Math.min(1.2, dist / 15));
                    mesh.userData.labelBaseOpacity = Math.max(0.7, Math.min(1, 35 / dist));
                }
                
                const labelScale = mesh.userData.labelBaseScale || 0.6;
                const aspect = mesh.userData.labelSprite.userData.aspect || 
                    (mesh.userData.labelSprite.scale.x / mesh.userData.labelSprite.scale.y);
                mesh.userData.labelSprite.scale.set(labelScale * aspect, labelScale, 1);
                
                // Update context badge position and animation
                if (mesh.userData.contextBadge) {
                    const badge = mesh.userData.contextBadge;
                    const labelWidth = labelScale * aspect;
                    const labelSprite = mesh.userData.labelSprite;
                    
                    // Position badge to the right of the label, matching label's Y position
                    badge.position.x = labelWidth / 2 + 0.16;
                    badge.position.y = labelSprite.position.y; // Keep Y synced with label
                    
                    // Pulse animation for the badge - scale and opacity
                    const pulsePhase = time * 2.5 + badge.userData.pulsePhase;
                    const scalePulse = 1 + Math.sin(pulsePhase) * 0.08;
                    const opacityPulse = 0.85 + Math.sin(pulsePhase) * 0.15;
                    
                    const baseScale = badge.userData.baseScale || 0.28;
                    let badgeScale = baseScale * scalePulse;
                    
                    // Hover effect
                    if (mesh.userData.badgeHovered) {
                        badgeScale *= 1.4;
                        badge.material.opacity = 1;
                    } else {
                        badge.material.opacity = opacityPulse;
                    }
                    
                    badge.scale.set(badgeScale, badgeScale, 1);
                }
            }

            // Goal node glow animation - pulsing rings
            if (mesh.userData.isGoal) {
                const glowPhase = mesh.userData.glowPhase || 0;
                const pulse = Math.sin(time * 2 + glowPhase);

                // Animate glow ring
                if (mesh.userData.glowRing) {
                    const glowRing = mesh.userData.glowRing;
                    glowRing.position.copy(mesh.position);
                    glowRing.material.opacity = 0.3 + pulse * 0.15;
                    const glowScale = mesh.scale.x * (1.0 + pulse * 0.1);
                    glowRing.scale.set(glowScale, glowScale, glowScale);
                    // Make ring face camera
                    glowRing.lookAt(camera.position);
                }

                // Animate target ring
                if (mesh.userData.targetRing) {
                    const targetRing = mesh.userData.targetRing;
                    targetRing.position.copy(mesh.position);
                    targetRing.material.opacity = 0.5 + pulse * 0.2;
                    const targetScale = mesh.scale.x * (1.0 - pulse * 0.05);
                    targetRing.scale.set(targetScale, targetScale, targetScale);
                    // Make ring face camera
                    targetRing.lookAt(camera.position);
                }

                // Boost emissive when not selected
                if (!mesh.userData.selected) {
                    mesh.material.emissiveIntensity = 0.5 + pulse * 0.15;
                }
            }

            // Selection glow - more prominent pulsing effect
            if (mesh.userData.selected) {
                // Stronger pulse with higher intensity range
                mesh.material.emissiveIntensity = 0.7 + Math.sin(time * 3) * 0.3;
                
                // Subtle scale pulse for selected node
                const scalePulse = 1 + Math.sin(time * 3) * 0.05;
                mesh.scale.setScalar(mesh.userData.baseScale * scalePulse);
            } else {
                mesh.material.emissiveIntensity = 0.3;
                // Reset scale if it was selected before
                if (mesh.userData.baseScale && mesh.scale.x !== mesh.userData.baseScale) {
                    mesh.scale.setScalar(mesh.userData.baseScale);
                }
            }
        });
        
        // Batch process all connection updates
        ConnectionManager.processBatch();

        // Smart label decluttering - checks camera movement and runs only when needed
        LabelSystem.checkCameraMovement(camera, controls);
        LabelSystem.update(camera, nodes);

        // Update goal beacons (distant goal visualization)
        if (typeof GoalVisualization !== 'undefined' && GoalVisualization.update) {
            GoalVisualization.update(time);
        }
        
        // Smooth camera animation (runs even during interaction if animation is active)
        if (cameraArcAnimation) {
            const elapsed = performance.now() - cameraArcAnimation.startTime;
            const progress = Math.min(elapsed / cameraArcAnimation.duration, 1);
            
            // Use smootherStep for silkier transitions
            const ease = Utils.easing.smootherStep(progress);
            
            // Lerp target position
            controls.target.lerpVectors(
                cameraArcAnimation.startTarget,
                cameraArcAnimation.endTarget,
                ease
            );
            
            if (cameraArcAnimation.useSpherical) {
                // Spherical interpolation for smooth horizontal rotation
                let startTheta = cameraArcAnimation.startTheta;
                let endTheta = cameraArcAnimation.endTheta;
                
                // Take shortest path around the circle
                let deltaTheta = endTheta - startTheta;
                if (deltaTheta > Math.PI) deltaTheta -= Math.PI * 2;
                if (deltaTheta < -Math.PI) deltaTheta += Math.PI * 2;
                
                const currentTheta = startTheta + deltaTheta * ease;
                
                // Vertical angle - keep relatively constant, slight interpolation
                const currentPhi = cameraArcAnimation.startPhi + 
                    (cameraArcAnimation.endPhi - cameraArcAnimation.startPhi) * ease;
                
                // Radius with arc boost - zoom out in middle, back in at end
                const arcProgress = Math.sin(progress * Math.PI); // peaks at 0.5
                const baseRadius = cameraArcAnimation.startRadius + 
                    (cameraArcAnimation.endRadius - cameraArcAnimation.startRadius) * ease;
                const currentRadius = baseRadius + arcProgress * cameraArcAnimation.arcBoost;
                
                // Convert spherical back to cartesian, relative to current target
                const newOffset = new THREE.Vector3(
                    Math.sin(currentTheta) * Math.sin(currentPhi) * currentRadius,
                    Math.cos(currentPhi) * currentRadius,
                    Math.cos(currentTheta) * Math.sin(currentPhi) * currentRadius
                );
                
                camera.position.copy(controls.target).add(newOffset);
            } else if (cameraArcAnimation.endCameraPos) {
                // Fallback linear interpolation
                camera.position.lerpVectors(
                    cameraArcAnimation.startCameraPos,
                    cameraArcAnimation.endCameraPos,
                    ease
                );
            }
            
            cameraTargetGoal.copy(controls.target);
            
            // Clear animation when done
            if (progress >= 1) {
                cameraArcAnimation = null;
            }
        } else if (!userInteracting) {
            // Normal slow follow when no arc animation and not interacting
            const targetDiff = new THREE.Vector3().subVectors(cameraTargetGoal, controls.target);
            const step = targetDiff.multiplyScalar(CONFIG.ANIMATION.cameraFollowSpeed);
            controls.target.add(step);
            camera.position.add(step);
        }
        
        // Update animation controller with count of animating nodes
        AnimationController.setAnimatingCount(animatingCount);
        
        controls.update();
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════════════════════
    // UI INTERACTIONS
    // ═══════════════════════════════════════════════════════════════════
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let moveMode = false;
    let draggedNode = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let dragOffset = new THREE.Vector3();
    let childOffsets = new Map(); // Store offsets for children when dragging expanded node
    let pointerDownTime = 0;
    let pointerDownPos = { x: 0, y: 0 };
    let clickedOnEmpty = false;
    let lastClickTime = 0;
    let lastClickedNodeId = null;
    
    // Right-click reparent drag state
    let reparentDragging = false;
    let reparentNode = null;
    let reparentTarget = null;
    let reparentHoverStart = 0;
    let reparentConfirmTime = 800; // Hold over target for 800ms to confirm
    let reparentGhostLine = null;

    // Get all visible descendants of a node
    function getVisibleDescendants(mesh, descendants = []) {
        if (!mesh.userData.children) return descendants;
        mesh.userData.children.forEach(childData => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.visible) {
                descendants.push(childMesh);
                getVisibleDescendants(childMesh, descendants);
            }
        });
        return descendants;
    }

    function onPointerDown(event) {
        if (event.target.closest('#info-panel, #side-panel, #top-controls, #quick-capture, #spotlight-overlay, #modal-overlay, #menu-dropdown, #theme-picker, #depth-indicator, #radial-menu, #voice-indicator, #voice-backdrop, #api-key-modal')) {
            return;
        }
        
        pointerDownTime = Date.now();
        pointerDownPos = { x: event.clientX, y: event.clientY };
        clickedOnEmpty = false;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const meshes = Array.from(nodes.values()).filter(m => m.visible);
        const intersects = raycaster.intersectObjects(meshes, true); // Include children (labels)
        
        if (intersects.length > 0) {
            // Get the intersected object - might be the label sprite or badge, not the mesh
            let mesh = intersects[0].object;
            let clickedOnContextBadge = false;
            
            // If we hit a sprite, get the parent mesh
            if (mesh.isSprite && mesh.parent && mesh.parent.userData?.id) {
                // Check if this is the context badge
                if (mesh.userData?.isContextBadge) {
                    clickedOnContextBadge = true;
                }
                mesh = mesh.parent;
            }
            
            // Make sure we have a valid node mesh with userData
            if (!mesh.userData?.id) {
                clickedOnEmpty = true;
                lastClickedNodeId = null;
                return;
            }
            
            // Right-click to start reparent drag (not on root node)
            if (event.button === 2 && mesh.userData.id !== store.data.id) {
                reparentDragging = true;
                reparentNode = mesh;
                reparentTarget = null;
                reparentHoverStart = 0;
                controls.enabled = false;
                renderer.domElement.style.cursor = 'grabbing';
                
                // Hide the connection line to parent while dragging
                if (mesh.userData.connectionLine) {
                    mesh.userData.connectionLine.visible = false;
                }
                
                // Set up drag plane facing camera
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), mesh.position);
                
                // Calculate offset
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragOffset.subVectors(mesh.position, intersectPoint);
                
                // Store offsets for all visible descendants
                childOffsets.clear();
                const descendants = getVisibleDescendants(mesh);
                descendants.forEach(childMesh => {
                    const offset = childMesh.position.clone().sub(mesh.position);
                    childOffsets.set(childMesh.userData.id, offset);
                });
                
                // Create ghost line for visual feedback
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.5,
                    linewidth: 2
                });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    mesh.position.clone(),
                    mesh.position.clone()
                ]);
                reparentGhostLine = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(reparentGhostLine);
                
                return; // Don't process as normal click
            }
            
            // Move mode - start dragging immediately, don't select (which might collapse)
            if (moveMode) {
                draggedNode = mesh;
                controls.enabled = false;
                renderer.domElement.style.cursor = 'grabbing';
                
                // Set up drag plane facing camera
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), mesh.position);
                
                // Calculate offset
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragOffset.subVectors(mesh.position, intersectPoint);
                
                // Store offsets for all visible descendants so they move with parent
                childOffsets.clear();
                const descendants = getVisibleDescendants(mesh);
                descendants.forEach(childMesh => {
                    const offset = childMesh.position.clone().sub(mesh.position);
                    childOffsets.set(childMesh.userData.id, offset);
                });
            } else {
                // Check for double-click on same node
                const now = Date.now();
                const isDoubleClick = (now - lastClickTime < 350) && (lastClickedNodeId === mesh.userData.id);
                
                lastClickTime = now;
                lastClickedNodeId = mesh.userData.id;
                
                selectNode(mesh, isDoubleClick);
                
                // If context badge was clicked, expand panel and open the question popover
                if (clickedOnContextBadge && mesh.userData.contextBadge) {
                    setTimeout(() => {
                        // Expand the info panel first so the button is visible
                        const infoPanel = document.getElementById('info-panel');
                        if (!infoPanel.classList.contains('expanded')) {
                            infoPanel.classList.add('expanded');
                        }
                        // Then click the context question button
                        setTimeout(() => {
                            document.getElementById('context-question-btn').click();
                        }, 100);
                    }, 100);
                }
            }
        } else {
            // Clicked on empty space - track for potential deselect on pointer up
            clickedOnEmpty = true;
            lastClickedNodeId = null;
        }
    }
    
    function onPointerMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Reparent drag logic
        if (reparentDragging && reparentNode) {
            raycaster.setFromCamera(mouse, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersectPoint);
            
            if (intersectPoint) {
                const newPos = intersectPoint.add(dragOffset);
                reparentNode.userData.spring.target.copy(newPos);
                
                // Move all children with the dragged node
                childOffsets.forEach((offset, childId) => {
                    const childMesh = nodes.get(childId);
                    if (childMesh && childMesh.visible) {
                        const childNewPos = newPos.clone().add(offset);
                        childMesh.userData.spring.target.copy(childNewPos);
                    }
                });
                
                // Check for hover over potential new parent
                const meshes = Array.from(nodes.values()).filter(m => 
                    m.visible && 
                    m.userData.id !== reparentNode.userData.id &&
                    !childOffsets.has(m.userData.id) // Not a descendant
                );
                const intersects = raycaster.intersectObjects(meshes, true);
                
                // Clear previous target highlight
                if (reparentTarget && reparentTarget !== intersects[0]?.object) {
                    let oldTarget = reparentTarget;
                    if (oldTarget.isSprite && oldTarget.parent) oldTarget = oldTarget.parent;
                    if (oldTarget.userData?.originalEmissive !== undefined) {
                        oldTarget.material.emissive.setHex(oldTarget.userData.originalEmissive);
                        oldTarget.material.emissiveIntensity = 0;
                    }
                }
                
                let newTarget = null;
                if (intersects.length > 0) {
                    let hitMesh = intersects[0].object;
                    if (hitMesh.isSprite && hitMesh.parent && hitMesh.parent.userData?.id) {
                        hitMesh = hitMesh.parent;
                    }
                    
                    // Can't reparent to self, descendant, or current parent
                    const currentParentId = reparentNode.userData.parent?.id;
                    if (hitMesh.userData?.id && hitMesh.userData.id !== currentParentId) {
                        newTarget = hitMesh;
                        
                        // Highlight potential target
                        if (hitMesh.userData.originalEmissive === undefined) {
                            hitMesh.userData.originalEmissive = hitMesh.material.emissive.getHex();
                        }
                        hitMesh.material.emissive.setHex(0x00ff00);
                        hitMesh.material.emissiveIntensity = 0.3;
                        
                        // Update ghost line to point to target
                        if (reparentGhostLine) {
                            const positions = reparentGhostLine.geometry.attributes.position;
                            positions.setXYZ(0, newPos.x, newPos.y, newPos.z);
                            positions.setXYZ(1, hitMesh.position.x, hitMesh.position.y, hitMesh.position.z);
                            positions.needsUpdate = true;
                            reparentGhostLine.material.color.setHex(0x00ff00);
                        }
                    }
                }
                
                // Track hover time on target (just for visual feedback intensity)
                if (newTarget !== reparentTarget) {
                    reparentTarget = newTarget;
                    reparentHoverStart = newTarget ? Date.now() : 0;
                } else if (reparentTarget && reparentHoverStart > 0) {
                    // Visual feedback only - pulse based on hover time
                    const hoverTime = Date.now() - reparentHoverStart;
                    const progress = Math.min(hoverTime / 500, 1); // Quick ramp up
                    
                    if (reparentTarget.material) {
                        reparentTarget.material.emissiveIntensity = 0.3 + progress * 0.4;
                    }
                    // Reparent happens on mouse release, not here
                }
                
                // Update ghost line if no target
                if (!reparentTarget && reparentGhostLine) {
                    const positions = reparentGhostLine.geometry.attributes.position;
                    positions.setXYZ(0, newPos.x, newPos.y, newPos.z);
                    positions.setXYZ(1, newPos.x, newPos.y, newPos.z);
                    positions.needsUpdate = true;
                    reparentGhostLine.material.color.setHex(0xffffff);
                }
            }
            return;
        }
        
        // Hover detection for labels with context badges
        if (!moveMode && !draggedNode) {
            raycaster.setFromCamera(mouse, camera);
            const meshes = Array.from(nodes.values()).filter(m => m.visible);
            const intersects = raycaster.intersectObjects(meshes, true);
            
            // Clear previous hover states
            nodes.forEach(mesh => {
                if (mesh.userData.badgeHovered) {
                    mesh.userData.badgeHovered = false;
                }
            });
            
            if (intersects.length > 0) {
                let hitObject = intersects[0].object;
                let parentMesh = null;
                
                // Check if we hit a context badge sprite
                if (hitObject.isSprite && hitObject.userData?.isContextBadge && hitObject.parent && hitObject.parent.userData?.id) {
                    parentMesh = hitObject.parent;
                    parentMesh.userData.badgeHovered = true;
                    renderer.domElement.style.cursor = 'pointer';
                } else if (hitObject.isSprite && hitObject.parent && hitObject.parent.userData?.id) {
                    // Hit the label - check if node has a context badge
                    parentMesh = hitObject.parent;
                }
                
                if (!parentMesh?.userData.badgeHovered) {
                    renderer.domElement.style.cursor = moveMode ? 'grab' : 'default';
                }
            } else {
                renderer.domElement.style.cursor = moveMode ? 'grab' : 'default';
            }
        }
        
        // Dragging logic
        if (!draggedNode || !moveMode) return;
        
        raycaster.setFromCamera(mouse, camera);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectPoint);
        
        if (intersectPoint) {
            const newPos = intersectPoint.add(dragOffset);
            draggedNode.userData.spring.target.copy(newPos);
            draggedNode.userData.basePosition = [newPos.x, newPos.y, newPos.z];
            
            // Move all children with the parent
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh && childMesh.visible) {
                    const childNewPos = newPos.clone().add(offset);
                    childMesh.userData.spring.target.copy(childNewPos);
                    childMesh.userData.basePosition = [childNewPos.x, childNewPos.y, childNewPos.z];
                    
                    // Update child's connection line
                    if (childMesh.userData.connectionLine && childMesh.userData.parent) {
                        const parentMesh = nodes.get(childMesh.userData.parent.id);
                        if (parentMesh) {
                            updateConnection(childMesh, parentMesh);
                        }
                    }
                }
            });
            
            // Update connection line for dragged node
            if (draggedNode.userData.connectionLine && draggedNode.userData.parent) {
                const parentMesh = nodes.get(draggedNode.userData.parent.id);
                if (parentMesh) {
                    updateConnection(draggedNode, parentMesh);
                }
            }
        }
    }
    
    function cleanupReparentDrag(restoreConnectionLine = true) {
        if (reparentTarget && reparentTarget.userData?.originalEmissive !== undefined) {
            reparentTarget.material.emissive.setHex(reparentTarget.userData.originalEmissive);
            reparentTarget.material.emissiveIntensity = 0;
        }
        if (reparentGhostLine) {
            scene.remove(reparentGhostLine);
            reparentGhostLine.geometry.dispose();
            reparentGhostLine.material.dispose();
            reparentGhostLine = null;
        }
        // Restore connection line visibility if not reparenting
        if (restoreConnectionLine && reparentNode && reparentNode.userData.connectionLine) {
            reparentNode.userData.connectionLine.visible = true;
        }
        reparentDragging = false;
        reparentNode = null;
        reparentTarget = null;
        reparentHoverStart = 0;
        childOffsets.clear();
        controls.enabled = true;
        renderer.domElement.style.cursor = 'default';
    }
    
    function onPointerUp(event) {
        // Handle reparent drag release
        if (reparentDragging) {
            if (reparentTarget && reparentNode) {
                // Perform reparent on release
                const targetId = reparentTarget.userData.id;
                const nodeId = reparentNode.userData.id;
                
                if (store.moveNode(nodeId, targetId)) {
                    showToast(`Moved to "${reparentTarget.userData.label}"`, 'success');
                    cleanupReparentDrag(false); // Don't restore connection line since we're rebuilding
                    buildScene();
                } else {
                    // Move failed, restore positions
                    buildScene();
                    cleanupReparentDrag(true);
                }
            } else {
                // No target, cancel drag and restore positions
                buildScene();
                cleanupReparentDrag(true);
            }
            return;
        }
        
        if (draggedNode && moveMode) {
            // Save final positions to store
            const nodeData = store.findNode(draggedNode.userData.id);
            if (nodeData) {
                const pos = draggedNode.userData.spring.target;
                nodeData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
            }
            
            // Save child positions too
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh) {
                    const childData = store.findNode(childId);
                    if (childData) {
                        const pos = childMesh.userData.spring.target;
                        childData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
                    }
                }
            });
            
            store.save();
            childOffsets.clear();
            draggedNode = null;
            controls.enabled = true;
            renderer.domElement.style.cursor = 'grab';
        }
        
        // Only deselect on single click (not drag) on empty space
        if (clickedOnEmpty) {
            const timeDiff = Date.now() - pointerDownTime;
            const dx = event.clientX - pointerDownPos.x;
            const dy = event.clientY - pointerDownPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Single click = short time and minimal movement
            if (timeDiff < 300 && distance < 10) {
                deselectNode();
            }
            clickedOnEmpty = false;
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // KEYBOARD SHORTCUTS
    // ═══════════════════════════════════════════════════════════════════
    document.addEventListener('keydown', (e) => {
        // Cmd/Ctrl + K for spotlight
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            toggleSpotlight();
            return;
        }
        
        // Ignore if in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch (e.key) {
            case 'ArrowLeft':
            case 'ArrowRight':
                e.preventDefault();
                if (selectedNode && selectedNode.userData.id !== store.data.id) {
                    const parentData = selectedNode.userData.parent;
                    if (parentData) {
                        const parent = store.findNode(parentData.id);
                        if (parent && parent.children && parent.children.length > 1) {
                            // Swapped: Right = -1 (previous), Left = +1 (next)
                            const direction = e.key === 'ArrowRight' ? -1 : 1;
                            
                            // Shift+Arrow = reorder within siblings
                            if (e.shiftKey) {
                                if (store.reorderNode(selectedNode.userData.id, direction)) {
                                    buildScene();
                                    // Re-select after rebuild
                                    setTimeout(() => {
                                        const mesh = nodes.get(selectedNode.userData.id);
                                        if (mesh) selectNode(mesh);
                                    }, 50);
                                }
                            } else {
                                // Arrow only = navigate between siblings
                                const currentIndex = parent.children.findIndex(c => c.id === selectedNode.userData.id);
                                let newIndex;
                                // Swapped: Right goes to previous, Left goes to next
                                if (e.key === 'ArrowRight') {
                                    newIndex = currentIndex > 0 ? currentIndex - 1 : parent.children.length - 1;
                                } else {
                                    newIndex = currentIndex < parent.children.length - 1 ? currentIndex + 1 : 0;
                                }
                                const siblingId = parent.children[newIndex].id;
                                const siblingMesh = nodes.get(siblingId);
                                if (siblingMesh && siblingMesh.visible) {
                                    selectNode(siblingMesh);
                                }
                            }
                        }
                    }
                }
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                if (selectedNode) {
                    const parentData = selectedNode.userData.parent;
                    if (parentData) {
                        const parentMesh = nodes.get(parentData.id);
                        if (parentMesh) {
                            selectNode(parentMesh);
                        }
                    }
                }
                break;
                
            case 'ArrowDown':
                e.preventDefault();
                if (selectedNode) {
                    const nodeData = store.findNode(selectedNode.userData.id);
                    if (nodeData && nodeData.children && nodeData.children.length > 0) {
                        // If node is collapsed, expand it first
                        if (!selectedNode.userData.isExpanded) {
                            expandNode(selectedNode, true);
                            // Wait for expansion animation, then select first child
                            setTimeout(() => {
                                const firstChildId = nodeData.children[0].id;
                                const childMesh = nodes.get(firstChildId);
                                if (childMesh) {
                                    selectNode(childMesh);
                                }
                            }, 150);
                        } else {
                            const firstChildId = nodeData.children[0].id;
                            const childMesh = nodes.get(firstChildId);
                            if (childMesh && childMesh.visible) {
                                selectNode(childMesh);
                            }
                        }
                    }
                }
                break;
                
            case 'Tab':
                e.preventDefault();
                if (selectedNode) {
                    openModal('add', selectedNode.userData.id);
                } else if (currentContextId) {
                    openModal('add', currentContextId);
                }
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedNode && selectedNode.userData.parent) {
                    openModal('add', selectedNode.userData.parent.id);
                }
                break;
                
            case ' ':
                e.preventDefault();
                if (selectedNode) {
                    toggleExpand(selectedNode);
                }
                break;
                
            case 'Escape':
                if (voiceAI.isRecording || voiceAI.isProcessing) {
                    voiceAI.stop();
                }
                closeSpotlight();
                closeModal();
                deselectNode();
                break;
                
            case 'Backspace':
            case 'Delete':
                if (selectedNode && selectedNode.userData.id !== store.data.id) {
                    const nodeLabel = selectedNode.userData.label;
                    const hasChildren = selectedNode.userData.children?.length > 0;
                    showConfirm({
                        title: 'Delete Node',
                        message: hasChildren 
                            ? `Delete "${nodeLabel}" and all its children?`
                            : `Delete "${nodeLabel}"?`,
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        danger: true
                    }).then(confirmed => {
                        if (confirmed) {
                            store.deleteNode(selectedNode.userData.id);
                            buildScene();
                            showToast('Node deleted', 'success');
                        }
                    });
                }
                break;
                
            case 'e':
                if (selectedNode) {
                    openModal('edit', selectedNode.userData.id);
                }
                break;
                
            case 'd':
                if (selectedNode && selectedNode.userData.children?.length) {
                    diveIntoNode(selectedNode.userData.id);
                }
                break;
                
            case 'u':
                surfaceUp();
                break;
                
            case '?':
                showKeyboardHints();
                break;
                
            case 'z':
                if (e.metaKey || e.ctrlKey) {
                    e.preventDefault();
                    const result = store.undo();
                    if (result.success) {
                        buildScene();
                        showToast(`Undid: ${result.actionName}`, 'info');
                    }
                }
                break;
        }
    });

    function showKeyboardHints() {
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 3000);
    }

    // ═══════════════════════════════════════════════════════════════════
    // SPOTLIGHT SEARCH
    // ═══════════════════════════════════════════════════════════════════
    const spotlightOverlay = document.getElementById('spotlight-overlay');
    const spotlightInput = document.getElementById('spotlight-input');
    const spotlightNodesList = document.getElementById('spotlight-nodes-list');
    let spotlightOpen = false;

    function toggleSpotlight() {
        spotlightOpen = !spotlightOpen;
        if (spotlightOpen) {
            spotlightOverlay.classList.add('active');
            spotlightInput.value = '';
            spotlightInput.focus();
            updateSpotlightResults('');
        } else {
            spotlightOverlay.classList.remove('active');
        }
    }

    function closeSpotlight() {
        spotlightOpen = false;
        spotlightOverlay.classList.remove('active');
    }

    spotlightOverlay.addEventListener('click', (e) => {
        if (e.target === spotlightOverlay) closeSpotlight();
    });

    spotlightInput.addEventListener('input', (e) => {
        updateSpotlightResults(e.target.value);
    });

    spotlightInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeSpotlight();
        } else if (e.key === 'Enter') {
            const selected = document.querySelector('.spotlight-item.selected');
            if (selected) {
                selected.click();
            } else if (spotlightInput.value.trim()) {
                // Create new node with input text
                const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
                store.addNode(parentId, { label: spotlightInput.value.trim() });
                buildScene();
                closeSpotlight();
                showToast(`Created "${spotlightInput.value.trim()}"`, 'success');
            }
        }
    });

    function updateSpotlightResults(query) {
        const results = query ? store.searchNodes(query) : store.getAllNodes().slice(0, 8);
        
        spotlightNodesList.innerHTML = results.map(node => `
            <div class="spotlight-item" data-id="${node.id}">
                <div class="spotlight-item-icon" style="background: ${node.color};"></div>
                <div class="spotlight-item-content">
                    <div class="spotlight-item-title">${escapeHTML(node.label)}</div>
                    <div class="spotlight-item-subtitle">${node.children?.length || 0} children</div>
                </div>
            </div>
        `).join('');
        
        // Add click handlers
        spotlightNodesList.querySelectorAll('.spotlight-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                const mesh = nodes.get(id);
                if (mesh) {
                    selectNode(mesh);
                    
                    // Pan camera to node
                    const targetPos = mesh.position.clone();
                    controls.target.lerp(targetPos, 0.5);
                }
                closeSpotlight();
            });
        });
    }

    // Quick actions in spotlight
    document.querySelectorAll('.spotlight-item[data-action]').forEach(item => {
        item.addEventListener('click', () => {
            const action = item.dataset.action;
            switch (action) {
                case 'new-node':
                    openModal('add', selectedNode?.userData.id || currentContextId);
                    break;
                case 'brainstorm':
                    if (selectedNode) {
                        brainstormNode(selectedNode.userData.id);
                    }
                    break;
            }
            closeSpotlight();
        });
    });

    // ═══════════════════════════════════════════════════════════════════
    // MODAL SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const modalOverlay = document.getElementById('modal-overlay');
    const modalTitle = document.getElementById('modal-title');
    const inputName = document.getElementById('input-name');
    const inputDesc = document.getElementById('input-desc');
    const colorGrid = document.getElementById('color-grid');
    let modalMode = 'add';
    let modalParentId = null;
    let modalEditId = null;
    let selectedColor = getThemeColors()[0];

    // Create color swatches
    colorGrid.innerHTML = getThemeColors().map(color => 
        `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
    ).join('');

    colorGrid.addEventListener('click', (e) => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            selectedColor = swatch.dataset.color;
            colorGrid.querySelectorAll('.color-swatch').forEach(s => 
                s.classList.toggle('selected', s.dataset.color === selectedColor)
            );
        }
    });

    function openModal(mode, targetId) {
        modalMode = mode;
        modalOverlay.classList.add('active');
        
        if (mode === 'add') {
            modalParentId = targetId;
            modalEditId = null;
            modalTitle.textContent = 'Add New Node';
            document.getElementById('modal-submit').textContent = 'Create';
            inputName.value = '';
            inputDesc.value = '';
            
            const parent = store.findNode(targetId);
            selectedColor = parent?.color || getThemeColors()[0];
        } else {
            modalEditId = targetId;
            modalParentId = null;
            modalTitle.textContent = 'Edit Node';
            document.getElementById('modal-submit').textContent = 'Save';
            
            const node = store.findNode(targetId);
            if (node) {
                inputName.value = node.label;
                inputDesc.value = node.description || '';
                selectedColor = node.color;
            }
        }
        
        colorGrid.querySelectorAll('.color-swatch').forEach(s => 
            s.classList.toggle('selected', s.dataset.color === selectedColor)
        );
        
        inputName.focus();
    }

    function closeModal() {
        modalOverlay.classList.remove('active');
        modalParentId = null;
        modalEditId = null;
    }

    function submitModal() {
        const name = inputName.value.trim();
        if (!name) {
            showToast('Please enter a name', 'error');
            return;
        }
        
        if (modalMode === 'add' && modalParentId) {
            const newNode = store.addNode(modalParentId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            if (newNode) {
                buildScene();
                
                // Celebration!
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, selectedColor, 6);
                    selectNode(mesh);
                }
                
                audio.success();
                haptic.success();
                showToast(`Created "${name}"`, 'success');
            }
        } else if (modalMode === 'edit' && modalEditId) {
            store.updateNode(modalEditId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            buildScene();
            showToast(`Updated "${name}"`, 'success');
        }
        
        closeModal();
    }

    document.getElementById('modal-cancel').addEventListener('click', closeModal);
    document.getElementById('modal-submit').addEventListener('click', submitModal);
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) closeModal();
    });
    
    // Enter key to submit modal
    inputName.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitModal();
        }
    });
    inputDesc.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            submitModal();
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // AI BRAINSTORM
    // ═══════════════════════════════════════════════════════════════════
    async function brainstormNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                showToast('API key required for AI features', 'error');
                return;
            }
        }
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 300,
                    messages: [{
                        role: 'user',
                        content: `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${node.label}"${description ? `\n- Description: "${description}"` : ''}
- Path to root: ${context}
- Existing children: ${siblings || 'none yet'}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of strings with the node labels. Make them concise but meaningful.
Example: ["Daily Habits", "Weekly Reviews", "Long-term Vision"]`
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            const ideas = JSON.parse(text);
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    store.addNode(nodeId, { label: idea, color: node.color });
                });
                
                // Mark node as expanded BEFORE building scene so children are visible
                store.expandedNodes.add(nodeId);
                
                buildScene();
                
                // Get the mesh and ensure it's marked as expanded
                const mesh = nodes.get(nodeId);
                if (mesh) {
                    mesh.userData.isExpanded = true;
                    
                    // Make sure all children are visible
                    mesh.userData.children?.forEach(childData => {
                        const childMesh = nodes.get(childData.id);
                        if (childMesh) {
                            childMesh.visible = true;
                            if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = true;
                            if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = true;
                            if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = true;
                            if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = true;
                            if (childMesh.userData.glowRing) childMesh.userData.glowRing.visible = true;
                            if (childMesh.userData.targetRing) childMesh.userData.targetRing.visible = true;
                            childMesh.userData.collapsed = false;
                        }
                    });

                    // Celebration
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, node.color, 8);
                }
                
                audio.success();
                haptic.success();
                showToast(`Added ${ideas.length} new ideas!`, 'success');
            }
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast('Failed to generate ideas. Check your API key.', 'error');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // INFO PANEL
    // ═══════════════════════════════════════════════════════════════════
    const infoPanel = document.getElementById('info-panel');
    const infoTitle = document.getElementById('info-title');
    const infoColor = document.getElementById('info-color');
    const infoColorPicker = document.getElementById('info-color-picker');
    const infoChildren = document.getElementById('info-children');
    
    // Populate color picker
    infoColorPicker.innerHTML = getThemeColors().slice(0, 12).map(color => 
        `<span style="background:${color}" data-color="${color}"></span>`
    ).join('');
    
    // Toggle color picker
    infoColor.addEventListener('click', (e) => {
        if (e.target === infoColor || e.target === infoColorPicker) {
            infoColorPicker.classList.toggle('active');
        }
    });
    
    // Select color from picker
    infoColorPicker.addEventListener('click', (e) => {
        const colorEl = e.target.closest('[data-color]');
        if (colorEl && selectedNode) {
            const newColor = colorEl.dataset.color;
            store.updateNode(selectedNode.userData.id, { color: newColor });
            selectedNode.userData.color = newColor;
            selectedNode.material.color.set(newColor);
            selectedNode.material.emissive.set(newColor);
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            if (selectedNode.userData.connectionLine) {
                selectedNode.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update label with new color
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(selectedNode.userData.label, newColor);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            infoColor.style.background = newColor;
            infoColorPicker.classList.remove('active');
            showToast('Color updated', 'success');
        }
    });
    
    // Inline title editing
    infoTitle.addEventListener('change', () => {
        if (selectedNode && infoTitle.value.trim()) {
            store.updateNode(selectedNode.userData.id, { label: infoTitle.value.trim() });
            selectedNode.userData.label = infoTitle.value.trim();
            // Update label sprite
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(infoTitle.value.trim(), selectedNode.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            showToast('Name updated', 'success');
        }
    });
    
    // Enter key to save and blur info title
    infoTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            infoTitle.blur();
        }
    });
    
    // Importance slider
    const infoImportance = document.getElementById('info-importance');
    infoImportance.addEventListener('input', () => {
        if (selectedNode) {
            const scale = parseFloat(infoImportance.value);
            selectedNode.userData.importance = scale;
            store.updateNode(selectedNode.userData.id, { importance: scale });
            
            // Update node size
            const baseSize = selectedNode.userData.baseSize || 1;
            const newSize = baseSize * scale;
            selectedNode.scale.set(newSize, newSize, newSize);
            selectedNode.userData.baseScale = newSize; // Update base scale for selection animation
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.scale.set(newSize * 1.03, newSize * 1.03, newSize * 1.03);
            }
            
            // Update spring scale target
            selectedNode.userData.spring.scaleTarget = newSize;
        }
    });
    
    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.info-color')) {
            infoColorPicker.classList.remove('active');
        }
    });

    bus.on('node:selected', ({ data: meshData }) => {
        // IMPORTANT: Fetch fresh data from store (mesh.userData may be stale for attachments)
        const data = store.findNode(meshData.id) || meshData;
        
        // Track node view in user profile
        userProfile.trackNodeViewed(data, store);
        
        // Track in meta-learner (exploration patterns)
        const path = store.getPath(data.id);
        const depth = path.length - 1;
        metaLearner.trackNodeSelected(data, depth, store);
        
        // CGT: Record select action
        cognitiveGT.recordAction('select', data.id, { nodeDepth: depth });
        
        infoTitle.value = data.label || 'Untitled';
        infoColor.style.background = data.color || '#888888';
        infoChildren.textContent = `${data.children?.length || 0} children`;
        infoColorPicker.classList.remove('active');
        
        // Set importance slider
        infoImportance.value = data.importance || 1;
        
        // Show source badge (AI, Link, etc.)
        const sourceEl = document.getElementById('info-source');
        const source = data.source || data.link?.source;
        if (source === 'ai' || source === 'brainstorm' || source === 'smart-expand') {
            sourceEl.textContent = 'AI';
            sourceEl.className = 'ai';
        } else if (source === 'link' || data.link) {
            sourceEl.textContent = '🔗 Link';
            sourceEl.className = 'link';
        } else {
            sourceEl.textContent = '';
            sourceEl.className = '';
        }
        
        // Populate expanded section
        // Description
        document.getElementById('info-description').value = data.description || '';
        
        // Show/hide context question button based on description (skip root node)
        document.getElementById('context-question-popover').classList.remove('active');
        
        if (data.level > 0 && (!data.description || data.description.trim() === '')) {
            document.getElementById('context-question-btn').classList.remove('hidden');
        } else {
            document.getElementById('context-question-btn').classList.add('hidden');
        }
        
        // Path breadcrumbs
        const pathSection = document.getElementById('info-path-section');
        const pathContainer = document.getElementById('info-path');
        // path already declared above for meta-learner
        
        if (path.length > 1) {
            pathSection.style.display = 'block';
            pathContainer.innerHTML = path.map((node, index) => {
                const isLast = index === path.length - 1;
                const separator = !isLast ? '<span class="info-path-separator">›</span>' : '';
                return `
                    <div class="info-path-item ${isLast ? 'info-path-current' : ''}" data-node-id="${node.id}">
                        <span class="info-path-color" style="background: ${node.color || '#888888'}"></span>
                        <span class="info-path-name">${node.label || 'Untitled'}</span>
                    </div>
                    ${separator}
                `;
            }).join('');
            
            // Add click handlers
            pathContainer.querySelectorAll('.info-path-item:not(.info-path-current)').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const nodeMesh = nodes.get(nodeId);
                    if (nodeMesh) {
                        selectNode(nodeMesh);
                        focusOnNode(nodeMesh);
                    }
                });
            });
        } else {
            pathSection.style.display = 'none';
        }
        
        // Show/hide link info (collapsed view)
        const linkSection = document.getElementById('info-link');
        const addLinkSection = document.getElementById('info-add-link-section');
        
        if (data.link?.url) {
            linkSection.style.display = 'block';
            document.getElementById('info-link-url').href = data.link.url;
            document.getElementById('info-link-favicon').src = data.link.favicon || '';
            document.getElementById('info-link-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
        } else {
            linkSection.style.display = 'none';
        }
        
        // Show add link section for all non-root nodes
        addLinkSection.style.display = data.id !== 'mynd' ? 'block' : 'none';
        document.getElementById('info-add-link-input').value = '';
        
        // Link info (expanded view)
        const linkExpandedSection = document.getElementById('info-link-section');
        if (data.link?.url) {
            linkExpandedSection.style.display = 'block';
            
            // Thumbnail
            const thumbnail = document.getElementById('info-link-thumbnail');
            if (data.link.image) {
                thumbnail.src = data.link.image;
                thumbnail.style.display = 'block';
            } else {
                thumbnail.style.display = 'none';
            }
            
            // URL and domain
            document.getElementById('info-link-full-url').href = data.link.url;
            document.getElementById('info-link-favicon-small').src = data.link.favicon || '';
            document.getElementById('info-link-full-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
            
            // Meta info
            const meta = [];
            if (data.link.type) meta.push(data.link.type);
            if (data.link.author) meta.push(`by ${data.link.author}`);
            if (data.link.addedAt) {
                const date = new Date(data.link.addedAt);
                meta.push(`added ${date.toLocaleDateString()}`);
            }
            document.getElementById('info-link-meta').textContent = meta.join(' • ');
        } else {
            linkExpandedSection.style.display = 'none';
        }
        
        // Transcript section
        const transcriptSection = document.getElementById('info-transcript-section');
        if (data.link?.transcript) {
            transcriptSection.style.display = 'block';
            
            const transcript = data.link.transcript;
            const charCount = transcript.length;
            document.getElementById('info-transcript-chars').textContent = `${Math.round(charCount / 100) / 10}k chars`;
            
            // Show preview (first 300 chars)
            document.getElementById('info-transcript-preview').textContent = 
                transcript.substring(0, 300) + (transcript.length > 300 ? '...' : '');
            
            // Full transcript
            document.getElementById('info-transcript-text').textContent = transcript;
            
            // Reset toggle state
            document.getElementById('info-transcript-full').style.display = 'none';
            document.getElementById('info-transcript-toggle').textContent = 'Show full transcript';
        } else {
            transcriptSection.style.display = 'none';
        }
        
        // Node metadata
        // Created date
        const createdSection = document.getElementById('info-created-section');
        if (data.createdAt) {
            createdSection.style.display = 'flex';
            const date = new Date(data.createdAt);
            document.getElementById('info-created').textContent = date.toLocaleDateString();
        } else {
            createdSection.style.display = 'none';
        }
        
        // Added by
        const addedByValue = document.getElementById('info-added-by');
        if (data.source === 'brainstorm') {
            addedByValue.textContent = 'AI Brainstorm';
        } else if (data.source === 'smart-expand') {
            addedByValue.textContent = 'Smart Expand';
        } else if (data.source === 'link' || data.link) {
            addedByValue.textContent = '🔗 Link Import';
        } else if (data.source === 'onboarding') {
            addedByValue.textContent = '📋 Onboarding';
        } else {
            addedByValue.textContent = 'You';
        }
        
        // Show/hide dive button
        document.getElementById('action-dive').style.display = 
            data.children?.length ? 'flex' : 'none';
        
        // Show/hide delete button (can't delete root in current context)
        document.getElementById('action-delete').style.display = 
            data.id !== currentContextId ? 'flex' : 'none';
        
        // Show/hide organize button
        // Show if: (1) 2+ link children from same domain, OR (2) 6+ children total
        const organizeBtn = document.getElementById('action-organize');
        if (data.children && data.children.length >= 2) {
            // Count links by domain
            const domainCounts = {};
            let linkCount = 0;
            data.children.forEach(child => {
                if (child.link?.domain || child.link?.url) {
                    linkCount++;
                    let domain = child.link.domain;
                    if (!domain && child.link.url) {
                        try {
                            domain = new URL(child.link.url).hostname;
                        } catch (e) {}
                    }
                    if (domain) {
                        domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                        domainCounts[domain] = (domainCounts[domain] || 0) + 1;
                    }
                }
            });
            
            // Show if any domain has 2+ items OR if node has 6+ children
            const hasMultipleSameDomain = Object.values(domainCounts).some(count => count >= 2);
            const hasManyChildren = data.children.length >= 6;
            
            organizeBtn.style.display = (hasMultipleSameDomain || hasManyChildren) ? 'flex' : 'none';
        } else {
            organizeBtn.style.display = 'none';
        }
        
        // Attachments section
        AttachmentManager.renderAttachments(data);
        
        // Hide quick capture, show info panel
        document.getElementById('quick-capture').style.display = 'none';
        infoPanel.classList.add('active');
        
        // Don't auto-expand - user can expand manually if needed
        // The context question button is visible in the collapsed view
        
        // Move toolbar up on mobile when info panel is visible
        if (window.innerWidth <= 768) {
            document.getElementById('side-panel').classList.add('info-visible');
            document.getElementById('toolbar-toggle').classList.add('info-visible');
        }
    });

    bus.on('node:deselected', () => {
        infoPanel.classList.remove('active');
        infoPanel.classList.remove('expanded');
        infoColorPicker.classList.remove('active');
        // Show quick capture again
        document.getElementById('quick-capture').style.display = 'block';
        
        // Move toolbar back down on mobile
        document.getElementById('side-panel').classList.remove('info-visible');
        document.getElementById('toolbar-toggle').classList.remove('info-visible');
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // INCREMENTAL LEARNING - Learn from every node addition
    // ═══════════════════════════════════════════════════════════════════
    bus.on('node:added', ({ parent, node }) => {
        if (!neuralNet.isReady) return;
        
        // Calculate depth first (needed for multiple systems)
        const path = store.getPath(node.id);
        const depth = path.length - 1; // Depth is path length minus 1 (root is depth 0)
        
        // Learn the parent->child pattern
        neuralNet.incrementalLearnPattern(parent.label, node.label, node.source || 'user', depth);
        
        // Queue embedding for new node
        const nodeText = node.description 
            ? `${node.label}. ${node.description}`
            : node.label;
        neuralNet.queueEmbedding(nodeText);
        
        // Track in user profile
        userProfile.trackNodeCreated(node, parent, depth, store);
        
        // Track in meta-learner (how user thinks)
        metaLearner.trackNodeCreated(node, parent, depth, store);
        
        // Store semantic memory for significant events
        const source = node.source || 'user';
        if (source === 'user') {
            semanticMemory.addMemory(
                'node_created_manual',
                `User created "${node.label}" under "${parent.label}"`,
                { parentLabel: parent.label, childLabel: node.label }
            );
        } else if (source === 'smart-expand') {
            // Memory already created when suggestion was accepted
        } else if (source === 'brainstorm') {
            semanticMemory.addMemory(
                'brainstorm_completed',
                `AI brainstormed "${node.label}" under "${parent.label}"`,
                { parentLabel: parent.label, childLabel: node.label, source: 'brainstorm' }
            );
        }
        
        // CGT: Record create action
        cognitiveGT.recordAction('create', node.id, { 
            parentId: parent.id, 
            nodeDepth: depth,
            source: node.source || 'user'
        });
        
        // StyleTransfer: Learn from creation
        if (styleTransfer.initialized) {
            styleTransfer.learnFromCreation(node, parent, store);
        }
        
        // Update UI stats
        NeuralUI.updateStatus();
    });
    
    // CGT: Track node deletion
    bus.on('node:deleted', ({ parentId, node }) => {
        cognitiveGT.recordAction('delete', node.id, { 
            parentId,
            nodeDepth: node.level || 0
        });
    });
    
    // CGT: Track node moved (reparented)
    bus.on('node:moved', ({ nodeId, oldParentId, newParentId }) => {
        cognitiveGT.recordAction('reparent', nodeId, { 
            oldParentId,
            newParentId
        });
        
        // StyleTransfer: Learn from reorganization
        if (styleTransfer.initialized) {
            styleTransfer.learnFromReorg();
        }
    });
    
    // CGT: Track node updated (label/description changes)
    bus.on('node:updated', ({ node }) => {
        cognitiveGT.recordAction('edit_label', node.id, { 
            nodeDepth: node.level || 0
        });
        
        // StyleTransfer: Learn from edit
        if (styleTransfer.initialized) {
            styleTransfer.learnFromEdit(node, 'label');
        }
    });
    
    // Info panel expand toggle
    document.getElementById('info-expand-toggle').addEventListener('click', () => {
        infoPanel.classList.toggle('expanded');
    });
    
    // Description save on blur
    document.getElementById('info-description').addEventListener('blur', (e) => {
        if (selectedNode) {
            const nodeData = store.findNode(selectedNode.userData.id);
            if (nodeData) {
                const newDescription = e.target.value.trim();
                const wasEmpty = !nodeData.description;
                nodeData.description = newDescription;
                selectedNode.userData.description = newDescription;
                store.save();
                
                // Track edit in meta-learner
                if (newDescription && wasEmpty) {
                    metaLearner.trackNodeEdited(nodeData, 'description');
                }
                
                // Remove context badge if description was added
                if (newDescription && selectedNode.userData.contextBadge) {
                    removeContextIndicator(selectedNode);
                    document.getElementById('context-question-btn').classList.add('hidden');
                }
            }
        }
    });
    
    // Transcript toggle
    document.getElementById('info-transcript-toggle').addEventListener('click', () => {
        const fullSection = document.getElementById('info-transcript-full');
        const toggleBtn = document.getElementById('info-transcript-toggle');
        
        if (fullSection.style.display === 'none') {
            fullSection.style.display = 'block';
            toggleBtn.textContent = 'Hide full transcript';
        } else {
            fullSection.style.display = 'none';
            toggleBtn.textContent = 'Show full transcript';
        }
    });

    document.getElementById('info-close').addEventListener('click', deselectNode);

    document.getElementById('action-dive').addEventListener('click', () => {
        if (selectedNode) diveIntoNode(selectedNode.userData.id);
    });

    document.getElementById('action-add').addEventListener('click', () => {
        if (selectedNode) openModal('add', selectedNode.userData.id);
    });

    document.getElementById('action-brainstorm').addEventListener('click', () => {
        if (selectedNode) brainstormNodeEnhanced(selectedNode.userData.id);
    });

    document.getElementById('action-delete').addEventListener('click', async () => {
        if (selectedNode && selectedNode.userData.id !== store.data.id) {
            const nodeLabel = selectedNode.userData.label;
            const hasChildren = selectedNode.userData.children?.length > 0;
            
            const confirmed = await showConfirm({
                title: 'Delete Node',
                message: hasChildren 
                    ? `Delete "${nodeLabel}" and all its children?`
                    : `Delete "${nodeLabel}"?`,
                confirmText: 'Delete',
                cancelText: 'Cancel',
                danger: true
            });
            
            if (confirmed) {
                store.deleteNode(selectedNode.userData.id);
                deselectNode();
                buildScene();
                showToast('Node deleted', 'success');
            }
        }
    });
    
    // Add link to node - creates a child node with the link
    document.getElementById('info-add-link-btn').addEventListener('click', () => {
        const input = document.getElementById('info-add-link-input');
        const url = input.value.trim();
        
        if (!url) {
            showToast('Please enter a URL', 'info');
            input.focus();
            return;
        }
        
        // Validate and normalize URL
        let normalizedUrl = url;
        if (!url.match(/^https?:\/\//i)) {
            normalizedUrl = 'https://' + url;
        }
        
        try {
            new URL(normalizedUrl);
        } catch {
            showToast('Invalid URL format', 'error');
            return;
        }
        
        if (!selectedNode) return;
        
        const parentId = selectedNode.userData.id;
        
        // Clear input
        input.value = '';
        
        // Use LinkManager to add as child node
        LinkManager.addLinkAsChild(normalizedUrl, parentId);
    });
    
    // Handle Enter key in add-link input
    document.getElementById('info-add-link-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('info-add-link-btn').click();
        }
    });
    
    // Organize button - groups children by domain/platform OR uses AI for regular nodes
    document.getElementById('action-organize').addEventListener('click', async () => {
        if (!selectedNode) return;
        
        const nodeId = selectedNode.userData.id;
        const nodeData = store.findNode(nodeId);
        if (!nodeData || !nodeData.children || nodeData.children.length < 2) return;
        
        // First, try domain-based grouping for links
        const domainGroups = {};
        let regularNodes = [];
        
        nodeData.children.forEach(child => {
            if (child.link?.domain || child.link?.url) {
                let domain = child.link.domain;
                if (!domain && child.link.url) {
                    try {
                        domain = new URL(child.link.url).hostname;
                    } catch (e) {}
                }
                if (domain) {
                    domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            } else {
                regularNodes.push(child);
            }
        });
        
        let totalMoved = 0;
        let foldersCreated = 0;
        
        // Handle link grouping by domain
        for (const [domain, items] of Object.entries(domainGroups)) {
            if (items.length >= 2) {
                const folderName = LinkManager.getDomainFolderName(domain);
                
                const existingFolder = nodeData.children.find(c => 
                    c.label.toLowerCase() === folderName.toLowerCase() && !c.link
                );
                
                let folderId;
                if (existingFolder) {
                    folderId = existingFolder.id;
                } else {
                    const folder = store.addNode(nodeId, {
                        label: folderName,
                        description: `Collection of ${folderName} content`,
                        color: nodeData.color,
                        source: 'smart-organize'
                    });
                    folderId = folder.id;
                    foldersCreated++;
                }
                
                for (const item of items) {
                    if (store.moveNode(item.id, folderId)) {
                        totalMoved++;
                    }
                }
            }
        }
        
        // If we have many regular nodes, use AI to organize (Edge Function or local API)
        if (regularNodes.length >= 5) {
            showToast('AI analyzing nodes...', 'info');
            
            try {
                const childrenList = regularNodes.map(c => `- ${c.label}${c.description ? ': ' + c.description.substring(0, 50) : ''}`).join('\n');
                
                const result = await callClaudeAPI({
                    type: 'organize',
                    nodeLabel: nodeData.label,
                    childrenList: childrenList
                });
                
                if (result.success && result.suggestions?.categories) {
                    // Collect all moves first, then execute
                    const movesToMake = [];
                    
                    for (const category of result.suggestions.categories) {
                        if (category.items && category.items.length >= 2) {
                            // Create category folder
                            const folder = store.addNode(nodeId, {
                                label: category.name,
                                description: category.description || '',
                                color: nodeData.color,
                                source: 'ai-organize'
                            });
                            foldersCreated++;
                            
                            // Find matching items to move
                            for (const itemLabel of category.items) {
                                // Extract just the label part (before any colon or description)
                                const cleanLabel = itemLabel.split(':')[0].trim().toLowerCase();
                                
                                const freshParent = store.findNode(nodeId);
                                const matchingChild = freshParent?.children?.find(c => 
                                    c.label.toLowerCase() === cleanLabel && 
                                    c.source !== 'ai-organize' && // Don't match folders we created
                                    c.source !== 'smart-organize'
                                );
                                if (matchingChild) {
                                    movesToMake.push({ childId: matchingChild.id, folderId: folder.id });
                                }
                            }
                        }
                    }
                    
                    // Execute all moves
                    for (const move of movesToMake) {
                        if (store.moveNode(move.childId, move.folderId)) {
                            totalMoved++;
                        }
                    }
                }
            } catch (error) {
                console.error('AI organize error:', error);
            }
        }
        
        if (totalMoved > 0) {
            // Collapse the parent first to reset layout
            const parentMesh = nodes.get(nodeId);
            if (parentMesh && parentMesh.userData.isExpanded) {
                collapseNode(parentMesh);
            }
            
            buildScene();
            
            // Re-expand after a brief delay to get fresh layout
            setTimeout(() => {
                const mesh = nodes.get(nodeId);
                if (mesh) {
                    expandNode(mesh);
                    selectNode(mesh);
                }
            }, 150);
            
            showToast(`Created ${foldersCreated} folders, organized ${totalMoved} items`, 'success');
        } else {
            showToast('No clear groupings found', 'info');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // QUICK CAPTURE
    // ═══════════════════════════════════════════════════════════════════
    const quickInput = document.getElementById('quick-input');

    quickInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && quickInput.value.trim()) {
            const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
            const newNode = store.addNode(parentId, { label: quickInput.value.trim() });
            
            if (newNode) {
                buildScene();
                
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, newNode.color, 6);
                    selectNode(mesh);
                }
                
                audio.pop();
                haptic.light();
                showToast(`Added "${newNode.label}"`, 'success');
            }
            
            quickInput.value = '';
        }
    });

    document.getElementById('quick-add').addEventListener('click', () => {
        if (quickInput.value.trim()) {
            quickInput.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // ROTATING PROMPTS
    // ═══════════════════════════════════════════════════════════════════
    const rotatingPrompts = [
        "What's on your mind?",
        "Capture that thought...",
        "Any ideas worth remembering?",
        "A goal taking shape?",
        "Something you're learning?",
        "A connection you just made?",
        "A problem you're working through?",
        "Something you don't want to forget?",
        "An insight worth keeping?",
        "A next step becoming clear?",
        "Something exciting emerging?",
        "A thought before it slips away?"
    ];
    
    let currentPromptIndex = 0;
    let promptRotationInterval = null;
    
    function rotatePrompt() {
        // Only rotate if input is empty and not focused
        if (quickInput.value === '' && document.activeElement !== quickInput) {
            // Fade out
            quickInput.style.transition = 'opacity 0.3s ease';
            quickInput.style.opacity = '0';
            
            setTimeout(() => {
                currentPromptIndex = (currentPromptIndex + 1) % rotatingPrompts.length;
                quickInput.placeholder = rotatingPrompts[currentPromptIndex];
                // Fade in
                quickInput.style.opacity = '1';
            }, 300);
        }
    }
    
    // Start rotating prompts every 12 seconds
    function startPromptRotation() {
        if (!promptRotationInterval) {
            promptRotationInterval = setInterval(rotatePrompt, 12000);
        }
    }
    
    function stopPromptRotation() {
        if (promptRotationInterval) {
            clearInterval(promptRotationInterval);
            promptRotationInterval = null;
        }
    }
    
    // Stop rotation when input is focused, resume when blurred
    quickInput.addEventListener('focus', () => {
        stopPromptRotation();
        quickInput.style.opacity = '1';
    });
    
    quickInput.addEventListener('blur', () => {
        if (quickInput.value === '') {
            startPromptRotation();
        }
    });
    
    // Start rotation on load
    startPromptRotation();

    // ═══════════════════════════════════════════════════════════════════
    // CONTEXT QUESTION SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const contextQuestionBtn = document.getElementById('context-question-btn');
    const contextQuestionPopover = document.getElementById('context-question-popover');
    const contextQuestionText = document.getElementById('context-question-text');
    const contextQuestionInput = document.getElementById('context-question-input');
    const contextQuestionSubmit = document.getElementById('context-question-submit');
    
    // Question templates based on common node types/keywords
    const questionTemplates = {
        // Goals & aspirations
        goal: ["What's your target timeline for this?", "What would achieving this mean to you?", "What's your first step toward this?"],
        dream: ["Why does this matter to you?", "What inspired this dream?", "How will you know when you've achieved it?"],
        want: ["What's driving this desire?", "How would having this change things?", "What's stopping you from getting this now?"],
        
        // Projects & work
        project: ["What's the current status?", "What's the main challenge right now?", "Who else is involved in this?"],
        work: ["What's your role in this?", "What's the deadline or timeline?", "What outcome are you aiming for?"],
        business: ["What problem does this solve?", "Who is your target audience?", "What's your next milestone?"],
        
        // Learning & skills
        learn: ["Why do you want to learn this?", "How are you planning to learn it?", "What level do you want to reach?"],
        skill: ["How proficient are you currently?", "How will you practice this?", "Why is this skill important to you?"],
        course: ["What do you hope to gain from this?", "How much time can you dedicate weekly?", "When do you plan to complete it?"],
        
        // People & relationships
        person: ["How do you know this person?", "What do you need to follow up on?", "When should you reach out?"],
        meet: ["What's the purpose of this meeting?", "What do you want to accomplish?", "Who needs to be there?"],
        call: ["What topics need to be discussed?", "When is this scheduled?", "What's the expected outcome?"],
        
        // Health & wellness
        health: ["What specific improvement are you targeting?", "How will you track progress?", "What triggered this focus?"],
        fitness: ["What's your specific goal?", "How often will you work on this?", "What's your current baseline?"],
        habit: ["What triggers this habit?", "How will you stay consistent?", "What's your streak goal?"],
        
        // Ideas & creativity
        idea: ["What problem does this solve?", "What inspired this idea?", "What's the first step to explore it?"],
        create: ["What's your vision for this?", "What resources do you need?", "Who might be interested in this?"],
        
        // Tasks & todos
        todo: ["When does this need to be done?", "How long will it take?", "Is anyone else involved?"],
        task: ["What's the priority level?", "What's blocking this?", "What does 'done' look like?"],
        buy: ["What's your budget for this?", "When do you need it by?", "Have you researched options?"],
        
        // General fallbacks
        default: [
            "What's most important about this to you?",
            "How does this connect to your other goals?",
            "What would success look like here?",
            "What's your next action on this?",
            "Why did you add this to your mind map?"
        ]
    };
    
    function generateContextQuestion(label) {
        const lowerLabel = label.toLowerCase();
        
        // Check for keyword matches
        for (const [keyword, questions] of Object.entries(questionTemplates)) {
            if (keyword !== 'default' && lowerLabel.includes(keyword)) {
                return questions[Math.floor(Math.random() * questions.length)];
            }
        }
        
        // Check for common patterns
        if (lowerLabel.match(/^(finish|complete|do|make|build|start|begin)/)) {
            return questionTemplates.task[Math.floor(Math.random() * questionTemplates.task.length)];
        }
        if (lowerLabel.match(/^(read|watch|listen|study)/)) {
            return questionTemplates.learn[Math.floor(Math.random() * questionTemplates.learn.length)];
        }
        if (lowerLabel.match(/^(talk|email|text|contact|reach)/)) {
            return questionTemplates.person[Math.floor(Math.random() * questionTemplates.person.length)];
        }
        
        // Default questions
        return questionTemplates.default[Math.floor(Math.random() * questionTemplates.default.length)];
    }
    
    function expandAnswer(label, question, answer) {
        // Generate an expanded description based on the question type and answer
        const lowerQuestion = question.toLowerCase();
        const trimmedAnswer = answer.trim();
        
        // Expansion templates based on question patterns
        if (lowerQuestion.includes('timeline') || lowerQuestion.includes('when') || lowerQuestion.includes('deadline')) {
            return `Timeline: ${trimmedAnswer}. This is a time-bound goal that requires focused attention and planning to achieve within the set timeframe.`;
        }
        if (lowerQuestion.includes('why') || lowerQuestion.includes('what') && lowerQuestion.includes('mean')) {
            return `This matters because ${trimmedAnswer.toLowerCase()}. Understanding this motivation helps maintain focus and commitment.`;
        }
        if (lowerQuestion.includes('first step') || lowerQuestion.includes('next action') || lowerQuestion.includes('next step')) {
            return `Next action: ${trimmedAnswer}. Taking this first step will create momentum and clarity for the path forward.`;
        }
        if (lowerQuestion.includes('status') || lowerQuestion.includes('current')) {
            return `Current status: ${trimmedAnswer}. Tracking this progress helps identify what's working and what needs adjustment.`;
        }
        if (lowerQuestion.includes('challenge') || lowerQuestion.includes('blocking') || lowerQuestion.includes('stopping')) {
            return `Main challenge: ${trimmedAnswer}. Identifying this obstacle is the first step to overcoming it.`;
        }
        if (lowerQuestion.includes('who') || lowerQuestion.includes('involved')) {
            return `Key people: ${trimmedAnswer}. Collaboration and accountability with others can accelerate progress.`;
        }
        if (lowerQuestion.includes('goal') || lowerQuestion.includes('target') || lowerQuestion.includes('outcome')) {
            return `Goal: ${trimmedAnswer}. Having a clear target makes it easier to measure progress and stay motivated.`;
        }
        if (lowerQuestion.includes('how') && (lowerQuestion.includes('plan') || lowerQuestion.includes('track') || lowerQuestion.includes('practice'))) {
            return `Approach: ${trimmedAnswer}. Having a systematic method increases the likelihood of success.`;
        }
        if (lowerQuestion.includes('priority') || lowerQuestion.includes('important')) {
            return `Priority: ${trimmedAnswer}. Understanding the importance helps with decision-making and time allocation.`;
        }
        if (lowerQuestion.includes('inspired') || lowerQuestion.includes('triggered')) {
            return `Origin: ${trimmedAnswer}. Remembering what sparked this can reignite motivation when needed.`;
        }
        if (lowerQuestion.includes('budget') || lowerQuestion.includes('cost') || lowerQuestion.includes('resource')) {
            return `Resources needed: ${trimmedAnswer}. Planning for requirements helps avoid obstacles later.`;
        }
        if (lowerQuestion.includes('success') || lowerQuestion.includes('done') || lowerQuestion.includes('achieve')) {
            return `Success looks like: ${trimmedAnswer}. Having a clear vision of the end state guides all actions toward it.`;
        }
        
        // Default expansion
        return `${trimmedAnswer}. This context helps clarify the purpose and direction for "${label}".`;
    }
    
    // Show question popover when button clicked
    contextQuestionBtn.addEventListener('click', () => {
        if (!selectedNode) return;
        
        const label = selectedNode.userData.label || 'this item';
        const question = generateContextQuestion(label);
        
        contextQuestionText.textContent = question;
        contextQuestionInput.value = '';
        contextQuestionPopover.classList.add('active');
        
        // Focus input after animation
        setTimeout(() => contextQuestionInput.focus(), 200);
    });
    
    // Handle answer submission
    function submitContextAnswer() {
        if (!selectedNode || !contextQuestionInput.value.trim()) return;
        
        const label = selectedNode.userData.label;
        const question = contextQuestionText.textContent;
        const answer = contextQuestionInput.value.trim();
        
        // Expand the answer into a full description
        const expandedDescription = expandAnswer(label, question, answer);
        
        // Update the node
        const descriptionEl = document.getElementById('info-description');
        descriptionEl.value = expandedDescription;
        
        // Save to store
        store.updateNode(selectedNode.userData.id, { description: expandedDescription });
        selectedNode.userData.description = expandedDescription;
        
        // Remove context indicator from node
        removeContextIndicator(selectedNode);
        
        // Update neural network with new context
        if (window.NeuralUI && NeuralUI.neuralNet) {
            NeuralUI.neuralNet.addEmbedding(selectedNode.userData.id, `${label} ${expandedDescription}`);
        }
        
        // Hide popover and question button
        contextQuestionPopover.classList.remove('active');
        contextQuestionBtn.classList.add('hidden');
        
        // Feedback
        showToast('Description added', 'success');
        audio.pop();
    }
    
    contextQuestionSubmit.addEventListener('click', submitContextAnswer);
    
    contextQuestionInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitContextAnswer();
        }
        if (e.key === 'Escape') {
            contextQuestionPopover.classList.remove('active');
        }
    });
    
    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
        if (contextQuestionPopover.classList.contains('active') && 
            !e.target.closest('.context-question-popover') && 
            !e.target.closest('.context-question-btn')) {
            contextQuestionPopover.classList.remove('active');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // SIDE PANEL BUTTONS
    // ═══════════════════════════════════════════════════════════════════
    document.getElementById('btn-home').addEventListener('click', resetCamera);
    document.getElementById('btn-expand').addEventListener('click', expandAll);
    document.getElementById('btn-collapse').addEventListener('click', collapseAll);
    
    document.getElementById('btn-add').addEventListener('click', () => {
        const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
        openModal('add', parentId);
    });
    
    // Link button - opens link modal
    document.getElementById('btn-link').addEventListener('click', () => {
        LinkManager.open();
    });
    
    // Move mode toggle
    const moveBtnEl = document.getElementById('btn-move');
    
    moveBtnEl.addEventListener('click', () => {
        moveMode = !moveMode;
        moveBtnEl.classList.toggle('active', moveMode);
        if (moveMode) {
            showToast('Move mode: Drag nodes to reposition', 'info');
            renderer.domElement.style.cursor = 'grab';
        } else {
            showToast('Move mode disabled', 'info');
            renderer.domElement.style.cursor = 'default';
        }
    });
    
    // Auto camera toggle
    const autoCamBtn = document.getElementById('btn-autocam');
    autoCamBtn.addEventListener('click', () => {
        autoCameraEnabled = !autoCameraEnabled;
        autoCamBtn.classList.toggle('active', autoCameraEnabled);
        showToast(autoCameraEnabled ? 'Auto camera enabled' : 'Auto camera disabled', 'info');
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // AI CHAT MANAGER - Conversational AI Interface
    // ═══════════════════════════════════════════════════════════════════
    const chatManager = {
        isOpen: false,
        isProcessing: false,
        conversation: [], // {role: 'user'|'assistant', content: string, actions?: array, timestamp: number}
        maxHistory: 20, // Keep last 20 messages for context
        
        init() {
            this.panel = document.getElementById('ai-chat-panel');
            this.messagesContainer = document.getElementById('chat-messages');
            this.input = document.getElementById('chat-input');
            this.sendBtn = document.getElementById('chat-send-btn');
            this.voiceBtn = document.getElementById('chat-voice-btn');
            this.slideToggle = document.getElementById('chat-slide-toggle');
            this.clearBtn = document.getElementById('chat-clear');
            this.ttsToggleBtn = document.getElementById('chat-tts-toggle');
            this.suggestionsContainer = document.getElementById('chat-suggestions');
            
            this.setupEventListeners();
            this.loadConversation();
            
            console.log('Chat Manager initialized');
        },
        
        setupEventListeners() {
            // Toggle chat via slide toggle
            this.slideToggle.addEventListener('click', () => this.toggle());
            
            // Mobile close button
            const mobileClose = document.getElementById('chat-mobile-close');
            if (mobileClose) {
                mobileClose.addEventListener('click', () => this.close());
            }
            
            // Clear conversation
            this.clearBtn.addEventListener('click', async () => {
                const confirmed = await showConfirm({
                    title: 'Clear Chat',
                    message: 'Clear all conversation history?',
                    confirmText: 'Clear',
                    cancelText: 'Cancel',
                    danger: true
                });
                if (confirmed) {
                    this.clearConversation();
                }
            });
            
            // TTS toggle
            this.updateTTSButton();
            this.ttsToggleBtn.addEventListener('click', () => {
                voiceAI.toggleTTS();
                this.updateTTSButton();
            });
            
            // Send message
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            
            // Input handling
            this.input.addEventListener('input', () => {
                this.autoResize();
                this.sendBtn.disabled = !this.input.value.trim();
            });
            
            this.input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            
            // Voice input
            this.voiceBtn.addEventListener('click', () => this.startVoiceInput());
            
            // Example buttons
            document.querySelectorAll('.chat-example-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
            
            // Keyboard shortcut to open chat (Ctrl/Cmd + /)
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                    e.preventDefault();
                    this.toggle();
                }
            });
        },
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        open() {
            // Close neural panel if open
            if (typeof NeuralUI !== 'undefined' && NeuralUI.isOpen) {
                NeuralUI.close();
            }
            
            this.isOpen = true;
            this.panel.classList.add('open');
            document.body.classList.add('chat-open');
            setTimeout(() => this.input.focus(), 350);
        },
        
        close() {
            this.isOpen = false;
            this.panel.classList.remove('open');
            document.body.classList.remove('chat-open');
        },
        
        updateTTSButton() {
            if (!this.ttsToggleBtn) return;
            
            if (voiceAI.ttsEnabled) {
                this.ttsToggleBtn.classList.add('active');
                this.ttsToggleBtn.title = 'Voice responses ON - click to mute';
                this.ttsToggleBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                    </svg>`;
            } else {
                this.ttsToggleBtn.classList.remove('active');
                this.ttsToggleBtn.title = 'Voice responses OFF - click to unmute';
                this.ttsToggleBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                        <line x1="23" y1="9" x2="17" y2="15"/>
                        <line x1="17" y1="9" x2="23" y2="15"/>
                    </svg>`;
            }
        },
        
        autoResize() {
            this.input.style.height = 'auto';
            this.input.style.height = Math.min(this.input.scrollHeight, 120) + 'px';
        },
        
        async sendMessage() {
            const content = this.input.value.trim();
            if (!content || this.isProcessing) return;
            
            // Clear input
            this.input.value = '';
            this.input.style.height = 'auto';
            this.sendBtn.disabled = true;
            
            // Hide welcome if shown
            const welcome = this.messagesContainer.querySelector('.chat-welcome');
            if (welcome) welcome.style.display = 'none';
            
            // Add user message
            this.addMessage('user', content);
            
            // Show typing indicator
            this.showTyping();
            
            // Process with AI
            this.isProcessing = true;
            try {
                const response = await this.callAI(content);
                this.hideTyping();
                
                if (response) {
                    // Debug log
                    console.log('AI Response:', response);
                    console.log('Actions to execute:', response.actions);
                    
                    // Execute any actions
                    let actionResults = [];
                    if (response.actions && response.actions.length > 0) {
                        console.log(`Executing ${response.actions.length} actions...`);
                        showToast(`Executing ${response.actions.length} action${response.actions.length > 1 ? 's' : ''}...`, 'info');
                        actionResults = await this.executeActions(response.actions);
                        console.log('Action results:', actionResults);
                        
                        // Show success/failure summary
                        const successCount = actionResults.filter(r => r.success).length;
                        const failCount = actionResults.length - successCount;
                        if (failCount > 0) {
                            showToast(`${successCount} succeeded, ${failCount} failed`, failCount === actionResults.length ? 'error' : 'info');
                        } else if (successCount > 0) {
                            showToast(`${successCount} action${successCount > 1 ? 's' : ''} completed`, 'success');
                        }
                    }
                    
                    // Add assistant message
                    this.addMessage('assistant', response.message, actionResults, response.suggestions);
                    
                    // Show quick suggestions if provided
                    if (response.suggestions && response.suggestions.length > 0) {
                        this.showSuggestions(response.suggestions);
                    } else {
                        this.hideSuggestions();
                    }
                }
            } catch (error) {
                this.hideTyping();
                this.addMessage('assistant', `Sorry, I encountered an error: ${error.message}. Please try again.`);
            } finally {
                this.isProcessing = false;
            }
        },
        
        addMessage(role, content, actionResults = [], suggestions = []) {
            const message = {
                role,
                content,
                actions: actionResults,
                timestamp: Date.now()
            };
            
            this.conversation.push(message);
            
            // Trim conversation history
            if (this.conversation.length > this.maxHistory) {
                this.conversation = this.conversation.slice(-this.maxHistory);
            }
            
            // Save conversation
            this.saveConversation();
            
            // Render message
            this.renderMessage(message);
            
            // Scroll to bottom
            this.scrollToBottom();
            
            // Speak assistant messages if TTS is enabled
            if (role === 'assistant' && voiceAI.ttsEnabled && content) {
                voiceAI.speak(content);
            }
        },
        
        renderMessage(message) {
            const div = document.createElement('div');
            div.className = `chat-message ${message.role}`;
            
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let actionsHTML = '';
            if (message.actions && message.actions.length > 0) {
                actionsHTML = `
                    <div class="chat-actions-indicator">
                        ${message.actions.map(a => {
                            let icon = a.success ? '✓' : '✗';
                            let className = a.success ? 'success' : 'error';
                            
                            if (a.skippedDuplicate) {
                                icon = '⚠';
                                className = 'warning';
                            }
                            if (a.pendingConfirmation) {
                                icon = '?';
                                className = 'pending';
                            }
                            
                            return `
                            <div class="chat-action-item ${className}">
                                <span class="chat-action-icon">${icon}</span>
                                <span>${a.description}</span>
                            </div>
                        `;
                        }).join('')}
                    </div>
                `;
            }
            
            div.innerHTML = `
                <div class="chat-bubble">
                    ${this.formatMessage(message.content)}
                    ${actionsHTML}
                </div>
                <div class="chat-message-time">${time}</div>
            `;
            
            this.messagesContainer.appendChild(div);
        },
        
        formatMessage(content) {
            // Basic markdown-like formatting
            return escapeHTML(content)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        },
        
        showTyping() {
            const typing = document.createElement('div');
            typing.className = 'chat-message assistant';
            typing.id = 'chat-typing';
            typing.innerHTML = `
                <div class="chat-typing">
                    <div class="chat-typing-dot"></div>
                    <div class="chat-typing-dot"></div>
                    <div class="chat-typing-dot"></div>
                </div>
            `;
            this.messagesContainer.appendChild(typing);
            this.scrollToBottom();
        },
        
        hideTyping() {
            const typing = document.getElementById('chat-typing');
            if (typing) typing.remove();
        },
        
        showSuggestions(suggestions) {
            this.suggestionsContainer.innerHTML = suggestions.map(s => 
                `<button class="chat-suggestion-btn">${escapeHTML(s)}</button>`
            ).join('');
            this.suggestionsContainer.style.display = 'flex';
            
            // Add click handlers
            this.suggestionsContainer.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
        },
        
        hideSuggestions() {
            this.suggestionsContainer.style.display = 'none';
        },
        
        scrollToBottom() {
            setTimeout(() => {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }, 50);
        },
        
        async callAI(userMessage) {
            // Build context
            const allNodes = store.getAllNodes();
            const selectedNodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
            
            // Build complete tree structure from store.data recursively
            const buildFullTree = (node, depth = 0) => {
                if (!node) return '';
                const indent = '  '.repeat(depth);
                const childCount = node.children?.length || 0;
                const desc = node.description ? ` - "${node.description.substring(0, 50)}${node.description.length > 50 ? '...' : ''}"` : '';
                let line = `${indent}- ${node.label} [id:${node.id}]${childCount > 0 ? ` (${childCount} children)` : ''}${desc}`;
                
                if (node.children && node.children.length > 0) {
                    const childLines = node.children.map(child => buildFullTree(child, depth + 1));
                    line += '\n' + childLines.join('\n');
                }
                return line;
            };
            
            const treeStructure = buildFullTree(store.data);
            const totalNodes = allNodes.length;
            
            // Build conversation history for Claude
            // Include completed actions so AI knows what was already done
            const historyForClaude = this.conversation.slice(-10).map(m => {
                let content = m.content;
                
                // If assistant message had successful actions, append them to content
                // This helps AI avoid repeating the same additions
                if (m.role === 'assistant' && m.actions && m.actions.length > 0) {
                    const completedActions = m.actions
                        .filter(a => a.success)
                        .map(a => a.description)
                        .join(', ');
                    
                    const skippedDupes = m.actions
                        .filter(a => a.skippedDuplicate)
                        .map(a => a.description)
                        .join(', ');
                    
                    if (completedActions) {
                        content += `\n\n[COMPLETED ACTIONS: ${completedActions}]`;
                    }
                    if (skippedDupes) {
                        content += `\n[SKIPPED DUPLICATES: ${skippedDupes}]`;
                    }
                }
                
                return { role: m.role, content };
            });
            
            // Gather neural context from all intelligence systems
            let neuralContext = '';
            
            // 1. Neural network predictions (category & similar nodes)
            if (neuralNet.isReady) {
                try {
                    const [categoryPredictions, similarNodes] = await Promise.all([
                        neuralNet.predictCategory(userMessage),
                        neuralNet.findSimilarNodes(userMessage, store, 5)
                    ]);
                    
                    if (categoryPredictions && categoryPredictions.length > 0) {
                        const topPreds = categoryPredictions.filter(p => p.confidence > 0.2).slice(0, 3);
                        if (topPreds.length > 0) {
                            neuralContext += `Category predictions: ${topPreds.map(p => `${p.category} (${Math.round(p.confidence * 100)}%)`).join(', ')}\n`;
                        }
                    }
                    
                    if (similarNodes && similarNodes.length > 0) {
                        const topSimilar = similarNodes.filter(s => s.similarity > 0.25).slice(0, 5);
                        if (topSimilar.length > 0) {
                            neuralContext += `Semantically similar existing nodes:\n`;
                            topSimilar.forEach(s => {
                                const node = store.findNode(s.nodeId);
                                if (node) {
                                    const parent = store.findParent(s.nodeId);
                                    neuralContext += `  - "${node.label}"${parent ? ` (under ${parent.label})` : ''} [${Math.round(s.similarity * 100)}% match]\n`;
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.warn('Neural net context error:', e);
                }
            }
            
            // 2. User profile insights (behavior patterns, preferences)
            if (userProfile.loaded) {
                try {
                    const profileInsights = userProfile.getPromptInsights();
                    if (profileInsights) {
                        neuralContext += `\nUser behavior patterns:\n${profileInsights}\n`;
                    }
                    
                    // Add focus areas and neglected areas
                    if (userProfile.categoryStats?.focusAreas?.length > 0) {
                        neuralContext += `Current focus areas: ${userProfile.categoryStats.focusAreas.join(', ')}\n`;
                    }
                    if (userProfile.categoryStats?.neglectedAreas?.length > 0) {
                        neuralContext += `Areas that may need attention: ${userProfile.categoryStats.neglectedAreas.join(', ')}\n`;
                    }
                } catch (e) {
                    console.warn('User profile context error:', e);
                }
            }
            
            // 3. Preference tracker (what user accepts/rejects)
            try {
                const prefInsights = preferenceTracker.getPromptInsights();
                if (prefInsights) {
                    neuralContext += `\nSuggestion preferences:\n${prefInsights}\n`;
                }
            } catch (e) {
                console.warn('Preference tracker context error:', e);
            }
            
            // 4. Semantic memories (past interactions)
            try {
                const selectedLabel = selectedNodeData?.label || '';
                const pathLabels = [];
                if (selectedNodeData) {
                    let current = selectedNodeData;
                    while (current) {
                        pathLabels.unshift(current.label);
                        current = store.findParent(current.id);
                    }
                }
                
                const memoryInsights = await semanticMemory.getPromptMemories(
                    selectedLabel || userMessage, 
                    pathLabels.length > 0 ? pathLabels : [userMessage], 
                    3
                );
                if (memoryInsights) {
                    neuralContext += `\n${memoryInsights}\n`;
                }
            } catch (e) {
                console.warn('Semantic memory context error:', e);
            }
            
            // 5. Concept abstractor (structural patterns)
            if (selectedNodeData) {
                try {
                    const pathLabels = [];
                    let current = selectedNodeData;
                    while (current) {
                        pathLabels.unshift(current.label);
                        current = store.findParent(current.id);
                    }
                    
                    const conceptInsights = await conceptAbstractor.getPromptInsights(
                        selectedNodeData.label, 
                        pathLabels
                    );
                    if (conceptInsights) {
                        neuralContext += `\nStructural insights:\n${conceptInsights}\n`;
                    }
                } catch (e) {
                    console.warn('Concept abstractor context error:', e);
                }
            }
            
            // 6. Quick stats summary
            try {
                const stats = {
                    patterns: neuralNet.isReady ? neuralNet.getStats().totalPatterns : 0,
                    memories: semanticMemory.getStats().totalMemories,
                    acceptedSuggestions: preferenceTracker.getStats().totalAccepted
                };
                if (stats.patterns > 0 || stats.memories > 0) {
                    neuralContext += `\nLearning stats: ${stats.patterns} patterns learned, ${stats.memories} memories, ${stats.acceptedSuggestions} accepted suggestions\n`;
                }
            } catch (e) {
                // Stats not critical
            }
            
            // 7. AI Feedback stats (user's response to predictions)
            try {
                const feedbackStats = AIFeedback.getStats('category');
                if (feedbackStats && feedbackStats.total >= 3) {
                    const rate = Math.round(feedbackStats.acceptanceRate * 100);
                    neuralContext += `\nCategory prediction feedback (${feedbackStats.total} samples):\n`;
                    neuralContext += `  Acceptance rate: ${rate}%\n`;
                    
                    // Give Claude actionable guidance based on the rate
                    if (rate >= 70) {
                        neuralContext += `  → User trusts category predictions. Be confident in categorization suggestions.\n`;
                    } else if (rate >= 40) {
                        neuralContext += `  → User sometimes overrides predictions. Offer alternatives when suggesting categories.\n`;
                    } else {
                        neuralContext += `  → User often chooses different categories. Focus on content/connection suggestions rather than categorization.\n`;
                    }
                    
                    // Add response time insight
                    if (feedbackStats.avgResponseTime < 5000) {
                        neuralContext += `  → User makes quick decisions - keep suggestions concise.\n`;
                    }
                }
            } catch (e) {
                // Feedback stats not critical
            }

            // 8. CodeRAG - Relevant codebase context (for technical questions about MYND)
            let codeContext = '';
            if (codeRAG.initialized) {
                try {
                    // Check if the message seems to be about the codebase/implementation
                    const technicalKeywords = ['code', 'function', 'implement', 'how does', 'how do', 'bug', 'fix', 'feature', 'animation', 'render', 'node', 'expand', 'collapse', 'camera', 'theme', 'neural', 'AI', 'embed', 'store', 'save', 'load', 'api', 'claude', 'three.js', '3d', 'css', 'style', 'layout', 'position', 'technical', 'architecture', 'system'];
                    const messageLower = userMessage.toLowerCase();
                    const isTechnical = technicalKeywords.some(kw => messageLower.includes(kw));

                    if (isTechnical) {
                        const relevantCode = await codeRAG.getContext(userMessage, 3, 3000);
                        if (relevantCode) {
                            codeContext = relevantCode;
                            console.log('📚 CodeRAG provided context for technical query');
                        }
                    }
                } catch (e) {
                    console.warn('CodeRAG context error:', e);
                }
            }

            // 9. CodeKnowledge - Self-awareness context (concept → code mapping)
            let selfAwarenessContext = '';
            if (codeKnowledge.initialized) {
                try {
                    const messageLower = userMessage.toLowerCase();
                    // Check for self-referential or technical questions
                    const selfAwareKeywords = ['yourself', 'your code', 'how do you', 'how are you', 'implemented', 'architecture', 'work internally', 'your neural', 'your ai', 'this app', 'mynd works', 'behind the scenes'];
                    const isSelfAware = selfAwareKeywords.some(kw => messageLower.includes(kw));

                    if (isSelfAware || codeContext) {
                        const knowledgeContext = await codeKnowledge.getContext(userMessage, 3);
                        if (knowledgeContext) {
                            selfAwarenessContext = knowledgeContext;
                            console.log('🧠 CodeKnowledge provided self-awareness context');

                            // Learn from this interaction (reinforce associations)
                            const stats = codeKnowledge.getStats();
                            if (stats.conceptsMapped > 0) {
                                // This query is helping the system learn
                                codeKnowledge.learnAssociation(userMessage.substring(0, 50), 'query', 0.5);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('CodeKnowledge context error:', e);
                }
            }

            // 10. CodePretraining - Deep pre-trained knowledge (systems, call graphs, architecture)
            let pretrainedContext = '';
            if (CodePretraining.initialized) {
                try {
                    const messageLower = userMessage.toLowerCase();
                    // Trigger on technical questions or when other code contexts are present
                    const deepTechKeywords = ['system', 'architecture', 'how does', 'works', 'function', 'calls', 'depends', 'built', 'implemented', 'structure'];
                    const needsDeepKnowledge = deepTechKeywords.some(kw => messageLower.includes(kw)) || codeContext || selfAwarenessContext;

                    if (needsDeepKnowledge) {
                        const pretrainedKnowledge = CodePretraining.getContext(userMessage, 2);
                        if (pretrainedKnowledge) {
                            pretrainedContext = pretrainedKnowledge;
                            console.log('🎓 CodePretraining provided deep knowledge context');
                        }
                    }
                } catch (e) {
                    console.warn('CodePretraining context error:', e);
                }
            }

            // 11. CodeAnalyzer - Self-improvement analysis (identifies all improvement opportunities)
            let improvementContext = '';
            if (CodeAnalyzer.initialized) {
                try {
                    const messageLower = userMessage.toLowerCase();
                    // Trigger on self-improvement, optimization, or code quality questions
                    const improvementKeywords = ['improve', 'better', 'optimize', 'fix', 'enhance', 'upgrade', 'faster', 'performance', 'security', 'refactor', 'debt', 'quality', 'suggestion', 'recommend', 'what should', 'how can i make', 'what needs', 'priorities', 'roadmap'];
                    const needsImprovementContext = improvementKeywords.some(kw => messageLower.includes(kw)) || codeContext || pretrainedContext;

                    if (needsImprovementContext) {
                        const analysisContext = CodeAnalyzer.getContext(userMessage);
                        if (analysisContext) {
                            improvementContext = analysisContext;
                            console.log('🔍 CodeAnalyzer provided self-improvement context');
                        }
                    }
                } catch (e) {
                    console.warn('CodeAnalyzer context error:', e);
                }
            }

            const systemPrompt = `You are the AI companion for MYND — a personalized second brain designed to capture and connect fragmented thoughts, fostering creativity and clarity.

=== YOUR PURPOSE ===

You are not just an assistant — you are a cognitive partner. MYND learns the user's individual thought patterns, proactively suggesting connections and expanding on ideas. You go beyond simple organization to actively aid in goal manifestation and problem-solving.

Your role is to help users unlock their full cognitive potential. You are a brain supercharger — helping overcome mental blocks, surface hidden connections, and achieve ambitious goals. The experience should feel anticipatory and intuitive, almost like reading their mind.

When users capture thoughts (especially quick voice input), honor that these are precious fragments of their thinking. Help weave them into the larger tapestry of their mind map. Notice patterns they might miss. Suggest connections that spark new ideas. Be the companion that helps their best thinking emerge.

=== MYND APP KNOWLEDGE ===

**CORE CONCEPT:**
MYND is a 3D spatial mind mapping tool where ideas exist as spheres in 3D space. Nodes are connected hierarchically - each node can have children. The visual size of nodes indicates their depth (root is largest). Users navigate by rotating the 3D view and clicking nodes to expand/collapse branches.

**NAVIGATION & INTERACTION:**
- Click node: Select it (shows info panel on left)
- Double-click node: Expand all its descendants  
- Click expanded node: Collapse it
- Drag on empty space: Rotate the 3D view
- Scroll/pinch: Zoom in/out
- The camera auto-follows selected nodes (Auto Cam feature)

**SIDEBAR TOOLS (right side, top to bottom):**
- HOME: Reset camera to see entire map
- EXPAND: Expand all nodes in the map
- COLLAPSE: Collapse all to show only root's children
- AUTO CAM: Toggle automatic camera following (on by default)
- ─── divider ───
- ADD: Create a new child node under selected (or root if none selected)
- LINK: Add a node by pasting a URL - auto-extracts title and description
- MOVE: Toggle move mode - drag nodes to reparent them
- MEMO (orange): Quick AI voice/text command - one-shot actions
- CHAT (teal): Open AI chat panel for ongoing conversation (that's me!)
- NEURAL (purple): View neural network stats and training status

**QUICK CAPTURE BAR (bottom center):**
The text input at the bottom with rotating placeholder questions. Type anything and press Enter/Add to quickly create a node. Supports "under [parent]" syntax like "Buy groceries under Shopping".

**INFO PANEL (left side, appears when node selected):**
Shows selected node's details:
- Label (editable)
- Color picker
- Description (editable)  
- URL (if linked)
- Children count
- Transcript (if created by voice)
- Delete button

**NEURAL NETWORK SYSTEM:**
MYND has a personal neural network that learns from the user's behavior:
- Learns category patterns (where users place different topics)
- Tracks expansion patterns (which nodes users expand frequently)
- Remembers color preferences per category
- Identifies naming style (concise vs descriptive)
- Finds similar nodes to avoid duplicates
- Predicts where new content should go
- The network trains automatically when maps load
- Users can manually retrain via Settings or Neural panel

**PREFERENCE LEARNING:**
The app tracks when users accept or ignore AI suggestions to improve over time:
- Acceptance rate shown in Neural panel
- Style preferences learned (action-oriented, concise, descriptive)
- Time-of-day patterns
- Session context (what branches user works on)

**SEMANTIC MEMORY:**
The app stores embeddings of all node content for:
- Finding semantically similar nodes
- Avoiding duplicates
- Suggesting connections

**TOP-RIGHT CONTROLS:**
- User avatar: Account info and sign out
- Sun/moon icon: Toggle light/dark mode
- Menu (hamburger): 
  - Search: Find nodes by name
  - Shortcuts: View keyboard shortcuts
  - Settings: Neural network controls
  - New Map: Start fresh
  - Save/Load Map: Export/import JSON files
  - Help: Basic tips

**THEMES:**
Multiple color themes available:
- Default (dark purple/blue)
- Coral (warm oranges)
- Frost (cool blues, light)
- Obsidian (pure dark)
- Sakura (pink/cherry blossom)

**KEYBOARD SHORTCUTS:**
- Ctrl/Cmd + K: Open spotlight search
- Arrow Left/Right: Navigate between siblings
- Shift + Arrow Left/Right: Reorder node within siblings
- Arrow Up: Go to parent node
- Arrow Down: Go to first child (expands if collapsed)
- Space: Expand/collapse selected node
- Tab: Add child to selected node
- Enter: Add sibling to selected node
- E: Edit selected node
- Delete/Backspace: Delete selected node (with confirmation)
- Escape: Close panels, deselect, cancel operations
- Ctrl/Cmd + Z: Undo last action
- ?: Show keyboard hints

**MOUSE INTERACTIONS:**
- Right-click + drag: Reparent node (drag onto new parent, hold to confirm)
- Move mode (via side panel): Free-drag nodes to reposition

**DATA & SYNC:**
- Maps auto-save to browser localStorage
- Signed-in users get cloud sync across devices
- Real-time collaboration (changes sync live)
- Export: Save map as JSON (optionally with neural data)
- Import: Load previously saved maps

**AI FEATURES (Memo vs Chat):**
- MEMO: Quick one-shot commands via voice or text. Say "add meditation under health" or "delete the budget node". Fast, no conversation history.
- CHAT (me): Ongoing conversation with context. I remember what we discussed. Better for complex reorganization, brainstorming, or questions about the map.

Both AI features can:
- Add, edit, delete, move nodes
- Focus/navigate to nodes
- Expand/collapse branches
- Search the web for current information
- Use neural network insights for smart placement

**COMMON USER QUESTIONS I CAN HELP WITH:**
- "How do I create a node?" → Use ADD button, quick capture bar, or ask me
- "How do I delete?" → Select node, click delete in info panel, or ask me
- "How do I move a node?" → Use MOVE mode and drag, or ask me to move it
- "How do I change colors?" → Select node, use color picker in info panel
- "Can I undo?" → Yes, undo button appears after changes
- "How does the neural network work?" → It learns your patterns automatically
- "How do I search?" → Menu > Search, or ask me to find nodes

=== END APP KNOWLEDGE ===

CURRENT CONTEXT:
- Total nodes in map: ${totalNodes}
- Selected node: ${selectedNodeData ? `"${selectedNodeData.label}" [id:${selectedNodeData.id}]${selectedNodeData.children?.length ? ` with ${selectedNodeData.children.length} children` : ''}` : 'None'}

COMPLETE MAP STRUCTURE:
${treeStructure || '(empty map)'}
${neuralContext ? `
NEURAL INTELLIGENCE CONTEXT:
${neuralContext}` : ''}
${codeContext ? `
MYND CODEBASE CONTEXT (for technical questions):
${codeContext}` : ''}
${selfAwarenessContext ? `
SELF-AWARENESS (how concepts map to code):
${selfAwarenessContext}` : ''}
${pretrainedContext ? `
DEEP ARCHITECTURE KNOWLEDGE (pre-trained):
${pretrainedContext}` : ''}
${improvementContext ? `
SELF-IMPROVEMENT ANALYSIS (all improvement opportunities):
${improvementContext}` : ''}

YOUR CAPABILITIES:
1. **Full Map Visibility**: You can see the ENTIRE map structure above
2. **Neural Insights**: Use the neural context above to understand user patterns, find similar nodes, and make personalized suggestions
3. **Actions**: Create, edit, delete, move, focus on nodes when user wants
4. **Proactive**: Suggest improvements, identify duplicates, offer to help organize based on learned patterns
5. **Real-time info**: You can search the web for current information
6. **App Expert**: You know all MYND features deeply - help users learn the app, explain features, suggest efficient workflows
7. **Codebase Knowledge**: For technical questions, you have access to relevant MYND source code. Use this to explain how features work, suggest improvements, or debug issues
8. **Self-Awareness**: You understand how MYND's concepts (in the map) connect to actual code implementations. You can explain your own architecture, how features are built, and the relationships between components
9. **Deep Architecture Knowledge**: You have pre-trained understanding of all systems, their functions, call graphs, and dependencies. You know which functions call which, how systems depend on each other, and the overall architecture flow
10. **Self-Improvement Analysis**: You have analyzed the entire codebase and identified all possible improvements across 16 categories: Performance, Architecture, Security, Code Quality, Maintainability, Scalability, UX Enhancement, Feature Gaps, Dead Code, Technical Debt, Optimization, Modularization, Error Handling, Accessibility, Testing, and ML Intelligence. You can suggest prioritized improvements, quick wins, and a roadmap for making MYND stronger over time
11. **ML Intelligence Mastery**: You deeply understand how MYND learns - from embeddings and neural architectures to training strategies, reinforcement learning, knowledge distillation, memory systems, uncertainty estimation, and self-improvement loops. You can explain how to make the ML systems more sophisticated and suggest a prioritized roadmap for evolving MYND's intelligence

RESPONSE FORMAT (always JSON):
{
  "message": "Your conversational response to the user",
  "actions": [
    // Optional - only if user wants to modify the map
    {"action": "add", "label": "Node Name", "description": "...", "color": null, "parentId": "selected|root|node-id"},
    {"action": "edit", "targetId": "node-id", "label": "new name", "color": "#hex"},
    {"action": "delete", "targetId": "node-id"},
    {"action": "move", "targetId": "node-id", "parentId": "new-parent-id"},
    {"action": "reorder", "targetId": "node-id", "position": "first|last|up|down|NUMBER"},
    {"action": "focus", "targetId": "node-id"},
    {"action": "expand", "targetId": "node-id"},
    {"action": "collapse", "targetId": "node-id"}
  ],
  "suggestions": ["Quick reply 1", "Quick reply 2"] // Optional quick reply suggestions
}

GUIDELINES:
- Be a cognitive partner, not just a task executor. Help users think better.
- Proactively notice connections between ideas - "This reminds me of your [other node]" or "This could connect to..."
- When users seem stuck or vague, help them clarify and expand their thinking
- Reference the neural context to personalize responses (match their style, preferred colors, naming patterns)
- Use similar nodes to avoid duplicates AND to surface potential connections
- You have FULL visibility of the map - reference specific nodes by name to show you understand their world
- Be warm, conversational, and genuinely curious about their ideas
- Proactively notice patterns: gaps in their map, imbalanced areas, potential goals hiding in their thoughts
- When capturing quick voice input, treat it as precious - help shape raw thoughts into clear nodes
- Suggest next steps: "Would you like to break this down further?" or "Should we connect this to...?"
- Only include actions when the user wants to modify the map
- Use web search for current events, prices, news, etc.
- Keep responses concise but insightful
- When users ask how to do something in MYND, explain and offer to do it for them

=== CRITICAL NODE CREATION RULES ===

**DUPLICATE PREVENTION (VERY IMPORTANT):**
1. BEFORE adding a node, ALWAYS check the COMPLETE MAP STRUCTURE above
2. NEVER add a node if the parent already has a child with the same or very similar name
3. If you already added a node in this conversation, DO NOT add it again - check conversation history
4. If a node with the same name exists elsewhere in the map, mention it in your message and ask if user wants to create anyway or navigate to existing
5. Watch for typos/variations: "Morning Routine" vs "morning routine" vs "Morning routine" are the SAME
6. If your previous response shows "Added [X]" in green, that node EXISTS - don't add it again

**WHEN YOU ALREADY CREATED A NODE:**
- If user continues conversation after you added a node, acknowledge the existing node
- Say things like "I've already captured that as [Node Name]" or "That's now in your map under [Parent]"
- Offer to expand, edit, or navigate to the existing node instead of recreating

**COLOR GUIDELINES:**
- Inherit parent's color unless user specifies or topic clearly differs
- Use consistent colors for categories: Health/Fitness=#26DE81 or #4ECDC4, Work=#EF8354 or #45B7D1, Personal=#9B5DE5 or #FF6B9D
- When creating multiple related nodes, use same or gradient colors
- Don't randomly assign colors - be intentional

**ORGANIZATION RULES:**
- Place nodes under the most specific relevant parent, not root
- If user says "add X" without location, use selected node or find best parent from context
- Group related items - don't scatter similar topics across the map
- Suggest reorganization when you notice misplaced nodes

**NAMING GUIDELINES:**
- Keep labels concise (2-5 words ideal)
- Use title case for consistency
- Avoid redundancy with parent (don't name child "Fitness Goals" under "Fitness")
- Make names scannable and unique within their context

**EDITING vs CREATING:**
- If a node exists that could be updated instead of creating new, suggest editing
- Prefer consolidation over proliferation - one good node beats three scattered ones

=== EXAMPLES ===

**ADDING NODES:**

User: "add a node called Morning Routine"
{"actions":[{"action":"add","label":"Morning Routine","description":"A structured sequence of activities to start each day with intention, energy, and clarity.","color":null,"parentId":"selected"}]}

User: "create three nodes for my workout: cardio, strength, flexibility"
{"actions":[{"action":"add","label":"Cardio","description":"Cardiovascular exercises to improve heart health and endurance.","color":"#EF4444","parentId":"selected"},{"action":"add","label":"Strength","description":"Resistance training to build muscle and increase metabolism.","color":"#EF8354","parentId":"selected"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work to prevent injury and improve range of motion.","color":"#4ECDC4","parentId":"selected"}]}

User: "what is machine learning" (tree has "AI (node-ai123)")
{"actions":[{"action":"add","label":"Machine Learning","description":"A subset of artificial intelligence where systems learn and improve from experience without being explicitly programmed. Uses algorithms to find patterns in data and make predictions or decisions.","color":null,"parentId":"node-ai123"}]}

User: "add project alpha under work with subitems planning and execution"
{"actions":[{"action":"add","label":"Project Alpha","description":"A major initiative requiring structured planning and careful execution.","color":"#9B5DE5","parentId":"work"},{"action":"add","label":"Planning","description":"Initial phase covering requirements, timeline, and resource allocation.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Execution","description":"Implementation phase where planned tasks are carried out.","color":null,"parentId":"PREV_0"}]}

User: "remind me to call mom"
{"actions":[{"action":"add","label":"Call Mom","description":"Remember to check in with mom. Consider scheduling a regular time for these calls.","color":"#FF6B9D","parentId":"selected"}]}

User: "I want to learn Spanish this year"
{"actions":[{"action":"add","label":"Learn Spanish","description":"Goal to achieve conversational Spanish fluency. Consider apps like Duolingo, classes, or conversation partners.","color":"#F7B731","parentId":"root"}]}

**NEURAL-GUIDED PLACEMENT (using all intelligence):**

User: "meditation benefits"
Neural: Category=Health(72%), Similar="Mindfulness" under Health, Color=Health uses #4ECDC4
{"actions":[{"action":"add","label":"Meditation Benefits","description":"Regular meditation practice offers reduced stress, improved focus, better emotional regulation, and enhanced overall wellbeing.","color":"#4ECDC4","parentId":"node-health123"}]}

User: "need to fix that bug"
Neural: Category=Work(68%), Active branch=Work, Session focus=Work, Naming=Concise
{"actions":[{"action":"add","label":"Bug Fix","description":"Technical issue requiring investigation and resolution.","color":null,"parentId":"node-work123"}]}

User: "random thought about saving money"
Neural: Similar="Budget" under Finance (65%), Gap="Finance missing Savings"
{"actions":[{"action":"add","label":"Savings","description":"Ideas and strategies for building financial reserves and reducing unnecessary spending.","color":"#26DE81","parentId":"node-finance456"}]}

User: "I should start running more"
Neural: Category=Fitness(80%), Expansion pattern="Under Fitness: Cardio, Strength, Nutrition", Similar="Cardio"(70%)
{"actions":[{"action":"add","label":"Running","description":"Cardiovascular exercise through running to improve endurance and overall health.","color":null,"parentId":"node-cardio789"}]}

User: "productivity hack I learned"
Neural: Relationship to selected=SIBLING(65%), Time=Morning(work time), Active=Personal Development
{"actions":[{"action":"add","label":"Productivity Hack","description":"Useful technique for getting more done with less effort and better focus.","color":null,"parentId":"node-personaldev123"}]}

**VAGUE INPUT HANDLING (neural is crucial here):**

User: "hmm just thinking about stuff"
Neural: Session focus=Work, Recent edits=Project X, Time=Afternoon
{"actions":[{"action":"add","label":"Project Thoughts","description":"General reflections and ideas related to current work focus.","color":null,"parentId":"node-work123"}]}

User: "something to remember"
Neural: Active branch=Tasks, Category=Personal(45%)
{"actions":[{"action":"add","label":"Quick Note","description":"Important thought or reminder to capture for later review.","color":"#F7B731","parentId":"selected"}]}

User: "that thing I saw online"
Neural: Similar="Bookmarks"(55%), Category=Resources(40%)
{"actions":[{"action":"add","label":"Web Discovery","description":"Interesting content found online worth saving for reference.","color":null,"parentId":"node-resources123"}]}

**EDITING NODES:**

User: "make the fitness node green"
{"actions":[{"action":"edit","targetId":"node-fitness123","color":"#26DE81"}]}

User: "change Morning Routine to green"
{"actions":[{"action":"edit","targetId":"node-morning456","color":"#26DE81"}]}

User: "rename meditation to mindfulness practice"
{"actions":[{"action":"edit","targetId":"node-meditation789","label":"Mindfulness Practice"}]}

User: "update the description of Project Alpha to say it's due next month"
{"actions":[{"action":"edit","targetId":"node-alpha123","description":"A major initiative due next month requiring structured planning and execution."}]}

User: "make work node orange and rename it to Career"
{"actions":[{"action":"edit","targetId":"node-work123","label":"Career","color":"#EF8354"}]}

User: "change the color of all my health nodes to teal" (health has id node-health1)
{"actions":[{"action":"edit","targetId":"node-health1","color":"#4ECDC4"}]}

User: "mark reading as purple"
{"actions":[{"action":"edit","targetId":"node-reading123","color":"#9B5DE5"}]}

User: "set the selected node to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

**DELETING NODES:**

User: "delete the meditation node"
{"actions":[{"action":"delete","targetId":"node-meditation789"}]}

User: "remove Project Beta"
{"actions":[{"action":"delete","targetId":"node-beta456"}]}

User: "get rid of the selected node"
{"actions":[{"action":"delete","targetId":"selected"}]}

**MOVING NODES:**

User: "move meditation under health"
{"actions":[{"action":"move","targetId":"node-meditation789","parentId":"node-health123"}]}

User: "put the reading node under personal development"
{"actions":[{"action":"move","targetId":"node-reading456","parentId":"node-personal789"}]}

User: "move project alpha to the root"
{"actions":[{"action":"move","targetId":"node-alpha123","parentId":"root"}]}

**REORDERING NODES (within siblings):**

User: "move budget to the first position"
{"actions":[{"action":"reorder","targetId":"node-budget123","position":"first"}]}

User: "put exercise before nutrition"
{"actions":[{"action":"reorder","targetId":"node-exercise456","position":"up"}]}

User: "move reading to the end"
{"actions":[{"action":"reorder","targetId":"node-reading789","position":"last"}]}

User: "move this node up"
{"actions":[{"action":"reorder","targetId":"selected","position":"up"}]}

**NAVIGATION:**

User: "go to the fitness node"
{"actions":[{"action":"focus","targetId":"node-fitness123"}]}

User: "show me my goals"
{"actions":[{"action":"focus","targetId":"node-goals456"}]}

User: "take me to work"
{"actions":[{"action":"focus","targetId":"node-work789"}]}

User: "find the meditation node"
{"actions":[{"action":"focus","targetId":"node-meditation123"}]}

**EXPAND/COLLAPSE:**

User: "expand the work node"
{"actions":[{"action":"expand","targetId":"node-work123"}]}

User: "collapse personal"
{"actions":[{"action":"collapse","targetId":"node-personal456"}]}

User: "open up my goals"
{"actions":[{"action":"expand","targetId":"node-goals789"}]}

User: "close the projects section"
{"actions":[{"action":"collapse","targetId":"node-projects123"}]}

**COMPLEX MULTI-ACTION:**

User: "create a new category called side projects with two items: app idea and blog"
{"actions":[{"action":"add","label":"Side Projects","description":"Personal projects pursued outside of main work for learning and creativity.","color":"#9B5DE5","parentId":"root"},{"action":"add","label":"App Idea","description":"Concept for a mobile or web application to develop.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Blog","description":"Personal blog for sharing thoughts, tutorials, or experiences.","color":null,"parentId":"PREV_0"}]}

User: "move reading to hobbies and make it blue"
{"actions":[{"action":"move","targetId":"node-reading123","parentId":"node-hobbies456"},{"action":"edit","targetId":"node-reading123","color":"#45B7D1"}]}

User: "delete the old project and add a new one called Project Phoenix"
{"actions":[{"action":"delete","targetId":"node-oldproject123"},{"action":"add","label":"Project Phoenix","description":"New initiative rising from lessons learned in previous projects.","color":"#EF8354","parentId":"selected"}]}

**CONVERSATIONAL/QUESTION INPUTS:**

User: "I'm feeling stressed about deadlines"
{"actions":[{"action":"add","label":"Deadline Stress","description":"Feeling overwhelmed by upcoming deadlines. Consider breaking tasks into smaller chunks, prioritizing ruthlessly, and scheduling breaks.","color":"#EF4444","parentId":"selected"}]}

User: "how do I stay motivated"
{"actions":[{"action":"add","label":"Staying Motivated","description":"Key strategies include: setting clear goals, tracking progress visibly, celebrating small wins, finding accountability partners, and connecting tasks to larger purpose.","color":"#F7B731","parentId":"selected"}]}

User: "what should I focus on today"
{"actions":[{"action":"add","label":"Today's Focus","description":"Review your most important tasks, identify the one with highest impact, and protect time to work on it without interruption.","color":"#26DE81","parentId":"selected"}]}

**PARENTID RULES:**
1. Use actual node IDs from the tree (like "node-abc123")
2. Use "selected" when user says "here", "this node", or no specific location
3. Use "root" for new top-level categories
4. Use "PREV_0", "PREV_1" etc. to reference nodes created earlier in same response
5. Search the tree for relevant parents - put fitness content under fitness nodes, work under work, etc.

**MORE COLOR EXAMPLES (various phrasings):**

User: "turn fitness green"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81"}]}

User: "I want the work node to be orange"
{"actions":[{"action":"edit","targetId":"work","color":"#EF8354"}]}

User: "can you change health to teal please"
{"actions":[{"action":"edit","targetId":"health","color":"#4ECDC4"}]}

User: "make my goals yellow"
{"actions":[{"action":"edit","targetId":"goals","color":"#F7B731"}]}

User: "set color of meditation to purple"
{"actions":[{"action":"edit","targetId":"meditation","color":"#9B5DE5"}]}

User: "color the selected node pink"
{"actions":[{"action":"edit","targetId":"selected","color":"#FF6B9D"}]}

User: "change this to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

User: "red for the deadline task"
{"actions":[{"action":"edit","targetId":"deadline","color":"#EF4444"}]}

User: "make morning routine lavender colored"
{"actions":[{"action":"edit","targetId":"morning routine","color":"#A29BFE"}]}

**MORE NATURAL LANGUAGE VARIATIONS:**

User: "add exercise"
{"actions":[{"action":"add","label":"Exercise","description":"Physical activity for health, fitness, and mental wellbeing. Consider cardio, strength training, and flexibility work.","color":null,"parentId":"selected"}]}

User: "new node: weekly review"
{"actions":[{"action":"add","label":"Weekly Review","description":"A dedicated time each week to reflect on progress, plan ahead, and realign with goals.","color":null,"parentId":"selected"}]}

User: "brainstorm: marketing ideas"
{"actions":[{"action":"add","label":"Marketing Ideas","description":"Creative concepts and strategies for promoting products, services, or brand awareness.","color":"#9B5DE5","parentId":"selected"}]}

User: "quick thought - need to buy groceries"
{"actions":[{"action":"add","label":"Buy Groceries","description":"Shopping reminder. Consider making a list and checking pantry before going.","color":null,"parentId":"selected"}]}

User: "jot down: call the dentist"
{"actions":[{"action":"add","label":"Call Dentist","description":"Schedule a dental appointment for routine checkup or specific concern.","color":null,"parentId":"selected"}]}

**RENAMING EXAMPLES:**

User: "rename fitness to health and wellness"
{"actions":[{"action":"edit","targetId":"fitness","label":"Health & Wellness"}]}

User: "change the name of project alpha to project omega"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Omega"}]}

User: "call the meditation node mindfulness instead"
{"actions":[{"action":"edit","targetId":"meditation","label":"Mindfulness"}]}

User: "update work label to career development"
{"actions":[{"action":"edit","targetId":"work","label":"Career Development"}]}

**DESCRIPTION UPDATES:**

User: "add a description to fitness: my workout plan for 2024"
{"actions":[{"action":"edit","targetId":"fitness","description":"My comprehensive workout plan for 2024 focusing on consistency and progressive improvement."}]}

User: "update the description of goals to mention Q1 targets"
{"actions":[{"action":"edit","targetId":"goals","description":"Key objectives and Q1 targets for personal and professional growth."}]}

**COMBINED EDIT EXAMPLES:**

User: "rename work to career and make it blue"
{"actions":[{"action":"edit","targetId":"work","label":"Career","color":"#45B7D1"}]}

User: "change fitness to green and add description about daily exercise"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81","description":"Daily exercise routine for physical health, mental clarity, and sustained energy."}]}

User: "update project alpha: rename to project beta, make it purple, and add description about the new scope"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Beta","color":"#9B5DE5","description":"Revised project with expanded scope and updated timeline."}]}

**HIERARCHICAL CREATION:**

User: "create a fitness category with subcategories for cardio, strength, and flexibility"
{"actions":[{"action":"add","label":"Fitness","description":"Physical training and exercise for health and performance.","color":"#26DE81","parentId":"root"},{"action":"add","label":"Cardio","description":"Cardiovascular exercises for heart health and endurance.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Strength","description":"Resistance training for muscle building and metabolism.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work for injury prevention.","color":null,"parentId":"PREV_0"}]}

User: "add a books section under personal with three books: atomic habits, deep work, and thinking fast and slow"
{"actions":[{"action":"add","label":"Books","description":"Reading list and book notes for personal development.","color":"#9B5DE5","parentId":"personal"},{"action":"add","label":"Atomic Habits","description":"James Clear's guide to building good habits and breaking bad ones through small changes.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Deep Work","description":"Cal Newport's framework for focused, distraction-free productivity.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Thinking Fast and Slow","description":"Daniel Kahneman's exploration of the two systems that drive how we think.","color":null,"parentId":"PREV_0"}]}

**QUESTION-BASED INPUTS:**

User: "what are the benefits of meditation"
{"actions":[{"action":"add","label":"Benefits of Meditation","description":"Meditation offers numerous benefits including reduced stress and anxiety, improved focus and concentration, better emotional regulation, enhanced self-awareness, and improved sleep quality. Regular practice can also lower blood pressure and boost immune function.","color":"#A29BFE","parentId":"selected"}]}

User: "explain compound interest"
{"actions":[{"action":"add","label":"Compound Interest","description":"Compound interest is interest calculated on both the initial principal and accumulated interest from previous periods. It's often called 'interest on interest' and is a powerful force for growing wealth over time. The formula is A = P(1 + r/n)^(nt).","color":"#F7B731","parentId":"selected"}]}

User: "how do I start a morning routine"
{"actions":[{"action":"add","label":"Starting a Morning Routine","description":"Begin by waking at a consistent time. Start simple with 2-3 activities like hydration, movement, and intention-setting. Prepare the night before and protect this time from distractions. Gradually add elements as habits solidify.","color":"#4ECDC4","parentId":"selected"}]}

**VOICE-STYLE INFORMAL INPUTS:**

User: "uh add something about like project deadlines I guess"
{"actions":[{"action":"add","label":"Project Deadlines","description":"Tracking and managing upcoming project deadlines to ensure timely delivery.","color":"#EF4444","parentId":"selected"}]}

User: "hmm let me think... yeah add productivity tips"
{"actions":[{"action":"add","label":"Productivity Tips","description":"Strategies and techniques for getting more done with less stress and better focus.","color":"#F7B731","parentId":"selected"}]}

User: "so basically I want to track my water intake"
{"actions":[{"action":"add","label":"Water Intake Tracking","description":"Monitor daily hydration to ensure adequate water consumption for health and energy.","color":"#45B7D1","parentId":"selected"}]}

**RESPOND ACTION (answer without creating nodes):**

User: "what's the weather today"
{"message":"Based on current conditions, it's 72°F and sunny in your area. Would you like me to add a weather tracking node to your map?","actions":[]}

User: "what time is it in Tokyo"
{"message":"It's currently 3:45 AM in Tokyo (JST, UTC+9).","actions":[]}

User: "what's Tesla stock price"
{"message":"Tesla (TSLA) is currently trading at $248.50, up 2.3% today. The stock has risen 15% this month following strong delivery numbers. Want me to add this to your map?","actions":[]}

User: "how many calories in an avocado"
{"message":"A medium avocado contains about 240 calories, with 22g of healthy fats, 12g of carbs, and 3g of protein. It's also rich in potassium, vitamin K, and fiber.","actions":[]}

User: "what's happening with bitcoin"
{"message":"Bitcoin is currently at $67,450, up 4% in the last 24 hours. Recent ETF inflows and halving anticipation are driving momentum. Want me to track this in your map?","actions":[]}

User: "who won the super bowl"
{"message":"The Kansas City Chiefs won Super Bowl LVIII in February 2024, defeating the San Francisco 49ers 25-22 in overtime.","actions":[]}

User: "summarize the latest AI news"
{"message":"Key AI developments this week: OpenAI announced GPT-5 training, Google released Gemini 2.0, and the EU AI Act enforcement began. Anthropic also launched new Claude features for enterprise. Want me to add an AI News node?","actions":[]}

**WHEN TO USE MESSAGE-ONLY vs ACTIONS:**

User: "what is meditation" (general question - message only)
{"message":"Meditation is a practice of focused attention and awareness, often involving breathing techniques or mindfulness. It reduces stress, improves focus, and promotes emotional wellbeing. Want me to add this to your map?","actions":[]}

User: "add info about meditation" (explicit request - include action)
{"message":"I've added a Meditation node with key information.","actions":[{"action":"add","label":"Meditation","description":"A practice of focused attention and awareness to reduce stress, improve concentration, and promote emotional wellbeing.","color":"#A29BFE","parentId":"selected"}]}

User: "tell me about compound interest" (informational - message only)
{"message":"Compound interest is interest calculated on both the initial principal and accumulated interest. The formula is A = P(1 + r/n)^(nt). It's powerful for long-term investing - $10,000 at 7% for 30 years becomes $76,123. Want me to add this to your map?","actions":[]}

User: "I need to learn about compound interest" (intent to capture - include action)
{"message":"I've added a node about compound interest to help you remember this concept.","actions":[{"action":"add","label":"Compound Interest","description":"Interest calculated on both principal and accumulated interest. Key wealth-building concept: A = P(1 + r/n)^(nt). Small regular investments grow exponentially over time.","color":"#26DE81","parentId":"selected"}]}

**APP HELP QUESTIONS (message only, no actions):**

User: "how do I delete a node"
{"message":"To delete a node: 1) Click the node to select it, 2) Look at the info panel on the left, 3) Click the Delete button at the bottom. Or just tell me which node to delete and I'll do it for you!","actions":[]}

User: "how do I change colors"
{"message":"Select any node by clicking it, then use the color picker in the info panel on the left. You can also ask me to change colors - just say 'make [node name] blue' or whatever color you want!","actions":[]}

User: "what does the neural network do"
{"message":"The neural network learns YOUR patterns - where you place different topics, what colors you prefer, your naming style (short vs detailed). Over time, I use these patterns to suggest better placements for new content. Check the Neural panel (purple icon) to see your learning stats!","actions":[]}

User: "how do I move nodes around"
{"message":"Two ways: 1) Click MOVE in the sidebar, then drag nodes to new parents. 2) Or just ask me - say 'move [node] under [parent]' and I'll do it instantly!","actions":[]}

User: "what's the difference between memo and chat"
{"message":"MEMO (orange) is for quick one-shot commands - fast and efficient. CHAT (teal, that's me!) is for ongoing conversation where I remember context. Use Memo for quick adds, Chat for complex organizing or questions.","actions":[]}

User: "how do I search my map"
{"message":"Click the menu (hamburger icon top right) and select Search. Or just ask me to find something - I can see your entire map and navigate to any node!","actions":[]}

**CRITICAL RULES:**
1. Always respond with valid JSON only - no extra text
2. Always include meaningful descriptions for new nodes
3. Match node IDs from the tree structure above, not labels
4. For colors, use the exact hex codes provided
5. When user mentions a node by name, find its ID in the tree
6. "selected" as targetId means the currently selected node
7. Be helpful and interpret user intent, don't be overly literal
8. For ambiguous color names, use closest match (e.g., "blue" = #45B7D1, "red" = #EF4444)
9. When editing, only include fields that are being changed
10. Use message-only responses for: factual questions, current events, prices, time queries, "what is X" questions, AND app help questions
11. Include actions for: "add", "create", "track", "remember", "I want to learn", "capture this", or when user clearly wants to modify the map
12. When unsure if user wants to add, ask in your message

**WEB SEARCH CAPABILITY:**
You have access to real-time web search. For questions about:
- Current stock prices, crypto prices, market data
- Latest news and current events  
- Weather, time zones, live information
- Recent developments, announcements
- Anything that requires up-to-date information
Use your web search to get accurate, current data before responding.

=== END EXAMPLES ===

COLORS: Red #EF4444, Orange #EF8354, Yellow #F7B731, Green #26DE81, Teal #4ECDC4, Blue #45B7D1, Purple #9B5DE5, Pink #FF6B9D

CRITICAL: Respond with ONLY a valid JSON object. No markdown, no code blocks, no explanation before or after. Just the raw JSON starting with { and ending with }.`;

            // Build messages array
            const messages = [
                { role: 'user', content: systemPrompt },
                { role: 'assistant', content: '{"message": "I understand. I\'m ready to help with your mind map.", "actions": [], "suggestions": []}' },
                ...historyForClaude,
                { role: 'user', content: userMessage }
            ];
            
            // Get auth session
            let session = null;
            if (typeof supabase !== 'undefined' && supabase !== null) {
                const { data } = await supabase.auth.getSession();
                session = data?.session;
            }
            
            let responseText;
            
            if (session?.access_token) {
                // Use Edge Function
                const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({
                        type: 'chat',
                        messages: messages,
                        maxTokens: 4096,
                        webSearch: true
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to get response');
                }
                
                const data = await response.json();
                responseText = data.response;
            } else {
                // Direct API call
                const apiKey = localStorage.getItem(CONFIG.API_KEY);
                if (!apiKey) {
                    throw new Error('Please sign in or add an API key in Settings');
                }
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey.trim(),
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 4096,
                        tools: [{
                            type: 'web_search_20250305',
                            name: 'web_search',
                            max_uses: 3
                        }],
                        messages: messages
                    })
                });
                
                if (!response.ok) {
                    throw new Error('API request failed');
                }
                
                const data = await response.json();
                // Extract text from response
                if (Array.isArray(data.content)) {
                    const textBlock = data.content.find(b => b.type === 'text');
                    responseText = textBlock?.text || '';
                } else {
                    responseText = data.content?.[0]?.text || '';
                }
            }
            
            // Parse JSON response - handle markdown code blocks and text before JSON
            try {
                // Remove markdown code block markers if present
                let cleanedResponse = responseText
                    .replace(/```json\s*/gi, '')
                    .replace(/```\s*/g, '')
                    .trim();
                
                // Try to find JSON starting with {"message" (our expected format)
                const jsonStartIndex = cleanedResponse.indexOf('{"message"');
                if (jsonStartIndex !== -1) {
                    // Extract from {"message" to the end and find the matching closing brace
                    const jsonPart = cleanedResponse.substring(jsonStartIndex);
                    
                    // Find the matching closing brace by counting braces
                    let braceCount = 0;
                    let endIndex = -1;
                    for (let i = 0; i < jsonPart.length; i++) {
                        if (jsonPart[i] === '{') braceCount++;
                        if (jsonPart[i] === '}') braceCount--;
                        if (braceCount === 0) {
                            endIndex = i + 1;
                            break;
                        }
                    }
                    
                    if (endIndex > 0) {
                        const jsonString = jsonPart.substring(0, endIndex);
                        const parsed = JSON.parse(jsonString);
                        
                        if (parsed && typeof parsed.message === 'string') {
                            console.log('Parsed AI response:', parsed);
                            return {
                                message: parsed.message,
                                actions: Array.isArray(parsed.actions) ? parsed.actions : [],
                                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : []
                            };
                        }
                    }
                }
                
                // Fallback: try generic JSON extraction
                const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    if (parsed && typeof parsed.message === 'string') {
                        return {
                            message: parsed.message,
                            actions: Array.isArray(parsed.actions) ? parsed.actions : [],
                            suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : []
                        };
                    }
                }
            } catch (e) {
                console.error('Failed to parse AI response:', e, responseText);
            }
            
            // Fallback - try to extract just the message if JSON parsing failed
            return { message: responseText.substring(0, 500), actions: [], suggestions: [] };
        },
        
        async executeActions(actions) {
            const results = [];
            const createdNodes = [];
            
            console.log('executeActions called with:', actions);
            
            for (const action of actions) {
                try {
                    let result = { action: action.action, success: false, description: '' };
                    console.log('Processing action:', action);
                    
                    // Resolve IDs
                    const resolveId = (id) => {
                        if (!id) return null;
                        if (id === 'selected') return selectedNode?.userData.id;
                        if (id === 'root') return store.data.id;
                        if (id.startsWith('PREV_')) {
                            const idx = parseInt(id.split('_')[1]);
                            return createdNodes[idx]?.id;
                        }
                        // Try to find by ID or label
                        if (store.findNode(id)) return id;
                        const allNodes = store.getAllNodes();
                        const match = allNodes.find(n => n.label.toLowerCase() === id.toLowerCase());
                        return match?.id;
                    };
                    
                    if (action.action === 'add') {
                        const parentId = resolveId(action.parentId) || selectedNode?.userData.id || store.data.id;
                        const labelLower = action.label?.toLowerCase().trim() || '';
                        
                        // DUPLICATE CHECK 1: Check if parent already has child with same name
                        const parent = store.findNode(parentId);
                        const siblingDupe = parent?.children?.find(c => 
                            c.label?.toLowerCase().trim() === labelLower
                        );
                        
                        if (siblingDupe) {
                            result.success = false;
                            result.description = `Skipped "${action.label}" (already exists under this parent)`;
                            result.skippedDuplicate = true;
                            results.push(result);
                            continue;
                        }
                        
                        // DUPLICATE CHECK 2: Check if node exists anywhere else in map
                        const allNodes = store.getAllNodes();
                        const existingElsewhere = allNodes.find(n => 
                            n.label?.toLowerCase().trim() === labelLower && 
                            n.id !== parentId
                        );
                        
                        if (existingElsewhere && !action.forceCreate) {
                            // Track pending confirmation
                            result.success = false;
                            result.description = `"${action.label}" already exists elsewhere in map`;
                            result.existingNode = existingElsewhere;
                            result.pendingConfirmation = true;
                            results.push(result);
                            continue;
                        }
                        
                        const newNode = store.addNode(parentId, {
                            label: action.label,
                            description: action.description || '',
                            color: action.color || null
                        });
                        if (newNode) {
                            createdNodes.push(newNode);
                            result.success = true;
                            result.description = `Added "${action.label}"`;
                        }
                    } else if (action.action === 'edit') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            const updates = {};
                            if (action.label) updates.label = action.label;
                            if (action.description) updates.description = action.description;
                            if (action.color) updates.color = action.color;
                            store.updateNode(targetId, updates);
                            result.success = true;
                            result.description = `Updated node`;
                            
                            // Update mesh
                            const mesh = nodes.get(targetId);
                            if (mesh && action.color) {
                                mesh.material.color.set(action.color);
                                mesh.material.emissive.set(action.color);
                            }
                            if (mesh && action.label) {
                                updateNodeLabel(mesh, action.label);
                            }
                        }
                    } else if (action.action === 'delete') {
                        const targetId = resolveId(action.targetId);
                        console.log('Delete action - raw targetId:', action.targetId, '- resolved:', targetId);
                        if (!targetId) {
                            result.description = `Could not find node "${action.targetId}"`;
                        } else if (targetId === store.data.id) {
                            result.description = `Cannot delete root node`;
                        } else {
                            const node = store.findNode(targetId);
                            if (store.deleteNode(targetId)) {
                                result.success = true;
                                result.description = `Deleted "${node?.label}"`;
                            } else {
                                result.description = `Failed to delete node`;
                            }
                        }
                    } else if (action.action === 'move') {
                        const targetId = resolveId(action.targetId);
                        const parentId = resolveId(action.parentId);
                        console.log('Move action - target:', action.targetId, '->', targetId, 'parent:', action.parentId, '->', parentId);
                        if (!targetId) {
                            result.description = `Could not find node to move "${action.targetId}"`;
                        } else if (!parentId) {
                            result.description = `Could not find target parent "${action.parentId}"`;
                        } else {
                            const moved = store.moveNode(targetId, parentId);
                            if (moved) {
                                result.success = true;
                                result.description = `Moved node`;
                            } else {
                                result.description = `Move operation failed`;
                            }
                        }
                    } else if (action.action === 'reorder') {
                        const targetId = resolveId(action.targetId);
                        if (!targetId) {
                            result.description = `Could not find node to reorder "${action.targetId}"`;
                        } else {
                            let reordered = false;
                            const position = action.position;
                            if (position === 'up') {
                                reordered = store.reorderNode(targetId, -1);
                            } else if (position === 'down') {
                                reordered = store.reorderNode(targetId, 1);
                            } else if (position === 'first' || position === 'last' || typeof position === 'number') {
                                reordered = store.reorderNodeToPosition(targetId, position);
                            }
                            if (reordered) {
                                result.success = true;
                                result.description = `Reordered node`;
                            } else {
                                result.description = `Reorder operation failed`;
                            }
                        }
                    } else if (action.action === 'focus') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            // Expand path to node
                            let current = targetId;
                            while (current && current !== store.data.id) {
                                const parent = store.findParent(current);
                                if (parent) store.expandedNodes.add(parent.id);
                                current = parent?.id;
                            }
                            buildScene();
                            setTimeout(() => {
                                const mesh = nodes.get(targetId);
                                if (mesh) {
                                    selectNode(mesh);
                                    focusOnNode(mesh);
                                }
                            }, 100);
                            result.success = true;
                            result.description = `Focused on node`;
                        }
                    } else if (action.action === 'expand') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            store.expandedNodes.add(targetId);
                            result.success = true;
                            result.description = `Expanded node`;
                        }
                    } else if (action.action === 'collapse') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            store.expandedNodes.delete(targetId);
                            result.success = true;
                            result.description = `Collapsed node`;
                        }
                    }
                    
                    results.push(result);
                } catch (e) {
                    results.push({ action: action.action, success: false, description: `Error: ${e.message}` });
                }
            }
            
            // Rebuild scene if any structural changes
            if (results.some(r => r.success && ['add', 'delete', 'move', 'expand', 'collapse'].includes(r.action))) {
                buildScene();
            }
            
            return results;
        },
        
        // Audio feedback for voice recording
        playVoiceSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                
                if (type === 'start') {
                    // Ascending tone for start
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'stop') {
                    // Descending tone for stop
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'error') {
                    // Low tone for error
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                }
            } catch (e) {
                // Audio not available, fail silently
                console.warn('Audio feedback not available:', e);
            }
        },
        
        startVoiceInput() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                showToast('Voice input not supported in this browser', 'error');
                return;
            }
            
            // Get overlay elements
            const overlay = document.getElementById('chat-voice-overlay');
            const status = document.getElementById('chat-voice-status');
            const cancelBtn = document.getElementById('chat-voice-cancel');
            const container = this.input.closest('.chat-input-container');
            
            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            // Store recognition instance for cancel
            this.activeRecognition = recognition;
            
            // Play start sound and show visual feedback
            this.playVoiceSound('start');
            this.voiceBtn.classList.add('recording');
            overlay.classList.add('active');
            if (container) container.classList.add('recording');
            status.textContent = 'Listening...';
            status.className = 'chat-voice-status recording';
            
            // Cancel button handler
            const handleCancel = () => {
                recognition.abort();
                this.cleanupVoiceUI();
            };
            cancelBtn.addEventListener('click', handleCancel, { once: true });
            
            recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                this.input.value = transcript;
                this.sendBtn.disabled = !transcript.trim();
                
                // Update status to show we're getting input
                if (transcript.trim()) {
                    status.textContent = 'Heard: ' + transcript.substring(0, 30) + (transcript.length > 30 ? '...' : '');
                }
            };
            
            recognition.onend = () => {
                // Play stop sound
                this.playVoiceSound('stop');
                
                // Update status briefly before hiding
                if (this.input.value.trim()) {
                    status.textContent = 'Processing...';
                    status.className = 'chat-voice-status processing';
                    
                    // Small delay to show processing state
                    setTimeout(() => {
                        this.cleanupVoiceUI();
                        this.sendMessage();
                    }, 200);
                } else {
                    this.cleanupVoiceUI();
                }
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                
                const errorMessages = {
                    'no-speech': 'No speech detected',
                    'audio-capture': 'No microphone found',
                    'not-allowed': 'Microphone access denied',
                    'network': 'Network error',
                    'aborted': null,
                    'service-not-allowed': 'Speech service not available'
                };
                
                const message = errorMessages[event.error];
                
                if (event.error !== 'aborted') {
                    this.playVoiceSound('error');
                }
                
                if (message) {
                    status.textContent = message;
                    status.className = 'chat-voice-status';
                    setTimeout(() => {
                        this.cleanupVoiceUI();
                        if (event.error !== 'no-speech') {
                            showToast(message, 'error', 3000);
                        }
                    }, 1000);
                } else {
                    this.cleanupVoiceUI();
                }
            };
            
            try {
                recognition.start();
            } catch (e) {
                this.playVoiceSound('error');
                this.cleanupVoiceUI();
                showToast('Could not start voice recognition', 'error');
                console.error('Recognition start error:', e);
            }
        },
        
        cleanupVoiceUI() {
            this.voiceBtn.classList.remove('recording', 'processing');
            const overlay = document.getElementById('chat-voice-overlay');
            if (overlay) overlay.classList.remove('active');
            const container = this.input?.closest('.chat-input-container');
            if (container) container.classList.remove('recording');
            this.activeRecognition = null;
        },
        
        saveConversation() {
            try {
                localStorage.setItem('mynd-chat-history', JSON.stringify(this.conversation));
            } catch (e) {
                console.warn('Failed to save chat history:', e);
            }
        },
        
        loadConversation() {
            try {
                const saved = localStorage.getItem('mynd-chat-history');
                if (saved) {
                    this.conversation = JSON.parse(saved);
                    // Render existing messages
                    const welcome = this.messagesContainer.querySelector('.chat-welcome');
                    if (this.conversation.length > 0 && welcome) {
                        welcome.style.display = 'none';
                    }
                    this.conversation.forEach(m => this.renderMessage(m));
                    this.scrollToBottom();
                }
            } catch (e) {
                console.warn('Failed to load chat history:', e);
            }
        },
        
        clearConversation() {
            this.conversation = [];
            localStorage.removeItem('mynd-chat-history');
            this.messagesContainer.innerHTML = `
                <div class="chat-welcome">
                    <div class="chat-welcome-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                        </svg>
                    </div>
                    <div class="chat-welcome-title">Hi, I'm your MYND assistant</div>
                    <div class="chat-welcome-text">
                        I can help you build and organize your mind map. Try asking me to:
                    </div>
                    <div class="chat-welcome-examples">
                        <button class="chat-example-btn">Help me brainstorm ideas for my goals</button>
                        <button class="chat-example-btn">What should I add to my fitness plan?</button>
                        <button class="chat-example-btn">Organize my project nodes</button>
                        <button class="chat-example-btn">What's the latest news on AI?</button>
                    </div>
                </div>
            `;
            // Re-attach example button handlers
            this.messagesContainer.querySelectorAll('.chat-example-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
            this.hideSuggestions();
            showToast('Conversation cleared', 'success');
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // VOICE AI SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const voiceAI = {
        recognition: null,
        isRecording: false,
        isProcessing: false,
        isSpeaking: false,
        apiKey: localStorage.getItem(CONFIG.API_KEY) || '',
        ttsEnabled: localStorage.getItem('mynd-tts-enabled') !== 'false', // Default on
        ttsVoice: null,
        
        // Text-to-Speech system
        initTTS() {
            if (!('speechSynthesis' in window)) {
                console.warn('Text-to-speech not supported');
                return false;
            }
            
            // Load voices (they load async)
            const loadVoices = () => {
                const voices = speechSynthesis.getVoices();
                if (voices.length === 0) return;
                
                // Prioritized voice selection for natural sound
                // macOS premium voices
                const preferredVoices = [
                    // macOS Siri/Premium voices (very natural)
                    v => v.name === 'Samantha',
                    v => v.name === 'Karen', // Australian, very clear
                    v => v.name === 'Daniel', // British, natural
                    v => v.name === 'Moira', // Irish
                    v => v.name === 'Tessa', // South African
                    // Microsoft Edge neural voices (Windows/Edge)
                    v => v.name.includes('Microsoft') && v.name.includes('Natural'),
                    v => v.name.includes('Aria') && v.name.includes('Natural'),
                    v => v.name.includes('Jenny') && v.name.includes('Natural'),
                    v => v.name.includes('Guy') && v.name.includes('Natural'),
                    // Google Chrome voices
                    v => v.name === 'Google UK English Female',
                    v => v.name === 'Google UK English Male',
                    v => v.name === 'Google US English',
                    // iOS/Safari premium
                    v => v.name.includes('Siri') && v.lang.startsWith('en'),
                    // Any "Premium" or "Enhanced" voice
                    v => v.name.includes('Premium') && v.lang.startsWith('en'),
                    v => v.name.includes('Enhanced') && v.lang.startsWith('en'),
                    // Fallbacks
                    v => v.name.includes('Google') && v.lang.startsWith('en'),
                    v => v.name.includes('Natural') && v.lang.startsWith('en'),
                    v => v.lang === 'en-GB' && v.localService,
                    v => v.lang === 'en-US' && v.localService,
                    v => v.lang.startsWith('en-') && v.localService,
                    v => v.lang.startsWith('en'),
                ];
                
                for (const test of preferredVoices) {
                    const voice = voices.find(test);
                    if (voice) {
                        this.ttsVoice = voice;
                        break;
                    }
                }
                
                if (!this.ttsVoice) {
                    this.ttsVoice = voices[0];
                }
                
                console.log('TTS voice selected:', this.ttsVoice?.name, `(${this.ttsVoice?.lang})`);
            };
            
            loadVoices();
            speechSynthesis.onvoiceschanged = loadVoices;
            
            return true;
        },
        
        speak(text, options = {}) {
            if (!this.ttsEnabled || !('speechSynthesis' in window)) return;
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            // Clean up text for more natural speech
            let cleanText = text
                .replace(/[*_`#]/g, '') // Remove markdown
                .replace(/\bhttps?:\/\/\S+/g, '') // Remove URLs entirely (sounds awkward)
                .replace(/\([^)]*\)/g, '') // Remove parentheticals (often awkward when spoken)
                .replace(/\s*[,;]\s*/g, ', ') // Normalize punctuation spacing
                .replace(/\s*\.\s*/g, '. ') // Add slight pause after periods
                .replace(/\s+/g, ' ') // Normalize whitespace
                .replace(/\n+/g, '. ') // Replace newlines with pause
                .trim();
            
            // Limit length but try to end at a sentence
            if (cleanText.length > 500) {
                const truncated = cleanText.substring(0, 500);
                const lastSentence = truncated.lastIndexOf('. ');
                if (lastSentence > 300) {
                    cleanText = truncated.substring(0, lastSentence + 1);
                } else {
                    cleanText = truncated + '...';
                }
            }
            
            const utterance = new SpeechSynthesisUtterance(cleanText);
            
            if (this.ttsVoice) {
                utterance.voice = this.ttsVoice;
            }
            
            // Tuned for natural conversation
            utterance.rate = options.rate || 1.0; // Normal speed sounds more natural
            utterance.pitch = options.pitch || 1.0;
            utterance.volume = options.volume || 0.9;
            
            utterance.onstart = () => {
                this.isSpeaking = true;
                this.updateUI('speaking');
            };
            
            utterance.onend = () => {
                this.isSpeaking = false;
                if (!this.isRecording && !this.isProcessing) {
                    this.updateUI('idle');
                }
            };
            
            utterance.onerror = (e) => {
                console.warn('TTS error:', e);
                this.isSpeaking = false;
            };
            
            speechSynthesis.speak(utterance);
        },
        
        stopSpeaking() {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            this.isSpeaking = false;
        },
        
        toggleTTS() {
            this.ttsEnabled = !this.ttsEnabled;
            localStorage.setItem('mynd-tts-enabled', this.ttsEnabled);
            showToast(this.ttsEnabled ? 'Voice responses enabled' : 'Voice responses disabled', 'info');
            return this.ttsEnabled;
        },
        
        init() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Speech recognition not supported');
                return false;
            }
            
            this.recognition = new SpeechRecognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = true;
            this.recognition.lang = 'en-US';
            
            this.recognition.onstart = () => {
                console.log('Voice recognition started');
            };
            
            this.recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                document.getElementById('voice-transcript').textContent = transcript || 'Listening...';
            };
            
            this.recognition.onend = () => {
                if (this.isRecording) {
                    const transcript = document.getElementById('voice-transcript').textContent;
                    if (transcript && transcript !== 'Listening...' && transcript !== 'Say something...') {
                        this.processWithAI(transcript);
                    } else {
                        this.stop();
                    }
                }
            };
            
            this.recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showToast('Microphone access denied', 'error');
                }
                this.stop();
            };
            
            // Initialize TTS
            this.initTTS();
            
            return true;
        },
        
        async start() {
            console.log('Voice memo start called');
            
            // Check if user is authenticated OR has API key
            let isAuthenticated = false;
            if (typeof supabase !== 'undefined' && supabase !== null) {
                const { data } = await supabase.auth.getSession();
                isAuthenticated = !!data?.session;
            }
            
            if (!isAuthenticated && !this.apiKey) {
                // Not authenticated and no API key - prompt to sign in
                showToast('Sign in for AI features', 'info');
                // Open auth modal instead
                document.getElementById('auth-modal').classList.add('active');
                return;
            }
            
            // Show UI immediately - even if voice isn't supported, text input will work
            this.isRecording = true;
            this.updateUI('recording');
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            // Try to initialize speech recognition
            if (!this.recognition && !this.init()) {
                // Voice not supported, but text input still works
                console.warn('Voice not supported, text input available');
                document.getElementById('voice-status').textContent = 'Voice not supported - use text';
                document.getElementById('voice-transcript').textContent = 'Click "Type" to enter your request';
                // Don't stop - let user switch to text mode
                return;
            }
            
            try {
                this.recognition.start();
                haptic.medium();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                // Don't hide UI - let user switch to text mode
                document.getElementById('voice-status').textContent = 'Voice unavailable - use text';
                document.getElementById('voice-transcript').textContent = 'Click "Type" to enter your request';
            }
        },
        
        // Start only the recording part (called from mode toggle)
        startRecording() {
            if (!this.recognition && !this.init()) {
                showToast('Voice not supported in this browser', 'error');
                return;
            }
            
            this.isRecording = true;
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            try {
                this.recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }
        },
        
        stop() {
            this.isRecording = false;
            this.isProcessing = false;
            if (this.recognition) {
                try { this.recognition.stop(); } catch (e) {}
            }
            this.stopSpeaking();
            this.updateUI('idle');
        },
        
        updateUI(state) {
            const voiceBtn = document.getElementById('btn-voice');
            const indicator = document.getElementById('voice-indicator');
            const backdrop = document.getElementById('voice-backdrop');
            const icon = document.getElementById('voice-icon');
            const micIcon = document.getElementById('voice-icon-mic');
            const brainIcon = document.getElementById('voice-icon-brain');
            const status = document.getElementById('voice-status');
            
            voiceBtn.classList.remove('recording', 'processing', 'active');
            indicator.classList.remove('active');
            backdrop.classList.remove('active');
            icon.classList.remove('recording', 'processing');
            
            if (state === 'recording') {
                voiceBtn.classList.add('recording');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('recording');
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                status.textContent = 'Listening...';
            } else if (state === 'processing') {
                voiceBtn.classList.add('processing');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('processing');
                micIcon.style.display = 'none';
                brainIcon.style.display = 'block';
                status.textContent = 'Thinking...';
            } else {
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                
                // Reset to speak mode
                const speakBtn = document.getElementById('voice-mode-speak');
                const typeBtn = document.getElementById('voice-mode-type');
                if (speakBtn) speakBtn.classList.add('active');
                if (typeBtn) typeBtn.classList.remove('active');
                document.getElementById('voice-icon').style.display = 'block';
                document.getElementById('voice-status').style.display = 'block';
                document.getElementById('voice-transcript').style.display = 'block';
                const textWrapper = document.getElementById('voice-text-wrapper');
                if (textWrapper) textWrapper.style.display = 'none';
                const textInput = document.getElementById('voice-text-input');
                if (textInput) textInput.value = '';
                document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
            }
        },
        
        async processWithAI(transcript) {
            console.log('processWithAI called with:', transcript);
            this.isRecording = false;
            this.isProcessing = true;
            this.updateUI('processing');
            
            // Check if user is authenticated with Supabase
            let session = null;
            if (typeof supabase !== 'undefined' && supabase !== null) {
                const { data } = await supabase.auth.getSession();
                session = data?.session;
            }
            
            // Refresh API key from localStorage (in case it was updated)
            this.apiKey = localStorage.getItem(CONFIG.API_KEY) || '';
            
            // Check for authentication or API key
            if (!session?.access_token && !this.apiKey) {
                console.error('No auth or API key!');
                showToast('Sign in for AI features', 'error');
                document.getElementById('auth-modal').classList.add('active');
                this.stop();
                return;
            }
            
            console.log('Auth or API key exists, proceeding with AI request...');
            
            // Fix common speech recognition errors
            let cleanedTranscript = transcript.trim()
                .replace(/\bnote\b/gi, 'node')
                .replace(/\bnotes\b/gi, 'nodes')
                .replace(/\bknow\b/gi, 'node')
                .replace(/\bno\b(?=\s+called)/gi, 'node')
                .replace(/\bmode\b(?=\s+called)/gi, 'node')
                .replace(/\badd a no\b/gi, 'add a node')
                .replace(/\bnew no\b/gi, 'new node')
                .replace(/\bcreate a no\b/gi, 'create a node');
            
            console.log('Original transcript:', transcript);
            console.log('Cleaned transcript:', cleanedTranscript);
            
            try {
                // ═══════════════════════════════════════════════════════════
                // GATHER NEURAL NETWORK CONTEXT (if available)
                // ═══════════════════════════════════════════════════════════
                let neuralContext = '';
                
                if (neuralNet.isReady || userProfile.loaded) {
                    try {
                        const allNodes = store.getAllNodes();
                        
                        // Run queries in parallel for speed
                        const [categoryPredictions, similarNodes, connectionPrediction] = await Promise.all([
                            neuralNet.isReady ? neuralNet.predictCategory(cleanedTranscript) : null,
                            neuralNet.isReady ? neuralNet.findSimilarNodes(cleanedTranscript, store, 5) : [],
                            neuralNet.isReady && selectedNode ? 
                                neuralNet.predictConnection(cleanedTranscript, selectedNode.userData.label) : null
                        ]);
                        
                        const stats = neuralNet.isReady ? neuralNet.getStats() : { totalPatterns: 0 };
                        
                        neuralContext += `\n═══ NEURAL INTELLIGENCE (learned from this user's patterns) ═══\n`;
                        
                        // 1. CATEGORY PREDICTIONS
                        if (categoryPredictions && categoryPredictions.length > 0) {
                            const topPredictions = categoryPredictions
                                .filter(p => p.confidence > 0.15)
                                .slice(0, 3);
                            
                            if (topPredictions.length > 0) {
                                neuralContext += `\n📁 CATEGORY PREDICTIONS:\n`;
                                for (const pred of topPredictions) {
                                    const matchingNode = allNodes.find(n => 
                                        n.label.toLowerCase() === pred.category.toLowerCase() ||
                                        n.label.toLowerCase().includes(pred.category.toLowerCase())
                                    );
                                    if (matchingNode) {
                                        neuralContext += `   • ${pred.category}: ${Math.round(pred.confidence * 100)}% confident → use parentId: "${matchingNode.id}"\n`;
                                    } else {
                                        neuralContext += `   • ${pred.category}: ${Math.round(pred.confidence * 100)}% confident (no matching node in tree)\n`;
                                    }
                                }
                            }
                        }
                        
                        // 2. SIMILAR NODES (semantic matches)
                        if (similarNodes && similarNodes.length > 0) {
                            const topSimilar = similarNodes
                                .filter(s => s.similarity > 0.25)
                                .slice(0, 5);
                            
                            if (topSimilar.length > 0) {
                                neuralContext += `\n🔗 SIMILAR EXISTING NODES:\n`;
                                for (const s of topSimilar) {
                                    const node = store.findNode(s.nodeId);
                                    const parent = store.findParent(s.nodeId);
                                    if (node) {
                                        neuralContext += `   • "${node.label}" under "${parent?.label || 'root'}" (${Math.round(s.similarity * 100)}% similar) → sibling parentId: "${parent?.id || store.data.id}"\n`;
                                    }
                                }
                            }
                        }
                        
                        // 3. CONNECTION PREDICTION (relationship to selected node)
                        if (connectionPrediction && selectedNode) {
                            neuralContext += `\n🔀 RELATIONSHIP TO SELECTED NODE "${selectedNode.userData.label}":\n`;
                            if (connectionPrediction.isParentChild > 0.5) {
                                neuralContext += `   • Should be CHILD of selected (${Math.round(connectionPrediction.isParentChild * 100)}% confident)\n`;
                            }
                            if (connectionPrediction.isSibling > 0.5) {
                                const parent = store.findParent(selectedNode.userData.id);
                                neuralContext += `   • Should be SIBLING (${Math.round(connectionPrediction.isSibling * 100)}% confident) → use parentId: "${parent?.id || store.data.id}"\n`;
                            }
                            if (connectionPrediction.shouldConnect < 0.3) {
                                neuralContext += `   • NOT related to selected node - find better parent from categories above\n`;
                            }
                        }
                        
                        // 4. EXPANSION PATTERNS (typical children for parent types)
                        if (neuralNet.expansionPatterns && neuralNet.expansionPatterns.size > 0) {
                            // Find patterns relevant to this input
                            const relevantPatterns = [];
                            for (const [parentLabel, children] of neuralNet.expansionPatterns) {
                                if (cleanedTranscript.toLowerCase().includes(parentLabel.toLowerCase()) ||
                                    parentLabel.toLowerCase().includes(cleanedTranscript.toLowerCase().split(' ')[0])) {
                                    relevantPatterns.push({ parent: parentLabel, children: children.slice(0, 5) });
                                }
                            }
                            if (relevantPatterns.length > 0) {
                                neuralContext += `\n📊 LEARNED EXPANSION PATTERNS:\n`;
                                for (const p of relevantPatterns.slice(0, 2)) {
                                    neuralContext += `   • Under "${p.parent}", user typically adds: ${p.children.join(', ')}\n`;
                                }
                            }
                        }
                        
                        // 5. COLOR PREFERENCES (from user profile and pattern analysis)
                        const colorPrefs = analyzeColorPreferences(store, allNodes);
                        if (colorPrefs.categoryColors.size > 0) {
                            neuralContext += `\n🎨 USER'S COLOR PREFERENCES:\n`;
                            for (const [category, color] of Array.from(colorPrefs.categoryColors).slice(0, 5)) {
                                neuralContext += `   • ${category} nodes: ${color}\n`;
                            }
                            if (colorPrefs.mostUsedColor) {
                                neuralContext += `   • Most used color overall: ${colorPrefs.mostUsedColor}\n`;
                            }
                        }
                        
                        // 6. NAMING STYLE (analyze user's labeling patterns)
                        const namingStyle = analyzeNamingStyle(allNodes);
                        if (namingStyle) {
                            neuralContext += `\n✏️ USER'S NAMING STYLE:\n`;
                            neuralContext += `   • Average label length: ${namingStyle.avgLength} words\n`;
                            neuralContext += `   • Style: ${namingStyle.style}\n`;
                            if (namingStyle.commonPrefixes.length > 0) {
                                neuralContext += `   • Common prefixes: ${namingStyle.commonPrefixes.join(', ')}\n`;
                            }
                        }
                        
                        // 7. MISSING SIBLINGS (gaps in structure)
                        const missingSiblings = findMissingSiblings(store, cleanedTranscript, allNodes);
                        if (missingSiblings.length > 0) {
                            neuralContext += `\n🧩 POTENTIAL GAPS (common patterns not in tree):\n`;
                            for (const gap of missingSiblings.slice(0, 3)) {
                                neuralContext += `   • "${gap.parent}" is missing typical child: "${gap.suggestion}"\n`;
                            }
                        }
                        
                        // 8. HIERARCHY DEPTH PREFERENCE
                        const depthStats = analyzeHierarchyDepth(store.data);
                        neuralContext += `\n📐 STRUCTURE PREFERENCES:\n`;
                        neuralContext += `   • Average depth: ${depthStats.avgDepth.toFixed(1)} levels\n`;
                        neuralContext += `   • Max depth: ${depthStats.maxDepth} levels\n`;
                        neuralContext += `   • Preference: ${depthStats.avgDepth < 2.5 ? 'FLAT structure' : depthStats.avgDepth > 4 ? 'DEEP nesting' : 'MODERATE nesting'}\n`;
                        
                        // 9. NODE IMPORTANCE (most interacted branches)
                        if (userProfile.categoryStats?.interactions) {
                            const topCategories = Object.entries(userProfile.categoryStats.interactions)
                                .map(([cat, data]) => [cat, data.views + data.edits * 2 + data.expansions])
                                .sort((a, b) => b[1] - a[1])
                                .slice(0, 3);
                            if (topCategories.length > 0) {
                                neuralContext += `\n⭐ MOST ACTIVE BRANCHES:\n`;
                                for (const [cat, score] of topCategories) {
                                    neuralContext += `   • "${cat}" (engagement score: ${Math.round(score)})\n`;
                                }
                            }
                        }
                        
                        // 10. TIME CONTEXT (when user typically works on what)
                        const currentHour = new Date().getHours();
                        if (userProfile.timeStats?.hourlyActivity) {
                            const hourlyActivity = userProfile.timeStats.hourlyActivity;
                            const peakHour = hourlyActivity.indexOf(Math.max(...hourlyActivity));
                            const isActiveTime = hourlyActivity[currentHour] > (Math.max(...hourlyActivity) * 0.5);
                            neuralContext += `\n🕐 TIME CONTEXT:\n`;
                            neuralContext += `   • Current hour: ${currentHour}:00 (${isActiveTime ? 'typically active' : 'less active'} time)\n`;
                            neuralContext += `   • Peak activity hour: ${peakHour}:00\n`;
                        }
                        
                        // 11. SESSION CONTEXT (what user has been working on this session)
                        if (userProfile.currentSession?.categories?.size > 0) {
                            const sessionCategories = Array.from(userProfile.currentSession.categories);
                            neuralContext += `\n📍 THIS SESSION:\n`;
                            neuralContext += `   • Working on: ${sessionCategories.join(', ')}\n`;
                            neuralContext += `   • Nodes created this session: ${userProfile.currentSession.nodeCount}\n`;
                        }
                        
                        // Summary guidance
                        neuralContext += `\n═══ PLACEMENT GUIDANCE ═══\n`;
                        neuralContext += `Use the node IDs from predictions above. Prioritize:\n`;
                        neuralContext += `1. High-confidence category matches (>50%)\n`;
                        neuralContext += `2. Similar node siblings (>60% similarity)\n`;
                        neuralContext += `3. Connection predictions for relationship to selected\n`;
                        neuralContext += `4. Match user's color and naming style\n`;
                        
                        // Add AI Feedback stats
                        try {
                            const feedbackStats = AIFeedback.getStats('category');
                            if (feedbackStats && feedbackStats.total >= 3) {
                                const rate = Math.round(feedbackStats.acceptanceRate * 100);
                                neuralContext += `\n═══ USER FEEDBACK ON PREDICTIONS ═══\n`;
                                neuralContext += `Category prediction acceptance: ${rate}% (${feedbackStats.total} samples)\n`;
                                if (rate < 40) {
                                    neuralContext += `⚠️ User often overrides predictions - offer alternatives\n`;
                                } else if (rate >= 70) {
                                    neuralContext += `✓ User trusts predictions - be confident\n`;
                                }
                            }
                        } catch (e) {}
                        
                    } catch (neuralError) {
                        console.warn('Could not get neural context:', neuralError);
                    }
                }
                
                // Helper functions for neural analysis
                function analyzeColorPreferences(store, allNodes) {
                    const categoryColors = new Map();
                    const colorCounts = new Map();
                    
                    // Analyze top-level nodes and their colors
                    if (store.data.children) {
                        for (const child of store.data.children) {
                            if (child.color) {
                                categoryColors.set(child.label, child.color);
                            }
                        }
                    }
                    
                    // Count all colors
                    for (const node of allNodes) {
                        if (node.color) {
                            colorCounts.set(node.color, (colorCounts.get(node.color) || 0) + 1);
                        }
                    }
                    
                    // Find most used color
                    let mostUsedColor = null;
                    let maxCount = 0;
                    for (const [color, count] of colorCounts) {
                        if (count > maxCount) {
                            maxCount = count;
                            mostUsedColor = color;
                        }
                    }
                    
                    return { categoryColors, mostUsedColor };
                }
                
                function analyzeNamingStyle(allNodes) {
                    if (allNodes.length < 5) return null;
                    
                    const labels = allNodes.map(n => n.label);
                    const wordCounts = labels.map(l => l.split(/\s+/).length);
                    const avgLength = wordCounts.reduce((a, b) => a + b, 0) / wordCounts.length;
                    
                    // Detect common prefixes
                    const prefixes = new Map();
                    for (const label of labels) {
                        const firstWord = label.split(/\s+/)[0];
                        if (firstWord.length > 2) {
                            prefixes.set(firstWord, (prefixes.get(firstWord) || 0) + 1);
                        }
                    }
                    const commonPrefixes = Array.from(prefixes.entries())
                        .filter(([_, count]) => count >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([prefix]) => prefix);
                    
                    // Determine style
                    let style = 'Mixed';
                    const allCaps = labels.filter(l => l === l.toUpperCase()).length;
                    const allLower = labels.filter(l => l === l.toLowerCase()).length;
                    const titleCase = labels.filter(l => /^[A-Z][a-z]/.test(l)).length;
                    
                    if (avgLength <= 2) style = 'Concise (1-2 words)';
                    else if (avgLength <= 4) style = 'Moderate (2-4 words)';
                    else style = 'Descriptive (4+ words)';
                    
                    if (titleCase > labels.length * 0.7) style += ', Title Case';
                    
                    return { avgLength: Math.round(avgLength * 10) / 10, style, commonPrefixes };
                }
                
                function findMissingSiblings(store, input, allNodes) {
                    const suggestions = [];
                    
                    // Common patterns
                    const commonPatterns = {
                        'fitness': ['Cardio', 'Strength', 'Flexibility', 'Nutrition'],
                        'health': ['Exercise', 'Diet', 'Sleep', 'Mental Health'],
                        'work': ['Projects', 'Meetings', 'Goals', 'Tasks'],
                        'projects': ['Planning', 'Execution', 'Review'],
                        'goals': ['Short-term', 'Long-term', 'Daily'],
                        'learning': ['Books', 'Courses', 'Practice'],
                        'finance': ['Income', 'Expenses', 'Savings', 'Investments'],
                        'personal': ['Health', 'Relationships', 'Hobbies', 'Growth']
                    };
                    
                    for (const node of allNodes) {
                        const key = node.label.toLowerCase();
                        if (commonPatterns[key]) {
                            const existingChildren = (node.children || []).map(c => c.label.toLowerCase());
                            for (const expected of commonPatterns[key]) {
                                if (!existingChildren.some(e => e.includes(expected.toLowerCase()))) {
                                    suggestions.push({ parent: node.label, suggestion: expected });
                                }
                            }
                        }
                    }
                    
                    return suggestions;
                }
                
                function analyzeHierarchyDepth(root, depth = 0, depths = []) {
                    depths.push(depth);
                    if (root.children) {
                        for (const child of root.children) {
                            analyzeHierarchyDepth(child, depth + 1, depths);
                        }
                    }
                    
                    const maxDepth = Math.max(...depths);
                    const avgDepth = depths.reduce((a, b) => a + b, 0) / depths.length;
                    
                    return { maxDepth, avgDepth };
                }
                
                // Build context about current mind map with proper parent tracking
                const buildNodeList = (node, parentId = null, list = []) => {
                    list.push({
                        id: node.id,
                        label: node.label,
                        parentId: parentId,
                        hasChildren: node.children && node.children.length > 0
                    });
                    if (node.children) {
                        node.children.forEach(child => buildNodeList(child, node.id, list));
                    }
                    return list;
                };
                const nodeContext = buildNodeList(store.data).slice(0, 60);
                
                const selectedNodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
                const currentContext = selectedNodeData 
                    ? `"${selectedNodeData.label}" (id: ${selectedNodeData.id})${selectedNodeData.description ? ' - ' + selectedNodeData.description.substring(0, 50) : ''}`
                    : 'None (will default to root)';
                
                // Build tree structure string for better visualization
                const buildTreeString = (nodes, parentId = null, depth = 0) => {
                    const children = nodes.filter(n => n.parentId === parentId);
                    return children.map(n => {
                        const indent = '  '.repeat(depth);
                        const childStr = buildTreeString(nodes, n.id, depth + 1);
                        return `${indent}- ${n.label} (${n.id})${childStr ? '\n' + childStr : ''}`;
                    }).join('\n');
                };
                const treeStructure = buildTreeString(nodeContext);
                
                const prompt = `You are the AI companion for MYND — a personalized second brain. You help capture fragmented thoughts, surface hidden connections, and turn ideas into action. Every input is a precious fragment of the user's thinking — help weave it into their larger vision. Be anticipatory, intuitive, almost like reading their mind.

=== QUICK APP REFERENCE ===
MYND is a 3D spatial mind map. Nodes are spheres connected hierarchically. Users click to select/expand, drag to rotate view.
- Sidebar: Home, Expand/Collapse, Auto Cam, Add, Link, Move, Memo (me), Chat, Neural
- Quick capture bar at bottom for fast node creation
- Neural network learns user patterns (categories, colors, naming style)
- Info panel (left) shows selected node details
- Cloud sync for signed-in users
- Themes: Default, Coral, Frost, Obsidian, Sakura
=== END REFERENCE ===

USER INPUT: "${cleanedTranscript}"

SELECTED NODE: ${currentContext || 'None selected'}
${neuralContext}
CURRENT MAP STRUCTURE (with node IDs):
${treeStructure || '(empty map)'}

AVAILABLE ACTIONS:
1. "add" - Create new node(s)
2. "edit" - Modify existing node (label, description, color)
3. "delete" - Remove a node
4. "move" - Move node to different parent
5. "focus" - Navigate to a node
6. "expand" - Expand a collapsed node
7. "collapse" - Collapse an expanded node
8. "respond" - Just answer a question WITHOUT creating a node (use for factual queries, current info, etc.)

RESPONSE FORMAT (JSON only):
{
  "actions": [
    {
      "action": "add|edit|delete|move|focus|expand|collapse|respond",
      "label": "Node name (for add)",
      "description": "2-3 sentences (for add/edit)",
      "color": "#HEX or null (for add/edit)",
      "parentId": "node-id, 'selected', 'root', or 'PREV_N' (for add/move)",
      "targetId": "node-id to act on (for edit/delete/move/focus/expand/collapse)",
      "message": "Response text to show user (for respond action)",
      "offerToAdd": true/false (for respond - offer to create a node with this info)
    }
  ]
}

AVAILABLE COLORS:
- Red: #EF4444
- Orange: #EF8354
- Yellow: #F7B731
- Green: #26DE81
- Teal: #4ECDC4
- Blue: #45B7D1
- Purple: #9B5DE5
- Pink: #FF6B9D
- Lavender: #A29BFE

**USING NEURAL INTELLIGENCE:**
The NEURAL INTELLIGENCE section above contains learned patterns from THIS SPECIFIC USER. Use it to make smart decisions:

📁 CATEGORY PREDICTIONS: Place nodes under the suggested category with highest confidence. Use the provided parentId directly.

🔗 SIMILAR NODES: If input is similar to existing nodes, place as sibling (same parent) or child of that branch.

🔀 RELATIONSHIP TO SELECTED: Use this to decide if new content should be:
   - CHILD of selected node (isParentChild > 50%)
   - SIBLING of selected (isSibling > 50%) 
   - SOMEWHERE ELSE (shouldConnect < 30%)

📊 EXPANSION PATTERNS: Follow the user's established patterns for child nodes.

🎨 COLOR PREFERENCES: Match colors to categories. If user always uses green for Health, use green for health-related nodes.

✏️ NAMING STYLE: Match the user's labeling style:
   - If "Concise (1-2 words)", use short labels like "Budget" not "Personal Budget Management"
   - If "Descriptive (4+ words)", use fuller labels
   - Follow any common prefixes the user uses

🧩 POTENTIAL GAPS: If a gap is mentioned that matches user input, fill it!

📐 STRUCTURE PREFERENCES: 
   - FLAT preference: Add to existing categories, don't create deep nesting
   - DEEP preference: OK to create sub-sub-categories

⭐ MOST ACTIVE BRANCHES: Prefer placing in user's most-used areas when relevant.

🕐 TIME CONTEXT: Consider what the user typically works on at this time.

📍 SESSION CONTEXT: Prefer branches the user is currently working on this session.

=== EXAMPLES ===

**ADDING NODES:**

User: "add a node called Morning Routine"
{"actions":[{"action":"add","label":"Morning Routine","description":"A structured sequence of activities to start each day with intention, energy, and clarity.","color":null,"parentId":"selected"}]}

User: "create three nodes for my workout: cardio, strength, flexibility"
{"actions":[{"action":"add","label":"Cardio","description":"Cardiovascular exercises to improve heart health and endurance.","color":"#EF4444","parentId":"selected"},{"action":"add","label":"Strength","description":"Resistance training to build muscle and increase metabolism.","color":"#EF8354","parentId":"selected"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work to prevent injury and improve range of motion.","color":"#4ECDC4","parentId":"selected"}]}

User: "what is machine learning" (tree has "AI (node-ai123)")
{"actions":[{"action":"add","label":"Machine Learning","description":"A subset of artificial intelligence where systems learn and improve from experience without being explicitly programmed. Uses algorithms to find patterns in data and make predictions or decisions.","color":null,"parentId":"node-ai123"}]}

User: "add project alpha under work with subitems planning and execution"
{"actions":[{"action":"add","label":"Project Alpha","description":"A major initiative requiring structured planning and careful execution.","color":"#9B5DE5","parentId":"work"},{"action":"add","label":"Planning","description":"Initial phase covering requirements, timeline, and resource allocation.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Execution","description":"Implementation phase where planned tasks are carried out.","color":null,"parentId":"PREV_0"}]}

User: "remind me to call mom"
{"actions":[{"action":"add","label":"Call Mom","description":"Remember to check in with mom. Consider scheduling a regular time for these calls.","color":"#FF6B9D","parentId":"selected"}]}

User: "I want to learn Spanish this year"
{"actions":[{"action":"add","label":"Learn Spanish","description":"Goal to achieve conversational Spanish fluency. Consider apps like Duolingo, classes, or conversation partners.","color":"#F7B731","parentId":"root"}]}

**NEURAL-GUIDED PLACEMENT (using all intelligence):**

User: "meditation benefits"
Neural: Category=Health(72%), Similar="Mindfulness" under Health, Color=Health uses #4ECDC4
{"actions":[{"action":"add","label":"Meditation Benefits","description":"Regular meditation practice offers reduced stress, improved focus, better emotional regulation, and enhanced overall wellbeing.","color":"#4ECDC4","parentId":"node-health123"}]}

User: "need to fix that bug"
Neural: Category=Work(68%), Active branch=Work, Session focus=Work, Naming=Concise
{"actions":[{"action":"add","label":"Bug Fix","description":"Technical issue requiring investigation and resolution.","color":null,"parentId":"node-work123"}]}

User: "random thought about saving money"
Neural: Similar="Budget" under Finance (65%), Gap="Finance missing Savings"
{"actions":[{"action":"add","label":"Savings","description":"Ideas and strategies for building financial reserves and reducing unnecessary spending.","color":"#26DE81","parentId":"node-finance456"}]}

User: "I should start running more"
Neural: Category=Fitness(80%), Expansion pattern="Under Fitness: Cardio, Strength, Nutrition", Similar="Cardio"(70%)
{"actions":[{"action":"add","label":"Running","description":"Cardiovascular exercise through running to improve endurance and overall health.","color":null,"parentId":"node-cardio789"}]}

User: "productivity hack I learned"
Neural: Relationship to selected=SIBLING(65%), Time=Morning(work time), Active=Personal Development
{"actions":[{"action":"add","label":"Productivity Hack","description":"Useful technique for getting more done with less effort and better focus.","color":null,"parentId":"node-personaldev123"}]}

**VAGUE INPUT HANDLING (neural is crucial here):**

User: "hmm just thinking about stuff"
Neural: Session focus=Work, Recent edits=Project X, Time=Afternoon
{"actions":[{"action":"add","label":"Project Thoughts","description":"General reflections and ideas related to current work focus.","color":null,"parentId":"node-work123"}]}

User: "something to remember"
Neural: Active branch=Tasks, Category=Personal(45%)
{"actions":[{"action":"add","label":"Quick Note","description":"Important thought or reminder to capture for later review.","color":"#F7B731","parentId":"selected"}]}

User: "that thing I saw online"
Neural: Similar="Bookmarks"(55%), Category=Resources(40%)
{"actions":[{"action":"add","label":"Web Discovery","description":"Interesting content found online worth saving for reference.","color":null,"parentId":"node-resources123"}]}

**EDITING NODES:**

User: "make the fitness node green"
{"actions":[{"action":"edit","targetId":"node-fitness123","color":"#26DE81"}]}

User: "change Morning Routine to green"
{"actions":[{"action":"edit","targetId":"node-morning456","color":"#26DE81"}]}

User: "rename meditation to mindfulness practice"
{"actions":[{"action":"edit","targetId":"node-meditation789","label":"Mindfulness Practice"}]}

User: "update the description of Project Alpha to say it's due next month"
{"actions":[{"action":"edit","targetId":"node-alpha123","description":"A major initiative due next month requiring structured planning and execution."}]}

User: "make work node orange and rename it to Career"
{"actions":[{"action":"edit","targetId":"node-work123","label":"Career","color":"#EF8354"}]}

User: "change the color of all my health nodes to teal" (health has id node-health1)
{"actions":[{"action":"edit","targetId":"node-health1","color":"#4ECDC4"}]}

User: "mark reading as purple"
{"actions":[{"action":"edit","targetId":"node-reading123","color":"#9B5DE5"}]}

User: "set the selected node to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

**DELETING NODES:**

User: "delete the meditation node"
{"actions":[{"action":"delete","targetId":"node-meditation789"}]}

User: "remove Project Beta"
{"actions":[{"action":"delete","targetId":"node-beta456"}]}

User: "get rid of the selected node"
{"actions":[{"action":"delete","targetId":"selected"}]}

**MOVING NODES:**

User: "move meditation under health"
{"actions":[{"action":"move","targetId":"node-meditation789","parentId":"node-health123"}]}

User: "put the reading node under personal development"
{"actions":[{"action":"move","targetId":"node-reading456","parentId":"node-personal789"}]}

User: "move project alpha to the root"

**REORDERING NODES (within siblings):**

User: "move budget to the first position"
{"actions":[{"action":"reorder","targetId":"node-budget123","position":"first"}]}

User: "put exercise before nutrition"
{"actions":[{"action":"reorder","targetId":"node-exercise456","position":"up"}]}

User: "move reading to the end"
{"actions":[{"action":"reorder","targetId":"node-reading789","position":"last"}]}

User: "move this node up"
{"actions":[{"action":"reorder","targetId":"selected","position":"up"}]}
{"actions":[{"action":"move","targetId":"node-alpha123","parentId":"root"}]}

**NAVIGATION:**

User: "go to the fitness node"
{"actions":[{"action":"focus","targetId":"node-fitness123"}]}

User: "show me my goals"
{"actions":[{"action":"focus","targetId":"node-goals456"}]}

User: "take me to work"
{"actions":[{"action":"focus","targetId":"node-work789"}]}

User: "find the meditation node"
{"actions":[{"action":"focus","targetId":"node-meditation123"}]}

**EXPAND/COLLAPSE:**

User: "expand the work node"
{"actions":[{"action":"expand","targetId":"node-work123"}]}

User: "collapse personal"
{"actions":[{"action":"collapse","targetId":"node-personal456"}]}

User: "open up my goals"
{"actions":[{"action":"expand","targetId":"node-goals789"}]}

User: "close the projects section"
{"actions":[{"action":"collapse","targetId":"node-projects123"}]}

**COMPLEX MULTI-ACTION:**

User: "create a new category called side projects with two items: app idea and blog"
{"actions":[{"action":"add","label":"Side Projects","description":"Personal projects pursued outside of main work for learning and creativity.","color":"#9B5DE5","parentId":"root"},{"action":"add","label":"App Idea","description":"Concept for a mobile or web application to develop.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Blog","description":"Personal blog for sharing thoughts, tutorials, or experiences.","color":null,"parentId":"PREV_0"}]}

User: "move reading to hobbies and make it blue"
{"actions":[{"action":"move","targetId":"node-reading123","parentId":"node-hobbies456"},{"action":"edit","targetId":"node-reading123","color":"#45B7D1"}]}

User: "delete the old project and add a new one called Project Phoenix"
{"actions":[{"action":"delete","targetId":"node-oldproject123"},{"action":"add","label":"Project Phoenix","description":"New initiative rising from lessons learned in previous projects.","color":"#EF8354","parentId":"selected"}]}

**CONVERSATIONAL/QUESTION INPUTS:**

User: "I'm feeling stressed about deadlines"
{"actions":[{"action":"add","label":"Deadline Stress","description":"Feeling overwhelmed by upcoming deadlines. Consider breaking tasks into smaller chunks, prioritizing ruthlessly, and scheduling breaks.","color":"#EF4444","parentId":"selected"}]}

User: "how do I stay motivated"
{"actions":[{"action":"add","label":"Staying Motivated","description":"Key strategies include: setting clear goals, tracking progress visibly, celebrating small wins, finding accountability partners, and connecting tasks to larger purpose.","color":"#F7B731","parentId":"selected"}]}

User: "what should I focus on today"
{"actions":[{"action":"add","label":"Today's Focus","description":"Review your most important tasks, identify the one with highest impact, and protect time to work on it without interruption.","color":"#26DE81","parentId":"selected"}]}

**PARENTID RULES:**
1. Use actual node IDs from the tree (like "node-abc123")
2. Use "selected" when user says "here", "this node", or no specific location
3. Use "root" for new top-level categories
4. Use "PREV_0", "PREV_1" etc. to reference nodes created earlier in same response
5. Search the tree for relevant parents - put fitness content under fitness nodes, work under work, etc.

**MORE COLOR EXAMPLES (various phrasings):**

User: "turn fitness green"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81"}]}

User: "I want the work node to be orange"
{"actions":[{"action":"edit","targetId":"work","color":"#EF8354"}]}

User: "can you change health to teal please"
{"actions":[{"action":"edit","targetId":"health","color":"#4ECDC4"}]}

User: "make my goals yellow"
{"actions":[{"action":"edit","targetId":"goals","color":"#F7B731"}]}

User: "set color of meditation to purple"
{"actions":[{"action":"edit","targetId":"meditation","color":"#9B5DE5"}]}

User: "color the selected node pink"
{"actions":[{"action":"edit","targetId":"selected","color":"#FF6B9D"}]}

User: "change this to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

User: "red for the deadline task"
{"actions":[{"action":"edit","targetId":"deadline","color":"#EF4444"}]}

User: "make morning routine lavender colored"
{"actions":[{"action":"edit","targetId":"morning routine","color":"#A29BFE"}]}

**MORE NATURAL LANGUAGE VARIATIONS:**

User: "add exercise"
{"actions":[{"action":"add","label":"Exercise","description":"Physical activity for health, fitness, and mental wellbeing. Consider cardio, strength training, and flexibility work.","color":null,"parentId":"selected"}]}

User: "new node: weekly review"
{"actions":[{"action":"add","label":"Weekly Review","description":"A dedicated time each week to reflect on progress, plan ahead, and realign with goals.","color":null,"parentId":"selected"}]}

User: "brainstorm: marketing ideas"
{"actions":[{"action":"add","label":"Marketing Ideas","description":"Creative concepts and strategies for promoting products, services, or brand awareness.","color":"#9B5DE5","parentId":"selected"}]}

User: "quick thought - need to buy groceries"
{"actions":[{"action":"add","label":"Buy Groceries","description":"Shopping reminder. Consider making a list and checking pantry before going.","color":null,"parentId":"selected"}]}

User: "jot down: call the dentist"
{"actions":[{"action":"add","label":"Call Dentist","description":"Schedule a dental appointment for routine checkup or specific concern.","color":null,"parentId":"selected"}]}

**RENAMING EXAMPLES:**

User: "rename fitness to health and wellness"
{"actions":[{"action":"edit","targetId":"fitness","label":"Health & Wellness"}]}

User: "change the name of project alpha to project omega"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Omega"}]}

User: "call the meditation node mindfulness instead"
{"actions":[{"action":"edit","targetId":"meditation","label":"Mindfulness"}]}

User: "update work label to career development"
{"actions":[{"action":"edit","targetId":"work","label":"Career Development"}]}

**DESCRIPTION UPDATES:**

User: "add a description to fitness: my workout plan for 2024"
{"actions":[{"action":"edit","targetId":"fitness","description":"My comprehensive workout plan for 2024 focusing on consistency and progressive improvement."}]}

User: "update the description of goals to mention Q1 targets"
{"actions":[{"action":"edit","targetId":"goals","description":"Key objectives and Q1 targets for personal and professional growth."}]}

**COMBINED EDIT EXAMPLES:**

User: "rename work to career and make it blue"
{"actions":[{"action":"edit","targetId":"work","label":"Career","color":"#45B7D1"}]}

User: "change fitness to green and add description about daily exercise"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81","description":"Daily exercise routine for physical health, mental clarity, and sustained energy."}]}

User: "update project alpha: rename to project beta, make it purple, and add description about the new scope"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Beta","color":"#9B5DE5","description":"Revised project with expanded scope and updated timeline."}]}

**HIERARCHICAL CREATION:**

User: "create a fitness category with subcategories for cardio, strength, and flexibility"
{"actions":[{"action":"add","label":"Fitness","description":"Physical training and exercise for health and performance.","color":"#26DE81","parentId":"root"},{"action":"add","label":"Cardio","description":"Cardiovascular exercises for heart health and endurance.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Strength","description":"Resistance training for muscle building and metabolism.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work for injury prevention.","color":null,"parentId":"PREV_0"}]}

User: "add a books section under personal with three books: atomic habits, deep work, and thinking fast and slow"
{"actions":[{"action":"add","label":"Books","description":"Reading list and book notes for personal development.","color":"#9B5DE5","parentId":"personal"},{"action":"add","label":"Atomic Habits","description":"James Clear's guide to building good habits and breaking bad ones through small changes.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Deep Work","description":"Cal Newport's framework for focused, distraction-free productivity.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Thinking Fast and Slow","description":"Daniel Kahneman's exploration of the two systems that drive how we think.","color":null,"parentId":"PREV_0"}]}

**QUESTION-BASED INPUTS:**

User: "what are the benefits of meditation"
{"actions":[{"action":"add","label":"Benefits of Meditation","description":"Meditation offers numerous benefits including reduced stress and anxiety, improved focus and concentration, better emotional regulation, enhanced self-awareness, and improved sleep quality. Regular practice can also lower blood pressure and boost immune function.","color":"#A29BFE","parentId":"selected"}]}

User: "explain compound interest"
{"actions":[{"action":"add","label":"Compound Interest","description":"Compound interest is interest calculated on both the initial principal and accumulated interest from previous periods. It's often called 'interest on interest' and is a powerful force for growing wealth over time. The formula is A = P(1 + r/n)^(nt).","color":"#F7B731","parentId":"selected"}]}

User: "how do I start a morning routine"
{"actions":[{"action":"add","label":"Starting a Morning Routine","description":"Begin by waking at a consistent time. Start simple with 2-3 activities like hydration, movement, and intention-setting. Prepare the night before and protect this time from distractions. Gradually add elements as habits solidify.","color":"#4ECDC4","parentId":"selected"}]}

**VOICE-STYLE INFORMAL INPUTS:**

User: "uh add something about like project deadlines I guess"
{"actions":[{"action":"add","label":"Project Deadlines","description":"Tracking and managing upcoming project deadlines to ensure timely delivery.","color":"#EF4444","parentId":"selected"}]}

User: "hmm let me think... yeah add productivity tips"
{"actions":[{"action":"add","label":"Productivity Tips","description":"Strategies and techniques for getting more done with less stress and better focus.","color":"#F7B731","parentId":"selected"}]}

User: "so basically I want to track my water intake"
{"actions":[{"action":"add","label":"Water Intake Tracking","description":"Monitor daily hydration to ensure adequate water consumption for health and energy.","color":"#45B7D1","parentId":"selected"}]}

**RESPOND ACTION (answer without creating nodes):**

User: "what's the weather today"
{"actions":[{"action":"respond","message":"Based on current conditions, it's 72°F and sunny in your area. Would you like me to add a weather tracking node to your map?","offerToAdd":false}]}

User: "what time is it in Tokyo"
{"actions":[{"action":"respond","message":"It's currently 3:45 AM in Tokyo (JST, UTC+9).","offerToAdd":false}]}

User: "what's Tesla stock price"
{"actions":[{"action":"respond","message":"Tesla (TSLA) is currently trading at $248.50, up 2.3% today. The stock has risen 15% this month following strong delivery numbers.","offerToAdd":true}]}

User: "how many calories in an avocado"
{"actions":[{"action":"respond","message":"A medium avocado contains about 240 calories, with 22g of healthy fats, 12g of carbs, and 3g of protein. It's also rich in potassium, vitamin K, and fiber.","offerToAdd":false}]}

User: "what's happening with bitcoin"
{"actions":[{"action":"respond","message":"Bitcoin is currently at $67,450, up 4% in the last 24 hours. Recent ETF inflows and halving anticipation are driving momentum.","offerToAdd":true}]}

User: "who won the super bowl"
{"actions":[{"action":"respond","message":"The Kansas City Chiefs won Super Bowl LVIII in February 2024, defeating the San Francisco 49ers 25-22 in overtime.","offerToAdd":false}]}

User: "summarize the latest AI news"
{"actions":[{"action":"respond","message":"Key AI developments this week: OpenAI announced GPT-5 training, Google released Gemini 2.0, and the EU AI Act enforcement began. Anthropic also launched new Claude features for enterprise.","offerToAdd":true}]}

**WHEN TO USE RESPOND vs ADD:**

User: "what is meditation" (general question - RESPOND)
{"actions":[{"action":"respond","message":"Meditation is a practice of focused attention and awareness, often involving breathing techniques or mindfulness. It reduces stress, improves focus, and promotes emotional wellbeing. Want me to add this to your map?","offerToAdd":true}]}

User: "add info about meditation" (explicit request - ADD)
{"actions":[{"action":"add","label":"Meditation","description":"A practice of focused attention and awareness to reduce stress, improve concentration, and promote emotional wellbeing.","color":"#A29BFE","parentId":"selected"}]}

User: "tell me about compound interest" (informational - RESPOND)
{"actions":[{"action":"respond","message":"Compound interest is interest calculated on both the initial principal and accumulated interest. The formula is A = P(1 + r/n)^(nt). It's powerful for long-term investing - $10,000 at 7% for 30 years becomes $76,123.","offerToAdd":true}]}

User: "I need to learn about compound interest" (intent to capture - ADD)
{"actions":[{"action":"add","label":"Compound Interest","description":"Interest calculated on both principal and accumulated interest. Key wealth-building concept: A = P(1 + r/n)^(nt). Small regular investments grow exponentially over time.","color":"#26DE81","parentId":"selected"}]}

**APP HELP QUESTIONS (always RESPOND):**

User: "how do I delete a node"
{"actions":[{"action":"respond","message":"To delete a node: 1) Click the node to select it, 2) Look at the info panel on the left, 3) Click the Delete button at the bottom. Or just tell me which node to delete and I'll do it for you!","offerToAdd":false}]}

User: "how do I change colors"
{"actions":[{"action":"respond","message":"Select any node by clicking it, then use the color picker in the info panel on the left. You can also ask me to change colors - just say 'make [node name] blue' or whatever color you want!","offerToAdd":false}]}

User: "what does the neural network do"
{"actions":[{"action":"respond","message":"The neural network learns YOUR patterns - where you place different topics, what colors you prefer, your naming style (short vs detailed). Over time, I use these patterns to suggest better placements for new content. Check the Neural panel (purple icon) to see your learning stats!","offerToAdd":false}]}

User: "how do I move nodes around"
{"actions":[{"action":"respond","message":"Two ways: 1) Click MOVE in the sidebar, then drag nodes to new parents. 2) Or just ask me - say 'move [node] under [parent]' and I'll do it instantly!","offerToAdd":false}]}

User: "what's the difference between memo and chat"
{"actions":[{"action":"respond","message":"MEMO (orange) is for quick one-shot commands - fast and efficient. CHAT (teal, that's me!) is for ongoing conversation where I remember context. Use Memo for quick adds, Chat for complex organizing or questions.","offerToAdd":false}]}

User: "how do I search my map"
{"actions":[{"action":"respond","message":"Click the menu (hamburger icon top right) and select Search. Or just ask me to find something - I can see your entire map and navigate to any node!","offerToAdd":false}]}

**CRITICAL RULES:**
1. Always respond with valid JSON only - no extra text
2. Always include meaningful descriptions for new nodes
3. Match node IDs from the tree structure above, not labels
4. For colors, use the exact hex codes provided
5. When user mentions a node by name, find its ID in the tree
6. "selected" as targetId means the currently selected node
7. Be helpful and interpret user intent, don't be overly literal
8. For ambiguous color names, use closest match (e.g., "blue" = #45B7D1, "red" = #EF4444)
9. When editing, only include fields that are being changed
10. Use "respond" for: factual questions, current events, prices, time queries, "what is X" questions, AND app help questions ("how do I...", "what does X do", "how to...")
11. Use "add" for: "add", "create", "track", "remember", "I want to learn", "capture this", or when user clearly wants to save info
12. When unsure, use "respond" with "offerToAdd": true so user can choose

**WEB SEARCH CAPABILITY:**
You have access to real-time web search. For questions about:
- Current stock prices, crypto prices, market data
- Latest news and current events  
- Weather, time zones, live information
- Recent developments, announcements
- Anything that requires up-to-date information
Use your web search to get accurate, current data before responding.

Respond with JSON only:`;

                let content;
                
                // Use Edge Function if authenticated, otherwise direct API
                if (session?.access_token) {
                    console.log('Using Edge Function for voice AI with web search...');
                    const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${session.access_token}`
                        },
                        body: JSON.stringify({
                            type: 'voice',
                            prompt: prompt,
                            maxTokens: 1024,
                            webSearch: true // Enable web search
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || 'Edge function request failed');
                    }
                    
                    const data = await response.json();
                    content = data.response;
                } else {
                    // Fall back to direct API call with web search
                    console.log('Using direct API for voice AI with web search...');
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey.trim(),
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1024,
                            tools: [{
                                type: 'web_search_20250305',
                                name: 'web_search',
                                max_uses: 3
                            }],
                            messages: [{
                                role: 'user',
                                content: prompt
                            }]
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error('API Error:', response.status, errorData);
                        
                        if (response.status === 401) {
                            throw new Error('Invalid API key. Check your key in Settings.');
                        } else if (response.status === 429) {
                            throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                        } else if (response.status === 400) {
                            throw new Error('Bad request. The voice input may be too long.');
                        } else if (response.status === 500 || response.status === 503) {
                            throw new Error('AI service temporarily unavailable. Try again shortly.');
                        } else if (errorData.error?.message) {
                            throw new Error(errorData.error.message);
                        } else {
                            throw new Error(`Connection error (${response.status}). Check your internet.`);
                        }
                    }
                    
                    const data = await response.json();
                    
                    // Handle potential tool use - extract final text response
                    if (data.content && Array.isArray(data.content)) {
                        // Find the text response (may be after tool_use blocks)
                        const textBlock = data.content.find(block => block.type === 'text');
                        if (textBlock) {
                            content = textBlock.text;
                        } else {
                            throw new Error('No text response from AI');
                        }
                    } else if (data.content?.[0]?.text) {
                        content = data.content[0].text;
                    } else {
                        throw new Error('Empty response from AI. Try speaking more clearly.');
                    }
                }
                
                console.log('AI response:', content);
                
                // Parse the JSON response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Could not understand that. Try a clearer command like "add node called Work"');
                }
                
                let result;
                try {
                    result = JSON.parse(jsonMatch[0]);
                } catch (parseError) {
                    throw new Error('AI response was unclear. Try rephrasing your command.');
                }
                
                console.log('Parsed result:', result);
                
                // Handle new multi-action format
                const actions = result.actions || [result]; // Support both old and new format
                const createdNodes = []; // Track created nodes for PREV_N references
                
                // Helper function to resolve targetId to actual node ID
                const resolveTargetId = (targetId) => {
                    if (!targetId) return null;
                    if (targetId === 'selected') {
                        return selectedNode?.userData.id || null;
                    }
                    // Try to find by ID first
                    const byId = store.findNode(targetId);
                    if (byId) return targetId;
                    
                    // Search by label (case-insensitive)
                    const allNodes = store.getAllNodes();
                    const searchTerm = targetId.toLowerCase();
                    
                    // Exact match first
                    let match = allNodes.find(n => n.label.toLowerCase() === searchTerm);
                    // Partial match
                    if (!match) {
                        match = allNodes.find(n => 
                            n.label.toLowerCase().includes(searchTerm) ||
                            searchTerm.includes(n.label.toLowerCase())
                        );
                    }
                    return match?.id || null;
                };
                
                for (const action of actions) {
                    // Resolve targetId for all actions that use it
                    const resolvedTargetId = resolveTargetId(action.targetId);
                    
                    // Handle respond action - just show message, no node creation
                    if (action.action === 'respond') {
                        // Show the response message
                        const message = action.message || 'No response provided';
                        
                        // Create a styled response toast/modal
                        showAIResponse(message, action.offerToAdd, cleanedTranscript);
                        continue;
                    }
                    
                    if (action.action === 'delete') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to delete', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (targetNode && targetNode.id !== store.data.id) {
                            const label = targetNode.label;
                            if (store.deleteNode(resolvedTargetId)) {
                                showToast(`Deleted "${label}"`, 'success');
                            }
                        }
                    } else if (action.action === 'edit') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to edit', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (targetNode) {
                            const updates = {};
                            if (action.label) updates.label = action.label;
                            if (action.description) updates.description = action.description;
                            if (action.color && action.color !== 'null') updates.color = action.color;
                            store.updateNode(resolvedTargetId, updates);
                            
                            // Update the mesh visually
                            const mesh = nodes.get(resolvedTargetId);
                            if (mesh && action.color) {
                                mesh.material.color.set(action.color);
                                mesh.material.emissive.set(action.color);
                                if (mesh.userData.outlineMesh) {
                                    mesh.userData.outlineMesh.material.color.set(action.color);
                                }
                            }
                            if (mesh && action.label) {
                                // Update label sprite
                                updateNodeLabel(mesh, action.label);
                            }
                            
                            showToast(`Updated "${targetNode.label}"`, 'success');
                        }
                    } else if (action.action === 'move') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to move', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (!targetNode || targetNode.id === store.data.id) {
                            showToast('Cannot move root node', 'error');
                            continue;
                        }
                        
                        // Resolve new parent
                        let newParentId = store.data.id;
                        if (action.parentId === 'root') {
                            newParentId = store.data.id;
                        } else if (action.parentId === 'selected' && selectedNode) {
                            newParentId = selectedNode.userData.id;
                        } else if (action.parentId) {
                            const resolved = resolveTargetId(action.parentId);
                            if (resolved) newParentId = resolved;
                        }
                        
                        // Move the node
                        if (store.moveNode && typeof store.moveNode === 'function') {
                            store.moveNode(resolvedTargetId, newParentId);
                        } else {
                            // Manual move if moveNode doesn't exist
                            const parent = store.findParent(resolvedTargetId);
                            if (parent) {
                                parent.children = parent.children.filter(c => c.id !== resolvedTargetId);
                            }
                            const newParent = store.findNode(newParentId);
                            if (newParent) {
                                newParent.children = newParent.children || [];
                                newParent.children.push(targetNode);
                            }
                            store.save();
                        }
                        showToast(`Moved "${targetNode.label}"`, 'success');
                        
                    } else if (action.action === 'reorder') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to reorder', 'error');
                            continue;
                        }
                        let reordered = false;
                        const position = action.position;
                        if (position === 'up') {
                            reordered = store.reorderNode(resolvedTargetId, -1);
                        } else if (position === 'down') {
                            reordered = store.reorderNode(resolvedTargetId, 1);
                        } else if (position === 'first' || position === 'last' || typeof position === 'number') {
                            reordered = store.reorderNodeToPosition(resolvedTargetId, position);
                        }
                        if (reordered) {
                            const targetNode = store.findNode(resolvedTargetId);
                            showToast(`Reordered "${targetNode?.label || 'node'}"`, 'success');
                        } else {
                            showToast('Reorder failed', 'error');
                        }
                        
                    } else if (action.action === 'focus') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node', 'error');
                            continue;
                        }
                        const mesh = nodes.get(resolvedTargetId);
                        if (mesh) {
                            // Expand parent chain first
                            let current = resolvedTargetId;
                            while (current && current !== store.data.id) {
                                const parent = store.findParent(current);
                                if (parent) {
                                    store.expandedNodes.add(parent.id);
                                }
                                current = parent?.id;
                            }
                            buildScene();
                            
                            // Then focus after rebuild
                            setTimeout(() => {
                                const updatedMesh = nodes.get(resolvedTargetId);
                                if (updatedMesh) {
                                    selectNode(updatedMesh);
                                    focusOnNode(updatedMesh);
                                    showToast(`Focused on "${store.findNode(resolvedTargetId)?.label}"`, 'success');
                                }
                            }, 100);
                        }
                        continue; // Skip buildScene at end since we handle it here
                        
                    } else if (action.action === 'expand') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to expand', 'error');
                            continue;
                        }
                        store.expandedNodes.add(resolvedTargetId);
                        const targetNode = store.findNode(resolvedTargetId);
                        showToast(`Expanded "${targetNode?.label}"`, 'success');
                        
                    } else if (action.action === 'collapse') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to collapse', 'error');
                            continue;
                        }
                        store.expandedNodes.delete(resolvedTargetId);
                        const targetNode = store.findNode(resolvedTargetId);
                        showToast(`Collapsed "${targetNode?.label}"`, 'success');
                        
                    } else if (action.action === 'add' || !action.action) {
                        // Resolve parentId (including PREV_N references)
                        let parentId = store.data.id; // Default to root
                        
                        console.log('Resolving parentId:', action.parentId);
                        
                        if (action.parentId === 'selected' && selectedNode) {
                            parentId = selectedNode.userData.id;
                            console.log('Using selected node:', parentId);
                        } else if (action.parentId === 'root') {
                            parentId = store.data.id;
                            console.log('Using root');
                        } else if (action.parentId && action.parentId.startsWith('PREV_')) {
                            const prevIndex = parseInt(action.parentId.replace('PREV_', ''));
                            if (createdNodes[prevIndex]) {
                                parentId = createdNodes[prevIndex].id;
                                console.log('Using PREV_' + prevIndex + ':', parentId);
                            }
                        } else if (action.parentId && action.parentId !== 'selected') {
                            // Try to find by ID first
                            const byId = store.findNode(action.parentId);
                            if (byId) {
                                parentId = action.parentId;
                                console.log('Found by ID:', parentId);
                            } else {
                                // Search by label (case-insensitive, partial match)
                                const allNodes = store.getAllNodes();
                                const searchTerm = action.parentId.toLowerCase();
                                
                                // Try exact match first
                                let byLabel = allNodes.find(n => 
                                    n.label.toLowerCase() === searchTerm
                                );
                                
                                // Try partial match if no exact match
                                if (!byLabel) {
                                    byLabel = allNodes.find(n => 
                                        n.label.toLowerCase().includes(searchTerm) ||
                                        searchTerm.includes(n.label.toLowerCase())
                                    );
                                }
                                
                                if (byLabel) {
                                    parentId = byLabel.id;
                                    console.log('Found by label "' + action.parentId + '":', byLabel.label, parentId);
                                } else {
                                    console.log('Could not find parent "' + action.parentId + '", using selected or root');
                                    parentId = selectedNode?.userData.id || store.data.id;
                                }
                            }
                        } else if (selectedNode) {
                            parentId = selectedNode.userData.id;
                            console.log('Defaulting to selected node:', parentId);
                        }
                        
                        // Final validation - make sure parent exists
                        const parentNode = store.findNode(parentId);
                        if (!parentNode) {
                            console.warn('Parent not found, falling back to root');
                            parentId = store.data.id;
                        }
                        
                        console.log('Final parentId:', parentId, 'Parent label:', store.findNode(parentId)?.label);
                        
                        const nodeData = { 
                            label: action.label,
                            source: 'ai-voice'
                        };
                        
                        // Add description if provided
                        if (action.description) {
                            nodeData.description = action.description;
                        }
                        
                        // Add color if provided
                        if (action.color && action.color !== 'null' && action.color !== null) {
                            nodeData.color = action.color;
                        }
                        
                        const newNode = store.addNode(parentId, nodeData);
                        if (newNode) {
                            createdNodes.push(newNode);
                            console.log(`Created node: "${action.label}" (${newNode.id}) under "${store.findNode(parentId)?.label}"`);
                            
                            // Make sure parent chain is expanded
                            let current = parentId;
                            while (current && current !== store.data.id) {
                                store.expandedNodes.add(current);
                                const parent = store.findParent(current);
                                current = parent?.id;
                            }
                        } else {
                            console.error('Failed to create node:', action.label);
                        }
                    }
                }
                
                // Rebuild scene after all actions
                buildScene();
                
                // Focus on last created node and show celebration
                if (createdNodes.length > 0) {
                    const lastNode = createdNodes[createdNodes.length - 1];
                    
                    // Small delay to let physics settle, then focus
                    setTimeout(() => {
                        const mesh = nodes.get(lastNode.id);
                        if (mesh) {
                            selectNode(mesh);
                            focusOnNode(mesh);
                            const screenPos = mesh.position.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                            createCelebration(x, y, lastNode.color, 12);
                        }
                    }, 300);
                    
                    // Announce what was created
                    if (createdNodes.length === 1) {
                        showToast(`Added "${lastNode.label}"`, 'success');
                    } else {
                        showToast(`Added ${createdNodes.length} nodes`, 'success');
                    }
                    haptic.success();
                }
                
            } catch (error) {
                console.error('AI processing error:', error);
                showToast(error.message || 'Failed to process', 'error');
                haptic.error();
            } finally {
                this.stop();
            }
        },
        
        showSettings() {
            showApiKeyModal();
        },
        
        hideSettings() {
            hideApiKeyModal();
        }
    };
    
    // Voice button click handler
    document.getElementById('btn-voice').addEventListener('click', () => {
        if (voiceAI.isRecording || voiceAI.isProcessing) {
            voiceAI.stop();
        } else {
            voiceAI.start();
        }
    });
    
    // Chat button click handler (sidebar)
    document.getElementById('btn-chat').addEventListener('click', () => {
        chatManager.toggle();
    });
    
    // Settings is now accessible via menu (gear icon removed from sidebar)
    
    // Standalone API key modal function with optional callback
    let apiKeyModalCallback = null;
    
    function showApiKeyModal(callback) {
        apiKeyModalCallback = callback || null;
        const modal = document.getElementById('api-key-modal');
        
        // Update neural network stats
        const neuralStats = document.getElementById('neural-stats-settings');
        if (neuralStats && neuralNet) {
            const stats = neuralNet.getStats();
            let statsText = 'The neural network learns from your mind map to provide intelligent suggestions.';
            if (stats.isReady) {
                statsText = `Neural network trained with ${stats.cachedEmbeddings} embeddings, ${stats.expansionPatterns} patterns.`;
            }
            neuralStats.textContent = statsText;
        }
        
        modal.classList.add('active');
    }
    
    function hideApiKeyModal() {
        document.getElementById('api-key-modal').classList.remove('active');
        apiKeyModalCallback = null;
    }
    
    // Voice indicator event handlers
    document.getElementById('voice-cancel').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-backdrop').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-indicator').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) voiceAI.stop();
    });
    
    // Voice mode toggle (speak vs type)
    let voiceInputMode = 'speak'; // 'speak' or 'type'
    
    // Prevent clicks on toggle from closing modal
    const voiceModeToggle = document.querySelector('.voice-mode-toggle');
    if (voiceModeToggle) {
        voiceModeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }
    
    const voiceModeSpeakBtn = document.getElementById('voice-mode-speak');
    if (voiceModeSpeakBtn) {
        voiceModeSpeakBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            voiceInputMode = 'speak';
            document.getElementById('voice-mode-speak').classList.add('active');
            document.getElementById('voice-mode-type').classList.remove('active');
            
            // Show voice UI, hide text UI
            document.getElementById('voice-icon').style.display = 'block';
            document.getElementById('voice-status').style.display = 'block';
            document.getElementById('voice-transcript').style.display = 'block';
            document.getElementById('voice-text-wrapper').style.display = 'none';
            document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
            
            // Start voice recognition if not already processing
            if (!voiceAI.isProcessing) {
                voiceAI.startRecording();
            }
        });
    }
    
    const voiceModeTypeBtn = document.getElementById('voice-mode-type');
    if (voiceModeTypeBtn) {
        voiceModeTypeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Type mode clicked');
            voiceInputMode = 'type';
            document.getElementById('voice-mode-type').classList.add('active');
            document.getElementById('voice-mode-speak').classList.remove('active');
            
            // Hide voice UI, show text UI
            document.getElementById('voice-icon').style.display = 'none';
            document.getElementById('voice-status').textContent = 'Type your request';
            document.getElementById('voice-status').style.display = 'block';
            document.getElementById('voice-transcript').style.display = 'none';
            
            const textWrapper = document.getElementById('voice-text-wrapper');
            textWrapper.style.display = 'block';
            
            document.getElementById('voice-hint').textContent = 'Press Enter or click Send to submit';
            
            // Stop voice recognition
            if (voiceAI.recognition) {
                try { voiceAI.recognition.stop(); } catch (e) {}
            }
            voiceAI.isRecording = false;
            
            // Focus text input
            setTimeout(() => {
                document.getElementById('voice-text-input').focus();
            }, 100);
        });
    }
    
    // Voice text input submit
    const voiceTextSubmit = document.getElementById('voice-text-submit');
    if (voiceTextSubmit) {
        voiceTextSubmit.addEventListener('click', (e) => {
            e.stopPropagation();
            const textInput = document.getElementById('voice-text-input');
            const text = textInput.value.trim();
            if (text) {
                voiceAI.processWithAI(text);
                textInput.value = '';
            } else {
                showToast('Please enter a request', 'info');
            }
        });
    }
    
    // Prevent clicks in text area from closing modal
    const voiceTextInput = document.getElementById('voice-text-input');
    if (voiceTextInput) {
        voiceTextInput.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        voiceTextInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('voice-text-submit').click();
            }
        });
    }
    
    const voiceTextWrapper = document.getElementById('voice-text-wrapper');
    if (voiceTextWrapper) {
        voiceTextWrapper.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }
    
    // Settings modal handlers
    document.getElementById('api-key-cancel').addEventListener('click', () => hideApiKeyModal());
    document.getElementById('api-key-modal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) hideApiKeyModal();
    });

    // ═══════════════════════════════════════════════════════════════════
    // AUTH MODAL HANDLERS
    // ═══════════════════════════════════════════════════════════════════
    const authModal = document.getElementById('auth-modal');
    const authForm = document.getElementById('auth-form');
    const authError = document.getElementById('auth-error');
    let authMode = 'signin'; // 'signin' or 'signup'
    
    function showAuthModal(isWelcome = false) {
        // Update modal text based on context
        if (isWelcome) {
            document.getElementById('auth-title').textContent = 'Welcome to MYND';
            document.getElementById('auth-subtitle').textContent = 'Sign in to save and sync your mind maps across devices';
        } else {
            document.getElementById('auth-title').textContent = authMode === 'signup' ? 'Create an account' : 'Sign in to MYND';
            document.getElementById('auth-subtitle').textContent = 'Sync your mind maps across devices';
        }
        
        authModal.classList.add('active');
        authError.classList.remove('active');
        document.getElementById('auth-email').value = '';
        document.getElementById('auth-password').value = '';
    }
    
    function hideAuthModal() {
        authModal.classList.remove('active');
    }
    
    function showAuthError(message) {
        authError.textContent = message;
        authError.classList.add('active');
    }
    
    function updateAuthUI(user) {
        const avatar = document.getElementById('user-avatar');
        const mobileAvatar = document.getElementById('mobile-user-avatar');
        const syncIndicator = document.getElementById('sync-indicator');
        const mobileSyncIndicator = document.getElementById('mobile-sync-indicator');
        
        if (!avatar || !syncIndicator) {
            console.warn('Auth UI elements not found');
            return;
        }
        
        console.log('Updating auth UI for user:', user?.email || 'logged out');
        
        if (user) {
            // Show user initial
            const initial = user.email?.charAt(0).toUpperCase() || 'U';
            avatar.innerHTML = `<span style="line-height: 1;">${initial}</span>`;
            avatar.title = user.email;
            
            // Update mobile avatar too
            if (mobileAvatar) {
                mobileAvatar.innerHTML = `<span style="line-height: 1; font-size: 14px; font-weight: 600;">${initial}</span>`;
            }
            
            // Update sync indicators
            syncIndicator.classList.add('synced');
            syncIndicator.title = 'Synced to cloud';
            if (mobileSyncIndicator) {
                mobileSyncIndicator.classList.add('synced');
            }
        } else {
            // Show default icon
            avatar.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                    <circle cx="12" cy="7" r="4"/>
                </svg>
            `;
            avatar.title = 'Sign in';
            
            // Update mobile avatar too
            if (mobileAvatar) {
                mobileAvatar.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                `;
            }
            
            syncIndicator.classList.remove('synced');
            syncIndicator.title = 'Offline mode';
            if (mobileSyncIndicator) {
                mobileSyncIndicator.classList.remove('synced');
            }
        }
    }
    
    function toggleAuthMode() {
        authMode = authMode === 'signin' ? 'signup' : 'signin';
        
        document.getElementById('auth-title').textContent = 
            authMode === 'signin' ? 'Sign in to MYND' : 'Create your account';
        document.getElementById('auth-subtitle').textContent = 
            authMode === 'signin' ? 'Sync your mind maps across devices' : 'Start saving and syncing your mind maps';
        document.getElementById('auth-submit').textContent = 
            authMode === 'signin' ? 'Sign In' : 'Sign Up';
        document.getElementById('auth-toggle-text').textContent = 
            authMode === 'signin' ? "Don't have an account?" : 'Already have an account?';
        document.getElementById('auth-toggle-link').textContent = 
            authMode === 'signin' ? 'Sign up' : 'Sign in';
        document.getElementById('auth-forgot').style.display = 
            authMode === 'signin' ? 'block' : 'none';
        
        authError.classList.remove('active');
    }
    
    // User account dropdown management
    const userDropdown = {
        _element: null,
        get element() {
            if (!this._element) {
                this._element = document.getElementById('user-dropdown');
            }
            return this._element;
        },
        isOpen: false,
        
        toggle() {
            if (!this.element) {
                console.error('User dropdown element not found');
                return;
            }
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        async open() {
            this.isOpen = true;
            this.element.classList.add('open');
            await this.refresh();
            
            // Close on outside click/touch
            setTimeout(() => {
                document.addEventListener('click', this.handleOutsideClick);
                document.addEventListener('touchend', this.handleOutsideClick);
            }, 10);
        },
        
        close() {
            this.isOpen = false;
            this.element.classList.remove('open');
            document.removeEventListener('click', this.handleOutsideClick);
            document.removeEventListener('touchend', this.handleOutsideClick);
        },
        
        handleOutsideClick: function(e) {
            if (!e.target.closest('#user-account-wrapper, #mobile-user-btn, #user-dropdown')) {
                userDropdown.close();
            }
        },
        
        async refresh() {
            const loggedIn = SupabaseAuth.isLoggedIn();
            
            document.getElementById('user-dropdown-loggedin').style.display = loggedIn ? 'block' : 'none';
            document.getElementById('user-dropdown-loggedout').style.display = loggedIn ? 'none' : 'block';
            
            if (loggedIn) {
                // Update email
                document.getElementById('user-dropdown-email').textContent = SupabaseAuth.getUserEmail();
                
                // Update sync status
                this.updateSyncStatus();
                
                // Load maps
                await this.loadMaps();
            }
        },
        
        updateSyncStatus() {
            const syncDot = document.querySelector('.user-dropdown-sync-dot');
            const syncStatus = document.getElementById('user-sync-status');
            
            if (SupabaseSync.lastSyncTime) {
                const ago = this.formatTimeAgo(SupabaseSync.lastSyncTime);
                syncStatus.textContent = `Synced ${ago}`;
                syncDot.className = 'user-dropdown-sync-dot synced';
            } else if (SupabaseSync.isSyncing) {
                syncStatus.textContent = 'Syncing...';
                syncDot.className = 'user-dropdown-sync-dot syncing';
            } else {
                syncStatus.textContent = 'Connected';
                syncDot.className = 'user-dropdown-sync-dot synced';
            }
        },
        
        formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        },
        
        async loadMaps() {
            const listEl = document.getElementById('user-maps-list');
            const maps = await SupabaseSync.loadUserMaps();
            
            if (maps.length === 0) {
                listEl.innerHTML = '<div class="user-maps-empty">No saved maps yet</div>';
                return;
            }
            
            listEl.innerHTML = maps.slice(0, 8).map(map => `
                <div class="user-map-item ${map.id === SupabaseSync.currentMapId ? 'active' : ''}" data-map-id="${map.id}">
                    <div class="user-map-icon"></div>
                    <div class="user-map-info">
                        <div class="user-map-name">${escapeHTML(map.name)}</div>
                        <div class="user-map-date">${this.formatTimeAgo(new Date(map.updated_at).getTime())}</div>
                    </div>
                    <div class="user-map-actions">
                        <button class="user-map-action rename" title="Rename" data-map-id="${map.id}">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="user-map-action delete" title="Delete" data-map-id="${map.id}">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Add click handlers
            listEl.querySelectorAll('.user-map-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    if (e.target.closest('.user-map-action')) return;
                    
                    const mapId = item.dataset.mapId;
                    if (mapId === SupabaseSync.currentMapId) return;
                    
                    await this.switchToMap(mapId);
                });
            });
            
            // Rename handlers
            listEl.querySelectorAll('.user-map-action.rename').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const mapId = btn.dataset.mapId;
                    const mapItem = btn.closest('.user-map-item');
                    const currentName = mapItem.querySelector('.user-map-name').textContent;
                    
                    const newName = prompt('Rename map:', currentName);
                    if (newName && newName !== currentName) {
                        await SupabaseSync.renameMap(mapId, newName);
                        await this.loadMaps();
                        
                        // Update store if current map
                        if (mapId === SupabaseSync.currentMapId) {
                            store.data.label = newName;
                            store.save();
                            updateNodeLabel(nodes.get(store.data.id), newName);
                        }
                    }
                });
            });
            
            // Delete handlers
            listEl.querySelectorAll('.user-map-action.delete').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const mapId = btn.dataset.mapId;
                    const mapItem = btn.closest('.user-map-item');
                    const mapName = mapItem.querySelector('.user-map-name').textContent;
                    
                    const confirmed = await showConfirm({
                        title: 'Delete Map',
                        message: `Delete "${mapName}"? This cannot be undone.`,
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        danger: true
                    });
                    
                    if (confirmed) {
                        await SupabaseSync.deleteMap(mapId);
                        await this.loadMaps();
                        
                        // If deleted current map, create new
                        if (mapId === SupabaseSync.currentMapId) {
                            await this.createNewMap();
                        }
                    }
                });
            });
        },
        
        async switchToMap(mapId) {
            this.close();
            showToast('Loading map...', 'info');
            
            const mapData = await SupabaseSync.loadMap(mapId);
            if (mapData && mapData.data) {
                store.data = mapData.data;
                store.expandedNodes = new Set([store.data.id]);
                store.save();
                buildScene();
                resetCamera();
                showToast(`Loaded "${mapData.name}"`, 'success');
                
                // Re-train neural net on new map (if training enabled)
                setTimeout(() => {
                    if (typeof neuralNet !== 'undefined' && isNeuralTrainingAllowed()) {
                        neuralNet.train(store).catch(err => console.warn('Neural net training failed:', err));
                    }
                }, 300);
            } else {
                showToast('Failed to load map', 'error');
            }
        },

        async createNewMap() {
            const name = prompt('Name for new map:', 'New Mind Map');
            if (!name) return;
            
            this.close();
            
            // Reset store
            store.reset(name);
            
            // Clear current map ID so a new one is created
            SupabaseSync.currentMapId = null;
            SupabaseSync.unsubscribeFromRealtime();
            
            // Save to create new map
            const saved = await SupabaseSync.saveMap(store.data, name);
            if (saved) {
                SupabaseSync.currentMapId = saved.id;
                await SupabaseSync.subscribeToRealtime(saved.id);
            }
            
            buildScene();
            resetCamera();
            showToast(`Created "${name}"`, 'success');
        }
    };
    
    // User account button click
    document.getElementById('user-account-btn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        userDropdown.toggle();
    });
    
    // Sign out button
    document.getElementById('user-dropdown-signout').addEventListener('click', async () => {
        userDropdown.close();
        await SupabaseAuth.signOut();
        showToast('Signed out', 'info');
    });
    
    // Sign in button (in dropdown)
    document.getElementById('user-dropdown-signin').addEventListener('click', () => {
        userDropdown.close();
        showAuthModal();
    });
    
    // New map action
    document.getElementById('user-action-new').addEventListener('click', () => {
        userDropdown.createNewMap();
    });
    
    // Export actions
    const handleExport = () => {
        userDropdown.close();
        const data = store.exportJSON();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${store.data.label || 'mindmap'}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('Map exported', 'success');
    };
    document.getElementById('user-action-export').addEventListener('click', handleExport);
    document.getElementById('user-action-export-offline').addEventListener('click', handleExport);
    
    // Import actions
    const handleImport = () => {
        userDropdown.close();
        document.getElementById('file-input').click();
    };
    document.getElementById('user-action-import').addEventListener('click', handleImport);
    document.getElementById('user-action-import-offline').addEventListener('click', handleImport);
    
    // Auth modal close
    document.getElementById('auth-close').addEventListener('click', () => {
        sessionStorage.setItem('mynd-skipped-welcome', 'true');
        hideAuthModal();
    });
    authModal.addEventListener('click', (e) => {
        if (e.target === authModal) {
            sessionStorage.setItem('mynd-skipped-welcome', 'true');
            hideAuthModal();
        }
    });
    
    // Google sign in
    document.getElementById('auth-google').addEventListener('click', async () => {
        await SupabaseAuth.signInWithGoogle();
    });
    
    // Email form submit
    authForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const email = document.getElementById('auth-email').value;
        const password = document.getElementById('auth-password').value;
        
        if (authMode === 'signin') {
            const { error } = await SupabaseAuth.signInWithEmail(email, password);
            if (error) {
                showAuthError(error.message);
            } else {
                hideAuthModal();
            }
        } else {
            const { error } = await SupabaseAuth.signUpWithEmail(email, password);
            if (error) {
                showAuthError(error.message);
            }
            // Don't hide modal - user needs to verify email
        }
    });
    
    // Toggle between sign in and sign up
    document.getElementById('auth-toggle-link').addEventListener('click', toggleAuthMode);
    
    // Forgot password
    document.getElementById('auth-forgot').addEventListener('click', async () => {
        const email = document.getElementById('auth-email').value;
        if (!email) {
            showAuthError('Enter your email address first');
            return;
        }
        await SupabaseAuth.resetPassword(email);
    });
    
    // Skip auth (continue offline)
    document.getElementById('auth-skip').addEventListener('click', () => {
        sessionStorage.setItem('mynd-skipped-welcome', 'true');
        hideAuthModal();
        
        // Ensure load option is hidden (user not logged in)
        const choicesEl = document.getElementById('onboarding-choices');
        if (choicesEl) {
            choicesEl.classList.remove('logged-in');
        }
        
        showToast('Building in offline mode — sign in anytime to save', 'info');
    });
    
    // Listen for auth state changes
    SupabaseAuth.onAuthChange(async (user, previousUser, event) => {
        updateAuthUI(user);
        
        // Refresh dropdown if it's open
        if (typeof userDropdown !== 'undefined' && userDropdown.isOpen) {
            userDropdown.refresh();
        }
        
        if (user && !previousUser) {
            // User just logged in
            hideAuthModal();
            showToast(`Welcome, ${user.email}!`, 'success');
            
            // Initialize sync first
            await SupabaseSync.init();
            
            // Now update onboarding choices (after sync is ready)
            if (typeof updateOnboardingForAuth !== 'undefined') {
                await updateOnboardingForAuth();
            }
            
            // Check if onboarding overlay is visible - if so, don't show confirm dialog
            const onboardingOverlay = document.getElementById('onboarding-overlay');
            const isOnboarding = onboardingOverlay && onboardingOverlay.style.display !== 'none';
            
            if (!isOnboarding) {
                // Not in onboarding, check for existing cloud data
                const maps = await SupabaseSync.loadUserMaps();
                if (maps.length > 0) {
                    // Ask user if they want to load cloud data
                    if (confirm(`Found ${maps.length} mind map(s) in the cloud. Load your most recent map?`)) {
                        const latestMap = maps[0];
                        const mapData = await SupabaseSync.loadMap(latestMap.id);
                        if (mapData?.data) {
                            store.importData(mapData.data);
                            showToast(`Loaded "${latestMap.name}"`, 'success');
                        }
                    }
                } else {
                    // No cloud data - sync current local data
                    await SupabaseSync.performFullSync(store, neuralNet, metaLearner, conceptAbstractor);
                }
            }
        } else if (!user && previousUser) {
            // User logged out
            SupabaseSync.syncEnabled = false;
            SupabaseSync.currentMapId = null;
            
            // Update onboarding if visible
            if (typeof updateOnboardingForAuth !== 'undefined') {
                updateOnboardingForAuth();
            }
        } else {
            // Other auth state changes - still update onboarding
            if (typeof updateOnboardingForAuth !== 'undefined') {
                updateOnboardingForAuth();
            }
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // TOP CONTROLS
    // ═══════════════════════════════════════════════════════════════════
    const themePicker = document.getElementById('theme-picker');
    
    document.getElementById('theme-btn')?.addEventListener('click', () => {
        themePicker.classList.toggle('active');
        document.getElementById('menu-dropdown').classList.remove('active');
    });
    
    document.querySelectorAll('.theme-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const oldTheme = document.documentElement.getAttribute('data-theme') || 'obsidian';
            const newTheme = opt.dataset.theme;
            themeManager.set(newTheme);
            themePicker.classList.remove('active');
            // Remap node colors to new theme palette FIRST
            updateNodeColorsForTheme(oldTheme, newTheme);
            // Update label sprites with new colors
            updateLabelsForTheme();
            // Update color pickers for theme
            updateColorPickers();
        });
    });

    const menuDropdown = document.getElementById('menu-dropdown');
    
    document.getElementById('menu-btn')?.addEventListener('click', () => {
        menuDropdown.classList.toggle('active');
        themePicker.classList.remove('active');
    });
    
    document.getElementById('menu-search').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        toggleSpotlight();
    });
    
    document.getElementById('menu-new').addEventListener('click', () => {
        if (confirm('Start a new map? This will clear your current map.')) {
            store.reset();
            currentContextId = store.data.id;
            
            // Reset onboarding state and show questionnaire
            currentQuestion = 0;
            questionAnswers = [];
            mapName = 'My Mind';
            localStorage.removeItem(CONFIG.ONBOARDING_KEY);
            
            // Re-create onboarding overlay if it was removed
            if (!document.getElementById('onboarding-overlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'onboarding-overlay';
                overlay.innerHTML = `
                    <button class="onboarding-avatar" id="onboarding-avatar" aria-label="Sign in or view account">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                            <circle cx="12" cy="7" r="4"/>
                        </svg>
                    </button>
                    <div class="onboarding-content" id="onboarding-welcome">
                        <div class="onboarding-logo">M</div>
                        <h1 class="onboarding-title">Create New Map</h1>
                        <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
                        <div class="onboarding-input-wrapper">
                            <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
                        </div>
                        <div class="onboarding-choices" id="onboarding-choices">
                            <div class="onboarding-choice ai" id="onboarding-ai">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                                </div>
                                <div class="onboarding-choice-title">AI-Assisted Setup</div>
                                <div class="onboarding-choice-desc">Answer a few questions and let AI build your map</div>
                            </div>
                            <div class="onboarding-choice scratch" id="onboarding-scratch">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                                </div>
                                <div class="onboarding-choice-title">Start from Scratch</div>
                                <div class="onboarding-choice-desc">Begin with a simple template</div>
                            </div>
                            <div class="onboarding-choice load" id="onboarding-load">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                        <polyline points="12 11 12 17"/>
                                        <polyline points="9 14 12 11 15 14"/>
                                    </svg>
                                </div>
                                <div class="onboarding-choice-title">Load Saved Map</div>
                                <div class="onboarding-choice-desc">Continue where you left off</div>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-questionnaire" id="onboarding-questionnaire">
                        <div class="question-header">
                            <div class="question-logo">M</div>
                            <div class="question-progress">
                                <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                                <div class="question-progress-bar">
                                    <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="question-text" id="question-text"></div>
                        <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
                        <div class="question-actions">
                            <span class="question-skip" id="question-skip-btn">Skip this question</span>
                            <div class="question-nav">
                                <button class="question-btn secondary" id="question-back" style="display: none;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                                    Back
                                </button>
                                <button class="question-btn primary" id="question-next">
                                    Next
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-processing" id="onboarding-processing">
                        <div class="processing-spinner"></div>
                        <div class="processing-title">Building your mind map...</div>
                        <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Re-attach event listeners to the NEW overlay specifically
                overlay.querySelector('.onboarding-choice.ai').addEventListener('click', async () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    
                    // Check for authentication
                    let isAuthenticated = false;
                    if (typeof supabase !== 'undefined' && supabase !== null) {
                        const { data } = await supabase.auth.getSession();
                        isAuthenticated = !!data?.session;
                    }
                    
                    if (!isAuthenticated) {
                        showToast('Sign in for AI features', 'info');
                        document.getElementById('auth-modal').classList.add('active');
                    } else {
                        showQuestionnaire();
                    }
                });
                
                overlay.querySelector('.onboarding-choice.scratch').addEventListener('click', () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    createBasicMapStructure();
                });
                
                // Load saved map handler
                const loadBtn = overlay.querySelector('.onboarding-choice.load');
                console.log('Load button found:', loadBtn);
                if (loadBtn) {
                    const handleLoadClick = async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Load Saved Map activated (dynamic)');
                        showToast('Opening login...', 'info');
                        
                        // Check if logged in
                        let isAuthenticated = false;
                        if (typeof SupabaseAuth !== 'undefined') {
                            isAuthenticated = SupabaseAuth.isLoggedIn();
                        }
                        
                        if (!isAuthenticated) {
                            // Show login modal
                            console.log('Not authenticated, showing auth modal');
                            showAuthModal(true);
                            return;
                        }
                        
                        // User is logged in, show saved maps
                        await showSavedMapsModal();
                    };
                    
                    loadBtn.addEventListener('click', handleLoadClick);
                    loadBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleLoadClick(e);
                    }, { passive: false });
                } else {
                    console.error('Load button not found in dynamic overlay');
                }
                
                // Avatar click handler for dynamic overlay
                const avatarBtn = overlay.querySelector('.onboarding-avatar');
                if (avatarBtn) {
                    avatarBtn.addEventListener('click', () => {
                        const isAuthenticated = SupabaseAuth.isLoggedIn();
                        if (isAuthenticated) {
                            const user = SupabaseAuth.getUser();
                            showToast(`Signed in as ${user.email}`, 'info');
                        } else {
                            showAuthModal(true);
                        }
                    });
                }
                
                overlay.querySelector('#onboarding-name').addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                        
                        // Check for authentication
                        let isAuthenticated = false;
                        if (typeof supabase !== 'undefined' && supabase !== null) {
                            const { data } = await supabase.auth.getSession();
                            isAuthenticated = !!data?.session;
                        }
                        
                        if (!isAuthenticated) {
                            showToast('Sign in for AI features', 'info');
                            document.getElementById('auth-modal').classList.add('active');
                        } else {
                            showQuestionnaire();
                        }
                    }
                });
                
                document.getElementById('question-next').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-back').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion > 0) {
                        currentQuestion--;
                        updateQuestionUI();
                    }
                });
                
                document.getElementById('question-skip-btn').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = '';
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('question-next').click();
                    }
                });
            }
            
            document.getElementById('onboarding-overlay').style.display = 'flex';
            document.getElementById('onboarding-overlay').classList.remove('fade-out');
            
            // Update load option visibility based on auth state
            updateOnboardingForAuth();
        }
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-save').addEventListener('click', async () => {
        menuDropdown.classList.remove('active');
        showToast('Preparing export with neural data...', 'info');
        
        try {
            const json = await store.exportFullJSON();
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mynd-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Check what data was included
            const hasNeural = json.includes('"neural"');
            const hasProfile = json.includes('"userProfile"');
            const hasMetaLearner = json.includes('"metaLearner"');
            const hasConcepts = json.includes('"conceptAbstractor"');
            const hasMemories = json.includes('"semanticMemory"');
            
            const components = [
                hasNeural && 'neural',
                hasProfile && 'profile',
                hasMetaLearner && 'learning',
                hasConcepts && 'concepts',
                hasMemories && 'memories'
            ].filter(Boolean);
            
            if (components.length > 0) {
                showToast(`Saved map + ${components.length} AI components!`, 'success');
            } else {
                showToast('Map saved!', 'success');
            }
        } catch (e) {
            console.error('Export failed:', e);
            showToast('Export failed', 'error');
        }
    });
    
    document.getElementById('menu-load').addEventListener('click', () => {
        document.getElementById('file-input').click();
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-shortcuts').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 5000);
    });
    
    document.getElementById('menu-settings').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        showApiKeyModal();
    });
    
    document.getElementById('menu-help').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        showToast('MYND: 3D Mind Mapping\n\nClick nodes to expand/collapse\nDouble-click to expand all\nDrag to rotate view\nUse sidebar for actions', 'info', 5000);
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // IMPORT NOTES FEATURE
    // ═══════════════════════════════════════════════════════════════════
    
    const ImportNotes = {
        modal: null,
        dropzone: null,
        fileInput: null,
        textInput: null,
        analyzeBtn: null,
        previewSection: null,
        previewImage: null,
        previewFile: null,
        processingSection: null,
        resultSection: null,
        resultTree: null,
        resultActions: null,
        inputSection: null,
        
        currentFile: null,
        currentImageData: null,
        parsedStructure: null,
        
        init() {
            this.modal = document.getElementById('import-notes-modal');
            this.dropzone = document.getElementById('import-notes-dropzone');
            this.fileInput = document.getElementById('import-notes-file');
            this.textInput = document.getElementById('import-notes-text');
            this.analyzeBtn = document.getElementById('import-notes-analyze');
            this.previewSection = document.getElementById('import-notes-preview');
            this.previewImage = document.getElementById('import-notes-preview-image');
            this.previewFile = document.getElementById('import-notes-preview-file');
            this.processingSection = document.getElementById('import-notes-processing');
            this.resultSection = document.getElementById('import-notes-result');
            this.resultTree = document.getElementById('import-notes-result-tree');
            this.resultActions = document.getElementById('import-notes-result-actions');
            this.inputSection = document.getElementById('import-notes-input');
            
            this.bindEvents();
        },
        
        bindEvents() {
            // Open modal
            document.getElementById('menu-import-notes')?.addEventListener('click', () => {
                menuDropdown.classList.remove('active');
                this.open();
            });
            
            // Close modal
            document.getElementById('import-notes-close')?.addEventListener('click', () => this.close());
            document.getElementById('import-notes-cancel')?.addEventListener('click', () => this.close());
            
            // Dropzone events
            this.dropzone?.addEventListener('click', () => this.fileInput.click());
            this.dropzone?.addEventListener('dragover', (e) => {
                e.preventDefault();
                this.dropzone.classList.add('dragover');
            });
            this.dropzone?.addEventListener('dragleave', () => {
                this.dropzone.classList.remove('dragover');
            });
            this.dropzone?.addEventListener('drop', (e) => {
                e.preventDefault();
                this.dropzone.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    this.handleFile(e.dataTransfer.files[0]);
                }
            });
            
            // File input
            this.fileInput?.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    this.handleFile(e.target.files[0]);
                }
            });
            
            // Text input
            this.textInput?.addEventListener('input', () => this.updateAnalyzeButton());
            
            // Remove preview
            document.getElementById('import-notes-remove')?.addEventListener('click', () => this.clearFile());
            
            // Analyze button
            this.analyzeBtn?.addEventListener('click', () => this.analyze());
            
            // Result actions
            document.getElementById('import-notes-retry')?.addEventListener('click', () => this.retry());
            document.getElementById('import-notes-create')?.addEventListener('click', () => this.createNodes());
            
            // Close on backdrop click
            this.modal?.addEventListener('click', (e) => {
                if (e.target === this.modal) this.close();
            });
        },
        
        open() {
            this.reset();
            this.modal.classList.add('active');
        },
        
        close() {
            this.modal.classList.remove('active');
            this.reset();
        },
        
        reset() {
            this.currentFile = null;
            this.currentImageData = null;
            this.parsedStructure = null;
            
            this.textInput.value = '';
            this.previewSection.classList.remove('active');
            this.previewImage.src = '';
            this.previewImage.style.display = 'block';
            this.previewFile.style.display = 'none';
            this.processingSection.classList.remove('active');
            this.resultSection.classList.remove('active');
            this.resultActions.style.display = 'none';
            this.inputSection.style.display = 'block';
            this.analyzeBtn.disabled = true;
            this.dropzone.style.display = 'block';
        },
        
        handleFile(file) {
            this.currentFile = file;
            
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.currentImageData = e.target.result;
                    this.previewImage.src = e.target.result;
                    this.previewImage.style.display = 'block';
                    this.previewFile.style.display = 'none';
                    this.previewSection.classList.add('active');
                    this.dropzone.style.display = 'none';
                    this.updateAnalyzeButton();
                };
                reader.readAsDataURL(file);
            } else {
                // Non-image file
                document.getElementById('import-notes-file-name').textContent = file.name;
                document.getElementById('import-notes-file-size').textContent = this.formatFileSize(file.size);
                this.previewImage.style.display = 'none';
                this.previewFile.style.display = 'flex';
                this.previewSection.classList.add('active');
                this.dropzone.style.display = 'none';
                
                // Read text files
                if (file.type === 'text/plain' || file.name.endsWith('.txt') || file.name.endsWith('.md')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.textInput.value = e.target.result;
                        this.updateAnalyzeButton();
                    };
                    reader.readAsText(file);
                }
                
                this.updateAnalyzeButton();
            }
        },
        
        clearFile() {
            this.currentFile = null;
            this.currentImageData = null;
            this.previewSection.classList.remove('active');
            this.dropzone.style.display = 'block';
            this.fileInput.value = '';
            this.updateAnalyzeButton();
        },
        
        formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        },
        
        updateAnalyzeButton() {
            const hasImage = !!this.currentImageData;
            const hasText = this.textInput.value.trim().length > 0;
            this.analyzeBtn.disabled = !hasImage && !hasText;
        },
        
        async analyze() {
            const apiKey = localStorage.getItem('claude_api_key');
            if (!apiKey) {
                showToast('Please set your Claude API key in Settings first', 'warning');
                this.close();
                showApiKeyModal();
                return;
            }
            
            // Show processing
            this.inputSection.style.display = 'none';
            this.processingSection.classList.add('active');
            this.resultSection.classList.remove('active');
            this.resultActions.style.display = 'none';
            
            try {
                let content = [];
                
                // Build the content array for Claude
                if (this.currentImageData) {
                    // Extract base64 data and media type
                    const matches = this.currentImageData.match(/^data:(.+);base64,(.+)$/);
                    if (matches) {
                        content.push({
                            type: "image",
                            source: {
                                type: "base64",
                                media_type: matches[1],
                                data: matches[2]
                            }
                        });
                    }
                }
                
                const textNotes = this.textInput.value.trim();
                const useSmartPlacement = document.getElementById('import-notes-smart-placement').checked;
                
                let prompt;
                
                if (useSmartPlacement) {
                    // Gather existing map structure
                    document.getElementById('import-notes-processing-text').textContent = 'Analyzing map structure...';
                    const mapContext = await this.gatherMapContext(textNotes);
                    this.mapContext = mapContext;
                    
                    // Build enhanced prompt with map context
                    document.getElementById('import-notes-processing-text').textContent = 'AI analyzing your notes...';
                    prompt = this.buildEnhancedPrompt(textNotes, mapContext);
                } else {
                    // Simple prompt without map context
                    document.getElementById('import-notes-processing-text').textContent = 'AI analyzing your notes...';
                    prompt = this.buildSimplePrompt(textNotes);
                }

                content.push({ type: "text", text: prompt });
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: content
                        }]
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API request failed');
                }
                
                const data = await response.json();
                const responseText = data.content[0].text;
                
                // Parse the JSON response
                let jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Could not parse structure from response');
                }
                
                this.parsedStructure = JSON.parse(jsonMatch[0]);
                
                // Show result
                this.processingSection.classList.remove('active');
                this.resultSection.classList.add('active');
                this.resultActions.style.display = 'flex';
                
                // Render tree preview with placement info
                this.renderTreePreview(this.parsedStructure);
                
            } catch (error) {
                console.error('Import notes error:', error);
                showToast('Failed to analyze notes: ' + error.message, 'error');
                this.retry();
            }
        },
        
        // Gather context about existing map and neural net insights
        async gatherMapContext(notesText) {
            const context = {
                nodes: [],
                nodeMap: {},
                semanticMatches: [],
                neuralCategories: [],
                learnedPatterns: []
            };
            
            // Get all existing nodes with their hierarchy
            const allNodes = store.getAllNodes();
            
            // Build node structure for context
            const buildNodeTree = (node, depth = 0, path = []) => {
                if (!node || !node.id) return null;
                
                const currentPath = [...path, node.label];
                const nodeInfo = {
                    id: node.id,
                    label: node.label,
                    path: currentPath.join(' > '),
                    depth: depth,
                    childCount: node.children?.length || 0,
                    hasNotes: !!node.notes
                };
                
                context.nodeMap[node.id] = nodeInfo;
                context.nodes.push(nodeInfo);
                
                if (node.children) {
                    node.children.forEach(child => buildNodeTree(child, depth + 1, currentPath));
                }
            };
            
            buildNodeTree(store.data);
            
            // Query semantic memory for relevant memories
            if (typeof semanticMemory !== 'undefined' && semanticMemory.loaded && semanticMemory.encoder) {
                try {
                    // Get memories related to the notes content
                    const memories = await semanticMemory.recallMemories(notesText, 10, 0.3);
                    context.semanticMatches = memories.map(m => ({
                        context: m.context,
                        similarity: m.similarity,
                        event: m.event
                    }));
                } catch (e) {
                    console.log('Semantic memory query failed:', e);
                }
            }
            
            // Get neural net category predictions if available
            if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                try {
                    const predictions = await neuralNet.predictCategory(notesText);
                    if (predictions && predictions.length > 0) {
                        context.neuralCategories = predictions.slice(0, 5).map(p => ({
                            category: p.category,
                            confidence: p.confidence
                        }));
                    }
                } catch (e) {
                    console.log('Neural prediction failed:', e);
                }
            }
            
            // Get learned expansion patterns from neural net
            if (typeof neuralNet !== 'undefined' && neuralNet.expansionPatterns) {
                context.learnedPatterns = neuralNet.expansionPatterns
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 10)
                    .map(p => `"${p.parent}" often has children like: ${p.children.slice(0, 3).join(', ')}`);
            }
            
            return context;
        },
        
        // Build enhanced prompt with all context
        buildEnhancedPrompt(textNotes, mapContext) {
            // Build existing structure summary
            let existingStructure = '';
            if (mapContext.nodes.length > 1) {
                const topLevelNodes = mapContext.nodes.filter(n => n.depth === 1);
                existingStructure = `
EXISTING MAP STRUCTURE (${mapContext.nodes.length} nodes):
${topLevelNodes.map(n => {
    const children = mapContext.nodes.filter(c => c.path.startsWith(n.label + ' > ') && c.depth === 2);
    return `• ${n.label}${children.length > 0 ? ` (${children.length} children: ${children.slice(0, 3).map(c => c.label).join(', ')}${children.length > 3 ? '...' : ''})` : ''}`;
}).join('\n')}
`;
            }
            
            // Build neural insights
            let neuralInsights = '';
            if (mapContext.neuralCategories.length > 0) {
                neuralInsights = `
NEURAL NET SUGGESTIONS (learned from user's patterns):
Categories that match this content: ${mapContext.neuralCategories.map(c => `${c.category} (${Math.round(c.confidence * 100)}%)`).join(', ')}
`;
            }
            
            if (mapContext.learnedPatterns.length > 0) {
                neuralInsights += `
LEARNED PATTERNS:
${mapContext.learnedPatterns.slice(0, 5).join('\n')}
`;
            }
            
            // Build semantic context
            let semanticContext = '';
            if (mapContext.semanticMatches.length > 0) {
                semanticContext = `
RELATED PAST ACTIVITY:
${mapContext.semanticMatches.slice(0, 5).map(m => `• ${m.context} (${Math.round(m.similarity * 100)}% match)`).join('\n')}
`;
            }

            return `Analyze the ${this.currentImageData ? 'image of notes' : 'text notes'} provided and intelligently organize them into the user's existing mind map.

${textNotes ? `TEXT NOTES:\n${textNotes}\n` : ''}
${existingStructure}
${neuralInsights}
${semanticContext}

YOUR TASK:
1. Extract all items/concepts from the notes
2. For each item, decide: should it be added to an EXISTING node, or create a NEW category?
3. Match items to existing nodes when semantically appropriate
4. Only create new top-level categories for genuinely new topics

Return a JSON structure with this format:
{
  "placements": [
    {
      "targetNodeId": "existing-node-id",
      "targetLabel": "Existing Node Label",
      "items": [
        { "label": "New item to add here" },
        { "label": "Another item", "children": [{ "label": "Sub-item" }] }
      ]
    }
  ],
  "newCategories": [
    {
      "label": "Genuinely New Topic",
      "reason": "Why this doesn't fit existing structure",
      "children": [
        { "label": "Item under new category" }
      ]
    }
  ],
  "summary": "Brief description of what was found and organized"
}

GUIDELINES:
- Prefer placing items under existing nodes when there's a logical fit
- Use the neural net suggestions to understand how the user typically organizes things
- Keep labels concise (under 50 characters)
- Create hierarchy where natural (max 3 levels deep)
- The "targetNodeId" must match an existing node ID from the map structure above
- If no existing nodes fit, put everything in "newCategories"
- Return ONLY valid JSON, no markdown or explanation`;
        },
        
        // Simple prompt without smart placement
        buildSimplePrompt(textNotes) {
            return `Analyze the ${this.currentImageData ? 'image of notes' : 'text notes'} provided and extract the content into a structured hierarchy suitable for a mind map.

${textNotes ? `TEXT NOTES:\n${textNotes}\n` : ''}

Return a JSON structure with this format:
{
  "title": "Main topic or title (if identifiable, otherwise null)",
  "nodes": [
    {
      "label": "Category or main item",
      "children": [
        { "label": "Sub-item" },
        { "label": "Another sub-item", "children": [...] }
      ]
    }
  ]
}

Guidelines:
- Identify natural groupings and categories in the notes
- Create a logical hierarchy (max 3-4 levels deep)
- Keep labels concise (under 50 characters)
- If there are lists, preserve the list structure
- If there's no clear hierarchy, create sensible categories
- Combine related items under appropriate headings
- Return ONLY valid JSON, no markdown or explanation`;
        },
        
        renderTreePreview(structure) {
            let html = '';
            
            // Show summary if available
            if (structure.summary) {
                html += `<div style="margin-bottom: 12px; font-size: 12px; color: var(--text-secondary); font-family: var(--font-sans);">${structure.summary}</div>`;
            }
            
            // Handle new format with placements
            if (structure.placements && structure.placements.length > 0) {
                html += `<div style="color: var(--accent); font-size: 11px; margin-bottom: 6px;">📍 ADDING TO EXISTING NODES:</div>`;
                
                structure.placements.forEach(placement => {
                    html += `<div class="import-notes-result-node category">→ ${placement.targetLabel}</div>`;
                    if (placement.items) {
                        this.renderNodeList(placement.items, 1).forEach(line => html += line);
                    }
                });
            }
            
            // Show new categories
            if (structure.newCategories && structure.newCategories.length > 0) {
                if (structure.placements?.length > 0) {
                    html += `<div style="color: #22c55e; font-size: 11px; margin: 10px 0 6px;">✨ NEW CATEGORIES:</div>`;
                }
                
                structure.newCategories.forEach(cat => {
                    html += `<div class="import-notes-result-node category">📁 ${cat.label}</div>`;
                    if (cat.children) {
                        this.renderNodeList(cat.children, 1).forEach(line => html += line);
                    }
                });
            }
            
            // Fallback for old format (title + nodes)
            if (structure.title && !structure.placements) {
                html += `<div class="import-notes-result-node category">📁 ${structure.title}</div>`;
            }
            
            if (structure.nodes && !structure.placements) {
                this.renderNodeList(structure.nodes, 0).forEach(line => html += line);
            }
            
            this.resultTree.innerHTML = html || '<div style="color: var(--text-muted);">No structure detected</div>';
        },
        
        renderNodeList(nodes, indent) {
            const lines = [];
            nodes.forEach(node => {
                const prefix = '  '.repeat(indent) + (node.children?.length ? '📁' : '•');
                const className = node.children?.length ? 'category' : '';
                lines.push(`<div class="import-notes-result-node ${className}">${prefix} ${node.label}</div>`);
                if (node.children?.length) {
                    this.renderNodeList(node.children, indent + 1).forEach(line => lines.push(line));
                }
            });
            return lines;
        },
        
        retry() {
            this.processingSection.classList.remove('active');
            this.resultSection.classList.remove('active');
            this.resultActions.style.display = 'none';
            this.inputSection.style.display = 'block';
        },
        
        createNodes() {
            if (!this.parsedStructure) return;
            
            let nodesCreated = 0;
            let nodesPlaced = 0;
            
            const createNodeRecursive = (nodeData, parentId) => {
                const newNode = {
                    id: generateId(),
                    label: nodeData.label,
                    parentId: parentId,
                    children: [],
                    collapsed: nodeData.children?.length > 3, // Auto-collapse large groups
                    color: null,
                    notes: '',
                    created: Date.now()
                };
                
                // Add to store
                const parent = store.findNode(parentId);
                if (parent) {
                    parent.children.push(newNode);
                    nodesCreated++;
                    
                    // Recursively add children
                    if (nodeData.children?.length) {
                        nodeData.children.forEach(child => {
                            createNodeRecursive(child, newNode.id);
                        });
                    }
                }
                
                return newNode;
            };
            
            // Handle new format: placements to existing nodes
            if (this.parsedStructure.placements && this.parsedStructure.placements.length > 0) {
                this.parsedStructure.placements.forEach(placement => {
                    // Find the target node
                    const targetNode = store.findNode(placement.targetNodeId);
                    if (targetNode && placement.items) {
                        // Expand the target node if collapsed
                        targetNode.collapsed = false;
                        
                        placement.items.forEach(item => {
                            createNodeRecursive(item, placement.targetNodeId);
                            nodesPlaced++;
                        });
                    } else {
                        console.warn(`Target node not found: ${placement.targetNodeId} (${placement.targetLabel})`);
                        // Fallback: add to root
                        if (placement.items) {
                            placement.items.forEach(item => {
                                createNodeRecursive(item, currentContextId);
                            });
                        }
                    }
                });
            }
            
            // Handle new categories
            if (this.parsedStructure.newCategories && this.parsedStructure.newCategories.length > 0) {
                const addToSelected = document.getElementById('import-notes-add-selected').checked;
                const parentId = addToSelected && selectedNode ? selectedNode.userData.id : currentContextId;
                
                this.parsedStructure.newCategories.forEach(category => {
                    createNodeRecursive(category, parentId);
                });
            }
            
            // Fallback for old format (title + nodes)
            if (this.parsedStructure.nodes && !this.parsedStructure.placements) {
                const addToSelected = document.getElementById('import-notes-add-selected').checked;
                let parentId = addToSelected && selectedNode ? selectedNode.userData.id : currentContextId;
                
                // If there's a title and we're adding to root, create a parent node
                if (this.parsedStructure.title && parentId === currentContextId) {
                    const titleNode = {
                        id: generateId(),
                        label: this.parsedStructure.title,
                        parentId: parentId,
                        children: [],
                        collapsed: false,
                        color: null,
                        notes: '',
                        created: Date.now()
                    };
                    
                    const parent = store.findNode(parentId);
                    if (parent) {
                        parent.children.push(titleNode);
                        nodesCreated++;
                        parentId = titleNode.id;
                    }
                }
                
                this.parsedStructure.nodes.forEach(node => {
                    createNodeRecursive(node, parentId);
                });
            }
            
            // Save and rebuild
            store.save();
            buildScene();
            
            // Close modal
            this.close();
            
            // Show appropriate toast
            if (nodesPlaced > 0) {
                showToast(`Added ${nodesCreated} nodes (${nodesPlaced} placed in existing categories)`, 'success');
            } else {
                showToast(`Created ${nodesCreated} nodes from your notes!`, 'success');
            }
            
            // Train neural net on the new structure
            if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                setTimeout(() => {
                    neuralNet.trainOnMap(store.data);
                }, 500);
            }
        }
    };
    
    // Initialize when DOM is ready
    ImportNotes.init();
    
    document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const content = event.target.result;
                if (store.importJSON(content)) {
                    currentContextId = store.data.id;
                    buildScene();
                    
                    // Check what data was included
                    const hasNeural = content.includes('"neural"') && (content.includes('"modelData"') || content.includes('"patternWeights"'));
                    const hasProfile = content.includes('"userProfile"');
                    const hasMetaLearner = content.includes('"metaLearner"');
                    const hasConcepts = content.includes('"conceptAbstractor"');
                    const hasMemories = content.includes('"semanticMemory"');
                    const version = content.match(/"version"\s*:\s*(\d+)/)?.[1] || '1';
                    
                    const components = [
                        hasNeural && 'neural',
                        hasProfile && 'profile',
                        hasMetaLearner && 'learning',
                        hasConcepts && 'concepts',
                        hasMemories && 'memories'
                    ].filter(Boolean);
                    
                    if (components.length > 0) {
                        showToast(`Loaded map + ${components.length} AI components (v${version})`, 'success');
                        // Update neural UI if it's initialized
                        if (typeof NeuralUI !== 'undefined') {
                            setTimeout(() => NeuralUI.updateStatus(), 500);
                        }
                    } else {
                        showToast('Map loaded!', 'success');
                        // Train neural net on loaded map if no neural data was included (if training enabled)
                        setTimeout(() => {
                            if (typeof neuralNet !== 'undefined' && isNeuralTrainingAllowed()) {
                                neuralNet.train(store).catch(err => console.warn('Neural net training failed:', err));
                            }
                        }, 300);
                    }
                } else {
                    showToast('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }
        e.target.value = '';
    });

    // Undo button
    const undoBtn = document.getElementById('undo-btn');
    
    undoBtn.addEventListener('click', () => {
        const result = store.undo();
        if (result.success) {
            buildScene();
            showToast(`Undid: ${result.actionName}`, 'info');
        }
    });
    
    bus.on('undo:changed', () => {
        undoBtn.disabled = !store.canUndo();
    });

    // Depth back button
    document.getElementById('depth-back').addEventListener('click', surfaceUp);

    // Close dropdowns on outside click
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#theme-btn, #theme-picker, #mobile-theme-btn')) {
            themePicker.classList.remove('active');
        }
        if (!e.target.closest('#menu-btn, #menu-dropdown, #mobile-menu-btn')) {
            menuDropdown.classList.remove('active');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // MOBILE HEADER HANDLERS
    // ═══════════════════════════════════════════════════════════════════
    
    // Mobile menu button - same as desktop menu
    document.getElementById('mobile-menu-btn')?.addEventListener('click', () => {
        menuDropdown.classList.toggle('active');
        themePicker.classList.remove('active');
    });

    // Mobile search input - opens spotlight search
    const mobileSearchInput = document.getElementById('mobile-search-input');
    mobileSearchInput?.addEventListener('focus', () => {
        // Open spotlight and transfer focus
        if (!spotlightOpen) {
            toggleSpotlight();
        }
        // Sync any typed value to spotlight
        if (mobileSearchInput.value) {
            spotlightInput.value = mobileSearchInput.value;
            updateSpotlightResults(mobileSearchInput.value);
        }
        mobileSearchInput.blur();
    });

    // Mobile theme button - same as desktop theme
    document.getElementById('mobile-theme-btn')?.addEventListener('click', () => {
        themePicker.classList.toggle('active');
        menuDropdown.classList.remove('active');
    });
    
    // Mobile undo button - same as desktop undo
    document.getElementById('mobile-undo-btn')?.addEventListener('click', () => {
        const result = store.undo();
        if (result.success) {
            buildScene();
            showToast(`Undid: ${result.actionName}`, 'info');
        }
    });

    // Goal buttons - open goal wizard
    document.getElementById('mobile-goal-btn')?.addEventListener('click', () => {
        if (typeof GoalWizard !== 'undefined') {
            GoalWizard.open();
        }
    });

    document.getElementById('goal-btn')?.addEventListener('click', () => {
        if (typeof GoalWizard !== 'undefined') {
            GoalWizard.open();
        }
    });

    // Mobile zoom slider (minimal scrollbar style)
    const mobileZoomSlider = document.getElementById('mobile-zoom-slider');
    const mobileZoomThumb = document.getElementById('mobile-zoom-thumb');
    
    if (mobileZoomSlider && mobileZoomThumb) {
        let isDragging = false;
        let hideTimeout = null;
        const minDistance = 5;
        const maxDistance = 200;
        
        function showSlider() {
            mobileZoomSlider.classList.add('visible');
            clearTimeout(hideTimeout);
        }
        
        function hideSliderDelayed() {
            clearTimeout(hideTimeout);
            hideTimeout = setTimeout(() => {
                if (!isDragging) {
                    mobileZoomSlider.classList.remove('visible');
                }
            }, 1500);
        }
        
        function updateThumbPosition() {
            if (!camera || !controls) return;
            const currentDistance = camera.position.distanceTo(controls.target);
            // Map distance to position (inverted: close = top, far = bottom)
            const trackHeight = mobileZoomSlider.offsetHeight - mobileZoomThumb.offsetHeight;
            const percent = (currentDistance - minDistance) / (maxDistance - minDistance);
            const clampedPercent = Math.max(0, Math.min(1, percent));
            mobileZoomThumb.style.top = (clampedPercent * trackHeight) + 'px';
        }
        
        function setZoomFromPosition(clientY) {
            if (!camera || !controls) return;
            const rect = mobileZoomSlider.getBoundingClientRect();
            const trackHeight = rect.height - mobileZoomThumb.offsetHeight;
            const relativeY = clientY - rect.top - (mobileZoomThumb.offsetHeight / 2);
            const percent = Math.max(0, Math.min(1, relativeY / trackHeight));
            
            // Map position to distance (top = close, bottom = far)
            const newDistance = minDistance + (percent * (maxDistance - minDistance));
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            controls.update();
        }
        
        // Touch handlers for the thumb
        mobileZoomThumb.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            mobileZoomSlider.classList.add('dragging');
            showSlider();
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const touch = e.touches[0];
            setZoomFromPosition(touch.clientY);
            updateThumbPosition();
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                mobileZoomSlider.classList.remove('dragging');
                hideSliderDelayed();
            }
        }, { passive: true });
        
        // Also allow tapping anywhere on the track
        mobileZoomSlider.addEventListener('touchstart', (e) => {
            if (e.target === mobileZoomSlider) {
                const touch = e.touches[0];
                setZoomFromPosition(touch.clientY);
                updateThumbPosition();
                showSlider();
                hideSliderDelayed();
            }
        }, { passive: true });
        
        // Show slider briefly when pinch zooming (on canvas)
        const canvas = document.getElementById('canvas-container');
        if (canvas) {
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    showSlider();
                }
            }, { passive: true });
            
            canvas.addEventListener('touchend', () => {
                updateThumbPosition();
                hideSliderDelayed();
            }, { passive: true });
        }
        
        // Update thumb position periodically
        setInterval(updateThumbPosition, 500);
    }
    
    // Mobile user button - same as desktop user account
    const mobileUserBtn = document.getElementById('mobile-user-btn');
    if (mobileUserBtn) {
        const handleUserBtnClick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Mobile user button activated');
            
            // Use the userDropdown object to properly handle open/close
            userDropdown.toggle();
            
            // Close other dropdowns
            if (menuDropdown) menuDropdown.classList.remove('active');
            if (themePicker) themePicker.classList.remove('active');
        };
        
        mobileUserBtn.addEventListener('click', handleUserBtnClick);
        // Also add touchend for mobile devices that might have issues with click
        mobileUserBtn.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent ghost click
            handleUserBtnClick(e);
        }, { passive: false });
    } else {
        console.warn('Mobile user button not found in DOM');
    }
    
    // Mobile brand click - go to root
    document.getElementById('mobile-brand-btn')?.addEventListener('click', () => {
        navigateToContext(store.data.id);
    });
    
    // Sync undo button state between desktop and mobile
    const mobileUndoBtn = document.getElementById('mobile-undo-btn');
    if (mobileUndoBtn && typeof undoManager !== 'undefined') {
        // Mirror the desktop undo button disabled state
        const desktopUndoBtn = document.getElementById('undo-btn');
        const syncUndoState = () => {
            if (desktopUndoBtn) {
                mobileUndoBtn.disabled = desktopUndoBtn.disabled;
            }
        };
        
        // Use MutationObserver to watch for disabled attribute changes
        const observer = new MutationObserver(syncUndoState);
        if (desktopUndoBtn) {
            observer.observe(desktopUndoBtn, { attributes: true, attributeFilter: ['disabled'] });
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // ONBOARDING
    // ═══════════════════════════════════════════════════════════════════
    const onboardingQuestions = [
        "What's one goal you want to make real progress on in the next 30 days?",
        "What's your ultimate dream career or life achievement?",
        "What's something you've been meaning to get around to but keep putting off?",
        "Is there a skill you're currently learning or want to develop?",
        "What area of your life feels cluttered, overwhelming, or in need of better organization?",
        "What do you do to recharge or find joy outside of work and responsibilities?"
    ];
    
    let currentQuestion = 0;
    let questionAnswers = [];
    let mapName = 'My Mind';
    
    function checkOnboarding() {
        const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
        const overlay = document.getElementById('onboarding-overlay');
        if (onboarded) {
            // Already onboarded - hide overlay
            overlay.style.display = 'none';
        } else {
            // Show onboarding
            overlay.style.display = 'flex';
        }
    }
    
    function updateQuestionUI() {
        document.getElementById('question-current').textContent = currentQuestion + 1;
        document.getElementById('question-progress-fill').style.width = `${((currentQuestion + 1) / onboardingQuestions.length) * 100}%`;
        document.getElementById('question-text').textContent = onboardingQuestions[currentQuestion];
        document.getElementById('question-input').value = questionAnswers[currentQuestion] || '';
        document.getElementById('question-input').placeholder = 'Type your answer here...';
        document.getElementById('question-back').style.display = currentQuestion > 0 ? 'flex' : 'none';
        
        const nextBtn = document.getElementById('question-next');
        if (currentQuestion === onboardingQuestions.length - 1) {
            nextBtn.innerHTML = 'Finish <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
        } else {
            nextBtn.innerHTML = 'Next <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>';
        }
        
        // Focus input
        setTimeout(() => document.getElementById('question-input').focus(), 100);
    }
    
    function showQuestionnaire() {
        document.getElementById('onboarding-welcome').style.display = 'none';
        document.getElementById('onboarding-questionnaire').classList.add('active');
        updateQuestionUI();
    }
    
    function showProcessing() {
        document.getElementById('onboarding-questionnaire').classList.remove('active');
        document.getElementById('onboarding-processing').classList.add('active');
    }
    
    async function processOnboardingAnswers() {
        showProcessing();
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        
        // If no API key, create basic structure without AI
        if (!apiKey) {
            createBasicMapStructure();
            return;
        }
        
        try {
            const answersContext = onboardingQuestions.map((q, i) => 
                `Q${i+1}: ${q}\nA${i+1}: ${questionAnswers[i] || '(skipped)'}`
            ).join('\n\n');
            
            console.log('🚀 Calling AI with answers:', answersContext);
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4000,
                    temperature: 0,
                    system: `You create mind map structures as JSON. You ALWAYS include nested children. You NEVER create flat structures. Every node at level 1 MUST have children, and those children MUST have their own children. You ALWAYS create EXACTLY 4 top-level nodes.`,
                    messages: [{
                        role: 'user',
                        content: `Based on these answers, create a mind map with EXACTLY this structure:
- EXACTLY 4 main categories (Level 1) - no more, no less
- Each category has 2-3 topics (Level 2)
- Each topic has 2-3 actions (Level 3)

User's answers:
${answersContext}

Return this EXACT JSON structure (with your own labels based on answers):

{"nodes":[{"label":"Goals","color":"#60a5fa","children":[{"label":"Short Term","children":[{"label":"Action 1"},{"label":"Action 2"}]},{"label":"Long Term","children":[{"label":"Action 1"},{"label":"Action 2"}]}]},{"label":"Growth","color":"#2dd4bf","children":[{"label":"Skills","children":[{"label":"Step 1"},{"label":"Step 2"}]},{"label":"Learning","children":[{"label":"Resource 1"},{"label":"Resource 2"}]}]},{"label":"Projects","color":"#c084fc","children":[{"label":"Current","children":[{"label":"Task 1"},{"label":"Task 2"}]},{"label":"Planned","children":[{"label":"Idea 1"},{"label":"Idea 2"}]}]},{"label":"Wellness","color":"#4ade80","children":[{"label":"Physical","children":[{"label":"Habit 1"},{"label":"Habit 2"}]},{"label":"Mental","children":[{"label":"Practice 1"},{"label":"Practice 2"}]}]}]}

Replace placeholder labels with real content from user's answers. MUST have exactly 4 top-level nodes. JSON only.`
                    }]
                })
            });
            
            if (!response.ok) {
                const errData = await response.json().catch(() => ({}));
                console.error('❌ API error:', response.status, errData);
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const content = data.content?.[0]?.text || '';
            console.log('📝 AI response:', content);
            
            // Find JSON in response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            
            if (jsonMatch) {
                try {
                    const structure = JSON.parse(jsonMatch[0]);
                    console.log('✅ Parsed structure:', structure);
                    console.log('📊 Top level nodes:', structure.nodes?.length);
                    
                    // Validate structure has nested children
                    if (structure.nodes?.[0]?.children?.[0]?.children) {
                        console.log('✅ Structure has 3 levels - using AI result');
                        createMapFromStructure(structure);
                    } else {
                        console.error('❌ Structure missing nested children, using fallback');
                        createBasicMapStructure();
                    }
                } catch (parseError) {
                    console.error('❌ JSON parse error:', parseError);
                    createBasicMapStructure();
                }
            } else {
                console.error('❌ No JSON found in response');
                createBasicMapStructure();
            }
        } catch (error) {
            console.error('Onboarding AI error:', error);
            createBasicMapStructure();
        }
    }
    
    function createMapFromStructure(structure) {
        // Update root label and clear any existing children
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear existing children
        
        // Get colors from current theme
        const themeColors = getThemeColors();
        
        console.log('🏗️ Creating map from structure, nodes:', structure.nodes?.length);
        
        // Add nodes from AI structure (3 levels deep)
        if (structure.nodes && Array.isArray(structure.nodes)) {
            // Limit to max 4 top-level nodes
            const topNodes = structure.nodes.slice(0, 4);
            
            topNodes.forEach((category, categoryIndex) => {
                // Use theme colors for top-level categories - start from index 1 (skip root color)
                const categoryColor = themeColors[(categoryIndex % 4) + 1];
                console.log('📁 Adding category:', category.label, 'color:', categoryColor);
                
                const categoryNode = store.addNode(store.data.id, {
                    label: category.label,
                    color: categoryColor,
                    source: 'onboarding'
                });
                
                if (!categoryNode) {
                    console.error('Failed to create category node');
                    return;
                }
                
                // Layer 2: Children of category - INHERIT parent color
                if (category.children && Array.isArray(category.children)) {
                    category.children.forEach((child) => {
                        console.log('  📄 Adding child:', child.label, 'inheriting color:', categoryColor);
                        
                        const childNode = store.addNode(categoryNode.id, {
                            label: child.label,
                            color: categoryColor,  // Inherit parent color
                            source: 'onboarding'
                        });
                        
                        if (!childNode) {
                            console.error('Failed to create child node');
                            return;
                        }
                        
                        // Layer 3: Grandchildren - INHERIT parent color
                        if (child.children && Array.isArray(child.children)) {
                            child.children.forEach((grandchild) => {
                                console.log('    📌 Adding grandchild:', grandchild.label, 'inheriting color:', categoryColor);
                                store.addNode(childNode.id, {
                                    label: grandchild.label,
                                    color: categoryColor,  // Inherit from top-level parent
                                    source: 'onboarding'
                                });
                            });
                        }
                    });
                }
            });
        }
        
        store.save();
        buildScene();
        completeOnboarding();
        
        // Auto-train neural network on newly created map (if training enabled)
        if (neuralNet.isReady && isNeuralTrainingAllowed()) {
            console.log('🧠 Auto-training neural network on new map...');
            setTimeout(() => {
                if (isNeuralTrainingAllowed()) {
                    neuralNet.train(store).then(() => {
                        console.log('✓ Neural network trained on initial map');
                    });
                }
            }, 3000); // Delay to let the scene fully build
        }
    }
    
    function createBasicMapStructure() {
        console.log('📝 Creating basic structure from scratch');
        // Create basic structure without AI
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear any existing children
        
        // Use colors from current theme palette
        const colors = getThemeColors();
        
        // Add default categories for starting from scratch
        // Using distinct colors that don't match root (orange)
        const categories = [
            { label: 'Goals', color: colors[4] },      // Blue
            { label: 'Ideas', color: colors[3] },      // Yellow
            { label: 'To Do', color: colors[7] },      // Purple
            { label: 'Wants', color: colors[2] }       // Teal
        ];
        
        categories.forEach(cat => {
            store.addNode(store.data.id, cat);
        });
        
        store.save();
        buildScene();
        completeOnboarding();
    }

    // AI-Assisted Setup choice - use class selector for clarity
    const aiChoiceBtn = document.querySelector('#onboarding-overlay .onboarding-choice.ai');
    if (aiChoiceBtn) {
        aiChoiceBtn.addEventListener('click', async () => {
            console.log('AI Assist clicked');
            mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
            
            // Check for authentication
            let isAuthenticated = false;
            if (typeof supabase !== 'undefined' && supabase !== null) {
                const { data } = await supabase.auth.getSession();
                isAuthenticated = !!data?.session;
            }
            
            if (!isAuthenticated) {
                showToast('Sign in for AI features', 'info');
                document.getElementById('auth-modal').classList.add('active');
            } else {
                showQuestionnaire();
            }
        });
    } else {
        console.error('Could not find AI choice button');
    }
    
    // Start from Scratch choice - use class selector for clarity
    const scratchChoiceBtn = document.querySelector('#onboarding-overlay .onboarding-choice.scratch');
    if (scratchChoiceBtn) {
        scratchChoiceBtn.addEventListener('click', () => {
            console.log('Start from Scratch clicked');
            mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
            createBasicMapStructure();
        });
    } else {
        console.error('Could not find Scratch choice button');
    }
    
    // Load Saved Map choice
    const loadChoiceBtn = document.querySelector('#onboarding-overlay .onboarding-choice.load');
    console.log('Original load button found:', loadChoiceBtn);
    if (loadChoiceBtn) {
        const handleLoadClick = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Load Saved Map activated (original)');
            showToast('Opening login...', 'info');
            
            // Check if logged in
            let isAuthenticated = false;
            if (typeof SupabaseAuth !== 'undefined') {
                isAuthenticated = SupabaseAuth.isLoggedIn();
            }
            
            if (!isAuthenticated) {
                // Show login modal
                console.log('Not authenticated, showing auth modal');
                showAuthModal(true);
                return;
            }
            
            // User is logged in, show saved maps
            await showSavedMapsModal();
        };
        
        loadChoiceBtn.addEventListener('click', handleLoadClick);
        loadChoiceBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleLoadClick(e);
        }, { passive: false });
    } else {
        console.warn('Load button not found in original overlay');
    }
    
    // Onboarding avatar click handler - use event delegation on overlay
    const onboardingOverlay = document.getElementById('onboarding-overlay');
    if (onboardingOverlay) {
        onboardingOverlay.addEventListener('click', (e) => {
            const avatar = e.target.closest('.onboarding-avatar');
            if (!avatar) return;
            
            console.log('Avatar clicked');
            const isAuthenticated = SupabaseAuth.isLoggedIn();
            if (isAuthenticated) {
                const user = SupabaseAuth.getUser();
                showToast(`Signed in as ${user.email}`, 'info');
            } else {
                showAuthModal(true);
            }
        });
    }
    
    // Update onboarding avatar state based on auth
    function updateOnboardingAvatar() {
        const avatar = document.getElementById('onboarding-avatar');
        if (!avatar) return;
        
        const isAuthenticated = SupabaseAuth.isLoggedIn();
        console.log('updateOnboardingAvatar - isAuthenticated:', isAuthenticated);
        
        if (isAuthenticated) {
            avatar.classList.add('logged-in');
            const user = SupabaseAuth.getUser();
            if (user?.email) {
                avatar.innerHTML = `<span style="color: white; font-weight: 600; font-size: 16px;">${user.email[0].toUpperCase()}</span>`;
            }
        } else {
            avatar.classList.remove('logged-in');
            avatar.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                <circle cx="12" cy="7" r="4"/>
            </svg>`;
        }
    }
    
    // Show load option if logged in
    async function updateOnboardingForAuth() {
        console.log('updateOnboardingForAuth called');
        
        // Update avatar state
        updateOnboardingAvatar();
        
        const choicesEl = document.getElementById('onboarding-choices');
        if (!choicesEl) {
            console.log('choicesEl not found');
            return;
        }
        
        let isAuthenticated = false;
        if (typeof supabase !== 'undefined' && supabase !== null) {
            const { data } = await supabase.auth.getSession();
            isAuthenticated = !!data?.session;
        }
        
        console.log('updateOnboardingForAuth - isAuthenticated:', isAuthenticated);
        console.log('SupabaseSync.syncEnabled:', SupabaseSync.syncEnabled);
        
        if (isAuthenticated) {
            choicesEl.classList.add('logged-in');
            console.log('Added logged-in class to choices');
            
            // Check if user has saved maps
            const maps = await SupabaseSync.loadUserMaps();
            console.log('Maps found:', maps.length);
            
            const loadBtn = document.querySelector('#onboarding-overlay .onboarding-choice.load');
            if (maps.length === 0) {
                // No saved maps, hide the load option
                if (loadBtn) loadBtn.style.display = 'none';
            } else {
                // Has saved maps, make sure load option is visible
                if (loadBtn) loadBtn.style.display = '';
            }
        } else {
            choicesEl.classList.remove('logged-in');
        }
    }
    
    // Show saved maps in a modal for selection
    async function showSavedMapsModal() {
        const maps = await SupabaseSync.loadUserMaps();
        
        if (maps.length === 0) {
            showToast('No saved maps found', 'info');
            return;
        }
        
        // Create modal for map selection
        const modal = document.createElement('div');
        modal.className = 'saved-maps-modal';
        modal.innerHTML = `
            <div class="saved-maps-content">
                <div class="saved-maps-header">
                    <h2>Your Saved Maps</h2>
                    <button class="saved-maps-close">&times;</button>
                </div>
                <div class="saved-maps-list">
                    ${maps.map(map => `
                        <div class="saved-map-item" data-map-id="${map.id}">
                            <div class="saved-map-icon">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"/>
                                    <circle cx="12" cy="12" r="4"/>
                                    <line x1="12" y1="2" x2="12" y2="4"/>
                                    <line x1="12" y1="20" x2="12" y2="22"/>
                                    <line x1="2" y1="12" x2="4" y2="12"/>
                                    <line x1="20" y1="12" x2="22" y2="12"/>
                                </svg>
                            </div>
                            <div class="saved-map-info">
                                <div class="saved-map-name">${escapeHTML(map.name)}</div>
                                <div class="saved-map-date">${new Date(map.updated_at).toLocaleDateString()}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .saved-maps-modal {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.8);
                backdrop-filter: blur(8px);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                animation: fadeIn 0.2s ease;
            }
            .saved-maps-content {
                background: var(--bg-secondary);
                border-radius: 20px;
                border: 1px solid var(--glass-border);
                width: 90%;
                max-width: 400px;
                max-height: 70vh;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            .saved-maps-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: var(--space-4);
                border-bottom: 1px solid var(--glass-border);
            }
            .saved-maps-header h2 {
                font-size: 18px;
                font-weight: 600;
                margin: 0;
            }
            .saved-maps-close {
                background: none;
                border: none;
                font-size: 24px;
                color: var(--text-secondary);
                cursor: pointer;
                padding: 0;
                line-height: 1;
            }
            .saved-maps-list {
                overflow-y: auto;
                padding: var(--space-3);
                display: flex;
                flex-direction: column;
                gap: var(--space-2);
            }
            .saved-map-item {
                display: flex;
                align-items: center;
                gap: var(--space-3);
                padding: var(--space-3);
                background: var(--bg-primary);
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }
            .saved-map-item:hover {
                background: var(--bg-elevated);
                transform: translateX(4px);
            }
            .saved-map-icon {
                width: 40px;
                height: 40px;
                background: linear-gradient(135deg, #3b82f6, #60a5fa);
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .saved-map-icon svg {
                width: 20px;
                height: 20px;
                stroke: white;
            }
            .saved-map-info {
                flex: 1;
            }
            .saved-map-name {
                font-weight: 600;
                color: var(--text-primary);
            }
            .saved-map-date {
                font-size: 12px;
                color: var(--text-secondary);
            }
        `;
        document.head.appendChild(style);
        document.body.appendChild(modal);
        
        // Close button
        modal.querySelector('.saved-maps-close').addEventListener('click', () => {
            modal.remove();
            style.remove();
        });
        
        // Click outside to close
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
                style.remove();
            }
        });
        
        // Map selection
        modal.querySelectorAll('.saved-map-item').forEach(item => {
            item.addEventListener('click', async () => {
                const mapId = item.dataset.mapId;
                modal.remove();
                style.remove();
                
                showToast('Loading map...', 'info');
                
                const mapData = await SupabaseSync.loadMap(mapId);
                if (mapData && mapData.data) {
                    store.data = mapData.data;
                    store.expandedNodes = new Set([store.data.id]);
                    store.save();
                    buildScene();
                    resetCamera();
                    completeOnboarding();
                    showToast(`Loaded "${mapData.name}"`, 'success');

                    // Train neural net (if training enabled)
                    setTimeout(() => {
                        if (typeof neuralNet !== 'undefined' && isNeuralTrainingAllowed()) {
                            neuralNet.train(store).catch(err => console.warn('Neural net training failed:', err));
                        }
                    }, 300);
                } else {
                    showToast('Failed to load map', 'error');
                }
            });
        });
    }
    
    // Check auth status on load
    updateOnboardingForAuth();
    
    const onboardingNameInput = document.querySelector('#onboarding-overlay #onboarding-name');
    if (onboardingNameInput) {
        onboardingNameInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter') {
                mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
                
                // Check for authentication
                let isAuthenticated = false;
                if (typeof supabase !== 'undefined' && supabase !== null) {
                    const { data } = await supabase.auth.getSession();
                    isAuthenticated = !!data?.session;
                }
                
                if (!isAuthenticated) {
                    showToast('Sign in for AI features', 'info');
                    document.getElementById('auth-modal').classList.add('active');
                } else {
                    showQuestionnaire();
                }
            }
        });
    }
    
    document.getElementById('question-next').addEventListener('click', () => {
        // Save current answer
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            // All questions answered
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-back').addEventListener('click', () => {
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        if (currentQuestion > 0) {
            currentQuestion--;
            updateQuestionUI();
        }
    });
    
    document.getElementById('question-skip-btn').addEventListener('click', () => {
        questionAnswers[currentQuestion] = '';
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('question-next').click();
        }
    });

    function completeOnboarding() {
        localStorage.setItem(CONFIG.ONBOARDING_KEY, 'true');
        const overlay = document.getElementById('onboarding-overlay');
        overlay.classList.add('fade-out');
        setTimeout(() => overlay.remove(), 800);
    }

    // ═══════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    async function init() {
        try {
            // Check onboarding first - hide overlay immediately if already completed
            const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
            if (onboarded) {
                document.getElementById('onboarding-overlay').style.display = 'none';
            }
            
            // Initialize Supabase (if configured)
            initSupabase();
            const initialUser = await SupabaseAuth.init();
            
            themeManager.init();
            updateColorPickers(); // Ensure color pickers match saved theme
            chatManager.init();
            initScene();
            
            // Update auth UI after scene is initialized (DOM ready)
            setTimeout(() => {
                updateAuthUI(initialUser);
                
                // If user is logged in, initialize sync
                if (initialUser) {
                    SupabaseSync.init().then(async () => {
                        // Update onboarding now that sync is ready
                        await updateOnboardingForAuth();
                        
                        // Check for cloud data
                        const maps = await SupabaseSync.loadUserMaps();
                        if (maps.length > 0) {
                            console.log(`Found ${maps.length} cloud map(s)`);
                        }
                    });
                }
            }, 100);
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                setTimeout(() => document.getElementById('loading').remove(), 500);
                
                // Show welcome modal for new users (not logged in)
                setTimeout(() => {
                    const user = SupabaseAuth.getUser();
                    const hasSkippedWelcome = sessionStorage.getItem('mynd-skipped-welcome');
                    
                    if (!user && !hasSkippedWelcome) {
                        // Update modal text for welcome experience
                        document.getElementById('auth-title').textContent = 'Welcome to MYND';
                        document.getElementById('auth-subtitle').textContent = 'Sign in to save and sync your mind maps across devices';
                        document.getElementById('auth-modal').classList.add('active');
                    }
                }, 300);
            }, 500);
            
            // Show keyboard hints briefly
            setTimeout(() => {
                if (window.innerWidth > 768) {
showKeyboardHints();
                }
            }, 2000);
            
            console.log('✨ MYND initialized successfully');
            
        } catch (error) {
            console.error('Initialization failed:', error);
            const loading = document.getElementById('loading');
            if (loading) {
                loading.innerHTML = `
                    <div class="loading-content">
                        <div class="loading-logo" style="background: #f87171;">!</div>
                        <div class="loading-text" style="color: #f87171;">Failed to load</div>
                        <p style="margin-top: 16px; color: var(--text-muted); font-size: 13px;">${error.message}</p>
                    </div>
                `;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // NEURAL NETWORK UI INTEGRATION
    // ═══════════════════════════════════════════════════════════════════
    
    const NeuralUI = {
        panel: null,
        isOpen: false,
        suggestionsForNodeId: null, // Track which node suggestions are for
        openedAt: null, // Track when panel was opened (for click-outside delay)
        
        init() {
            this.panel = document.getElementById('neural-panel');
            this.bindEvents();
            this.initNeuralNetwork();
        },
        
        bindEvents() {
            // Toggle panel
            document.getElementById('btn-neural')?.addEventListener('click', () => {
                this.toggle();
            });
            
            // Close button
            document.getElementById('neural-close')?.addEventListener('click', () => {
                this.close();
            });

            // Training toggle
            document.getElementById('neural-training-toggle')?.addEventListener('change', (e) => {
                neuralTrainingEnabled = e.target.checked;
                showToast(neuralTrainingEnabled ? 'Neural training enabled' : 'Neural training disabled', 'info');
                console.log(`Neural training ${neuralTrainingEnabled ? 'enabled' : 'disabled'}`);
            });

            // Train button (now in settings modal)
            document.getElementById('neural-train-settings-btn')?.addEventListener('click', () => {
                this.trainNetwork();
                // Close settings modal
                document.getElementById('api-key-modal').classList.remove('active');
            });
            
            // Train button in neural panel
            document.getElementById('neural-train-panel-btn')?.addEventListener('click', () => {
                this.trainNetwork();
            });
            
            // Suggest connections button
            document.getElementById('neural-suggest-btn')?.addEventListener('click', () => {
                this.suggestConnections();
            });
            
            // Reset button (now in settings modal)
            document.getElementById('neural-reset-settings-btn')?.addEventListener('click', () => {
                this.resetNetwork();
                // Close settings modal
                document.getElementById('api-key-modal').classList.remove('active');
            });
            
            // Smart suggest button
            document.getElementById('neural-smart-suggest-btn')?.addEventListener('click', () => {
                this.smartExpand();
            });
            
            // CGT Insights button
            document.getElementById('cgt-insights-btn')?.addEventListener('click', () => {
                this.showCGTInsights();
            });
            
            // Transfer Suggestions button
            document.getElementById('transfer-suggest-btn')?.addEventListener('click', () => {
                this.showTransferSuggestions();
            });
            
            // GPU Benchmark button
            document.getElementById('gpu-benchmark-btn')?.addEventListener('click', async () => {
                if (!gpuCompute.initialized) {
                    await gpuCompute.initialize();
                }
                
                showToast('Running GPU benchmark...', 'info');
                
                try {
                    const results = await gpuCompute.benchmark(200, 128);
                    
                    // Display results in toast
                    if (gpuCompute.supported) {
                        showToast(`GPU ${results.batchSimilarity.speedup} faster! (${results.batchSimilarity.gpu} vs CPU ${results.batchSimilarity.cpu})`, 'success');
                    } else {
                        showToast(`CPU mode: ${results.batchSimilarity.cpu} for 200 vectors`, 'info');
                    }
                    
                    // Update stats
                    this.updateStatus();
                    
                } catch (e) {
                    console.error('Benchmark failed:', e);
                    showToast('Benchmark failed', 'error');
                }
            });
            
            // Semantic Engine - Load Model button
            document.getElementById('semantic-load-btn')?.addEventListener('click', async () => {
                const btn = document.getElementById('semantic-load-btn');
                const progressRow = document.getElementById('semantic-progress-row');
                
                btn.disabled = true;
                btn.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px; animation: spin 1s linear infinite;">
                        <circle cx="12" cy="12" r="10" stroke-dasharray="30 60"/>
                    </svg>
                    Loading Model...
                `;
                progressRow.style.display = 'flex';
                
                // Set up progress callback
                semanticEngine.onProgress = (progress, status) => {
                    document.getElementById('semantic-progress').textContent = `${progress}%`;
                };
                
                semanticEngine.onReady = () => {
                    btn.style.display = 'none';
                    document.getElementById('semantic-cluster-btn').style.display = 'flex';
                    document.getElementById('semantic-holes-btn').style.display = 'flex';
                    progressRow.style.display = 'none';
                    document.getElementById('semantic-embeddings-row').style.display = 'flex';
                    document.getElementById('semantic-inference-row').style.display = 'flex';
                    showToast('Semantic model loaded! Real AI ready.', 'success');
                    this.updateStatus();
                };
                
                try {
                    await semanticEngine.initialize();
                    await semanticEngine.load(); // Load cached embeddings
                } catch (e) {
                    console.error('Semantic engine failed:', e);
                    btn.disabled = false;
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M12 6v6l4 2"/>
                        </svg>
                        Load Semantic Model (22MB)
                    `;
                    showToast('Failed to load model', 'error');
                }
            });
            
            // Semantic Engine - Detect Topic Clusters
            document.getElementById('semantic-cluster-btn')?.addEventListener('click', async () => {
                if (!semanticEngine.initialized) {
                    showToast('Load semantic model first', 'info');
                    return;
                }
                
                // If clusters are active, reset them
                if (clusterColorsActive) {
                    resetClusterColors();
                    resetClusterHighlight();
                    
                    // Update button
                    const btn = document.getElementById('semantic-cluster-btn');
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                            <circle cx="6" cy="6" r="3"/>
                            <circle cx="18" cy="6" r="3"/>
                            <circle cx="12" cy="18" r="3"/>
                        </svg>
                        Detect Topic Clusters
                    `;
                    btn.style.background = 'linear-gradient(135deg, #8b5cf6, #a78bfa)';
                    
                    // Hide suggestions
                    document.getElementById('neural-suggestions').style.display = 'none';
                    
                    showToast('Cluster colors reset', 'info');
                    return;
                }
                
                showToast('Analyzing topic clusters...', 'info');
                
                try {
                    const clusters = await semanticEngine.detectTopicClusters(store);
                    
                    if (!clusters || clusters.length === 0) {
                        showToast('Not enough nodes to cluster', 'info');
                        return;
                    }
                    
                    // Apply cluster colors to 3D visualization
                    applyClusterColors(clusters);
                    
                    // Update button to show reset option
                    const btn = document.getElementById('semantic-cluster-btn');
                    btn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                        Reset Cluster Colors
                    `;
                    btn.style.background = 'linear-gradient(135deg, #ef4444, #f87171)';
                    
                    // Display interactive cluster legend
                    const suggestionsSection = document.getElementById('neural-suggestions');
                    const suggestionsList = document.getElementById('neural-suggestions-list');
                    
                    const colorHexStrings = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#14b8a6'];
                    
                    let html = `
                        <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                <circle cx="6" cy="6" r="3"/>
                                <circle cx="18" cy="6" r="3"/>
                                <circle cx="12" cy="18" r="3"/>
                            </svg>
                            ${clusters.length} Topic Clusters
                            <span style="font-size: 9px; background: rgba(34, 197, 94, 0.2); color: #22c55e; padding: 1px 4px; border-radius: 3px;">COLORED</span>
                        </div>
                        <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 12px;">
                            Click a cluster to highlight • Click again to reset
                        </div>
                    `;
                    
                    clusters.forEach((cluster, i) => {
                        const color = colorHexStrings[i % colorHexStrings.length];
                        html += `
                            <div class="cluster-legend-item" data-cluster-index="${i}" style="
                                background: var(--bg-tertiary); 
                                border-radius: 8px; 
                                padding: 10px; 
                                margin-bottom: 8px; 
                                border-left: 4px solid ${color};
                                cursor: pointer;
                                transition: all 0.2s ease;
                            " onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='var(--bg-tertiary)'">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                    <div style="width: 12px; height: 12px; border-radius: 50%; background: ${color};"></div>
                                    <span style="font-weight: 600; color: ${color};">
                                        ${cluster.label || `Cluster ${i + 1}`}
                                    </span>
                                    <span style="font-size: 10px; color: var(--text-muted); margin-left: auto;">
                                        ${cluster.size} nodes
                                    </span>
                                </div>
                                <div style="font-size: 10px; color: var(--text-secondary); padding-left: 20px;">
                                    ${cluster.nodes.slice(0, 4).map(n => n.label).join(', ')}
                                    ${cluster.nodes.length > 4 ? ` +${cluster.nodes.length - 4} more` : ''}
                                </div>
                            </div>
                        `;
                    });
                    
                    // Add "Show All" button
                    html += `
                        <button id="cluster-show-all-btn" style="
                            width: 100%;
                            padding: 8px;
                            margin-top: 8px;
                            background: var(--bg-tertiary);
                            border: 1px solid var(--border);
                            border-radius: 6px;
                            color: var(--text-secondary);
                            font-size: 11px;
                            cursor: pointer;
                            transition: all 0.2s ease;
                        ">
                            Show All Clusters
                        </button>
                    `;
                    
                    if (suggestionsSection && suggestionsList) {
                        suggestionsList.innerHTML = html;
                        suggestionsSection.style.display = 'block';
                        
                        // Track which cluster is highlighted
                        let highlightedCluster = null;
                        
                        // Add click handlers to cluster items
                        suggestionsList.querySelectorAll('.cluster-legend-item').forEach(el => {
                            el.addEventListener('click', () => {
                                const clusterIndex = parseInt(el.dataset.clusterIndex);
                                
                                if (highlightedCluster === clusterIndex) {
                                    // Already highlighted, reset
                                    resetClusterHighlight();
                                    highlightedCluster = null;
                                    
                                    // Reset all item styles
                                    suggestionsList.querySelectorAll('.cluster-legend-item').forEach(item => {
                                        item.style.opacity = '1';
                                        item.style.transform = 'scale(1)';
                                    });
                                } else {
                                    // Highlight this cluster
                                    highlightCluster(clusterIndex);
                                    highlightedCluster = clusterIndex;
                                    
                                    // Update item styles
                                    suggestionsList.querySelectorAll('.cluster-legend-item').forEach(item => {
                                        if (parseInt(item.dataset.clusterIndex) === clusterIndex) {
                                            item.style.opacity = '1';
                                            item.style.transform = 'scale(1.02)';
                                        } else {
                                            item.style.opacity = '0.5';
                                            item.style.transform = 'scale(0.98)';
                                        }
                                    });
                                    
                                    // Zoom camera to cluster center
                                    const cluster = clusters[clusterIndex];
                                    if (cluster.nodes.length > 0) {
                                        const center = new THREE.Vector3();
                                        let count = 0;
                                        cluster.nodes.forEach(n => {
                                            const mesh = nodes.get(n.id);
                                            if (mesh) {
                                                center.add(mesh.position);
                                                count++;
                                            }
                                        });
                                        if (count > 0) {
                                            center.divideScalar(count);
                                            cameraTargetGoal.copy(center);
                                        }
                                    }
                                }
                            });
                        });
                        
                        // Show All button handler
                        document.getElementById('cluster-show-all-btn')?.addEventListener('click', () => {
                            resetClusterHighlight();
                            highlightedCluster = null;
                            
                            // Reset all item styles
                            suggestionsList.querySelectorAll('.cluster-legend-item').forEach(item => {
                                item.style.opacity = '1';
                                item.style.transform = 'scale(1)';
                            });
                        });
                    }
                    
                    // Save embeddings
                    await semanticEngine.save();
                    this.updateStatus();
                    
                    showToast(`Colored ${clusters.length} topic clusters!`, 'success');
                    
                } catch (e) {
                    console.error('Clustering failed:', e);
                    showToast('Clustering failed', 'error');
                }
            });
            
            // Semantic Engine - Find Hidden Connections
            document.getElementById('semantic-holes-btn')?.addEventListener('click', async () => {
                if (!semanticEngine.initialized) {
                    showToast('Load semantic model first', 'info');
                    return;
                }
                
                showToast('Finding semantic connections...', 'info');
                
                try {
                    const holes = await semanticEngine.findSemanticStructuralHoles(store, 0.65);
                    
                    if (holes.length === 0) {
                        showToast('No hidden connections found', 'info');
                        return;
                    }
                    
                    // Display holes in suggestions panel
                    const suggestionsSection = document.getElementById('neural-suggestions');
                    const suggestionsList = document.getElementById('neural-suggestions-list');
                    
                    let html = `
                        <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44"/>
                                <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44"/>
                            </svg>
                            ${holes.length} Hidden Connections
                            <span style="font-size: 9px; background: rgba(34, 197, 94, 0.2); color: #22c55e; padding: 1px 4px; border-radius: 3px;">REAL AI</span>
                        </div>
                        <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 12px;">
                            These nodes are semantically similar but not directly connected.
                        </div>
                    `;
                    
                    holes.forEach((hole, i) => {
                        const simPercent = Math.round(hole.similarity * 100);
                        html += `
                            <div class="neural-suggestion" data-node-a="${hole.nodeA.id}" data-node-b="${hole.nodeB.id}" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 6px; cursor: pointer;">
                                <div style="flex: 1;">
                                    <span style="color: var(--text-primary);">"${hole.nodeA.label}"</span>
                                    <span style="color: var(--text-muted); margin: 0 4px;">↔</span>
                                    <span style="color: var(--text-primary);">"${hole.nodeB.label}"</span>
                                </div>
                                <span style="background: rgba(34, 197, 94, 0.2); color: #22c55e; padding: 2px 6px; border-radius: 4px; font-size: 10px;">
                                    ${simPercent}%
                                </span>
                            </div>
                        `;
                    });
                    
                    if (suggestionsSection && suggestionsList) {
                        suggestionsList.innerHTML = html;
                        suggestionsSection.style.display = 'block';
                        
                        // Add click handlers to zoom to nodes
                        suggestionsList.querySelectorAll('.neural-suggestion').forEach(el => {
                            el.addEventListener('click', () => {
                                const nodeAId = el.dataset.nodeA;
                                const nodeBId = el.dataset.nodeB;
                                
                                // Find and zoom to first node
                                const meshA = nodes.get(nodeAId);
                                if (meshA) {
                                    selectNode(meshA);
                                    showToast(`Selected "${store.findNode(nodeAId)?.label}"`, 'info');
                                }
                            });
                        });
                    }
                    
                    // Save embeddings
                    await semanticEngine.save();
                    this.updateStatus();
                    
                    showToast(`Found ${holes.length} hidden connections!`, 'success');
                    
                } catch (e) {
                    console.error('Finding holes failed:', e);
                    showToast('Analysis failed', 'error');
                }
            });
            
            // Close when clicking outside (with delay to prevent immediate close on open)
            document.addEventListener('click', (e) => {
                // Skip if panel just opened (within 300ms)
                if (this.openedAt && Date.now() - this.openedAt < 300) {
                    return;
                }
                
                if (this.isOpen && 
                    !this.panel?.contains(e.target) && 
                    !e.target.closest('#btn-neural') &&
                    !e.target.closest('[data-action="neural"]') &&
                    !e.target.closest('.sheet-quick-btn')) {
                    this.close();
                }
            });
        },
        
        async initNeuralNetwork() {
            // Initialize preference tracker, semantic memory, and user profile first (don't need TensorFlow)
            await preferenceTracker.init();
            await semanticMemory.init();
            await userProfile.init();
            await conceptAbstractor.init();
            await metaLearner.init();
            
            // DON'T initialize neural network here - defer until first AI feature use
            // This saves ~10MB download and several seconds on mobile
            console.log('✓ Preference systems ready (TensorFlow deferred)');
        },
        
        async ensureNeuralNetReady() {
            // Lazy initialize neural network when first needed
            if (neuralNet.isReady) return true;
            if (neuralNet.isInitializing) {
                // Wait for ongoing initialization
                return new Promise(resolve => {
                    const check = setInterval(() => {
                        if (neuralNet.isReady || neuralNet.loadError) {
                            clearInterval(check);
                            resolve(neuralNet.isReady);
                        }
                    }, 100);
                });
            }
            
            neuralNet.isInitializing = true;
            console.log('🧠 First AI feature used - loading TensorFlow...');
            
            const success = await neuralNet.initialize();
            neuralNet.isInitializing = false;
            
            if (success) {
                document.getElementById('neural-train-settings-btn').disabled = false;
                this.updateStatus();
                
                // Set up event listeners
                this.setupNeuralEventListeners();
            }
            
            return success;
        },
        
        setupNeuralEventListeners() {
            neuralNet.on('onTrainingStart', () => {
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = true;
                    trainBtn.innerHTML = `
                        <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2"/>
                        </svg>
                        Training...
                    `;
                }
                document.getElementById('neural-progress').style.display = 'block';
            });
            
            neuralNet.on('onTrainingProgress', (data) => {
                document.getElementById('neural-progress-bar').style.width = `${data.progress}%`;
                document.getElementById('neural-status-text').textContent = 
                    `Training ${data.phase} (${Math.round(data.progress)}%)`;
                document.getElementById('neural-status-text').className = 'neural-status-value training';
            });
            
            neuralNet.on('onTrainingComplete', (data) => {
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = false;
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    `;
                }
                document.getElementById('neural-progress').style.display = 'none';
                document.getElementById('neural-suggest-btn').disabled = false;
                this.updateStatus();
                showToast('Neural network trained successfully!', 'success');
            });
            
            // Auto-train on first load if no model exists but enough nodes do
            const stats = neuralNet.getStats();
            if (!stats.hasCategoryModel && !stats.hasPredictionModel) {
                // Count nodes
                let nodeCount = 0;
                const countNodes = (node) => {
                    nodeCount++;
                    node.children?.forEach(countNodes);
                };
                countNodes(store.data);
                
                if (nodeCount >= CONFIG.NEURAL_NET.minTrainingNodes && isNeuralTrainingAllowed()) {
                    console.log('🧠 Auto-training on first load...');
                    setTimeout(() => {
                        if (isNeuralTrainingAllowed()) {
                            neuralNet.train(store);
                        }
                    }, 2000); // Delay to let UI settle
                }
            }
        },
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        open() {
            // Close chat panel if open
            if (typeof chatManager !== 'undefined' && chatManager.isOpen) {
                chatManager.close();
            }
            
            const isMobile = window.innerWidth <= 768;
            
            // Remove any leftover test div
            const testDiv = document.getElementById('neural-test-div');
            if (testDiv) testDiv.remove();
            
            this.panel = document.getElementById('neural-panel');
            
            if (!this.panel) {
                showToast('Neural panel not found', 'error');
                return;
            }
            
            this.panel.classList.add('active');
            
            // Mobile-specific positioning using fixed for smooth sliding
            if (isMobile) {
                // Determine position based on current sheet state
                const sheetMinimized = document.body.classList.contains('sheet-minimized');
                const bottomPosition = sheetMinimized ? '80px' : '140px';
                
                this.panel.style.cssText = `
                    visibility: visible;
                    position: fixed;
                    bottom: ${bottomPosition};
                    left: 12px;
                    right: 12px;
                    top: auto;
                    width: auto;
                    max-height: 70vh;
                    z-index: 999998;
                    background: var(--bg-secondary);
                    pointer-events: auto;
                    transform: none;
                    border-radius: 20px;
                    padding: 20px;
                    box-sizing: border-box;
                    overflow-y: auto;
                    border: 1px solid var(--glass-border);
                    transition: bottom 0.3s ease-out;
                `;
                document.body.appendChild(this.panel);
            }
            
            // Record when we opened (for click-outside delay)
            this.openedAt = Date.now();
            this.isOpen = true;
            document.getElementById('btn-neural')?.classList.add('active');
            this.updateStatus();
            
            // Check if we should clear suggestions
            const currentNodeId = selectedNode?.userData?.id;
            if (this.suggestionsForNodeId && this.suggestionsForNodeId !== currentNodeId) {
                this.clearSuggestions();
            }
        },
        
        close() {
            if (!this.panel) return;
            
            // Immediately and completely hide the panel
            this.panel.classList.remove('active');
            this.panel.style.cssText = 'visibility: hidden !important; opacity: 0 !important; pointer-events: none !important; display: none !important;';
            
            // Remove test div if exists
            const testDiv = document.getElementById('neural-test-div');
            if (testDiv) testDiv.remove();
            
            this.isOpen = false;
            this.openedAt = null;
            document.getElementById('btn-neural')?.classList.remove('active');
            
            // Clear inline styles after brief delay so CSS takes over
            setTimeout(() => {
                if (this.panel && !this.isOpen) {
                    this.panel.style.cssText = '';
                }
            }, 100);
            
            // If no node is selected, clear suggestions for next open
            if (!selectedNode) {
                this.clearSuggestions();
            }
        },
        
        clearSuggestions() {
            this.suggestionsForNodeId = null;
            document.getElementById('neural-suggestions').style.display = 'none';
            document.getElementById('neural-suggestions-list').innerHTML = '';
            document.getElementById('neural-suggestions-for').textContent = '';
        },
        
        updateStatus() {
            const stats = neuralNet.getStats();
            
            // Update status text
            const statusText = document.getElementById('neural-status-text');
            const trainBtn = document.getElementById('neural-train-panel-btn');
            
            if (stats.isTraining) {
                statusText.textContent = 'Training...';
                statusText.className = 'neural-status-value training';
                if (trainBtn) trainBtn.style.display = 'none';
            } else if (stats.isReady) {
                statusText.textContent = stats.hasPredictionModel ? 'Trained' : 'Ready';
                statusText.className = 'neural-status-value ready';
                // Hide train button when ready, but allow retraining
                if (trainBtn) {
                    trainBtn.style.display = 'flex';
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                            <path d="M23 4v6h-6M1 20v-6h6"/>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                        </svg>
                        Retrain Network
                    `;
                    trainBtn.style.background = 'linear-gradient(135deg, #6b7280, #9ca3af)';
                }
            } else {
                statusText.textContent = 'Not Ready';
                statusText.className = 'neural-status-value not-ready';
                // Show prominent train button when not ready
                if (trainBtn) {
                    trainBtn.style.display = 'flex';
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 16px; height: 16px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    `;
                    trainBtn.style.background = 'linear-gradient(135deg, #f59e0b, #fbbf24)';
                }
            }
            
            // Update counts
            document.getElementById('neural-category-count').textContent = stats.categories.length;
            document.getElementById('neural-pattern-count').textContent = stats.expansionPatterns;
            document.getElementById('neural-embedding-count').textContent = stats.cachedEmbeddings;
            
            // Update preference stats
            const prefStats = preferenceTracker.getStats();
            document.getElementById('pref-accepted-count').textContent = prefStats.totalAccepted;
            document.getElementById('pref-ignored-count').textContent = prefStats.totalIgnored;
            
            if (prefStats.overallAcceptanceRate !== null) {
                const rate = Math.round(prefStats.overallAcceptanceRate * 100);
                const rateEl = document.getElementById('pref-acceptance-rate');
                rateEl.textContent = `${rate}%`;
                rateEl.style.color = rate >= 50 ? '#22c55e' : rate >= 30 ? '#f59e0b' : '#ef4444';
            } else {
                document.getElementById('pref-acceptance-rate').textContent = '—';
            }
            
            // Show style preference if we have enough data
            const style = prefStats.stylePreferences;
            const styleRow = document.getElementById('pref-style-row');
            const styleEl = document.getElementById('pref-style');
            if (prefStats.totalAccepted + prefStats.totalIgnored >= 15) {
                styleRow.style.display = 'flex';
                let styleText = [];
                if (style.prefersActionLabels > 0.3) styleText.push('Action-oriented');
                if (style.prefersShortLabels > 0.3) styleText.push('Concise');
                if (style.prefersDescriptive > 0.3) styleText.push('Descriptive');
                if (style.prefersActionLabels < -0.3) styleText.push('Noun-based');
                styleEl.textContent = styleText.length > 0 ? styleText.join(', ') : 'Balanced';
            } else {
                styleRow.style.display = 'none';
            }
            
            // Update incremental learning stats
            document.getElementById('incr-pattern-weights').textContent = stats.patternWeights || 0;
            document.getElementById('incr-high-confidence').textContent = stats.highConfidencePatterns || 0;
            
            if (stats.avgPatternWeight > 0) {
                const avgEl = document.getElementById('incr-avg-weight');
                avgEl.textContent = `${Math.round(stats.avgPatternWeight * 100)}%`;
                avgEl.style.color = stats.avgPatternWeight >= 0.6 ? '#22c55e' : stats.avgPatternWeight >= 0.4 ? '#f59e0b' : 'var(--text-secondary)';
            } else {
                document.getElementById('incr-avg-weight').textContent = '—';
            }
            
            // Show pending embeddings if any
            const pendingRow = document.getElementById('incr-pending-row');
            if (stats.pendingEmbeddings > 0) {
                pendingRow.style.display = 'flex';
                document.getElementById('incr-pending').textContent = stats.pendingEmbeddings;
            } else {
                pendingRow.style.display = 'none';
            }
            
            // Update semantic memory stats
            const memStats = semanticMemory.getStats();
            document.getElementById('mem-total-count').textContent = memStats.totalMemories;
            document.getElementById('mem-important-count').textContent = memStats.importantMemories;
            
            if (memStats.avgImportance > 0) {
                const avgMemEl = document.getElementById('mem-avg-importance');
                avgMemEl.textContent = `${Math.round(memStats.avgImportance * 100)}%`;
                avgMemEl.style.color = memStats.avgImportance >= 0.6 ? '#22c55e' : memStats.avgImportance >= 0.4 ? '#f59e0b' : 'var(--text-secondary)';
            } else {
                document.getElementById('mem-avg-importance').textContent = '—';
            }
            
            // Update user profile stats
            const profileStats = userProfile.getStats();
            document.getElementById('profile-nodes-count').textContent = profileStats.totalNodes;
            
            // Preferred depth
            const depthLabels = { 1: 'Shallow', 2: 'Moderate', 3: 'Deep', 4: 'Very Deep' };
            document.getElementById('profile-depth').textContent = 
                profileStats.totalNodes >= 10 ? depthLabels[profileStats.preferredDepth] || 'Moderate' : '—';
            
            // Naming style
            const styleLabels = {
                'concise': 'Concise',
                'descriptive': 'Descriptive',
                'action-oriented': 'Action-oriented',
                'balanced': 'Balanced'
            };
            document.getElementById('profile-naming-style').textContent = 
                profileStats.totalLabels >= 10 ? styleLabels[profileStats.namingStyle] || 'Balanced' : '—';
            
            // Focus areas
            const focusRow = document.getElementById('profile-focus-row');
            if (profileStats.focusAreas && profileStats.focusAreas.length > 0) {
                focusRow.style.display = 'flex';
                document.getElementById('profile-focus').textContent = profileStats.focusAreas.slice(0, 2).join(', ');
            } else {
                focusRow.style.display = 'none';
            }
            
            // Peak hours
            const peakRow = document.getElementById('profile-peak-row');
            if (profileStats.peakHours && profileStats.peakHours.length > 0) {
                peakRow.style.display = 'flex';
                const peakStr = profileStats.peakHours.slice(0, 3).map(h => {
                    const hour12 = h % 12 || 12;
                    const ampm = h < 12 ? 'am' : 'pm';
                    return `${hour12}${ampm}`;
                }).join(', ');
                document.getElementById('profile-peak-hours').textContent = peakStr;
            } else {
                peakRow.style.display = 'none';
            }
            
            // Update relationship type stats
            const relStats = relationshipClassifier.getStats();
            document.getElementById('rel-classified-count').textContent = relStats.cachedClassifications;
            
            // Find dominant type
            const dominantRow = document.getElementById('rel-dominant-row');
            const typeDist = relStats.typeDistribution;
            const sortedTypes = Object.entries(typeDist).sort((a, b) => b[1] - a[1]);
            
            if (sortedTypes.length > 0 && sortedTypes[0][1] >= 3) {
                dominantRow.style.display = 'flex';
                const typeLabels = {
                    decomposition: 'Decomposition',
                    component: 'Components',
                    sequence: 'Sequence',
                    category: 'Categories',
                    example: 'Examples',
                    attribute: 'Attributes',
                    cause_effect: 'Cause/Effect',
                    comparison: 'Comparison',
                    temporal: 'Temporal',
                    action: 'Actions'
                };
                document.getElementById('rel-dominant-type').textContent = typeLabels[sortedTypes[0][0]] || sortedTypes[0][0];
            } else {
                dominantRow.style.display = 'none';
            }
            
            // Count transfer-ready patterns (high confidence, typed)
            const transferRow = document.getElementById('rel-transfer-row');
            let transferReady = 0;
            for (const [, weight] of neuralNet.patternWeights) {
                if (weight.relationshipType && weight.relationshipConfidence >= 0.5 && weight.weight >= 0.5) {
                    transferReady++;
                }
            }
            
            if (transferReady >= 3) {
                transferRow.style.display = 'flex';
                document.getElementById('rel-transfer-count').textContent = transferReady;
            } else {
                transferRow.style.display = 'none';
            }
            
            // Update concept abstraction stats
            const conceptStats = conceptAbstractor.getStats();
            document.getElementById('concept-schemas').textContent = conceptStats.schemas;
            document.getElementById('concept-clusters').textContent = conceptStats.clusters;
            
            // Show hierarchy patterns if any
            const hierarchyRow = document.getElementById('concept-hierarchy-row');
            if (conceptStats.hierarchyPatterns > 0) {
                hierarchyRow.style.display = 'flex';
                document.getElementById('concept-hierarchies').textContent = conceptStats.hierarchyPatterns;
            } else {
                hierarchyRow.style.display = 'none';
            }
            
            // Show transfers applied if any
            const transfersRow = document.getElementById('concept-transfers-row');
            if (conceptStats.transfersApplied > 0) {
                transfersRow.style.display = 'flex';
                document.getElementById('concept-transfers').textContent = conceptStats.transfersApplied;
            } else {
                transfersRow.style.display = 'none';
            }
            
            // Update meta-learner stats
            const metaStats = metaLearner.getStats();
            
            // Building style
            const buildingStyleEl = document.getElementById('meta-building-style');
            if (metaStats.sessionsAnalyzed >= 2 || metaStats.buildingScore !== 0.5) {
                buildingStyleEl.textContent = metaStats.buildingStyle;
                buildingStyleEl.style.color = metaStats.buildingStyle === 'Breadth-first' ? '#3b82f6' :
                    metaStats.buildingStyle === 'Depth-first' ? '#8b5cf6' : 'var(--text-primary)';
            }
            
            // Decision speed
            const decisionSpeedEl = document.getElementById('meta-decision-speed');
            if (metaStats.sessionsAnalyzed >= 1) {
                decisionSpeedEl.textContent = metaStats.quickDecider ? 'Quick' : 'Deliberate';
                decisionSpeedEl.style.color = metaStats.quickDecider ? '#22c55e' : '#f59e0b';
            }
            
            // Work rhythm (show after 2+ sessions)
            const rhythmRow = document.getElementById('meta-rhythm-row');
            if (metaStats.sessionsAnalyzed >= 2) {
                rhythmRow.style.display = 'flex';
                const rhythmEl = document.getElementById('meta-rhythm');
                const rhythmLabels = {
                    'accelerating': 'Builds Momentum',
                    'decelerating': 'Front-loaded',
                    'burst-rest': 'Burst Worker',
                    'steady': 'Steady Pace'
                };
                rhythmEl.textContent = rhythmLabels[metaStats.momentumPattern] || metaStats.momentumPattern;
            }
            
            // Selectivity (show after some suggestions)
            const selectivityRow = document.getElementById('meta-selectivity-row');
            if (metaStats.selectivityRate !== 0.5) {
                selectivityRow.style.display = 'flex';
                const selectivityEl = document.getElementById('meta-selectivity');
                if (metaStats.selectivityRate > 0.7) {
                    selectivityEl.textContent = 'Very Selective';
                    selectivityEl.style.color = '#8b5cf6';
                } else if (metaStats.selectivityRate > 0.4) {
                    selectivityEl.textContent = 'Balanced';
                    selectivityEl.style.color = 'var(--text-primary)';
                } else {
                    selectivityEl.textContent = 'Open-minded';
                    selectivityEl.style.color = '#22c55e';
                }
            }
            
            // Sessions analyzed
            const sessionsRow = document.getElementById('meta-sessions-row');
            if (metaStats.sessionsAnalyzed > 0) {
                sessionsRow.style.display = 'flex';
                document.getElementById('meta-sessions').textContent = metaStats.sessionsAnalyzed;
            }
            
            // Show strengths if available
            const insightsSection = document.getElementById('meta-insights-section');
            const strengthsEl = document.getElementById('meta-strengths');
            if (metaStats.insights && metaStats.insights.strengths && metaStats.insights.strengths.length > 0) {
                insightsSection.style.display = 'block';
                strengthsEl.innerHTML = metaStats.insights.strengths.map(s => 
                    `<span style="background: rgba(139, 92, 246, 0.2); color: #a78bfa; padding: 2px 8px; border-radius: 4px; font-size: 10px;">${s}</span>`
                ).join('');
            } else {
                insightsSection.style.display = 'none';
            }
            
            // Update categories list
            const categoriesSection = document.getElementById('neural-categories');
            const categoryList = document.getElementById('neural-category-list');
            
            if (stats.categories.length > 0) {
                categoriesSection.style.display = 'block';
                categoryList.innerHTML = stats.categories.map(cat => 
                    `<span class="neural-category-tag">${cat}</span>`
                ).join('');
            } else {
                categoriesSection.style.display = 'none';
            }
            
            // Enable/disable buttons based on model availability
            document.getElementById('neural-suggest-btn').disabled = !stats.hasCategoryModel;
            // Enable smart expand if neural net is ready (will fall back to AI if no prediction model)
            document.getElementById('neural-smart-suggest-btn').disabled = !neuralNet.isReady;
            
            // Update Cognitive Graph Transformer stats
            if (typeof cognitiveGT !== 'undefined') {
                const cgtStats = cognitiveGT.getStats();
                
                document.getElementById('cgt-embeddings').textContent = cgtStats.gnn?.nodesProcessed || 0;
                document.getElementById('cgt-actions').textContent = cgtStats.actions?.historySize || 0;
                document.getElementById('cgt-patterns').textContent = cgtStats.actions?.uniquePatterns || 0;
                
                // Cognitive state
                const cogState = cognitiveGT.getCognitiveState();
                const stateEl = document.getElementById('cgt-state');
                if (cogState.confidence > 0.5) {
                    const stateLabels = {
                        'contemplative': 'Thinking',
                        'exploratory-searching': 'Searching',
                        'divergent-brainstorming': 'Brainstorming',
                        'convergent-detailing': 'Detailing',
                        'refinement': 'Refining',
                        'review': 'Reviewing',
                        'mixed-productive': 'Productive',
                        'unknown': '—'
                    };
                    stateEl.textContent = stateLabels[cogState.state] || cogState.state;
                    stateEl.style.color = cogState.confidence > 0.7 ? '#22c55e' : 'var(--text-secondary)';
                } else {
                    stateEl.textContent = '—';
                    stateEl.style.color = 'var(--text-secondary)';
                }
            }
            
            // Update Style Transfer stats
            if (typeof styleTransfer !== 'undefined' && styleTransfer.initialized) {
                const styleStats = styleTransfer.getPatternStats();
                const fp = styleTransfer.getStyleFingerprint();
                const styleDesc = styleTransfer.getStyleDescription();
                
                // Style traits
                const traitsEl = document.getElementById('style-traits');
                if (traitsEl) {
                    traitsEl.textContent = styleDesc.slice(0, 3).join(', ') || 'Learning...';
                    traitsEl.title = styleDesc.join(', ');
                }
                
                // Pattern counts
                document.getElementById('style-patterns').textContent = styleStats.learnedPatterns + styleStats.seedPatterns;
                document.getElementById('style-memories').textContent = styleStats.structuralMemories;
                
                // Confidence
                const confEl = document.getElementById('style-confidence');
                if (confEl) {
                    const conf = fp.confidence.overall;
                    if (conf > 0.1) {
                        confEl.textContent = `${Math.round(conf * 100)}%`;
                        confEl.style.color = conf > 0.6 ? '#22c55e' : conf > 0.3 ? '#f59e0b' : 'var(--text-secondary)';
                    } else {
                        confEl.textContent = '—';
                    }
                }
            }
            
            // Update Semantic Engine stats
            if (typeof semanticEngine !== 'undefined') {
                const modelEl = document.getElementById('semantic-model');
                const embeddingsRow = document.getElementById('semantic-embeddings-row');
                const inferenceRow = document.getElementById('semantic-inference-row');
                
                if (modelEl) {
                    if (semanticEngine.initialized) {
                        modelEl.textContent = 'MiniLM-L6 ✓';
                        modelEl.style.color = '#22c55e';
                        modelEl.title = `${semanticEngine.modelId} (${semanticEngine.embeddingDim}d)`;
                        
                        // Show feature buttons
                        document.getElementById('semantic-load-btn').style.display = 'none';
                        document.getElementById('semantic-cluster-btn').style.display = 'flex';
                        document.getElementById('semantic-holes-btn').style.display = 'flex';
                    } else if (semanticEngine.initializing) {
                        modelEl.textContent = `Loading... ${semanticEngine.loadProgress}%`;
                        modelEl.style.color = '#f59e0b';
                    } else {
                        modelEl.textContent = 'Not loaded';
                        modelEl.style.color = 'var(--text-muted)';
                    }
                }
                
                if (semanticEngine.initialized) {
                    const stats = semanticEngine.getStats();
                    
                    if (embeddingsRow) {
                        embeddingsRow.style.display = 'flex';
                        document.getElementById('semantic-embeddings').textContent = stats.cacheSize;
                    }
                    
                    if (inferenceRow && stats.avgInferenceTime > 0) {
                        inferenceRow.style.display = 'flex';
                        document.getElementById('semantic-inference').textContent = 
                            stats.avgInferenceTime.toFixed(0) + 'ms';
                    }
                }
            }
            
            // Update GPU Compute stats
            if (typeof gpuCompute !== 'undefined') {
                const gpuStatusEl = document.getElementById('gpu-status');
                const gpuOpsRow = document.getElementById('gpu-ops-row');
                const gpuTimeRow = document.getElementById('gpu-time-row');
                
                if (gpuStatusEl) {
                    if (!gpuCompute.initialized) {
                        gpuStatusEl.textContent = 'Initializing...';
                        gpuStatusEl.style.color = 'var(--text-muted)';
                    } else if (gpuCompute.supported) {
                        gpuStatusEl.textContent = '✓ Active';
                        gpuStatusEl.style.color = '#22c55e';
                        gpuStatusEl.title = gpuCompute.adapter?.info?.device || 'GPU Accelerated';
                    } else {
                        gpuStatusEl.textContent = 'CPU Fallback';
                        gpuStatusEl.style.color = '#f59e0b';
                        gpuStatusEl.title = 'WebGPU not available - using optimized CPU';
                    }
                }
                
                if (gpuCompute.initialized && gpuCompute.stats.operationCount > 0) {
                    const stats = gpuCompute.getStats();
                    
                    if (gpuOpsRow) {
                        gpuOpsRow.style.display = 'flex';
                        document.getElementById('gpu-ops-count').textContent = stats.operationCount;
                    }
                    
                    if (gpuTimeRow && stats.avgGpuTime !== 'N/A') {
                        gpuTimeRow.style.display = 'flex';
                        document.getElementById('gpu-avg-time').textContent = stats.avgGpuTime;
                    }
                }
            }
        },
        
        async trainNetwork() {
            if (neuralNet.isTraining) return;
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            showToast('Starting neural network training...', 'info');
            const success = await neuralNet.train(store);
            
            if (!success) {
                showToast('Need more nodes to train (minimum 5)', 'error');
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = false;
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    `;
                }
                document.getElementById('neural-progress').style.display = 'none';
            }
        },
        
        async suggestConnections() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            const nodeText = nodeData.description 
                ? `${nodeData.label}. ${nodeData.description}`
                : nodeData.label;
            
            showToast('Analyzing connections...', 'info');
            
            // Get suggestions from neural network
            const suggestions = await neuralNet.suggestConnections(nodeText, store);
            
            // Also get Claude enhancement if API key available
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            let claudeSuggestion = null;
            if (apiKey) {
                claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
            }
            
            this.displaySuggestions(suggestions, claudeSuggestion);
        },
        
        displaySuggestions(neuralSuggestions, claudeSuggestion) {
            const suggestionsSection = document.getElementById('neural-suggestions');
            const suggestionsList = document.getElementById('neural-suggestions-list');
            
            // Get current node info for tracking
            const nodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
            
            if (neuralSuggestions.length === 0 && !claudeSuggestion) {
                suggestionsSection.style.display = 'none';
                showToast('No strong connections found', 'info');
                return;
            }
            
            suggestionsSection.style.display = 'block';
            
            // Track which node these suggestions are for
            if (nodeData) {
                this.suggestionsForNodeId = nodeData.id;
                document.getElementById('neural-suggestions-for').textContent = `for "${nodeData.label}"`;
            }
            
            let html = '';
            
            // Neural network suggestions - these navigate to related nodes
            if (neuralSuggestions.length > 0) {
                html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">Related nodes in your map:</div>`;
                neuralSuggestions.forEach(s => {
                    html += `
                        <div class="neural-suggestion" data-node-id="${s.nodeId}">
                            <span class="neural-suggestion-text">${s.label}</span>
                            <span class="neural-suggestion-score">${Math.round(s.isRelated * 100)}%</span>
                        </div>
                    `;
                });
            }
            
            // Claude suggestion - this can move the node
            if (claudeSuggestion) {
                const suggestedParent = claudeSuggestion.suggestedParent || claudeSuggestion.category;
                html += `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin: ${neuralSuggestions.length > 0 ? '12px' : '0'} 0 8px 0;">AI reorganization suggestion:</div>
                    <div class="neural-suggestion claude-suggestion" data-suggested-parent="${suggestedParent}" style="border-left: 3px solid var(--accent); cursor: pointer;">
                        <div>
                            <div class="neural-suggestion-text" style="font-weight: 600;">
                                Move to "${suggestedParent}"
                            </div>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">
                                ${claudeSuggestion.reasoning || 'Click to reorganize'}
                            </div>
                        </div>
                        <span class="neural-suggestion-score">${Math.round((claudeSuggestion.confidence || 0.8) * 100)}%</span>
                    </div>
                `;
                
                // Show related concepts
                if (claudeSuggestion.relatedConcepts?.length > 0) {
                    html += `
                        <div style="margin-top: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">Related concepts to add:</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${claudeSuggestion.relatedConcepts.join(', ')}
                            </div>
                        </div>
                    `;
                }
            }
            
            suggestionsList.innerHTML = html;
            
            // Scroll panel to show suggestions
            setTimeout(() => {
                suggestionsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
            
            // Add click handlers to navigate to related nodes
            suggestionsList.querySelectorAll('.neural-suggestion[data-node-id]').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const mesh = nodes.get(nodeId);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                        this.close();
                    }
                });
            });
            
            // Add click handler for Claude's reorganization suggestion
            const claudeSuggestionEl = suggestionsList.querySelector('.claude-suggestion[data-suggested-parent]');
            if (claudeSuggestionEl && selectedNode) {
                claudeSuggestionEl.addEventListener('click', () => {
                    const suggestedParent = claudeSuggestionEl.dataset.suggestedParent;
                    const nodeToMove = selectedNode.userData.id;
                    const nodeData = store.findNode(nodeToMove);
                    
                    if (!nodeData || nodeToMove === 'mynd') {
                        showToast("Can't move root node", 'error');
                        return;
                    }
                    
                    // Find the suggested parent node
                    const findNodeByLabel = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNodeByLabel(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const newParent = findNodeByLabel(store.data, suggestedParent);
                    
                    if (!newParent) {
                        showToast(`Couldn't find "${suggestedParent}"`, 'error');
                        return;
                    }
                    
                    if (newParent.id === nodeToMove) {
                        showToast("Can't move node into itself", 'error');
                        return;
                    }
                    
                    // Confirm the move
                    if (confirm(`Move "${nodeData.label}" under "${newParent.label}"?`)) {
                        // Use store.moveNode
                        if (store.moveNode(nodeToMove, newParent.id)) {
                            // Update color to match new parent
                            nodeData.color = newParent.color;
                            store.save();
                            buildScene();
                            
                            // Focus on the moved node in its new location
                            setTimeout(() => {
                                const movedMesh = nodes.get(nodeToMove);
                                if (movedMesh) {
                                    selectNode(movedMesh);
                                    focusOnNode(movedMesh);
                                }
                            }, 100);
                            
                            this.close();
                            showToast(`Moved to "${newParent.label}"`, 'success');
                        } else {
                            showToast('Failed to move node', 'error');
                        }
                    }
                });
            }
        },
        
        async resetNetwork() {
            if (confirm('Reset neural network? This will clear all learned patterns.')) {
                await neuralNet.reset();
                
                // Ask about preference history separately
                if (confirm('Also reset preference learning history?')) {
                    await preferenceTracker.reset();
                }
                
                // Ask about semantic memories separately
                if (confirm('Also reset semantic memories?')) {
                    await semanticMemory.reset();
                }
                
                // Ask about user profile separately
                if (confirm('Also reset user profile (depth, naming, time patterns)?')) {
                    await userProfile.reset();
                }
                
                // Ask about concept abstractions separately
                if (confirm('Also reset concept abstractions (schemas, clusters)?')) {
                    await conceptAbstractor.reset();
                }
                
                // Ask about meta-learner separately
                if (confirm('Also reset thinking patterns (building style, decisions, rhythm)?')) {
                    await metaLearner.reset();
                }
                
                this.updateStatus();
                document.getElementById('neural-suggestions').style.display = 'none';
                document.getElementById('neural-suggest-btn').disabled = true;
                document.getElementById('neural-smart-suggest-btn').disabled = true;
                showToast('Neural network reset', 'info');
            }
        },
        
        async showCGTInsights() {
            showToast('Analyzing your thinking patterns...', 'info');
            
            try {
                // Ensure CGT has processed the graph
                await cognitiveGT.processGraph(store);
                
                // Get insights
                const selectedNodeId = selectedNode?.userData?.id || null;
                const insights = await cognitiveGT.getInsights(store, selectedNodeId);
                
                if (insights.length === 0) {
                    showToast('Keep working - insights will appear as patterns emerge', 'info');
                    return;
                }
                
                // Build insight display
                const insightHTML = insights.map(insight => {
                    let icon = '💡';
                    let color = 'var(--accent)';
                    
                    switch (insight.type) {
                        case 'cognitive_state':
                            icon = '🧠';
                            color = '#3b82f6';
                            break;
                        case 'structural_hole':
                            icon = '🔗';
                            color = '#22c55e';
                            break;
                        case 'node_role':
                            icon = '🏷️';
                            color = '#8b5cf6';
                            break;
                        case 'completion':
                            icon = '✨';
                            color = '#f59e0b';
                            break;
                    }
                    
                    return `
                        <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px; margin-bottom: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <span style="font-size: 16px;">${icon}</span>
                                <span style="font-weight: 600; color: ${color}; font-size: 13px;">${insight.title}</span>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 12px; line-height: 1.4;">
                                ${insight.description}
                            </div>
                            ${insight.confidence ? `<div style="color: var(--text-muted); font-size: 10px; margin-top: 6px;">Confidence: ${Math.round(insight.confidence * 100)}%</div>` : ''}
                        </div>
                    `;
                }).join('');
                
                // Show in suggestions section
                const suggestionsSection = document.getElementById('neural-suggestions');
                const suggestionsList = document.getElementById('neural-suggestions-list');
                
                if (suggestionsSection && suggestionsList) {
                    suggestionsList.innerHTML = `
                        <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                            </svg>
                            Cognitive Graph Insights
                        </div>
                        ${insightHTML}
                    `;
                    suggestionsSection.style.display = 'block';
                }
                
                // Also update the insight row in stats
                const insightRow = document.getElementById('cgt-insight-row');
                const insightEl = document.getElementById('cgt-insight');
                if (insightRow && insightEl && insights.length > 0) {
                    insightRow.style.display = 'flex';
                    insightEl.textContent = insights[0].title;
                    insightEl.title = insights[0].description;
                }
                
                showToast(`Found ${insights.length} insight${insights.length > 1 ? 's' : ''}!`, 'success');
                
            } catch (e) {
                console.error('CGT insights failed:', e);
                showToast('Insight generation failed', 'error');
            }
        },
        
        async showTransferSuggestions() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            if (!styleTransfer.initialized) {
                await styleTransfer.initialize();
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            showToast('Finding pattern matches...', 'info');
            
            try {
                // Get existing children
                const existingChildren = nodeData.children || [];
                
                // Get transfer suggestions
                const suggestions = styleTransfer.getSuggestions(nodeData, existingChildren);
                
                if (suggestions.length === 0) {
                    // Show style info instead
                    const style = styleTransfer.getStyleDescription();
                    const stats = styleTransfer.getPatternStats();
                    
                    showToast('No patterns match yet. Keep building!', 'info');
                    
                    // Show current style
                    const suggestionsSection = document.getElementById('neural-suggestions');
                    const suggestionsList = document.getElementById('neural-suggestions-list');
                    
                    if (suggestionsSection && suggestionsList) {
                        suggestionsList.innerHTML = `
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 12px;">
                                Your Thinking Style
                            </div>
                            <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px;">
                                <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;">
                                    ${style.map(s => `<span style="background: rgba(139, 92, 246, 0.2); color: #a78bfa; padding: 4px 8px; border-radius: 4px; font-size: 11px;">${s}</span>`).join('')}
                                </div>
                                <div style="font-size: 10px; color: var(--text-muted);">
                                    ${stats.learnedPatterns} patterns learned • ${stats.structuralMemories} structures remembered
                                </div>
                            </div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 12px;">
                                Create more nodes with children to build your pattern library.
                            </div>
                        `;
                        suggestionsSection.style.display = 'block';
                    }
                    return;
                }
                
                // Display suggestions
                const suggestionsSection = document.getElementById('neural-suggestions');
                const suggestionsList = document.getElementById('neural-suggestions-list');
                
                let html = `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 12px; display: flex; align-items: center; gap: 6px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 12px; height: 12px;">
                            <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                            <path d="M2 17l10 5 10-5"/>
                        </svg>
                        Pattern Suggestions for "${nodeData.label}"
                    </div>
                `;
                
                // Group by source type
                const patternSuggestions = suggestions.filter(s => s.type === 'pattern');
                const transferSuggestions = suggestions.filter(s => s.type === 'transfer');
                
                if (patternSuggestions.length > 0) {
                    html += `<div style="font-size: 10px; color: var(--text-muted); margin-bottom: 6px;">From universal patterns:</div>`;
                    patternSuggestions.forEach(s => {
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="transfer" data-source="${s.source}">
                                <span class="neural-suggestion-text">${s.label}</span>
                                <span class="neural-suggestion-score" style="background: rgba(139, 92, 246, 0.2); color: #a78bfa;">${Math.round(s.confidence * 100)}%</span>
                            </div>
                        `;
                    });
                }
                
                if (transferSuggestions.length > 0) {
                    html += `<div style="font-size: 10px; color: var(--text-muted); margin: 12px 0 6px 0;">From your previous work:</div>`;
                    transferSuggestions.forEach(s => {
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="transfer" data-source="${s.source}">
                                <span class="neural-suggestion-text">${s.label}</span>
                                <span class="neural-suggestion-score" style="background: rgba(34, 197, 94, 0.2); color: #22c55e;">${Math.round(s.confidence * 100)}%</span>
                            </div>
                        `;
                    });
                    html += `<div style="font-size: 9px; color: var(--text-muted); margin-top: 4px;">Based on: ${[...new Set(transferSuggestions.map(s => s.source))].join(', ')}</div>`;
                }
                
                // Style info at bottom
                const style = styleTransfer.getStyleDescription();
                html += `
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--bg-tertiary);">
                        <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 6px;">Your style:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                            ${style.map(s => `<span style="background: var(--bg-tertiary); color: var(--text-secondary); padding: 2px 6px; border-radius: 3px; font-size: 9px;">${s}</span>`).join('')}
                        </div>
                    </div>
                `;
                
                if (suggestionsSection && suggestionsList) {
                    suggestionsList.innerHTML = html;
                    suggestionsSection.style.display = 'block';
                    
                    // Bind click handlers
                    suggestionsList.querySelectorAll('.neural-suggestion').forEach(el => {
                        el.addEventListener('click', () => {
                            const label = el.dataset.label;
                            const source = el.dataset.source;
                            
                            // Create the node
                            const newNode = store.addNode(nodeData.id, label, { source: 'transfer' });
                            
                            // Record the accepted suggestion
                            styleTransfer.recordAcceptedSuggestion(
                                { label, source, type: el.dataset.type },
                                nodeData
                            );
                            
                            // Rebuild scene
                            buildScene();
                            
                            // Select new node
                            setTimeout(() => {
                                const mesh = nodes.get(newNode.id);
                                if (mesh) selectNode(mesh);
                            }, 100);
                            
                            showToast(`Added "${label}"`, 'success');
                            
                            // Remove this suggestion from UI
                            el.remove();
                        });
                    });
                }
                
                showToast(`Found ${suggestions.length} pattern suggestion${suggestions.length > 1 ? 's' : ''}!`, 'success');
                
            } catch (e) {
                console.error('Transfer suggestions failed:', e);
                showToast('Failed to get suggestions', 'error');
            }
        },
        
        async smartExpand() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            showToast('Generating smart suggestions...', 'info');
            
            try {
                // Get AI-enhanced suggestions
                const result = await neuralNet.generateSmartSuggestions(nodeData, store);
                
                if (!result) {
                    showToast('Failed to generate suggestions', 'error');
                    return;
                }
                
                // Display suggestions in the panel
                const suggestionsSection = document.getElementById('neural-suggestions');
                const suggestionsList = document.getElementById('neural-suggestions-list');
                
                let html = '';
                
                // Show ML-based suggestions first
                if (result.mlSuggestions && result.mlSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">From learned patterns:</div>`;
                    result.mlSuggestions.forEach(s => {
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ml">
                                <span class="neural-suggestion-text">${s.label}</span>
                                <span class="neural-suggestion-score">${Math.round(s.confidence * 100)}%</span>
                            </div>
                        `;
                    });
                }
                
                // Show AI suggestions
                if (result.aiSuggestions && result.aiSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin: 12px 0 8px 0;">AI recommendations:</div>`;
                    result.aiSuggestions.forEach(s => {
                        // Escape the reasoning for use in data attribute
                        const escapedReasoning = (s.reasoning || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ai" data-description="${escapedReasoning}" style="border-left: 3px solid var(--accent);">
                                <div>
                                    <span class="neural-suggestion-text">${s.label}</span>
                                    ${s.reasoning ? `<div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${s.reasoning}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Add "Add All" button if we have suggestions
                if (result.mlSuggestions?.length > 0 || result.aiSuggestions?.length > 0) {
                    html += `
                        <button class="neural-btn primary" id="neural-add-all-btn" style="margin-top: 12px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Add All Suggestions
                        </button>
                    `;
                }
                
                suggestionsList.innerHTML = html;
                suggestionsSection.style.display = 'block';
                
                // Track which node these suggestions are for
                this.suggestionsForNodeId = nodeData.id;
                
                // Show which node the suggestions are for
                document.getElementById('neural-suggestions-for').textContent = `for "${nodeData.label}"`;
                
                // Scroll panel to show suggestions
                setTimeout(() => {
                    suggestionsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
                
                // Store parentId on container for click handlers to use
                const currentParentId = selectedNode.userData.id;
                suggestionsList.dataset.parentId = currentParentId;
                
                // Start preference tracking session
                const allSuggestions = [
                    ...(result.mlSuggestions || []).map(s => ({ label: s.label, type: 'ml', confidence: s.confidence })),
                    ...(result.aiSuggestions || []).map(s => ({ label: s.label, type: 'ai' }))
                ];
                if (allSuggestions.length > 0) {
                    preferenceTracker.startSession(currentParentId, nodeData.label, allSuggestions);
                    metaLearner.trackSuggestionsShown(allSuggestions, nodeData);
                }
                
                // Add click handlers for individual suggestions
                suggestionsList.querySelectorAll('.neural-suggestion[data-label]').forEach(el => {
                    el.addEventListener('click', () => {
                        if (el.classList.contains('added')) return; // Already added
                        
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        const suggestionType = el.dataset.type; // 'ml' or 'ai'
                        const parentId = suggestionsList.dataset.parentId; // Get from container, not selectedNode
                        const parentNode = store.findNode(parentId);
                        
                        store.addNode(parentId, { 
                            label, 
                            description,
                            color: parentNode?.color,
                            source: 'smart-expand'
                        });
                        
                        // Track preference and boost pattern weight
                        preferenceTracker.recordAccept(label, suggestionType);
                        metaLearner.trackSuggestionAccepted(label, false); // false = not Add All
                        if (parentNode) {
                            neuralNet.boostPattern(parentNode.label, label, suggestionType);
                            
                            // Store semantic memory
                            semanticMemory.addMemory(
                                'suggestion_accepted',
                                `User accepted ${suggestionType} suggestion "${label}" under "${parentNode.label}"`,
                                { parentLabel: parentNode.label, childLabel: label, suggestionType }
                            );
                        }
                        
                        buildScene();
                        
                        // Re-select the parent node to keep panel active
                        const newParentMesh = nodes.get(parentId);
                        if (newParentMesh) {
                            // Update selectedNode reference without triggering full selection animation
                            selectedNode = newParentMesh;
                            
                            // Expand the parent node if collapsed
                            if (!newParentMesh.userData.isExpanded) {
                                expandNode(newParentMesh);
                            }
                        }
                        
                        // Mark as added instead of removing
                        el.classList.add('added');
                        el.style.opacity = '0.5';
                        el.style.pointerEvents = 'none';
                        
                        // Add checkmark
                        const score = el.querySelector('.neural-suggestion-score');
                        if (score) {
                            score.textContent = '✓';
                            score.style.background = '#22c55e';
                            score.style.color = 'white';
                        } else {
                            // For AI suggestions without score element, add a checkmark
                            const textEl = el.querySelector('.neural-suggestion-text');
                            if (textEl && !textEl.textContent.includes('✓')) {
                                textEl.textContent = '✓ ' + textEl.textContent;
                            }
                        }
                        
                        // Update "Add All" button to show remaining count
                        const remaining = suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').length;
                        const addAllBtn = document.getElementById('neural-add-all-btn');
                        if (addAllBtn) {
                            if (remaining === 0) {
                                addAllBtn.style.display = 'none';
                            } else {
                                addAllBtn.innerHTML = `
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                                    </svg>
                                    Add Remaining (${remaining})
                                `;
                            }
                        }
                        
                        showToast(`Added "${label}"`, 'success');
                        audio.add();
                    });
                });
                
                // Add click handler for "Add All" button
                document.getElementById('neural-add-all-btn')?.addEventListener('click', () => {
                    const parentId = suggestionsList.dataset.parentId; // Get from container
                    const parentNode = store.findNode(parentId);
                    let added = 0;
                    
                    // Only add suggestions that haven't been added yet
                    suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').forEach(el => {
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        const suggestionType = el.dataset.type || 'ai';
                        if (label) {
                            store.addNode(parentId, { 
                                label, 
                                description,
                                color: parentNode?.color,
                                source: 'smart-expand'
                            });
                            added++;
                            
                            // Track preference and boost pattern weight
                            preferenceTracker.recordAccept(label, suggestionType);
                            metaLearner.trackSuggestionAccepted(label, true); // true = Add All
                            if (parentNode) {
                                neuralNet.boostPattern(parentNode.label, label, suggestionType);
                                
                                // Store semantic memory
                                semanticMemory.addMemory(
                                    'suggestion_accepted',
                                    `User accepted ${suggestionType} suggestion "${label}" under "${parentNode.label}"`,
                                    { parentLabel: parentNode.label, childLabel: label, suggestionType }
                                );
                            }
                            
                            // Mark as added
                            el.classList.add('added');
                            el.style.opacity = '0.5';
                            el.style.pointerEvents = 'none';
                            const score = el.querySelector('.neural-suggestion-score');
                            if (score) {
                                score.textContent = '✓';
                                score.style.background = '#22c55e';
                                score.style.color = 'white';
                            }
                        }
                    });
                    
                    if (added === 0) {
                        showToast('All suggestions already added', 'info');
                        return;
                    }
                    
                    buildScene();
                    
                    // Expand the parent
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                    
                    // Hide the button
                    document.getElementById('neural-add-all-btn').style.display = 'none';
                    showToast(`Added ${added} nodes`, 'success');
                    audio.success();
                    
                    // Close the panel to reveal new nodes
                    setTimeout(() => {
                        NeuralPanel.close();
                    }, 300);
                });
                
            } catch (error) {
                console.error('Smart expand error:', error);
                showToast('Failed to generate suggestions', 'error');
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // CLAUDE API HELPER - Uses Edge Function when authenticated
    // ═══════════════════════════════════════════════════════════════════
    
    async function callClaudeAPI(requestBody) {
        // Check if user is authenticated with Supabase
        let session = null;
        if (typeof supabase !== 'undefined' && supabase !== null) {
            const { data } = await supabase.auth.getSession();
            session = data?.session;
        }
        
        if (session?.access_token) {
            // Use Edge Function (secure, no API key exposed)
            try {
                const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Edge function request failed');
                }
                
                const data = await response.json();
                return { success: true, suggestions: data.suggestions };
            } catch (error) {
                console.error('Edge function error:', error);
                // Fall back to direct API if edge function fails
                console.log('Falling back to direct API call...');
            }
        }
        
        // Fall back to direct API call (requires local API key)
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:\n\n(Sign in with Google to use AI features without an API key)');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                throw new Error('API key required for AI features');
            }
        }
        
        // Build prompt based on request type
        let aiPrompt, maxTokens;
        
        if (requestBody.type === 'brainstorm') {
            maxTokens = 600;
            aiPrompt = `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${requestBody.nodeLabel}"${requestBody.nodeDescription ? `\n- Description: "${requestBody.nodeDescription}"` : ''}
- Path to root: ${requestBody.pathContext}
- Existing children: ${requestBody.existingChildren || 'none yet'}${requestBody.neuralContext || ''}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of objects with "label" and "description" properties. Make labels concise but meaningful. Descriptions should be 1-2 sentences explaining the purpose or context of that node.
Example: [{"label": "Daily Habits", "description": "Small, repeatable actions that compound over time into significant results."}, {"label": "Weekly Reviews", "description": "Regular reflection sessions to assess progress and adjust course."}]`;
        } else if (requestBody.type === 'smart-expand') {
            maxTokens = 800;
            aiPrompt = `You are the AI core of MYND, a 3D mind mapping tool that learns from user behavior. You're helping expand a node with intelligent suggestions.

CONTEXT:
- Current node: "${requestBody.nodeLabel}"${requestBody.nodeDescription ? `\n- Description: "${requestBody.nodeDescription}"` : ''}
- Path to root: ${requestBody.pathContext}
- Existing children: ${requestBody.existingChildren || 'none yet'}
${requestBody.userProfile ? `\nUSER PROFILE:\n${JSON.stringify(requestBody.userProfile, null, 2)}` : ''}
${requestBody.semanticContext ? `\nSEMANTIC CONTEXT:\n${requestBody.semanticContext}` : ''}

Generate 3-5 suggestions for child nodes. For each suggestion, consider:
1. The user's demonstrated patterns and preferences
2. Natural subcategories or next steps
3. Connections to other areas of their mind map
4. Actionable items that would help them progress

Return ONLY a JSON array of objects with "label", "description", and "reasoning" properties.
- label: Concise node name (2-5 words)
- description: 1-2 sentence explanation of the node's purpose
- reasoning: Brief explanation of why this suggestion fits the user's patterns

Example: [{"label": "Morning Routine", "description": "A sequence of activities to start each day with intention and energy.", "reasoning": "User has shown interest in habits and productivity optimization."}]`;
        } else if (requestBody.type === 'organize') {
            maxTokens = 800;
            aiPrompt = `You are organizing a mind map. The parent node is "${requestBody.nodeLabel}".

Here are the child nodes that need organizing:
${requestBody.childrenList}

Group these into 2-4 logical categories. Each category should have at least 2 items.

Respond with JSON only:
{
  "categories": [
    {
      "name": "Category Name",
      "description": "Brief description of this category",
      "items": ["Life Hacks", "Mental Models"]
    }
  ]
}

IMPORTANT: In the "items" array, use ONLY the exact node label (the part before the colon). Do not include descriptions.`;
        } else {
            throw new Error('Invalid request type');
        }
        
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: maxTokens,
                messages: [{ role: 'user', content: aiPrompt }]
            })
        });
        
        if (!response.ok) {
            throw new Error('API request failed');
        }
        
        const data = await response.json();
        const text = data.content[0].text;
        
        // Parse JSON response
        let suggestions;
        try {
            suggestions = JSON.parse(text);
        } catch (e) {
            const jsonMatch = text.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                suggestions = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Failed to parse response');
            }
        }
        
        return { success: true, suggestions };
    }

    // ═══════════════════════════════════════════════════════════════════
    // ENHANCED BRAINSTORM WITH NEURAL NETWORK
    // ═══════════════════════════════════════════════════════════════════
    
    async function brainstormNodeEnhanced(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            // Get neural network predictions if available
            let neuralContext = '';
            if (neuralNet.isReady && neuralNet.categories.length > 0) {
                const nodeText = description ? `${node.label}. ${description}` : node.label;
                const predictions = await neuralNet.predictCategory(nodeText);
                
                if (predictions && predictions.length > 0) {
                    const topPredictions = predictions.slice(0, 3)
                        .filter(p => p.probability > 0.1)
                        .map(p => `${p.category} (${Math.round(p.probability * 100)}%)`);
                    
                    if (topPredictions.length > 0) {
                        neuralContext = `\n\nNEURAL NETWORK ANALYSIS:
The user's personalized neural network suggests this content relates to: ${topPredictions.join(', ')}
Consider these learned patterns when generating suggestions.`;
                    }
                }
            }
            
            // Use the unified Claude API helper
            const result = await callClaudeAPI({
                type: 'brainstorm',
                nodeLabel: node.label,
                nodeDescription: description,
                pathContext: context,
                existingChildren: siblings,
                neuralContext: neuralContext
            });
            
            if (!result.success || !result.suggestions) {
                throw new Error('No suggestions returned');
            }
            
            const ideas = result.suggestions;
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    // Handle both old format (string) and new format (object with label/description)
                    const label = typeof idea === 'string' ? idea : idea.label;
                    const desc = typeof idea === 'string' ? '' : (idea.description || '');
                    store.addNode(nodeId, { 
                        label, 
                        description: desc,
                        color: node.color, 
                        source: 'brainstorm' 
                    });
                });
                
                buildScene();
                
                // Focus on the parent node
                const parentMesh = nodes.get(nodeId);
                if (parentMesh) {
                    selectNode(parentMesh);
                    
                    // Expand if collapsed
                    if (!parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
                
                showToast(`Added ${ideas.length} ideas`, 'success');
                audio.ai();
                
                // Update embeddings for new nodes in background
                if (neuralNet.isReady) {
                    ideas.forEach(async (idea) => {
                        const label = typeof idea === 'string' ? idea : idea.label;
                        const desc = typeof idea === 'string' ? '' : (idea.description || '');
                        const nodeText = desc ? `${label}. ${desc}` : label;
                        await neuralNet.getEmbedding(nodeText);
                    });
                    neuralNet.saveEmbeddings();
                }
            }
            
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast(error.message || 'Failed to generate ideas', 'error');
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SMART NODE PLACEMENT - Uses neural network for intelligent categorization
    // ═══════════════════════════════════════════════════════════════════
    
    async function smartAddNode(label, description = '') {
        if (!neuralNet.isReady || neuralNet.categories.length === 0) {
            // Fall back to adding under root or selected node
            const parentId = selectedNode?.userData.id || 'mynd';
            const parentNode = store.findNode(parentId);
            const newNode = store.addNode(parentId, { 
                label, 
                description,
                color: parentNode?.color 
            });
            buildScene();
            return newNode;
        }
        
        const nodeText = description ? `${label}. ${description}` : label;

        // Get predictions with active learning (routes to Claude if uncertain)
        const predictions = await neuralNet.predictCategoryWithActiveLearning(nodeText, store);

        // Check confidence (handle both property names)
        const topConf = predictions?.[0]?.confidence || predictions?.[0]?.probability || 0;

        if (predictions && predictions.length > 0 && topConf > 0.5) {
            // High confidence - place under predicted category
            const categoryLabel = predictions[0].category;
            
            // Find the category node
            const categoryNode = store.data.children?.find(c => c.label === categoryLabel);
            
            if (categoryNode) {
                // Get Claude suggestion for specific parent within category
                const claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
                
                let parentId = categoryNode.id;
                
                // Try to find more specific parent if Claude suggests one
                if (claudeSuggestion?.suggestedParent) {
                    const findNode = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNode(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const specificParent = findNode(categoryNode, claudeSuggestion.suggestedParent);
                    if (specificParent) {
                        parentId = specificParent.id;
                    }
                }
                
                const parentNode = store.findNode(parentId);
                const newNode = store.addNode(parentId, { 
                    label, 
                    description,
                    color: parentNode?.color 
                });
                
                buildScene();
                
                // Focus on the new node
                setTimeout(() => {
                    const mesh = nodes.get(newNode.id);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                    }
                }, 100);
                
                showToast(`Added to ${categoryLabel}`, 'success');
                return newNode;
            }
        }
        
        // Low confidence or no prediction - ask user or add to root
        const parentId = selectedNode?.userData.id || 'mynd';
        const parentNode = store.findNode(parentId);
        const newNode = store.addNode(parentId, { 
            label, 
            description,
            color: parentNode?.color 
        });
        
        buildScene();
        return newNode;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // AUTO-TRAIN ON SIGNIFICANT CHANGES
    // ═══════════════════════════════════════════════════════════════════
    
    let nodeCountAtLastTrain = 0;
    const AUTO_TRAIN_THRESHOLD = 10; // Train when 10 new nodes added
    
    bus.on('data:saved', () => {
        if (!neuralNet.isReady || neuralNet.isTraining) return;
        
        // Count total nodes
        let nodeCount = 0;
        const countNodes = (node) => {
            nodeCount++;
            node.children?.forEach(countNodes);
        };
        countNodes(store.data);
        
        // Auto-train if significant new nodes (and training enabled)
        if (nodeCount - nodeCountAtLastTrain >= AUTO_TRAIN_THRESHOLD && isNeuralTrainingAllowed()) {
            console.log('🧠 Auto-training neural network (new nodes detected)');
            neuralNet.train(store).then(() => {
                nodeCountAtLastTrain = nodeCount;
            });
        }
    });

    // Start the app
    init();
    
    // ═══════════════════════════════════════════════════════════════════
    // LINK MANAGER - Add links from URLs
    // ═══════════════════════════════════════════════════════════════════
    const LinkManager = {
        modal: null,
        currentLink: null,
        selectedCategory: null,
        pasteToast: null,
        
        init() {
            this.modal = document.getElementById('link-modal');
            this.createPasteToast();
            this.bindEvents();
        },
        
        createPasteToast() {
            // Create a special toast for link paste detection
            const toast = document.createElement('div');
            toast.id = 'link-paste-toast';
            toast.innerHTML = `
                <div class="link-paste-content">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;flex-shrink:0;">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                    </svg>
                    <span class="link-paste-text">Link detected</span>
                    <button class="link-paste-add">Add to Map</button>
                    <button class="link-paste-dismiss">✕</button>
                </div>
            `;
            document.body.appendChild(toast);
            this.pasteToast = toast;
            
            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                #link-paste-toast {
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%) translateY(100px);
                    background: var(--bg-primary);
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                    border: 1px solid var(--bg-tertiary);
                    z-index: 10001;
                    opacity: 0;
                    pointer-events: none;
                    transition: all 0.3s ease;
                }
                
                #link-paste-toast.visible {
                    transform: translateX(-50%) translateY(0);
                    opacity: 1;
                    pointer-events: auto;
                }
                
                .link-paste-content {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 12px 16px;
                    color: var(--text-primary);
                }
                
                .link-paste-text {
                    font-size: 14px;
                    font-weight: 500;
                    max-width: 200px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                
                .link-paste-add {
                    background: var(--accent);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                
                .link-paste-add:hover {
                    filter: brightness(1.1);
                }
                
                .link-paste-dismiss {
                    background: none;
                    border: none;
                    color: var(--text-tertiary);
                    font-size: 16px;
                    cursor: pointer;
                    padding: 4px;
                    line-height: 1;
                }
                
                .link-paste-dismiss:hover {
                    color: var(--text-primary);
                }
                
                @media (max-width: 768px) {
                    #link-paste-toast {
                        bottom: 140px;
                        left: 16px;
                        right: 16px;
                        transform: translateX(0) translateY(100px);
                    }
                    
                    #link-paste-toast.visible {
                        transform: translateX(0) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);
        },
        
        bindEvents() {
            // Open modal
            document.getElementById('quick-link')?.addEventListener('click', () => {
                this.open();
            });
            
            // Close modal
            document.getElementById('link-modal-close')?.addEventListener('click', () => {
                this.close();
            });
            
            document.getElementById('link-cancel')?.addEventListener('click', () => {
                this.close();
            });
            
            // Close on overlay click
            this.modal?.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.close();
                }
            });
            
            // Close on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.modal?.classList.contains('active')) {
                    this.close();
                }
            });
            
            // Fetch button
            document.getElementById('link-fetch')?.addEventListener('click', () => {
                this.fetchLink();
            });
            
            // Enter in URL input
            document.getElementById('link-url')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.fetchLink();
                }
            });
            
            // Auto-detect URL paste in modal
            document.getElementById('link-url')?.addEventListener('paste', (e) => {
                setTimeout(() => this.fetchLink(), 100);
            });
            
            // Add to map
            document.getElementById('link-add')?.addEventListener('click', () => {
                this.addToMap();
            });
            
            // SMART PASTE DETECTION - Global paste listener
            document.addEventListener('paste', (e) => {
                this.handleGlobalPaste(e);
            });
            
            // Paste toast buttons
            this.pasteToast?.querySelector('.link-paste-add')?.addEventListener('click', () => {
                this.addPastedLink();
            });
            
            this.pasteToast?.querySelector('.link-paste-dismiss')?.addEventListener('click', () => {
                this.hidePasteToast();
            });
        },
        
        // Check if text is a valid URL
        isURL(text) {
            if (!text || typeof text !== 'string') return false;
            text = text.trim();
            
            // Quick pattern check
            if (!text.match(/^https?:\/\//i) && !text.match(/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}/i)) {
                return false;
            }
            
            // Add protocol if missing
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            
            try {
                new URL(text);
                return true;
            } catch {
                return false;
            }
        },
        
        // Normalize URL (add protocol if missing)
        normalizeURL(text) {
            text = text.trim();
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            return text;
        },
        
        // Handle paste anywhere in the document
        handleGlobalPaste(e) {
            // Ignore if we're in an input field (let normal paste work)
            const activeEl = document.activeElement;
            const isInput = activeEl && (
                activeEl.tagName === 'INPUT' || 
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.isContentEditable
            );
            
            // Allow paste in link-url input (handled separately)
            if (activeEl?.id === 'link-url') return;
            
            // If in another input, only intercept if it's clearly a URL being pasted into quick-input
            if (isInput && activeEl?.id !== 'quick-input') return;
            
            // Get clipboard text
            const text = e.clipboardData?.getData('text')?.trim();
            if (!text || !this.isURL(text)) return;
            
            // Don't show if modal is already open
            if (this.modal?.classList.contains('active')) return;
            
            // If pasting into quick-input, intercept it
            if (activeEl?.id === 'quick-input') {
                e.preventDefault();
            }
            
            // Store the URL and show toast
            this.pendingURL = this.normalizeURL(text);
            this.showPasteToast(this.pendingURL);
        },
        
        showPasteToast(url) {
            // Get domain for display
            let domain = 'Link detected';
            try {
                domain = new URL(url).hostname.replace('www.', '');
            } catch {}
            
            // Show where link will be added
            const textEl = this.pasteToast.querySelector('.link-paste-text');
            if (selectedNode) {
                const nodeData = store.findNode(selectedNode.userData.id);
                const nodeName = nodeData?.label || 'node';
                textEl.textContent = `${domain} → "${nodeName}"`;
            } else {
                textEl.textContent = domain;
            }
            
            this.pasteToast.classList.add('visible');
            
            // Auto-hide after 5 seconds
            clearTimeout(this.pasteToastTimeout);
            this.pasteToastTimeout = setTimeout(() => {
                this.hidePasteToast();
            }, 5000);
        },
        
        hidePasteToast() {
            this.pasteToast.classList.remove('visible');
            clearTimeout(this.pasteToastTimeout);
        },
        
        addPastedLink() {
            if (!this.pendingURL) return;
            
            this.hidePasteToast();
            
            // If a node is selected, add directly as a child
            if (selectedNode) {
                this.addLinkAsChild(this.pendingURL, selectedNode.userData.id);
            } else {
                // No node selected - open modal for categorization
                this.openWithURL(this.pendingURL);
            }
            
            this.pendingURL = null;
        },
        
        // Quick add link as child of a node
        async addLinkAsChild(url, parentId) {
            const parentNode = store.findNode(parentId);
            if (!parentNode) {
                showToast('Parent node not found', 'error');
                return;
            }
            
            // Get domain for initial display
            let domain = 'Link';
            try {
                domain = new URL(url).hostname.replace('www.', '');
            } catch {}
            
            // Create node immediately with domain as placeholder
            const linkData = {
                url: url,
                domain: domain,
                type: 'link',
                addedAt: new Date().toISOString()
            };
            
            const newNode = store.addNode(parentId, {
                label: domain,
                description: url,
                color: parentNode.color,
                link: linkData
            });
            
            buildScene();
            
            // Expand parent to show new node
            const parentMesh = nodes.get(parentId);
            if (parentMesh && !parentMesh.userData.isExpanded) {
                expandNode(parentMesh);
            }
            
            // Focus on new node
            setTimeout(() => {
                const newMesh = nodes.get(newNode.id);
                if (newMesh) {
                    selectNode(newMesh);
                    focusOnNode(newMesh);
                }
            }, 100);
            
            showToast(`Added link from ${domain}`, 'success');
            audio.add();
            
            // Fetch metadata in background and update the node
            this.fetchAndUpdateNode(url, newNode.id);
        },
        
        // Fetch metadata and update an existing node
        async fetchAndUpdateNode(url, nodeId) {
            try {
                const metadata = await this.extractMetadata(url);
                
                if (metadata.title) {
                    const node = store.findNode(nodeId);
                    if (node) {
                        // Update node with fetched metadata
                        node.label = metadata.title;
                        if (metadata.description && !node.description.startsWith('http')) {
                            node.description = metadata.description;
                        }
                        
                        // Update link data
                        if (node.link) {
                            node.link.type = metadata.type || 'link';
                            node.link.favicon = metadata.favicon;
                            node.link.image = metadata.image;
                            node.link.author = metadata.author;
                        }
                        
                        store.save();
                        
                        // Update the node mesh label
                        const mesh = nodes.get(nodeId);
                        if (mesh) {
                            // Update label
                            const oldLabel = mesh.children.find(c => c.userData?.isLabel);
                            if (oldLabel) {
                                mesh.remove(oldLabel);
                                oldLabel.geometry?.dispose();
                                oldLabel.material?.dispose();
                            }
                            const newLabel = createTextSprite(metadata.title, mesh.userData.depth || 0);
                            newLabel.position.set(0, CONFIG.VISUAL.labelOffsetY, 0);
                            newLabel.userData.isLabel = true;
                            mesh.add(newLabel);
                        }
                        
                        // Update info panel if this node is selected
                        if (selectedNode && selectedNode.userData.id === nodeId) {
                            document.getElementById('info-title').value = metadata.title;
                            if (metadata.description) {
                                document.getElementById('info-desc').value = metadata.description;
                            }
                        }
                        
                        console.log(`✓ Updated node "${nodeId}" with metadata: ${metadata.title}`);
                    }
                }
            } catch (error) {
                console.warn('Failed to fetch link metadata:', error);
            }
        },
        
        openWithURL(url) {
            this.open();
            document.getElementById('link-url').value = url;
            // Auto-fetch
            setTimeout(() => this.fetchLink(), 100);
        },
        
        open() {
            this.modal.classList.add('active');
            this.reset();
            document.getElementById('link-url').focus();
        },
        
        close() {
            // Resolve any pending feedback as rejected (user closed without adding)
            if (this.currentSuggestionId) {
                AIFeedback.resolve(this.currentSuggestionId, 'rejected');
                this.currentSuggestionId = null;
            }
            this.modal.classList.remove('active');
            this.reset();
        },
        
        reset() {
            document.getElementById('link-url').value = '';
            document.getElementById('link-preview').style.display = 'none';
            document.getElementById('link-category').style.display = 'none';
            document.getElementById('link-add').disabled = true;
            this.currentLink = null;
            this.selectedCategory = null;
            this.predictedCategory = null;
        },
        
        async fetchLink() {
            const url = document.getElementById('link-url').value.trim();
            
            if (!url) {
                showToast('Please enter a URL', 'error');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }
            
            // Show loading
            document.getElementById('link-preview').style.display = 'block';
            document.getElementById('link-preview-loading').style.display = 'flex';
            document.getElementById('link-preview-content').style.display = 'none';
            
            try {
                // Extract metadata
                const metadata = await this.extractMetadata(url);
                this.currentLink = metadata;
                
                // Show preview
                this.showPreview(metadata);
                
                // Get AI categorization
                await this.categorizeLink(metadata);
                
                // Enable add button
                document.getElementById('link-add').disabled = false;
                
                // For video content, try to fetch transcript in background
                if (metadata.type === 'video') {
                    this.fetchAndProcessTranscript(url, metadata);
                }
                
            } catch (error) {
                console.error('Failed to fetch link:', error);
                showToast('Failed to fetch link info', 'error');
                document.getElementById('link-preview').style.display = 'none';
            }
        },
        
        async fetchAndProcessTranscript(url, metadata) {
            // Show transcript loading indicator
            const transcriptStatus = document.getElementById('link-transcript-status');
            if (transcriptStatus) {
                transcriptStatus.style.display = 'flex';
                transcriptStatus.innerHTML = `
                    <svg class="spinner" viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" opacity="0.25"/>
                        <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                    </svg>
                    <span>Fetching transcript...</span>
                `;
            }
            
            try {
                const transcriptData = await this.fetchTranscript(url, metadata);
                
                if (transcriptData && transcriptData.text) {
                    // Store transcript with current link
                    this.currentLink.transcript = transcriptData.text;
                    this.currentLink.transcriptSource = transcriptData.source;
                    
                    // Update status
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span style="color: #22c55e;">Transcript found (${Math.round(transcriptData.text.length / 100) / 10}k chars)</span>
                        `;
                    }
                    
                    // Generate AI summary if we have API key and no description yet
                    const currentDescription = document.getElementById('link-preview-description').value.trim();
                    if (!currentDescription || currentDescription.startsWith('Video by')) {
                        const summary = await this.generateAISummary(transcriptData.text, metadata);
                        if (summary) {
                            document.getElementById('link-preview-description').value = summary;
                            this.currentLink.description = summary;
                            this.currentLink.aiSummary = summary;
                            
                            // Update status
                            if (transcriptStatus) {
                                transcriptStatus.innerHTML = `
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span style="color: #22c55e;">AI summary generated</span>
                                `;
                            }
                        }
                    }
                } else {
                    // No transcript available
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                            <span>No transcript available</span>
                        `;
                    }
                }
            } catch (error) {
                console.warn('Transcript fetch failed:', error);
                if (transcriptStatus) {
                    transcriptStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <circle cx="12" cy="16" r="1" fill="currentColor"/>
                        </svg>
                        <span>Transcript fetch failed</span>
                    `;
                }
            }
        },
        
        async extractMetadata(url) {
            const urlObj = new URL(url);
            const domain = urlObj.hostname.replace('www.', '');
            
            // Basic metadata from URL
            const metadata = {
                url: url,
                domain: domain,
                title: '',
                description: '',
                image: '',
                favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`,
                type: this.detectContentType(url, domain),
                source: 'url' // Track where we got the data
            };
            
            // Method 1: YouTube oEmbed (free, no API key needed)
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                try {
                    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
                    const response = await fetch(oembedUrl);
                    if (response.ok) {
                        const data = await response.json();
                        metadata.title = data.title || '';
                        metadata.description = `Video by ${data.author_name}`;
                        metadata.image = data.thumbnail_url || '';
                        metadata.author = data.author_name;
                        metadata.source = 'youtube';
                        console.log('✓ Got YouTube metadata via oEmbed');
                        return metadata;
                    }
                } catch (e) {
                    console.warn('YouTube oEmbed failed:', e);
                }
            }
            
            // Method 2: Free metadata API (jsonlink.io)
            // Works for TikTok, Twitter, Instagram, articles, etc.
            try {
                const metaApiUrl = `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`;
                const response = await fetch(metaApiUrl);
                if (response.ok) {
                    const data = await response.json();
                    if (data.title || data.description) {
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.images?.[0] || '';
                        metadata.author = data.author || data.site_name || '';
                        metadata.source = 'jsonlink';
                        console.log('✓ Got metadata via jsonlink.io');
                        
                        // For TikTok, the description often IS the video caption
                        if (domain.includes('tiktok.com') && metadata.description) {
                            // Move caption to title if title is generic
                            if (!metadata.title || metadata.title.includes('TikTok')) {
                                metadata.title = metadata.description.slice(0, 100) + (metadata.description.length > 100 ? '...' : '');
                                metadata.description = metadata.author ? `Video by ${metadata.author}` : '';
                            }
                        }
                        
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('jsonlink.io failed:', e);
            }
            
            // Method 3: Try microlink.io as backup
            try {
                const microlinkUrl = `https://api.microlink.io?url=${encodeURIComponent(url)}`;
                const response = await fetch(microlinkUrl);
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success' && result.data) {
                        const data = result.data;
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.image?.url || '';
                        metadata.author = data.author || data.publisher || '';
                        metadata.source = 'microlink';
                        console.log('✓ Got metadata via microlink.io');
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('microlink.io failed:', e);
            }
            
            // Method 4: Use Claude AI to guess from URL (if we have API key)
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (apiKey && !metadata.title) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 300,
                            messages: [{
                                role: 'user',
                                content: `Extract information about this URL: ${url}

Based on the URL pattern and domain, provide your best guess for:
1. A short, descriptive title (what the content is likely about)
2. A brief description (1-2 sentences max)
3. The type of content (video, article, product, social post, etc.)

Return ONLY JSON:
{"title": "...", "description": "...", "type": "..."}`
                            }]
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const text = data.content[0].text;
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const info = JSON.parse(jsonMatch[0]);
                            metadata.title = info.title || metadata.title;
                            metadata.description = info.description || metadata.description;
                            metadata.type = info.type || metadata.type;
                            metadata.source = 'ai';
                            console.log('✓ Got metadata via Claude AI');
                        }
                    }
                } catch (e) {
                    console.warn('Could not get AI metadata:', e);
                }
            }
            
            // Fallback: Parse title from URL
            if (!metadata.title) {
                const path = urlObj.pathname.split('/').filter(Boolean).pop() || '';
                metadata.title = path
                    .replace(/[-_]/g, ' ')
                    .replace(/\.(html|php|aspx?)$/i, '')
                    .replace(/\b\w/g, l => l.toUpperCase()) || domain;
                metadata.source = 'fallback';
            }
            
            return metadata;
        },
        
        detectContentType(url, domain) {
            const lowerUrl = url.toLowerCase();
            const lowerDomain = domain.toLowerCase();
            
            // Video platforms
            if (['youtube.com', 'youtu.be', 'vimeo.com', 'tiktok.com', 'twitch.tv'].some(d => lowerDomain.includes(d))) {
                return 'video';
            }
            
            // Social media
            if (['twitter.com', 'x.com', 'facebook.com', 'instagram.com', 'linkedin.com', 'reddit.com', 'threads.net'].some(d => lowerDomain.includes(d))) {
                return 'social';
            }
            
            // Shopping
            if (['amazon.com', 'ebay.com', 'etsy.com', 'shopify.com', 'shop'].some(d => lowerDomain.includes(d)) || lowerUrl.includes('/product')) {
                return 'product';
            }
            
            // News/Articles
            if (['medium.com', 'substack.com', 'news', 'blog', 'article'].some(d => lowerUrl.includes(d))) {
                return 'article';
            }
            
            // Code
            if (['github.com', 'gitlab.com', 'stackoverflow.com', 'codepen.io'].some(d => lowerDomain.includes(d))) {
                return 'code';
            }
            
            return 'link';
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // VIDEO TRANSCRIPT EXTRACTION
        // ═══════════════════════════════════════════════════════════════════
        
        async fetchTranscript(url, metadata) {
            const domain = metadata.domain;
            console.log('📝 Attempting transcript fetch for:', domain);
            
            let transcript = null;
            let transcriptSource = null;
            
            // YouTube transcripts
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                transcript = await this.fetchYouTubeTranscript(url);
                if (transcript) transcriptSource = 'youtube-captions';
            }
            
            // TikTok transcripts
            else if (domain.includes('tiktok.com')) {
                transcript = await this.fetchTikTokTranscript(url);
                if (transcript) transcriptSource = 'tiktok-captions';
            }
            
            // Instagram Reels
            else if (domain.includes('instagram.com') && url.includes('/reel')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'instagram-captions';
            }
            
            // Twitter/X videos
            else if ((domain.includes('twitter.com') || domain.includes('x.com')) && url.includes('/video')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'twitter-captions';
            }
            
            if (transcript) {
                console.log(`✓ Got transcript (${transcript.length} chars) from ${transcriptSource}`);
                return { text: transcript, source: transcriptSource };
            }
            
            console.log('✗ No transcript available');
            return null;
        },
        
        extractYouTubeVideoId(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([^&\n?#]+)/,
                /youtube\.com\/shorts\/([^&\n?#]+)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        },
        
        async fetchYouTubeTranscript(url) {
            const videoId = this.extractYouTubeVideoId(url);
            if (!videoId) {
                console.warn('Could not extract YouTube video ID');
                return null;
            }
            
            console.log('📺 Fetching YouTube transcript for:', videoId);
            
            // Method 1: Try youtubetranscript.com API (free, no key needed)
            try {
                const response = await fetch(`https://youtubetranscript.com/?server_vid2=${videoId}`);
                if (response.ok) {
                    const text = await response.text();
                    // Parse the XML response
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/xml');
                    const textElements = doc.querySelectorAll('text');
                    
                    if (textElements.length > 0) {
                        const transcript = Array.from(textElements)
                            .map(el => el.textContent)
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (transcript.length > 50) {
                            console.log('✓ Got YouTube transcript via youtubetranscript.com');
                            return transcript;
                        }
                    }
                }
            } catch (e) {
                console.warn('youtubetranscript.com failed:', e);
            }
            
            // Method 2: Try kome.ai transcript API
            try {
                const response = await fetch(`https://kome.ai/api/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript) {
                        console.log('✓ Got YouTube transcript via kome.ai');
                        return data.transcript;
                    }
                }
            } catch (e) {
                console.warn('kome.ai failed:', e);
            }
            
            // Method 3: Try tactiq.io API
            try {
                const response = await fetch(`https://tactiq-apps-prod.tactiq.io/transcript?videoId=${videoId}&langCode=en`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.captions && data.captions.length > 0) {
                        const transcript = data.captions.map(c => c.text).join(' ');
                        console.log('✓ Got YouTube transcript via tactiq.io');
                        return transcript;
                    }
                }
            } catch (e) {
                console.warn('tactiq.io failed:', e);
            }
            
            return null;
        },
        
        extractTikTokVideoId(url) {
            // TikTok URLs: tiktok.com/@user/video/1234567890
            const match = url.match(/\/video\/(\d+)/);
            return match ? match[1] : null;
        },
        
        async fetchTikTokTranscript(url) {
            console.log('📱 Fetching TikTok transcript...');
            
            // Method 1: Try supdata.ai (has free tier for transcripts)
            try {
                const response = await fetch(`https://api.supdata.ai/v1/tiktok/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript || data.text) {
                        console.log('✓ Got TikTok transcript via supdata.ai');
                        return data.transcript || data.text;
                    }
                }
            } catch (e) {
                console.warn('supdata.ai failed:', e);
            }
            
            // Note: tikwm.com only returns captions/descriptions, not actual spoken transcripts
            // So we don't use it as a transcript source
            
            return null;
        },
        
        async fetchGenericTranscript(url) {
            // Try generic video transcript services
            console.log('🎬 Trying generic transcript fetch...');
            
            // Could add more services here as they become available
            // For now, return null - user can add description manually
            return null;
        },
        
        async generateAISummary(transcript, metadata) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey || !transcript) return null;
            
            console.log('🤖 Generating AI summary from transcript...');
            
            // Truncate transcript if too long (keep first 4000 chars)
            const truncatedTranscript = transcript.length > 4000 
                ? transcript.substring(0, 4000) + '...' 
                : transcript;
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `Summarize this ${metadata.type || 'video'} transcript in 2-3 sentences. Focus on the key points and takeaways. Be concise.

Title: ${metadata.title || 'Unknown'}
Author: ${metadata.author || 'Unknown'}

Transcript:
${truncatedTranscript}

Summary:`
                        }]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const summary = data.content[0].text.trim();
                    console.log('✓ Generated AI summary');
                    return summary;
                }
            } catch (e) {
                console.warn('AI summary generation failed:', e);
            }
            
            return null;
        },
        
        showPreview(metadata) {
            document.getElementById('link-preview-loading').style.display = 'none';
            document.getElementById('link-preview-content').style.display = 'flex';
            
            // Set preview content
            const img = document.getElementById('link-preview-image');
            if (metadata.image) {
                img.src = metadata.image;
                img.style.display = 'block';
                img.style.objectFit = 'cover';
                img.style.padding = '0';
                img.style.background = 'var(--bg-tertiary)';
            } else {
                // Use a placeholder with the favicon
                img.src = metadata.favicon;
                img.style.objectFit = 'contain';
                img.style.padding = '20px';
                img.style.background = 'var(--bg-tertiary)';
            }
            
            document.getElementById('link-preview-title').value = metadata.title;
            document.getElementById('link-preview-description').value = metadata.description;
            
            // Source indicator
            const sourceLabels = {
                'youtube': '✓ YouTube',
                'jsonlink': '✓ Real data',
                'microlink': '✓ Real data',
                'ai': 'AI guess',
                'fallback': 'From URL'
            };
            const sourceLabel = sourceLabels[metadata.source] || '';
            
            document.getElementById('link-preview-source').innerHTML = `
                <img src="${metadata.favicon}" alt="">
                ${metadata.domain} • ${metadata.type}
                ${sourceLabel ? `<span style="margin-left: 8px; opacity: 0.7;">${sourceLabel}</span>` : ''}
            `;
        },
        
        async categorizeLink(metadata) {
            const categories = neuralNet.categories;
            
            if (categories.length === 0) {
                // No trained categories, use default placement
                this.selectedCategory = null;
                document.getElementById('link-category').style.display = 'none';
                return;
            }
            
            document.getElementById('link-category').style.display = 'block';
            document.getElementById('link-category-name').textContent = 'Analyzing...';
            document.getElementById('link-category-confidence').textContent = '';
            document.getElementById('link-category-alt').innerHTML = '';
            
            // Clear any previous suggestion tracking
            this.currentSuggestionId = null;
            this.predictedCategory = null;
            
            // Use neural network + Claude to categorize (with active learning)
            const contentText = `${metadata.title}. ${metadata.description}. ${metadata.type} from ${metadata.domain}`;

            try {
                // Get predictions with active learning (routes to Claude if uncertain)
                const predictions = await neuralNet.predictCategoryWithActiveLearning(contentText, store);

                if (predictions && predictions.length > 0) {
                    // Show top prediction
                    const top = predictions[0];
                    const confidence = top.confidence || top.probability || 0;
                    this.selectedCategory = top.category;
                    this.predictedCategory = top.category; // Store original prediction

                    // Track this suggestion for feedback (include source for debugging)
                    this.currentSuggestionId = AIFeedback.suggest('category', {
                        predicted: top.category,
                        confidence: confidence,
                        alternatives: predictions.slice(1, 4).map(p => p.category),
                        source: top.source || 'local' // Track if Claude was used
                    }, {
                        nodeLabel: metadata.title,
                        nodeText: contentText
                    });

                    // Show source indicator if from Claude
                    const sourceIndicator = top.source === 'claude' ? ' 🤖' : '';
                    document.getElementById('link-category-name').textContent = top.category + sourceIndicator;
                    document.getElementById('link-category-confidence').textContent = `${Math.round(confidence * 100)}%`;

                    // Show alternatives
                    const alts = predictions.slice(1, 4);
                    document.getElementById('link-category-alt').innerHTML = alts.map(p => {
                        const altConf = p.confidence || p.probability || 0;
                        return `
                        <div class="link-category-alt-item" data-category="${p.category}">
                            ${p.category} (${Math.round(altConf * 100)}%)
                        </div>
                    `;
                    }).join('');
                    
                    // Handle alt selection
                    document.querySelectorAll('.link-category-alt-item').forEach(el => {
                        el.addEventListener('click', () => {
                            this.selectedCategory = el.dataset.category;
                            document.querySelectorAll('.link-category-alt-item').forEach(e => e.classList.remove('selected'));
                            el.classList.add('selected');
                            document.getElementById('link-category-name').textContent = el.dataset.category;
                        });
                    });
                } else {
                    // No predictions available
                    document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                    this.selectedCategory = categories[0] || null;
                }
                
            } catch (error) {
                console.error('Categorization error:', error);
                document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                this.selectedCategory = categories[0] || null;
            }
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // SMART ORGANIZATION - Creates sub-folders when patterns detected
        // ═══════════════════════════════════════════════════════════════════
        
        async smartOrganize(parentId, newItemDomain, newItemType) {
            const parentNode = store.findNode(parentId);
            if (!parentNode || !parentNode.children) {
                console.log('📁 SmartOrganize: No parent or no children');
                return { parentId, organized: false };
            }
            
            // Analyze siblings for patterns
            const siblings = parentNode.children;
            const domainGroups = {};
            
            console.log(`📁 SmartOrganize: Analyzing ${siblings.length} siblings in "${parentNode.label}"`);
            
            // Group existing children by domain (check both link.domain and URL)
            siblings.forEach(child => {
                let domain = null;
                
                // Try to get domain from link.domain
                if (child.link?.domain) {
                    domain = this.normalizeDomain(child.link.domain);
                }
                // Also try to extract from URL if domain is missing
                else if (child.link?.url) {
                    try {
                        const urlObj = new URL(child.link.url);
                        domain = this.normalizeDomain(urlObj.hostname);
                    } catch (e) {}
                }
                
                if (domain) {
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            });
            
            console.log('📁 SmartOrganize: Domain groups:', Object.keys(domainGroups).map(k => `${k}: ${domainGroups[k].length}`).join(', '));
            
            const normalizedNewDomain = this.normalizeDomain(newItemDomain);
            console.log(`📁 SmartOrganize: New item domain: "${newItemDomain}" → normalized: "${normalizedNewDomain}"`);
            
            // Check if we should create a domain-based sub-folder
            // Trigger: 1+ existing items from same domain (so 2+ total after adding new one)
            if (normalizedNewDomain && domainGroups[normalizedNewDomain]?.length >= 1) {
                const existingSameDomain = domainGroups[normalizedNewDomain];
                const folderName = this.getDomainFolderName(normalizedNewDomain);
                
                console.log(`📁 SmartOrganize: Found ${existingSameDomain.length} existing items from ${normalizedNewDomain}`);
                
                // Check if folder already exists
                const existingFolder = siblings.find(s => 
                    s.label.toLowerCase() === folderName.toLowerCase() && 
                    !s.link // It's a folder, not a link
                );
                
                if (existingFolder) {
                    // Folder exists, just use it as parent
                    console.log(`📁 SmartOrganize: "${folderName}" folder already exists, using it`);
                    return { parentId: existingFolder.id, organized: false };
                }
                
                // Create new sub-folder
                console.log(`📁 SmartOrganize: Creating "${folderName}" folder and moving ${existingSameDomain.length} existing items`);
                
                const folderNode = store.addNode(parentId, {
                    label: folderName,
                    description: `Collection of ${folderName} content`,
                    color: parentNode.color,
                    source: 'smart-organize'
                });
                
                // Move existing same-domain items into the folder
                let movedCount = 0;
                for (const item of existingSameDomain) {
                    const moved = store.moveNode(item.id, folderNode.id);
                    if (moved) movedCount++;
                    console.log(`📁 SmartOrganize: Moving "${item.label}" → ${moved ? 'success' : 'failed'}`);
                }
                
                showToast(`Created "${folderName}" folder and organized ${movedCount} existing items`, 'success');
                
                return { parentId: folderNode.id, organized: true, folderName };
            }
            
            // Check if parent has too many children (> 7) and we should suggest AI organization
            if (siblings.length > 7 && localStorage.getItem(CONFIG.API_KEY)) {
                console.log('⚠️ Parent has many children, consider reorganizing');
            }
            
            return { parentId, organized: false };
        },
        
        normalizeDomain(domain) {
            if (!domain) return null;
            // Remove www. and common subdomains, then lowercase
            return domain
                .replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '')
                .toLowerCase();
        },
        
        getDomainFolderName(domain) {
            // Map common domains to friendly folder names
            const domainNames = {
                'tiktok.com': 'TikToks',
                'youtube.com': 'YouTube Videos',
                'youtu.be': 'YouTube Videos',
                'instagram.com': 'Instagram',
                'twitter.com': 'Twitter/X',
                'x.com': 'Twitter/X',
                'reddit.com': 'Reddit Posts',
                'github.com': 'GitHub Repos',
                'medium.com': 'Medium Articles',
                'substack.com': 'Substack',
                'linkedin.com': 'LinkedIn',
                'facebook.com': 'Facebook',
                'pinterest.com': 'Pinterest',
                'spotify.com': 'Spotify',
                'soundcloud.com': 'SoundCloud',
                'twitch.tv': 'Twitch',
                'vimeo.com': 'Vimeo'
            };
            
            return domainNames[domain] || `${domain.split('.')[0].charAt(0).toUpperCase() + domain.split('.')[0].slice(1)} Links`;
        },
        
        async addToMap() {
            if (!this.currentLink) return;
            
            // Get user-edited values
            const title = document.getElementById('link-preview-title').value.trim() || this.currentLink.title;
            const description = document.getElementById('link-preview-description').value.trim();
            
            // Find parent node (selected category or selected node or root)
            let parentId = store.data.id;
            
            if (this.selectedCategory) {
                // Find the category node
                const findCategory = (node) => {
                    if (node.label === this.selectedCategory) return node;
                    for (const child of (node.children || [])) {
                        const found = findCategory(child);
                        if (found) return found;
                    }
                    return null;
                };
                const categoryNode = findCategory(store.data);
                if (categoryNode) {
                    parentId = categoryNode.id;
                }
            } else if (selectedNode && selectedNode.userData.id !== 'mynd') {
                parentId = selectedNode.userData.id;
            }
            
            // Smart organization - check if we should create a sub-folder
            const organizeResult = await this.smartOrganize(
                parentId, 
                this.currentLink.domain, 
                this.currentLink.type
            );
            parentId = organizeResult.parentId;
            
            const parentNode = store.findNode(parentId);
            
            // Build link data with transcript if available
            const linkData = {
                url: this.currentLink.url,
                domain: this.currentLink.domain,
                type: this.currentLink.type,
                favicon: this.currentLink.favicon,
                image: this.currentLink.image || null,
                author: this.currentLink.author || null,
                source: this.currentLink.source || 'unknown',
                addedAt: new Date().toISOString()
            };
            
            // Include transcript if available
            if (this.currentLink.transcript) {
                linkData.transcript = this.currentLink.transcript;
                linkData.transcriptSource = this.currentLink.transcriptSource;
            }
            
            // Include AI summary if generated
            if (this.currentLink.aiSummary) {
                linkData.aiSummary = this.currentLink.aiSummary;
            }
            
            // Add the link node
            const newNode = store.addNode(parentId, {
                label: title,
                description: description,
                color: parentNode?.color,
                link: linkData
            });
            
            // Rebuild scene
            buildScene();
            
            // Focus on the new node
            setTimeout(() => {
                const newMesh = nodes.get(newNode.id);
                if (newMesh) {
                    selectNode(newMesh);
                    focusOnNode(newMesh);
                    
                    // Expand parent if collapsed
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
            }, 100);
            
            // Resolve AI feedback - track if user accepted or modified prediction
            if (this.currentSuggestionId) {
                if (this.selectedCategory === this.predictedCategory) {
                    AIFeedback.resolve(this.currentSuggestionId, 'accepted');
                } else {
                    AIFeedback.resolve(this.currentSuggestionId, 'modified', this.selectedCategory);
                }
                this.currentSuggestionId = null; // Clear so close() doesn't double-resolve
            }
            
            this.close();
            showToast(`Added "${title}" to ${this.selectedCategory || 'map'}`, 'success');
            audio.add();
        }
    };
    
    // Initialize Link Manager
    setTimeout(() => {
        LinkManager.init();
    }, 50);
    
    // Initialize Neural Network UI after app init
    setTimeout(() => {
        NeuralUI.init();
    }, 100);
    
    // Initialize Attachment Manager
    setTimeout(() => {
        AttachmentManager.init();
    }, 150);
    
    // ═══════════════════════════════════════════════════════════════════
    // MOBILE BOTTOM SHEET CONTROLLER
    // Input-first mobile UI with Waze-style bottom sheet
    // ═══════════════════════════════════════════════════════════════════
    
    const MobileSheet = {
        sheet: null,
        dragHandle: null,
        isExpanded: false,
        isMinimized: false,
        miniToolbarVisible: false,
        startY: 0,
        currentY: 0,
        isDragging: false,
        speechRecognition: null,
        isRecordingVoice: false,
        
        init() {
            // Only init on mobile
            if (window.innerWidth > 768) return;
            
            this.sheet = document.getElementById('mobile-bottom-sheet');
            if (!this.sheet) return;
            
            this.dragHandle = document.getElementById('sheet-drag-handle');
            this.bindEvents();
            this.loadRecentCaptures();
            
            // Start collapsed
            this.sheet.classList.add('collapsed');
            this.isExpanded = false;
            this.isMinimized = false;
            
            // Set initial body class for info panel positioning
            document.body.classList.add('sheet-collapsed');
            
            // Update auto-cam button state
            this.updateAutoCamState();
            
            console.log('📱 Mobile Sheet initialized');
        },
        
        updateAutoCamState() {
            const btn = document.getElementById('mini-autocam-btn');
            if (btn) {
                btn.classList.toggle('active', window.autoCameraEnabled !== false);
            }
        },
        
        bindEvents() {
            // Drag handle for expanding/collapsing
            if (this.dragHandle) {
                this.dragHandle.addEventListener('touchstart', (e) => this.onDragStart(e), { passive: true });
                this.dragHandle.addEventListener('touchmove', (e) => this.onDragMove(e), { passive: false });
                this.dragHandle.addEventListener('touchend', (e) => this.onDragEnd(e));
                
                // Click to toggle
                this.dragHandle.addEventListener('click', () => this.toggle());
            }
            
            // Allow dragging from anywhere on sheet when expanded
            if (this.sheet) {
                this.sheet.addEventListener('touchstart', (e) => {
                    // Only allow drag from content area when expanded
                    if (this.isExpanded && !e.target.closest('input, textarea, button, .sheet-tab, .sheet-tool, .sheet-recent-item, .sheet-suggestion')) {
                        this.onDragStart(e);
                    }
                }, { passive: true });
                
                this.sheet.addEventListener('touchmove', (e) => {
                    if (this.isDragging && this.isExpanded) {
                        this.onDragMove(e);
                    }
                }, { passive: false });
                
                this.sheet.addEventListener('touchend', (e) => {
                    if (this.isDragging && this.isExpanded) {
                        this.onDragEnd(e);
                    }
                });
            }
            
            // Tap on map/canvas to close toolbar or minimize sheet
            const canvas = document.getElementById('canvas-container');
            if (canvas) {
                canvas.addEventListener('touchstart', (e) => {
                    // If mini toolbar is visible, only close it (don't affect sheet)
                    if (this.miniToolbarVisible) {
                        this.hideMiniToolbar();
                        return;
                    }
                    
                    // Only collapse expanded state, don't minimize from collapsed
                    if (this.isExpanded) {
                        this.collapse();
                    }
                    // When collapsed, tapping map does nothing to sheet state
                }, { passive: true });
            }
            
            // Mini toolbar toggle
            const mapToggle = document.getElementById('sheet-map-toggle');
            if (mapToggle) {
                mapToggle.addEventListener('click', () => this.toggleMiniToolbar());
            }
            
            // Mini toolbar buttons
            document.querySelectorAll('.sheet-mini-toolbar-btn').forEach(btn => {
                btn.addEventListener('click', () => this.handleMiniToolbarAction(btn.dataset.action));
            });
            
            // Tab switching
            document.querySelectorAll('.sheet-tab').forEach(tab => {
                tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
            });
            
            // Text input
            const textInput = document.getElementById('sheet-text-input');
            const sendBtn = document.getElementById('sheet-send-btn');
            
            if (textInput) {
                textInput.addEventListener('input', () => {
                    sendBtn.disabled = !textInput.value.trim();
                });
                
                textInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                // Focus expands sheet
                textInput.addEventListener('focus', () => {
                    if (!this.isExpanded) this.expand();
                });
            }
            
            if (sendBtn) {
                sendBtn.addEventListener('click', () => this.sendMessage());
            }
            
            // Voice button
            const voiceBtn = document.getElementById('sheet-voice-btn');
            if (voiceBtn) {
                voiceBtn.addEventListener('click', () => this.startVoiceInput());
            }
            
            // Tool actions
            document.querySelectorAll('.sheet-tool').forEach(tool => {
                tool.addEventListener('click', () => this.handleToolAction(tool.dataset.action));
            });
            
            // Quick action buttons (collapsed state)
            document.querySelectorAll('.sheet-quick-btn').forEach(btn => {
                btn.addEventListener('click', () => this.handleQuickAction(btn.dataset.action));
            });
            
            // Map actions
            document.querySelectorAll('.sheet-map-btn').forEach(btn => {
                btn.addEventListener('click', () => this.handleMapAction(btn.dataset.action));
            });
            
            // Suggestions
            document.querySelectorAll('.sheet-suggestion').forEach(sug => {
                sug.addEventListener('click', () => {
                    const textInput = document.getElementById('sheet-text-input');
                    if (textInput) {
                        textInput.value = sug.textContent;
                        textInput.dispatchEvent(new Event('input'));
                        this.sendMessage();
                    }
                });
            });
        },
        
        onDragStart(e) {
            this.isDragging = true;
            this.startY = e.touches[0].clientY;
            this.sheet.style.transition = 'none';
            
            // If collapsed, set initial height for expansion
            if (!this.isExpanded && !this.isMinimized) {
                this.sheet.style.height = '85vh';
                // Position it at collapsed position using transform
                this.sheet.style.transform = `translateY(calc(100% - 130px))`;
            }
        },
        
        onDragMove(e) {
            if (!this.isDragging) return;
            
            this.currentY = e.touches[0].clientY;
            const deltaY = this.currentY - this.startY;
            
            // Apply transform based on drag direction
            if (this.isExpanded) {
                // Dragging down from expanded
                if (deltaY > 0) {
                    this.sheet.style.transform = `translateY(${deltaY}px)`;
                }
            } else if (this.isMinimized) {
                // Dragging up from minimized - show real-time movement
                if (deltaY < 0) {
                    const maxDelta = 60; // 130 - 70 = 60px difference
                    const clampedDelta = Math.max(deltaY, -maxDelta);
                    this.sheet.style.transform = `translateY(calc(100% - 70px + ${clampedDelta}px))`;
                }
            } else {
                // Dragging from collapsed - use transform for smooth animation
                if (deltaY < 0) {
                    // Dragging up - expand (sheet is now 85vh, transform controls position)
                    // At rest: translateY(calc(100% - 130px)), fully expanded: translateY(0)
                    // So we add deltaY (negative) to move up
                    this.sheet.style.transform = `translateY(calc(100% - 130px + ${deltaY}px))`;
                } else if (deltaY > 0) {
                    // Dragging down - minimize
                    const maxDelta = 60; // 130 - 70 = 60px difference
                    const clampedDelta = Math.min(deltaY, maxDelta);
                    this.sheet.style.transform = `translateY(calc(100% - 130px + ${clampedDelta}px))`;
                }
            }
            
            e.preventDefault();
        },
        
        onDragEnd(e) {
            if (!this.isDragging) return;
            
            this.isDragging = false;
            this.sheet.style.transition = '';
            this.sheet.style.transform = '';
            
            const deltaY = this.currentY - this.startY;
            const threshold = 40;
            
            if (this.isExpanded && deltaY > threshold) {
                this.collapse();
            } else if (this.isMinimized && deltaY < -threshold) {
                this.collapse(); // Go back to collapsed from minimized
            } else if (!this.isExpanded && !this.isMinimized) {
                // From collapsed state
                if (deltaY < -threshold) {
                    this.expand();
                } else if (deltaY > threshold) {
                    this.minimize();
                } else {
                    // Reset - remove the temporary height we set
                    this.collapse();
                }
            } else {
                // Reset to current state
                if (this.isExpanded) {
                    this.expand();
                } else if (this.isMinimized) {
                    this.minimize();
                } else {
                    this.collapse();
                }
            }
        },
        
        toggle() {
            if (this.isMinimized) {
                // When minimized, tapping handle goes to collapsed
                this.collapse();
            } else if (this.isExpanded) {
                this.collapse();
            } else {
                // From collapsed, tap goes to minimize (slide down)
                this.minimize();
            }
        },
        
        expand() {
            this.isExpanded = true;
            this.isMinimized = false;
            this.sheet.classList.add('expanded');
            this.sheet.classList.remove('collapsed', 'minimized');
            this.sheet.style.height = '85vh';
            this.hideMiniToolbar();
            // Update body class for info panel positioning
            document.body.classList.add('sheet-expanded');
            document.body.classList.remove('sheet-minimized', 'sheet-collapsed');
            
            // Close neural panel when sheet expands (sheet covers the area)
            if (typeof NeuralUI !== 'undefined' && NeuralUI.isOpen) {
                NeuralUI.close();
            }
        },
        
        collapse() {
            this.isExpanded = false;
            this.isMinimized = false;
            this.sheet.classList.remove('expanded', 'minimized');
            this.sheet.classList.add('collapsed');
            this.sheet.style.height = '';
            // Update body class for info panel positioning
            document.body.classList.add('sheet-collapsed');
            document.body.classList.remove('sheet-expanded', 'sheet-minimized');
            
            // Slide neural panel back up with the sheet
            if (typeof NeuralUI !== 'undefined' && NeuralUI.isOpen && NeuralUI.panel) {
                NeuralUI.panel.style.bottom = '140px';
            }
        },
        
        minimize() {
            this.isExpanded = false;
            this.isMinimized = true;
            this.sheet.classList.remove('expanded', 'collapsed');
            this.sheet.classList.add('minimized');
            this.sheet.style.height = '';
            this.hideMiniToolbar();
            // Update body class for info panel positioning
            document.body.classList.add('sheet-minimized');
            document.body.classList.remove('sheet-expanded', 'sheet-collapsed');
            
            // Slide neural panel down with the sheet
            if (typeof NeuralUI !== 'undefined' && NeuralUI.isOpen && NeuralUI.panel) {
                NeuralUI.panel.style.bottom = '80px';
            }
        },
        
        toggleMiniToolbar() {
            const toolbar = document.getElementById('sheet-mini-toolbar');
            const toggle = document.getElementById('sheet-map-toggle');
            
            this.miniToolbarVisible = !this.miniToolbarVisible;
            toolbar?.classList.toggle('visible', this.miniToolbarVisible);
            toggle?.classList.toggle('active', this.miniToolbarVisible);
        },
        
        hideMiniToolbar() {
            const toolbar = document.getElementById('sheet-mini-toolbar');
            const toggle = document.getElementById('sheet-map-toggle');
            
            this.miniToolbarVisible = false;
            toolbar?.classList.remove('visible');
            toggle?.classList.remove('active');
        },
        
        handleMiniToolbarAction(action) {
            switch(action) {
                case 'expand-all':
                    if (typeof expandAll !== 'undefined') {
                        expandAll();
                    }
                    break;
                    
                case 'collapse-all':
                    if (typeof collapseAll !== 'undefined') {
                        collapseAll();
                    }
                    break;
                    
                case 'auto-cam':
                    window.autoCameraEnabled = !window.autoCameraEnabled;
                    this.updateAutoCamState();
                    showToast(window.autoCameraEnabled ? 'Auto camera enabled' : 'Auto camera disabled', 'info');
                    break;
            }
            // Toolbar stays visible - only closes on toggle tap or map tap
        },
        
        switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.sheet-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            
            // Update content panels
            document.querySelectorAll('.sheet-content').forEach(content => {
                content.classList.toggle('active', content.id === `sheet-content-${tabName}`);
            });
            
            // Expand sheet when switching tabs (if not already)
            if (!this.isExpanded) {
                this.expand();
            }
        },
        
        async sendMessage() {
            const textInput = document.getElementById('sheet-text-input');
            const message = textInput?.value.trim();
            if (!message) return;
            
            // Clear input
            textInput.value = '';
            document.getElementById('sheet-send-btn').disabled = true;
            
            // Switch to chat tab and expand
            this.switchTab('chat');
            
            // Add user message to chat
            this.addChatMessage(message, 'user');
            
            // Show thinking indicator
            const thinkingId = this.addThinkingIndicator();
            
            // Save to recent captures
            this.saveRecentCapture(message);
            
            try {
                // Use chatManager's AI call
                if (typeof chatManager !== 'undefined' && chatManager.callAI) {
                    const response = await chatManager.callAI(message);
                    this.removeThinkingIndicator(thinkingId);
                    
                    if (response && response.message) {
                        this.addChatMessage(response.message, 'assistant');
                        
                        // Execute any actions
                        if (response.actions && response.actions.length > 0) {
                            const results = await chatManager.executeActions(response.actions);
                            const successCount = results.filter(r => r.success).length;
                            if (successCount > 0) {
                                showToast(`${successCount} action${successCount > 1 ? 's' : ''} completed`, 'success');
                            }
                        }
                    }
                } else {
                    // No AI available - just add as node
                    this.removeThinkingIndicator(thinkingId);
                    
                    // Add as node to mind map
                    if (typeof addNodeToSelected !== 'undefined') {
                        addNodeToSelected(message);
                        this.addChatMessage("Added to your mind map.", 'assistant');
                    } else {
                        this.addChatMessage("AI features require sign-in.", 'assistant');
                    }
                }
            } catch (error) {
                console.error('Chat error:', error);
                this.removeThinkingIndicator(thinkingId);
                this.addChatMessage("Sorry, I encountered an error. Try signing in for AI features.", 'assistant');
            }
        },
        
        addChatMessage(text, type) {
            const messagesContainer = document.getElementById('sheet-chat-messages');
            if (!messagesContainer) return;
            
            // Remove welcome message if present
            const welcome = messagesContainer.querySelector('.sheet-chat-welcome');
            if (welcome) welcome.remove();
            
            const messageEl = document.createElement('div');
            messageEl.className = `sheet-message ${type}`;
            messageEl.textContent = text;
            
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        },
        
        addThinkingIndicator() {
            const messagesContainer = document.getElementById('sheet-chat-messages');
            if (!messagesContainer) return null;
            
            const id = 'thinking-' + Date.now();
            const thinkingEl = document.createElement('div');
            thinkingEl.className = 'sheet-message assistant thinking';
            thinkingEl.id = id;
            thinkingEl.innerHTML = '<span></span><span></span><span></span>';
            
            messagesContainer.appendChild(thinkingEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            return id;
        },
        
        removeThinkingIndicator(id) {
            if (!id) return;
            const el = document.getElementById(id);
            if (el) el.remove();
        },
        
        startVoiceInput() {
            const voiceBtn = document.getElementById('sheet-voice-btn');
            const textInput = document.getElementById('sheet-text-input');
            
            // If already recording, stop
            if (this.speechRecognition && this.isRecordingVoice) {
                this.stopVoiceInput();
                return;
            }
            
            // Check for speech recognition support
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                showToast('Voice not supported in this browser', 'warning');
                return;
            }
            
            // Create speech recognition
            this.speechRecognition = new SpeechRecognition();
            this.speechRecognition.continuous = false;
            this.speechRecognition.interimResults = true;
            this.speechRecognition.lang = 'en-US';
            
            this.isRecordingVoice = true;
            voiceBtn?.classList.add('recording');
            textInput.placeholder = 'Listening...';
            
            // Audio feedback
            if (typeof haptic !== 'undefined') haptic.medium();
            
            let finalTranscript = '';
            
            this.speechRecognition.onresult = (event) => {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                // Show real-time transcription in input
                textInput.value = finalTranscript + interimTranscript;
                document.getElementById('sheet-send-btn').disabled = !textInput.value.trim();
            };
            
            this.speechRecognition.onend = () => {
                this.isRecordingVoice = false;
                voiceBtn?.classList.remove('recording');
                textInput.placeholder = 'What\'s on your mind?';
                
                // If we got text, auto-send or keep for editing
                if (finalTranscript.trim()) {
                    textInput.value = finalTranscript.trim();
                    document.getElementById('sheet-send-btn').disabled = false;
                    // Focus on input so user can edit or press send
                    textInput.focus();
                }
            };
            
            this.speechRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                this.isRecordingVoice = false;
                voiceBtn?.classList.remove('recording');
                textInput.placeholder = 'What\'s on your mind?';
                
                if (event.error === 'not-allowed') {
                    showToast('Microphone access denied', 'error');
                } else if (event.error !== 'aborted') {
                    showToast('Voice input error', 'warning');
                }
            };
            
            try {
                this.speechRecognition.start();
            } catch (e) {
                console.error('Failed to start speech recognition:', e);
                this.isRecordingVoice = false;
                voiceBtn?.classList.remove('recording');
                showToast('Could not start voice input', 'warning');
            }
        },
        
        stopVoiceInput() {
            if (this.speechRecognition) {
                this.speechRecognition.stop();
                this.speechRecognition = null;
            }
            this.isRecordingVoice = false;
            document.getElementById('sheet-voice-btn')?.classList.remove('recording');
            document.getElementById('sheet-text-input').placeholder = 'What\'s on your mind?';
        },
        
        handleToolAction(action) {
            console.log('Sheet tool action:', action);
            switch(action) {
                case 'add-node':
                    if (typeof openModal !== 'undefined') {
                        const targetId = (typeof selectedNode !== 'undefined' && selectedNode) 
                            ? selectedNode.userData.id 
                            : (typeof currentContextId !== 'undefined' ? currentContextId : 'root');
                        openModal('add', targetId);
                    }
                    this.collapse();
                    break;
                    
                case 'add-link':
                    console.log('Add-link action - LinkManager:', typeof LinkManager, LinkManager?.modal);
                    if (typeof LinkManager !== 'undefined' && LinkManager.modal) {
                        LinkManager.open();
                    } else {
                        showToast('Link manager not ready', 'warning');
                    }
                    this.collapse();
                    break;
                    
                case 'neural':
                    if (typeof NeuralUI !== 'undefined') {
                        NeuralUI.toggle();
                        // Keep sheet collapsed (buttons visible) so user can tap neural again to close
                        if (NeuralUI.isOpen) {
                            this.collapse();
                        }
                    }
                    break;
                    
                case 'focus':
                    // Focus mode - zoom to fit entire map and center on root
                    console.log('Focus action - window.zoomToFitMap:', typeof window.zoomToFitMap);
                    if (window.zoomToFitMap) {
                        window.zoomToFitMap(0);
                        showToast('Showing full map', 'info');
                    } else {
                        showToast('Scene not ready', 'warning');
                    }
                    this.collapse();
                    break;
                    
                case 'export':
                    // Export map as JSON
                    console.log('Export action - store:', typeof store, store?.exportJSON);
                    if (typeof store !== 'undefined' && store.exportJSON) {
                        const data = store.exportJSON();
                        const blob = new Blob([data], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${store.data.label || 'mindmap'}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showToast('Map exported', 'success');
                    } else {
                        showToast('Export not available', 'warning');
                    }
                    this.collapse();
                    break;
                    
                case 'import-notes':
                    if (typeof ImportNotes !== 'undefined') {
                        ImportNotes.open();
                    }
                    this.collapse();
                    break;
                    
                case 'settings':
                    document.getElementById('api-key-modal')?.classList.add('active');
                    break;
            }
        },
        
        handleQuickAction(action) {
            switch(action) {
                case 'add-node':
                    // Use the in-app modal
                    if (typeof openModal !== 'undefined') {
                        const targetId = (typeof selectedNode !== 'undefined' && selectedNode) 
                            ? selectedNode.userData.id 
                            : (typeof currentContextId !== 'undefined' ? currentContextId : 'root');
                        openModal('add', targetId);
                    } else {
                        showToast('Add node not available', 'warning');
                    }
                    break;
                    
                case 'open-chat':
                    this.expand();
                    this.switchTab('chat');
                    setTimeout(() => {
                        document.getElementById('sheet-text-input')?.focus();
                    }, 100);
                    break;
                    
                case 'voice':
                    // Voice button - opens full voice memo UI
                    if (typeof voiceAI !== 'undefined') {
                        voiceAI.start();
                    } else {
                        showToast('Voice features not available', 'warning');
                    }
                    break;
                    
                case 'memo':
                    // Memo - quick text note entry
                    this.expand();
                    this.switchTab('chat');
                    setTimeout(() => {
                        const input = document.getElementById('sheet-text-input');
                        if (input) {
                            input.focus();
                            input.placeholder = 'Quick memo...';
                        }
                    }, 100);
                    break;
                    
                case 'neural':
                    // Open neural panel
                    if (typeof NeuralUI !== 'undefined') {
                        NeuralUI.toggle();
                        // Keep sheet collapsed (buttons visible) so user can tap neural again to close
                        if (NeuralUI.isOpen) {
                            this.collapse();
                        }
                    } else {
                        showToast('Neural panel not available', 'warning');
                    }
                    break;
                    
                default:
                    console.log('Unknown quick action:', action);
            }
        },
        
        handleMapAction(action) {
            switch(action) {
                case 'home':
                    if (typeof resetCameraView !== 'undefined') {
                        resetCameraView();
                    }
                    break;
                    
                case 'expand-all':
                    if (typeof expandAll !== 'undefined') {
                        expandAll();
                    }
                    break;
                    
                case 'collapse-all':
                    if (typeof collapseAll !== 'undefined') {
                        collapseAll();
                    }
                    break;
                    
                case 'auto-cam':
                    if (typeof autoCameraEnabled !== 'undefined') {
                        window.autoCameraEnabled = !window.autoCameraEnabled;
                        showToast(window.autoCameraEnabled ? 'Auto camera enabled' : 'Auto camera disabled', 'info');
                    }
                    break;
            }
            
            this.collapse();
        },
        
        saveRecentCapture(text) {
            try {
                const captures = JSON.parse(localStorage.getItem('mynd-recent-captures') || '[]');
                captures.unshift({
                    text: text,
                    timestamp: Date.now()
                });
                // Keep last 20
                localStorage.setItem('mynd-recent-captures', JSON.stringify(captures.slice(0, 20)));
                this.loadRecentCaptures();
            } catch (e) {
                console.warn('Failed to save capture:', e);
            }
        },
        
        loadRecentCaptures() {
            const container = document.getElementById('sheet-recent-list');
            if (!container) return;
            
            try {
                const captures = JSON.parse(localStorage.getItem('mynd-recent-captures') || '[]');
                
                if (captures.length === 0) {
                    container.innerHTML = `
                        <div class="sheet-recent-empty">
                            <p>No recent captures yet.</p>
                            <p style="margin-top: 8px; font-size: 12px;">Use voice or text to add thoughts!</p>
                        </div>
                    `;
                    return;
                }
                
                container.innerHTML = captures.map((capture, i) => `
                    <div class="sheet-recent-item" data-index="${i}">
                        <div class="sheet-recent-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="12" y1="8" x2="12" y2="12"/>
                                <line x1="12" y1="16" x2="12.01" y2="16"/>
                            </svg>
                        </div>
                        <div class="sheet-recent-info">
                            <div class="sheet-recent-title">${this.escapeHtml(capture.text.substring(0, 50))}${capture.text.length > 50 ? '...' : ''}</div>
                            <div class="sheet-recent-meta">${this.formatTime(capture.timestamp)}</div>
                        </div>
                    </div>
                `).join('');
                
                // Add click handlers
                container.querySelectorAll('.sheet-recent-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const index = parseInt(item.dataset.index);
                        const capture = captures[index];
                        if (capture) {
                            document.getElementById('sheet-text-input').value = capture.text;
                            document.getElementById('sheet-send-btn').disabled = false;
                            this.switchTab('chat');
                        }
                    });
                });
            } catch (e) {
                console.warn('Failed to load captures:', e);
            }
        },
        
        formatTime(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
            if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
            return new Date(timestamp).toLocaleDateString();
        },
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    };
    
    // Initialize Mobile Sheet after a delay
    setTimeout(() => {
        MobileSheet.init();
        
        // Re-init on resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (window.innerWidth <= 768 && !MobileSheet.sheet) {
                    MobileSheet.init();
                }
            }, 250);
        });
    }, 200);
    
    // Initialize Cognitive Graph Transformer (advanced ML)
    setTimeout(async () => {
        try {
            await cognitiveGT.initialize();
            
            // Process graph on initial load
            setTimeout(() => {
                cognitiveGT.processGraph(store);
            }, 2000);
            
            // Periodic graph processing (every 30 seconds when active)
            let lastActivity = Date.now();
            document.addEventListener('click', () => lastActivity = Date.now());
            document.addEventListener('keydown', () => lastActivity = Date.now());
            
            setInterval(() => {
                // Only process if user has been active in last 2 minutes
                // And not on mobile (to save battery)
                const isMobile = window.innerWidth <= 768;
                if (Date.now() - lastActivity < 120000 && !isMobile) {
                    cognitiveGT.processGraph(store);
                }
            }, 60000); // Increased from 30s to 60s
            
            // Save CGT state periodically
            setInterval(() => {
                if (cognitiveGT.initialized) {
                    cognitiveGT.saveState();
                }
            }, 120000); // Increased from 60s to 120s
            
            // Save on page unload
            window.addEventListener('beforeunload', () => {
                if (cognitiveGT.initialized) {
                    cognitiveGT.saveState();
                }
            });
            
        } catch (e) {
            console.warn('CGT initialization deferred:', e.message);
        }
    }, 500);
    
    // Initialize Style Transfer System (Phase 4)
    setTimeout(async () => {
        try {
            await styleTransfer.initialize();
            
            // Save periodically (less frequently on mobile)
            const saveInterval = window.innerWidth <= 768 ? 300000 : 120000; // 5min mobile, 2min desktop
            setInterval(() => {
                if (styleTransfer.initialized) {
                    styleTransfer.save();
                }
            }, saveInterval);
            
            // Save on page unload and end session
            window.addEventListener('beforeunload', () => {
                if (styleTransfer.initialized) {
                    styleTransfer.endSession();
                    styleTransfer.save();
                }
            });
            
        } catch (e) {
            console.warn('StyleTransfer initialization deferred:', e.message);
        }
    }, 600);
    
    // Initialize WebGPU Compute Engine (GPU-accelerated similarity)
    setTimeout(async () => {
        try {
            const supported = await gpuCompute.initialize();
            
            if (supported) {
                // Optional: Run benchmark on first load (can be removed in production)
                // gpuCompute.benchmark(100, 128);
                
                // Update UI to show GPU is active
                NeuralUI.updateStatus();
            }
        } catch (e) {
            console.warn('WebGPU initialization deferred:', e.message);
        }
    }, 700);

    // Initialize CodeRAG System (codebase understanding for AI)
    setTimeout(async () => {
        try {
            // Wait for neuralNet to be ready (need encoder)
            if (neuralNet.isReady || neuralNet.encoder) {
                await codeRAG.initialize();
                console.log('📚 CodeRAG stats:', codeRAG.getStats());
            } else {
                // Retry after neuralNet initializes
                const checkEncoder = setInterval(async () => {
                    if (neuralNet.encoder) {
                        clearInterval(checkEncoder);
                        codeRAG.setEncoder(neuralNet.encoder);
                        await codeRAG.initialize();
                        console.log('📚 CodeRAG stats:', codeRAG.getStats());
                    }
                }, 2000);
                // Give up after 30 seconds
                setTimeout(() => clearInterval(checkEncoder), 30000);
            }
        } catch (e) {
            console.warn('CodeRAG initialization deferred:', e.message);
        }
    }, 800);

    // Initialize CodeKnowledge System (self-awareness - concept to code mapping)
    setTimeout(async () => {
        try {
            // CodeKnowledge depends on CodeRAG being ready
            if (codeRAG.initialized) {
                await codeKnowledge.initialize();
                console.log('🧠 CodeKnowledge stats:', codeKnowledge.getStats());
            } else {
                // Wait for CodeRAG to be ready
                const checkCodeRAG = setInterval(async () => {
                    if (codeRAG.initialized) {
                        clearInterval(checkCodeRAG);
                        await codeKnowledge.initialize();
                        console.log('🧠 CodeKnowledge stats:', codeKnowledge.getStats());
                    }
                }, 3000);
                // Give up after 60 seconds
                setTimeout(() => clearInterval(checkCodeRAG), 60000);
            }
        } catch (e) {
            console.warn('CodeKnowledge initialization deferred:', e.message);
        }
    }, 2000);

    // Initialize CodePretraining System (deep pre-trained codebase understanding)
    setTimeout(async () => {
        try {
            // CodePretraining depends on CodeRAG being ready
            if (codeRAG.initialized) {
                await CodePretraining.initialize();
                console.log('🎓 CodePretraining stats:', CodePretraining.getStats());
            } else {
                // Wait for CodeRAG to be ready
                const checkCodeRAG = setInterval(async () => {
                    if (codeRAG.initialized) {
                        clearInterval(checkCodeRAG);
                        await CodePretraining.initialize();
                        console.log('🎓 CodePretraining stats:', CodePretraining.getStats());
                    }
                }, 3000);
                // Give up after 90 seconds
                setTimeout(() => clearInterval(checkCodeRAG), 90000);
            }
        } catch (e) {
            console.warn('CodePretraining initialization deferred:', e.message);
        }
    }, 3000);

    // Initialize CodeAnalyzer System (comprehensive self-improvement analysis)
    setTimeout(async () => {
        try {
            // CodeAnalyzer depends on CodePretraining being ready
            if (CodePretraining.initialized) {
                await CodeAnalyzer.initialize();
                console.log('🔍 CodeAnalyzer stats:', CodeAnalyzer.getStats());
            } else {
                // Wait for CodePretraining to be ready
                const checkCodePretraining = setInterval(async () => {
                    if (CodePretraining.initialized) {
                        clearInterval(checkCodePretraining);
                        await CodeAnalyzer.initialize();
                        console.log('🔍 CodeAnalyzer stats:', CodeAnalyzer.getStats());
                    }
                }, 3000);
                // Give up after 120 seconds
                setTimeout(() => clearInterval(checkCodePretraining), 120000);
            }
        } catch (e) {
            console.warn('CodeAnalyzer initialization deferred:', e.message);
        }
    }, 4000);

    // Mobile: Start with toolbar collapsed
    if (window.innerWidth <= 768) {
        document.getElementById('side-panel').classList.add('collapsed');
    }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('SW registered'))
                .catch(err => console.log('SW failed:', err));
        }

    // Handle incoming shared content (PWA Share Target)
    function handleShareTarget() {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedUrl = urlParams.get('url');
        const sharedText = urlParams.get('text');
        const sharedTitle = urlParams.get('title');
        
        // Check if this is a share action
        if (!sharedUrl && !sharedText) return;
        
        console.log('Share Target received:', { url: sharedUrl, text: sharedText, title: sharedTitle });
        
        // Extract URL from text if no direct URL provided
        let urlToAdd = sharedUrl;
        if (!urlToAdd && sharedText) {
            // Try to extract URL from shared text
            const urlMatch = sharedText.match(/https?:\/\/[^\s]+/);
            if (urlMatch) {
                urlToAdd = urlMatch[0];
            }
        }
        
        if (urlToAdd) {
            // Clean the URL from query params so share doesn't trigger again
            window.history.replaceState({}, document.title, window.location.pathname);
            
            // Wait a moment for app to fully load, then trigger link capture
            setTimeout(() => {
                // If a node is selected, add as child
                if (selectedNode) {
                    LinkManager.addLinkAsChild(urlToAdd, selectedNode.userData.id);
                } else {
                    // Otherwise open the link modal
                    LinkManager.openWithURL(urlToAdd);
                }
                
                showToast('Link received from share', 'success');
            }, 500);
        } else if (sharedText || sharedTitle) {
            // Just text/title shared - open quick capture
            window.history.replaceState({}, document.title, window.location.pathname);
            
            setTimeout(() => {
                const quickInput = document.getElementById('quick-input');
                if (quickInput) {
                    quickInput.value = sharedTitle || sharedText;
                    quickInput.focus();
                }
                showToast('Content received from share', 'success');
            }, 500);
        }
    }
    
    // Run share handler after a short delay to ensure app is ready
    setTimeout(handleShareTarget, 100);

    </script>
    <!-- External modules -->
    <script src="js/goal-system.js"></script>
    <script src="js/demo-map.js"></script>
</body>
</html>
