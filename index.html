<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MYND — Your Mind, Visualized</title>
    <meta name="theme-color" content="#0a0a0f">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* ═══════════════════════════════════════════════════════════
           THEME SYSTEM - 6 Modern Themes
           ═══════════════════════════════════════════════════════════ */
        :root {
            /* Base/Shared Variables */
            --font-display: 'Space Grotesk', sans-serif;
            --font-body: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            
            --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px; 
            --space-5: 20px; --space-6: 24px; --space-7: 32px; --space-8: 40px;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            
            --duration-instant: 100ms;
            --duration-fast: 200ms;
            --duration-normal: 350ms;
            --duration-slow: 500ms;
            --duration-slower: 800ms;
            
            --z-bg: 0;
            --z-canvas: 1;
            --z-ui: 100;
            --z-overlay: 200;
            --z-spotlight: 250;
            --z-modal: 300;
            --z-toast: 400;
            
            /* Default to Sandstone theme */
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --glass-blur: 20px;
            --nebula-1: rgba(177, 116, 87, 0.08);
            --nebula-2: rgba(74, 73, 71, 0.06);
            --nebula-3: rgba(216, 210, 194, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
            --shadow-glow: 0 0 24px var(--accent-glow);
            
            /* AI/Brainstorm button colors */
            --purple: #8B5CF6;
            --pink: #EC4899;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 1: SANDSTONE - Natural/Professional (Default)
           Inspired by: Milk, Light Stone, Desert Clay, Graphite
           ═══════════════════════════════════════════════════════════ */
        [data-theme="sandstone"] {
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --nebula-1: rgba(196, 151, 138, 0.08);
            --nebula-2: rgba(74, 73, 71, 0.06);
            --nebula-3: rgba(216, 210, 194, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 2: CORAL - Ultra-flat Cartoon/Pastel
           Inspired by: Clean white UI, soft pastels, no shadows
           ═══════════════════════════════════════════════════════════ */
        [data-theme="coral"] {
            --bg-deep: #FAFAFA;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F5F5F5;
            --bg-tertiary: #EEEEEE;
            --bg-elevated: #E8E8E8;
            --text-primary: #1A1A1A;
            --text-secondary: #666666;
            --text-muted: #999999;
            --accent: #E87D7D;
            --accent-light: #F09999;
            --accent-glow: rgba(232, 125, 125, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.04);
            --glass-blur: 0px;
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: none;
            --shadow-md: none;
            --shadow-lg: none;
            --shadow-glow: none;
        }
        
        /* Minimal theme specific - remove all visual noise */
        [data-theme="coral"] .brand,
        [data-theme="coral"] .icon-btn,
        [data-theme="coral"] #side-panel,
        [data-theme="coral"] #info-panel,
        [data-theme="coral"] .modal-content,
        [data-theme="coral"] #theme-picker,
        [data-theme="coral"] #menu-dropdown {
            box-shadow: none !important;
            border: 1px solid #E0E0E0 !important;
        }
        
        [data-theme="coral"] .brand-logo {
            background: var(--accent) !important;
            box-shadow: none !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 3: EMBER - Warm Light
           Inspired by: Burnt orange to cream gradient on warm white
           ═══════════════════════════════════════════════════════════ */
        [data-theme="ember"] {
            --bg-deep: #FAF6F0;
            --bg-primary: #FDF9F4;
            --bg-secondary: #F5F0E8;
            --bg-tertiary: #EDE6DC;
            --bg-elevated: #E5DCD0;
            --text-primary: #2A2420;
            --text-secondary: #5A5048;
            --text-muted: #8A8078;
            --accent: #E87830;
            --accent-light: #F49848;
            --accent-glow: rgba(232, 120, 48, 0.3);
            --glass-bg: rgba(253, 249, 244, 0.95);
            --glass-border: rgba(42, 36, 32, 0.08);
            --nebula-1: rgba(232, 120, 48, 0.1);
            --nebula-2: rgba(244, 152, 72, 0.08);
            --nebula-3: rgba(255, 200, 100, 0.06);
            --shadow-sm: 0 2px 8px rgba(42, 36, 32, 0.06);
            --shadow-md: 0 4px 20px rgba(42, 36, 32, 0.08);
            --shadow-lg: 0 8px 40px rgba(42, 36, 32, 0.1);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 4: FROST - Glassmorphism Light
           Inspired by: Frosted glass panels, soft backgrounds
           ═══════════════════════════════════════════════════════════ */
        [data-theme="frost"] {
            --bg-deep: #E8ECF0;
            --bg-primary: #F0F4F8;
            --bg-secondary: #E4E8EC;
            --bg-tertiary: #D8DDE4;
            --bg-elevated: #CCD4DC;
            --text-primary: #1A2030;
            --text-secondary: #4A5568;
            --text-muted: #718096;
            --accent: #5B8DEF;
            --accent-light: #7DA8F5;
            --accent-glow: rgba(91, 141, 239, 0.3);
            --glass-bg: rgba(255, 255, 255, 0.6);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-blur: 24px;
            --nebula-1: rgba(91, 141, 239, 0.1);
            --nebula-2: rgba(125, 168, 245, 0.08);
            --nebula-3: rgba(200, 220, 255, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.08);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.1);
        }
        
        /* Frost theme glassmorphism enhancements */
        [data-theme="frost"] .brand,
        [data-theme="frost"] .icon-btn,
        [data-theme="frost"] #side-panel,
        [data-theme="frost"] #info-panel,
        [data-theme="frost"] .modal-content,
        [data-theme="frost"] #theme-picker,
        [data-theme="frost"] #menu-dropdown,
        [data-theme="frost"] .spotlight-container,
        [data-theme="frost"] #quick-capture {
            background: rgba(255, 255, 255, 0.55) !important;
            backdrop-filter: blur(24px) saturate(180%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(180%) !important;
            border: 1px solid rgba(255, 255, 255, 0.5) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 5: OBSIDIAN - Glassmorphism Dark
           Inspired by: Dark translucent panels, deep blue-gray
           ═══════════════════════════════════════════════════════════ */
        [data-theme="obsidian"] {
            --bg-deep: #1A1D24;
            --bg-primary: #20242C;
            --bg-secondary: #282D38;
            --bg-tertiary: #323844;
            --bg-elevated: #3C4452;
            --text-primary: #F0F2F5;
            --text-secondary: #A0A8B8;
            --text-muted: #687080;
            --accent: #EF8354;
            --accent-light: #F59B70;
            --accent-glow: rgba(239, 131, 84, 0.35);
            --glass-bg: rgba(32, 36, 44, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-blur: 24px;
            --nebula-1: rgba(239, 131, 84, 0.1);
            --nebula-2: rgba(79, 93, 117, 0.12);
            --nebula-3: rgba(191, 192, 192, 0.06);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.5);
        }
        
        /* Obsidian theme glassmorphism enhancements */
        [data-theme="obsidian"] .brand,
        [data-theme="obsidian"] .icon-btn,
        [data-theme="obsidian"] #side-panel,
        [data-theme="obsidian"] #info-panel,
        [data-theme="obsidian"] .modal-content,
        [data-theme="obsidian"] #theme-picker,
        [data-theme="obsidian"] #menu-dropdown,
        [data-theme="obsidian"] .spotlight-container,
        [data-theme="obsidian"] #quick-capture {
            background: rgba(32, 36, 44, 0.7) !important;
            backdrop-filter: blur(24px) saturate(150%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(150%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           BASE STYLES
           ═══════════════════════════════════════════════════════════ */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        
        html { 
            font-size: 16px; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body { 
            font-family: var(--font-body); 
            background: var(--bg-deep); 
            color: var(--text-primary); 
            overflow: hidden; 
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        button { font-family: inherit; cursor: pointer; border: none; background: none; color: inherit; }
        input, textarea { font-family: inherit; border: none; background: none; color: inherit; }
        
        /* Selection */
        ::selection { background: var(--accent); color: white; }

        /* ═══════════════════════════════════════════════════════════
           AMBIENT BACKGROUND - Living, Breathing Space
           ═══════════════════════════════════════════════════════════ */
        #ambient-bg {
            position: fixed;
            inset: 0;
            z-index: var(--z-bg);
            overflow: hidden;
            background: var(--bg-deep);
        }
        
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0;
            animation: nebulaFloat 20s ease-in-out infinite, nebulaFade 3s ease-out forwards;
        }
        
        .nebula-1 {
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--nebula-1) 0%, transparent 70%);
            top: -10%; left: 10%;
            animation-delay: 0s;
        }
        
        .nebula-2 {
            width: 500px; height: 500px;
            background: radial-gradient(circle, var(--nebula-2) 0%, transparent 70%);
            bottom: -5%; right: 5%;
            animation-delay: -7s;
        }
        
        .nebula-3 {
            width: 700px; height: 700px;
            background: radial-gradient(circle, var(--nebula-3) 0%, transparent 70%);
            top: 30%; left: 50%;
            transform: translateX(-50%);
            animation-delay: -14s;
        }
        
        @keyframes nebulaFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(30px, -20px) scale(1.05); }
            50% { transform: translate(-20px, 30px) scale(0.95); }
            75% { transform: translate(-30px, -10px) scale(1.02); }
        }
        
        @keyframes nebulaFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particle container - handled by Three.js */
        #particle-bg {
            position: fixed;
            inset: 0;
            z-index: calc(var(--z-bg) + 1);
            pointer-events: none;
        }

        /* ═══════════════════════════════════════════════════════════
           CANVAS & 3D SCENE
           ═══════════════════════════════════════════════════════════ */
        #canvas-container { 
            position: fixed; 
            inset: 0; 
            z-index: var(--z-canvas); 
            touch-action: none;
        }

        /* ═══════════════════════════════════════════════════════════
           FOCUS MODE - Spotlight Effect
           ═══════════════════════════════════════════════════════════ */
        #focus-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-overlay);
            background: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
            pointer-events: none;
            transition: all var(--duration-slow) var(--ease-smooth);
        }
        
        #focus-overlay.active {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
        }
        
        .focus-spotlight {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-normal);
        }

        /* ═══════════════════════════════════════════════════════════
           HEADER & BRANDING
           ═══════════════════════════════════════════════════════════ */
        #header { 
            position: fixed; 
            top: var(--space-5); 
            left: var(--space-5); 
            z-index: var(--z-ui);
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }
        
        .brand { 
            display: flex; 
            align-items: center; 
            gap: var(--space-3); 
            padding: var(--space-3) var(--space-4);
            background: var(--glass-bg); 
            backdrop-filter: blur(var(--glass-blur)); 
            border: 1px solid var(--glass-border);
            border-radius: 16px; 
            box-shadow: var(--shadow-md);
            transition: all var(--duration-fast);
        }
        
        .brand:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .brand-logo { 
            width: 40px; 
            height: 40px; 
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px; 
            display: grid; 
            place-items: center; 
            font-family: var(--font-display);
            font-weight: 700; 
            font-size: 18px; 
            color: white;
            box-shadow: var(--shadow-glow);
        }
        
        .brand-text h1 { 
            font-family: var(--font-display); 
            font-size: 18px; 
            font-weight: 700; 
            letter-spacing: 1px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .brand-text p { 
            font-family: var(--font-mono); 
            font-size: 9px; 
            color: var(--text-muted); 
            letter-spacing: 2px; 
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════
           TOP CONTROLS
           ═══════════════════════════════════════════════════════════ */
        #top-controls {
            position: fixed;
            top: var(--space-5);
            right: var(--space-5);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-2);
            align-items: center;
        }
        
        .icon-btn {
            width: 44px;
            height: 44px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }
        
        .icon-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .icon-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* ═══════════════════════════════════════════════════════════
           SPOTLIGHT SEARCH (Cmd+K)
           ═══════════════════════════════════════════════════════════ */
        #spotlight-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-spotlight);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: start center;
            padding-top: 15vh;
        }
        
        #spotlight-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast) var(--ease-out);
        }
        
        .spotlight-container {
            width: min(580px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-lg), 0 0 60px rgba(0, 0, 0, 0.3);
            animation: spotlightIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes spotlightIn {
            from { opacity: 0; transform: scale(0.95) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .spotlight-input-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-5);
            border-bottom: 1px solid var(--glass-border);
        }
        
        .spotlight-input-wrapper svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
            flex-shrink: 0;
        }
        
        #spotlight-input {
            flex: 1;
            font-size: 18px;
            font-weight: 500;
            background: transparent;
            outline: none;
        }
        
        #spotlight-input::placeholder {
            color: var(--text-muted);
        }
        
        .spotlight-hint {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        
        .spotlight-results {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .spotlight-section {
            padding: var(--space-2) var(--space-4);
        }
        
        .spotlight-section-title {
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: var(--space-2) 0;
        }
        
        .spotlight-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .spotlight-item:hover,
        .spotlight-item.selected {
            background: var(--bg-elevated);
        }
        
        .spotlight-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .spotlight-item-content {
            flex: 1;
            min-width: 0;
        }
        
        .spotlight-item-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .spotlight-item-subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .spotlight-item-shortcut {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-1);
        }
        
        .spotlight-item-shortcut kbd {
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }
        
        .spotlight-empty {
            padding: var(--space-8);
            text-align: center;
            color: var(--text-muted);
        }
        
        .spotlight-footer {
            padding: var(--space-3) var(--space-5);
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: var(--space-5);
            justify-content: center;
        }
        
        .spotlight-footer-hint {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .spotlight-footer-hint kbd {
            font-family: var(--font-mono);
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           QUICK CAPTURE BAR
           ═══════════════════════════════════════════════════════════ */
        #quick-capture {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
        }
        
        .quick-capture-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            transition: all var(--duration-fast);
        }
        
        .quick-capture-wrapper:focus-within {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #quick-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            font-size: 15px;
            background: transparent;
            outline: none;
        }
        
        #quick-input::placeholder {
            color: var(--text-muted);
        }
        
        .quick-btn {
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
        }
        
        .quick-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .quick-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .quick-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .quick-btn.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .quick-btn.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* ═══════════════════════════════════════════════════════════
           SIDE PANEL - Controls
           ═══════════════════════════════════════════════════════════ */
        #side-panel {
            position: fixed;
            top: 50%;
            right: var(--space-3);
            transform: translateY(-50%);
            z-index: var(--z-ui);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: var(--shadow-md);
        }
        
        .side-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-2) var(--space-3);
            border-radius: 10px;
            color: var(--text-secondary);
            transition: all var(--duration-fast);
            cursor: pointer;
        }
        
        .side-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .side-btn.active {
            background: var(--accent);
            color: white;
        }
        
        #btn-voice.active {
            animation: pulse-recording 1s ease-in-out infinite;
            background: var(--accent);
            color: white;
        }
        
        #btn-voice.recording {
            background: #fb923c;
            color: white;
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        #btn-voice.processing {
            background: #2dd4bf;
            color: white;
        }
        
        @keyframes pulse-recording {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 var(--accent-glow); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px 5px var(--accent-glow); }
        }
        
        @keyframes voicePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 131, 84, 0.5); }
            50% { box-shadow: 0 0 0 12px rgba(239, 131, 84, 0); }
        }
        
        /* Voice Indicator Modal */
        #voice-backdrop {
            position: fixed;
            inset: 0;
            z-index: 449;
            background: rgba(0,0,0,0.5);
            display: none;
        }
        #voice-backdrop.active { display: block; }
        
        #voice-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 450;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: var(--space-6);
            text-align: center;
            display: none;
            min-width: 280px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        #voice-indicator.active {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }
        
        .voice-icon {
            margin-bottom: var(--space-4);
            color: #fb923c;
        }
        .voice-icon.recording svg { animation: voiceIconPulse 1s ease-in-out infinite; }
        .voice-icon.processing { color: #2dd4bf; }
        @keyframes voiceIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .voice-status {
            font-family: var(--font-display);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .voice-transcript {
            font-size: 14px;
            color: var(--text-secondary);
            min-height: 40px;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-top: var(--space-3);
        }
        
        .voice-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: var(--space-3);
        }
        
        .voice-cancel {
            margin-top: var(--space-4);
            padding: var(--space-2) var(--space-4);
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .voice-cancel:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Voice mode toggle */
        .voice-mode-toggle {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: var(--space-4);
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 10px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        
        .voice-mode-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            background: transparent;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .voice-mode-btn:hover {
            color: var(--text-primary);
        }
        
        .voice-mode-btn.active {
            background: var(--accent);
            color: white;
        }
        
        /* Voice text input */
        .voice-text-input-wrapper {
            margin-top: var(--space-3);
        }
        
        #voice-text-input {
            width: 100%;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            resize: none;
            min-height: 80px;
        }
        
        #voice-text-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        #voice-text-input::placeholder {
            color: var(--text-muted);
        }
        
        .voice-text-submit {
            margin-top: 10px;
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            transition: all 0.2s;
        }
        
        .voice-text-submit:hover {
            filter: brightness(1.1);
        }
        
        .voice-text-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* API Key Modal */
        #api-key-modal {
            position: fixed;
            inset: 0;
            z-index: 10001;
            background: rgba(30,34,51,0.8);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        #api-key-modal.active { display: grid; }
        
        .api-key-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-6);
            width: min(400px, calc(100vw - 32px));
        }
        
        .api-key-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .api-key-desc {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            line-height: 1.5;
        }
        
        .api-key-status {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: var(--space-3);
            padding: var(--space-2);
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        .api-key-status.configured { color: #4ECDC4; }
        
        .api-key-input {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
        }
        .api-key-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .api-key-buttons {
            display: flex;
            gap: var(--space-3);
            justify-content: flex-end;
        }
        
        .api-key-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }
        .api-key-btn.primary {
            background: var(--accent);
            color: white;
        }
        .api-key-btn.secondary {
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
        }
        
        .side-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .side-btn-label {
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .side-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-1) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           INFO PANEL - Node Details
           ═══════════════════════════════════════════════════════════ */
        #info-panel {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: var(--space-2);
            opacity: 0;
            pointer-events: none;
            transition: all var(--duration-normal) var(--ease-out);
        }
        
        #info-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        
        .info-header {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-bottom: var(--space-1);
        }
        
        .info-color {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            position: relative;
            transition: transform var(--duration-fast);
        }
        
        .info-color:hover {
            transform: scale(1.05);
        }
        
        .info-color-picker {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 8px;
            display: none;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            z-index: 10;
            box-shadow: var(--shadow-lg);
        }
        
        .info-color-picker.active {
            display: grid;
        }
        
        .info-color-picker span {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform var(--duration-fast);
        }
        
        .info-color-picker span:hover {
            transform: scale(1.15);
        }
        
        .info-title-area {
            flex: 1;
            min-width: 0;
        }
        
        #info-title {
            font-family: var(--font-display);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 0;
            cursor: text;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            width: 100%;
            transition: all var(--duration-fast);
        }
        
        #info-title:hover {
            background: var(--bg-elevated);
        }
        
        #info-title:focus {
            background: var(--bg-elevated);
            border-color: var(--accent);
        }
        
        #info-meta {
            font-size: 10px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-2);
            padding-left: 6px;
        }
        
        .info-link {
            padding: 8px 12px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .info-link a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-secondary);
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .info-link a:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
        }
        
        .info-link img {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .info-link span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-close {
            width: 22px;
            height: 22px;
            border-radius: 6px;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-close:hover {
            background: var(--accent);
            color: white;
        }
        
        /* Expand Toggle Button */
        .info-expand-toggle {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-elevated);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-expand-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-expand-toggle .expand-icon {
            width: 16px;
            height: 16px;
            transition: transform 0.3s ease;
        }
        
        #info-panel.expanded .info-expand-toggle .expand-icon {
            transform: rotate(180deg);
        }
        
        /* Expanded Section */
        .info-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 0;
        }
        
        #info-panel.expanded .info-expanded {
            max-height: 400px;
            opacity: 1;
            padding: 12px 0;
            border-top: 1px solid var(--bg-tertiary);
            margin-top: 8px;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section-label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        #info-description {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            resize: none;
            transition: border-color 0.2s;
        }
        
        #info-description:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        #info-description::placeholder {
            color: var(--text-muted);
        }
        
        /* Path Breadcrumbs */
        .info-path {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .info-path-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 120px;
        }
        
        .info-path-item:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-path-item:hover .info-path-color {
            box-shadow: 0 0 0 2px rgba(255,255,255,0.5);
        }
        
        .info-path-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .info-path-name {
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-path-separator {
            color: var(--text-muted);
            font-size: 10px;
        }
        
        .info-path-current {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Link Card in Expanded View */
        .info-link-card {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-link-thumbnail {
            width: 80px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
            background: var(--bg-tertiary);
        }
        
        .info-link-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }
        
        .info-link-details a {
            display: flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 13px;
            transition: color 0.2s;
        }
        
        .info-link-details a:hover {
            color: var(--accent);
        }
        
        .info-link-favicon-small {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .info-link-meta {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        
        /* Transcript Section */
        #info-transcript-section .info-section-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .info-transcript-chars {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .info-transcript-wrapper {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-transcript-preview {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            max-height: 60px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        
        .info-transcript-toggle {
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .info-transcript-toggle:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-transcript-full {
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .info-transcript-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        /* Metadata Section */
        .info-metadata {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .info-meta-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .info-meta-label {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        
        .info-meta-value {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        #info-source {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            color: var(--text-tertiary);
        }
        
        #info-source:empty {
            display: none;
        }
        
        #info-source.ai {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }
        
        #info-source.link {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .info-slider {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-1) 0;
            margin-bottom: var(--space-2);
        }
        
        .info-slider-label {
            font-size: 10px;
            color: var(--text-muted);
            min-width: 55px;
        }
        
        .info-slider-wrapper {
            flex: 1;
            position: relative;
            height: 14px;
            display: flex;
            align-items: center;
        }
        
        .info-slider-wrapper::after {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--text-muted);
            pointer-events: none;
        }
        
        .info-slider input[type="range"] {
            flex: 1;
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.15s;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .info-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }
        
        .info-actions {
            display: flex;
            gap: var(--space-1);
            flex-wrap: nowrap;
        }
        
        .info-action {
            flex: 1;
            min-width: 60px;
            padding: 6px var(--space-2);
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all var(--duration-fast);
        }
        
        .info-action svg {
            width: 12px;
            height: 12px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .info-action.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .info-action.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .info-action.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-action.ai {
            background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
            color: white;
        }
        
        .info-action.ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.4);
        }
        
        .info-action.danger {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.danger:hover {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        /* ═══════════════════════════════════════════════════════════
           MODAL SYSTEM
           ═══════════════════════════════════════════════════════════ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-modal);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        
        .modal-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            width: min(480px, calc(100vw - 40px));
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: var(--space-7);
            box-shadow: var(--shadow-lg);
            animation: modalIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .modal-header {
            margin-bottom: var(--space-6);
        }
        
        .modal-title {
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .modal-subtitle {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .form-group {
            margin-bottom: var(--space-5);
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-2);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            font-size: 15px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        .form-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        .form-input::placeholder {
            color: var(--text-muted);
        }
        
        textarea.form-input {
            resize: vertical;
            min-height: 100px;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-2);
        }
        
        .color-swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--duration-fast);
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: white;
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.1);
        }
        
        .modal-actions {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-6);
        }
        
        .modal-btn {
            flex: 1;
            padding: var(--space-4);
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        .modal-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .modal-btn.cancel:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .modal-btn.submit {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .modal-btn.submit:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        /* ═══════════════════════════════════════════════════════════
           NEURAL NETWORK PANEL
           ═══════════════════════════════════════════════════════════ */
        #neural-panel {
            position: fixed;
            bottom: 100px;
            right: var(--space-4);
            width: 320px;
            max-height: 60vh;
            background: var(--bg-secondary);
            backdrop-filter: blur(24px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-modal);
            padding: var(--space-5);
            z-index: var(--z-modal);
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: all var(--duration-normal) var(--ease-out);
            overflow-y: auto;
        }
        
        #neural-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        .neural-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
        }
        
        .neural-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .neural-title svg {
            width: 20px;
            height: 20px;
            stroke: var(--accent);
        }
        
        .neural-close {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-close:hover {
            background: var(--accent);
            color: white;
        }
        
        .neural-close svg {
            width: 14px;
            height: 14px;
        }
        
        .neural-status {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: var(--space-4);
            margin-bottom: var(--space-4);
        }
        
        .neural-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }
        
        .neural-status-row:last-child {
            margin-bottom: 0;
        }
        
        .neural-status-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .neural-status-value.ready {
            color: #22c55e;
        }
        
        .neural-status-value.training {
            color: var(--accent);
        }
        
        .neural-progress {
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            overflow: hidden;
            margin-top: var(--space-3);
        }
        
        .neural-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .neural-categories {
            margin-bottom: var(--space-4);
        }
        
        .neural-categories-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-2);
        }
        
        .neural-category-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
        }
        
        .neural-category-tag {
            padding: var(--space-1) var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .neural-actions {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }
        
        .neural-btn {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
            cursor: pointer;
        }
        
        .neural-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .neural-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .neural-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .neural-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .neural-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .neural-btn.secondary:hover {
            background: var(--bg-elevated);
        }
        
        .neural-suggestions {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--glass-border);
        }
        
        .neural-suggestions-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-3);
        }
        
        .neural-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-suggestion:hover {
            background: var(--bg-elevated);
            transform: translateX(4px);
        }
        
        .neural-suggestion-text {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .neural-suggestion-score {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
            padding: 2px 8px;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            #neural-panel {
                left: var(--space-4);
                right: var(--space-4);
                width: auto;
                bottom: calc(var(--space-4) + 80px);
            }
        }

        /* ═══════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════ */
        #toast-container {
            position: fixed;
            top: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            pointer-events: none;
        }
        
        .toast {
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: var(--space-3);
            box-shadow: var(--shadow-lg);
            animation: toastIn var(--duration-normal) var(--ease-spring);
            pointer-events: auto;
        }
        
        .toast.success {
            border-left: 4px solid var(--green);
        }
        
        .toast.error {
            border-left: 4px solid #ef4444;
        }
        
        .toast.info {
            border-left: 4px solid var(--accent);
        }
        
        .toast.exiting {
            animation: toastOut var(--duration-normal) var(--ease-out) forwards;
        }
        
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes toastOut {
            to { opacity: 0; transform: translateY(-20px) scale(0.95); }
        }

        /* ═══════════════════════════════════════════════════════════
           CELEBRATION PARTICLES
           ═══════════════════════════════════════════════════════════ */
        .celebration-particle {
            position: fixed;
            pointer-events: none;
            z-index: var(--z-toast);
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════
           DEPTH INDICATOR
           ═══════════════════════════════════════════════════════════ */
        #depth-indicator {
            position: fixed;
            top: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: none;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            box-shadow: var(--shadow-md);
        }
        
        #depth-indicator.active {
            display: flex;
        }
        
        .depth-back {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .depth-back:hover {
            background: var(--accent);
            color: white;
        }
        
        .depth-back svg {
            width: 14px;
            height: 14px;
        }
        
        .depth-path {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .depth-item {
            color: var(--text-secondary);
        }
        
        .depth-item.current {
            color: var(--accent);
            font-weight: 600;
        }

        /* ═══════════════════════════════════════════════════════════
           RADIAL MENU
           ═══════════════════════════════════════════════════════════ */
        #radial-menu {
            position: fixed;
            z-index: var(--z-overlay);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-fast);
        }
        
        #radial-menu.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-toggle {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 2px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: all var(--duration-fast);
        }
        
        .radial-toggle:hover,
        .radial-toggle.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .radial-toggle svg {
            width: 14px;
            height: 14px;
        }
        
        .radial-item {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: all var(--duration-fast);
        }
        
        .radial-item.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-item:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        .radial-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* ═══════════════════════════════════════════════════════════
           ONBOARDING
           ═══════════════════════════════════════════════════════════ */
        #onboarding-overlay {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slower);
        }
        
        #onboarding-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .onboarding-content {
            text-align: center;
            max-width: 500px;
            padding: var(--space-6);
        }
        
        .onboarding-logo {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 42px;
            font-weight: 700;
            color: white;
            margin: 0 auto var(--space-7);
            box-shadow: var(--shadow-glow);
            animation: logoPulse 2s ease-in-out infinite;
        }
        
        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .onboarding-title {
            font-family: var(--font-display);
            font-size: 36px;
            font-weight: 700;
            margin-bottom: var(--space-3);
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .onboarding-subtitle {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: var(--space-8);
            line-height: 1.6;
        }
        
        .onboarding-input-wrapper {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-6);
        }
        
        #onboarding-name {
            flex: 1;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        #onboarding-name:focus {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #onboarding-start {
            padding: var(--space-4) var(--space-6);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        #onboarding-start:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color var(--duration-fast);
        }
        
        .onboarding-skip:hover {
            color: var(--text-secondary);
        }
        
        /* Choice Buttons */
        .onboarding-choices {
            display: flex;
            gap: var(--space-4);
            margin-top: var(--space-6);
            margin-bottom: var(--space-4);
        }
        
        .onboarding-choice {
            flex: 1;
            padding: var(--space-5);
            background: var(--bg-secondary);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            cursor: pointer;
            transition: all var(--duration-fast);
            text-align: center;
        }
        
        .onboarding-choice:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-choice-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto var(--space-3);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .onboarding-choice-icon svg {
            width: 24px;
            height: 24px;
            stroke: white;
            fill: white;
            stroke-width: 2;
        }
        
        .onboarding-choice.ai .onboarding-choice-icon svg {
            stroke: none;
            fill: white;
        }
        
        .onboarding-choice.scratch .onboarding-choice-icon {
            background: linear-gradient(135deg, var(--text-secondary) 0%, var(--text-muted) 100%);
        }
        
        .onboarding-choice-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-2);
        }
        
        .onboarding-choice-desc {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        @media (max-width: 500px) {
            .onboarding-choices {
                flex-direction: column;
            }
        }
        
        /* Questionnaire Styles */
        .onboarding-questionnaire {
            display: none;
            text-align: left;
            max-width: 560px;
            width: 100%;
            padding: var(--space-6);
        }
        
        .onboarding-questionnaire.active {
            display: block;
        }
        
        .question-header {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }
        
        .question-logo {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        
        .question-progress {
            flex: 1;
        }
        
        .question-step {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }
        
        .question-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .question-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 2px;
            transition: width 0.4s ease;
        }
        
        .question-text {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.4;
            margin-bottom: var(--space-6);
        }
        
        .question-input {
            width: 100%;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            color: var(--text-primary);
            outline: none;
            transition: all var(--duration-fast);
            resize: none;
            min-height: 100px;
            font-family: inherit;
            line-height: 1.5;
        }
        
        .question-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(239, 131, 84, 0.15);
        }
        
        .question-input::placeholder {
            color: var(--text-muted);
        }
        
        .question-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-5);
        }
        
        .question-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-2) var(--space-3);
            border-radius: 8px;
            transition: all var(--duration-fast);
        }
        
        .question-skip:hover {
            color: var(--text-secondary);
            background: var(--bg-tertiary);
        }
        
        .question-nav {
            display: flex;
            gap: var(--space-3);
        }
        
        .question-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .question-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .question-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .question-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .question-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .question-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Processing state */
        .onboarding-processing {
            display: none;
            text-align: center;
            max-width: 400px;
            padding: var(--space-6);
        }
        
        .onboarding-processing.active {
            display: block;
        }
        
        .processing-spinner {
            width: 64px;
            height: 64px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto var(--space-6);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }
        
        .processing-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-3);
        }
        
        .processing-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           KEYBOARD HINTS
           ═══════════════════════════════════════════════════════════ */
        #keyboard-hints {
            position: fixed;
            bottom: calc(var(--space-5) + 70px + 80px);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-4);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--duration-fast);
        }
        
        #keyboard-hints.visible {
            opacity: 1;
        }
        
        .key-hint {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .key-hint kbd {
            font-family: var(--font-mono);
            font-size: 11px;
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           LOADING STATE
           ═══════════════════════════════════════════════════════════ */
        #loading {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: var(--bg-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slow);
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            text-align: center;
        }
        
        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--glass-border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-4);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loader-text {
            font-family: var(--font-display);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           THEME PICKER
           ═══════════════════════════════════════════════════════════ */
        #theme-picker {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-3);
            display: none;
            flex-direction: column;
            gap: var(--space-2);
            box-shadow: var(--shadow-lg);
        }
        
        #theme-picker.active {
            display: flex;
            animation: fadeIn var(--duration-fast);
        }
        
        .theme-option {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .theme-option:hover {
            background: var(--bg-elevated);
        }
        
        .theme-option.active {
            background: var(--accent);
            color: white;
        }
        
        .theme-preview {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            overflow: hidden;
        }
        
        .theme-preview span {
            flex: 1;
        }
        
        .theme-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* ═══════════════════════════════════════════════════════════
           MENU DROPDOWN
           ═══════════════════════════════════════════════════════════ */
        #menu-dropdown {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-2);
            min-width: 180px;
            display: none;
            box-shadow: var(--shadow-lg);
        }
        
        #menu-dropdown.active {
            display: block;
            animation: fadeIn var(--duration-fast);
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .menu-item:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .menu-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .menu-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-2) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           RESPONSIVE DESIGN
           ═══════════════════════════════════════════════════════════ */
        @media (max-width: 768px) {
            :root {
                --space-5: 16px;
                --space-6: 20px;
            }
            
            #header {
                top: var(--space-4);
                left: var(--space-4);
            }
            
            .brand {
                padding: var(--space-2) var(--space-3);
            }
            
            .brand-logo {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .brand-text h1 {
                font-size: 16px;
            }
            
            #top-controls {
                top: var(--space-4);
                right: var(--space-4);
            }
            
            /* Hide quick capture on mobile */
            #quick-capture {
                display: none !important;
            }
            
            /* Toolbar at bottom on mobile */
            #side-panel {
                top: auto;
                bottom: var(--space-4);
                right: 50%;
                transform: translateX(50%);
                flex-direction: row;
                padding: var(--space-2) var(--space-3);
                gap: var(--space-1);
            }
            
            #side-panel .side-btn {
                padding: var(--space-2);
            }
            
            .side-btn-label {
                display: none;
            }
            
            #info-panel {
                bottom: calc(var(--space-4) + 70px);
                width: calc(100vw - 32px);
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }
            
            #keyboard-hints {
                display: none !important;
            }
        }
        
        /* Link Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .link-modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        .link-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .link-modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }
        
        .link-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-tertiary);
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .link-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-input-group {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .link-input-group label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .link-input-group input {
            flex: 1;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .link-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .link-fetch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .link-fetch-btn:hover {
            filter: brightness(1.1);
        }
        
        .link-preview {
            padding: 0 20px 20px;
        }
        
        .link-preview-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 24px;
            color: var(--text-tertiary);
            font-size: 13px;
        }
        
        .link-preview-content {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .link-preview-image {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--bg-tertiary);
            flex-shrink: 0;
        }
        
        .link-preview-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }
        
        .link-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border: none;
            background: transparent;
            padding: 0;
            width: 100%;
        }
        
        .link-preview-title:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-description {
            font-size: 12px;
            color: var(--text-secondary);
            border: none;
            background: transparent;
            padding: 0;
            resize: none;
            font-family: inherit;
        }
        
        .link-preview-description:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-source {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .link-preview-source img {
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        
        .link-transcript-status {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-transcript-status .spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .link-category {
            padding: 0 20px 20px;
        }
        
        .link-category label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
        }
        
        .link-category-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 2px solid var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .link-category-suggestion:hover {
            background: var(--bg-tertiary);
        }
        
        .link-category-suggestion.selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        .link-category-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .link-category-confidence {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .link-category-alt {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .link-category-alt-item {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .link-category-alt-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-category-alt-item.selected {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .link-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        
        .link-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .link-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .link-btn.primary {
            background: var(--accent);
            color: white;
        }
        
        .link-btn.primary:hover:not(:disabled) {
            filter: brightness(1.1);
        }
        
        .link-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Link indicator on nodes */
        .node-link-indicator {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .node-link-indicator svg {
            width: 10px;
            height: 10px;
            stroke: white;
        }
    </style>
</head>
<body>
    <!-- Ambient Background -->
    <div id="ambient-bg">
        <div class="nebula nebula-1"></div>
        <div class="nebula nebula-2"></div>
        <div class="nebula nebula-3"></div>
    </div>
    <div id="particle-bg"></div>
    
    <!-- 3D Canvas -->
    <div id="canvas-container" role="application" aria-label="3D mind map visualization - use mouse to rotate, scroll to zoom"></div>
    
    <!-- Focus Mode Overlay -->
    <div id="focus-overlay"></div>
    
    <!-- Loading -->
    <div id="loading">
        <div class="loader">
            <div class="loader-spinner"></div>
            <div class="loader-text">Loading your mind...</div>
        </div>
    </div>
    
    <!-- Onboarding -->
    <div id="onboarding-overlay" style="display: flex;">
        <!-- Welcome Screen -->
        <div class="onboarding-content" id="onboarding-welcome">
            <div class="onboarding-logo">M</div>
            <h1 class="onboarding-title">Welcome to MYND</h1>
            <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
            <div class="onboarding-input-wrapper">
                <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
            </div>
            <div class="onboarding-choices">
                <div class="onboarding-choice ai" id="onboarding-ai">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                    </div>
                    <div class="onboarding-choice-title">AI-Assisted Setup</div>
                    <div class="onboarding-choice-desc">Answer a few questions and let AI build your personalized mind map</div>
                </div>
                <div class="onboarding-choice scratch" id="onboarding-scratch">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    </div>
                    <div class="onboarding-choice-title">Start from Scratch</div>
                    <div class="onboarding-choice-desc">Begin with a simple template and build your own structure</div>
                </div>
            </div>
        </div>
        
        <!-- Questionnaire -->
        <div class="onboarding-questionnaire" id="onboarding-questionnaire">
            <div class="question-header">
                <div class="question-logo">M</div>
                <div class="question-progress">
                    <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                    <div class="question-progress-bar">
                        <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                    </div>
                </div>
            </div>
            <div class="question-text" id="question-text">What's one goal you want to make real progress on in the next 30 days?</div>
            <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
            <div class="question-actions">
                <span class="question-skip" id="question-skip-btn">Skip this question</span>
                <div class="question-nav">
                    <button class="question-btn secondary" id="question-back" style="display: none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                        Back
                    </button>
                    <button class="question-btn primary" id="question-next">
                        Next
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Processing -->
        <div class="onboarding-processing" id="onboarding-processing">
            <div class="processing-spinner"></div>
            <div class="processing-title">Building your mind map...</div>
            <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
        </div>
    </div>
    
    <!-- Header -->
    <div id="header">
        <div class="brand">
            <div class="brand-logo">M</div>
            <div class="brand-text">
                <h1>MYND</h1>
                <p>Mind Architect</p>
            </div>
        </div>
    </div>
    
    <!-- Top Controls -->
    <div id="top-controls">
        <button class="icon-btn" id="theme-btn" title="Theme" aria-label="Change color theme">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/></svg>
        </button>
        <button class="icon-btn" id="menu-btn" title="Menu" aria-label="Open menu">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
        <button class="icon-btn" id="undo-btn" title="Undo" aria-label="Undo last action" disabled>
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
        </button>
    </div>
    
    <!-- Theme Picker -->
    <div id="theme-picker">
        <div class="theme-option" data-theme="sandstone">
            <div class="theme-preview"><span style="background:#C4978A"></span><span style="background:#F9F7F0"></span></div>
            <span class="theme-name">Sandstone</span>
        </div>
        <div class="theme-option active" data-theme="coral">
            <div class="theme-preview"><span style="background:#E87D7D"></span><span style="background:#FFFFFF"></span></div>
            <span class="theme-name">Coral</span>
        </div>
        <div class="theme-option" data-theme="ember">
            <div class="theme-preview"><span style="background:#E87830"></span><span style="background:#FAF6F0"></span></div>
            <span class="theme-name">Ember</span>
        </div>
        <div class="theme-option" data-theme="frost">
            <div class="theme-preview"><span style="background:#5B8DEF"></span><span style="background:#E8ECF0"></span></div>
            <span class="theme-name">Frost</span>
        </div>
        <div class="theme-option" data-theme="obsidian">
            <div class="theme-preview"><span style="background:#EF8354"></span><span style="background:#1A1D24"></span></div>
            <span class="theme-name">Obsidian</span>
        </div>
    </div>
    
    <!-- Menu Dropdown -->
    <div id="menu-dropdown">
        <div class="menu-item" id="menu-search">
            <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
            Search
        </div>
        <div class="menu-item" id="menu-shortcuts">
            <svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h8M6 16h.01M10 16h.01M14 16h.01M18 16h.01"/></svg>
            Shortcuts
        </div>
        <div class="menu-item" id="menu-voice-settings">
            <svg viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            Voice AI Settings
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-new">
            <svg viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>
            New Map
        </div>
        <div class="menu-item" id="menu-save">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Save Map
        </div>
        <div class="menu-item" id="menu-load">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
            Load Map
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-help">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
            Help
        </div>
    </div>
    
    <!-- Depth Indicator -->
    <div id="depth-indicator">
        <div class="depth-back" id="depth-back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
        </div>
        <div class="depth-path" id="depth-path"></div>
    </div>
    
    <!-- Side Panel -->
    <div id="side-panel" role="toolbar" aria-label="Mind map controls">
        <div class="side-btn" id="btn-home" title="Reset View" role="button" aria-label="Reset camera to home view">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
            <span class="side-btn-label">Home</span>
        </div>
        <div class="side-btn" id="btn-expand" title="Expand All" role="button" aria-label="Expand all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
            <span class="side-btn-label">Expand</span>
        </div>
        <div class="side-btn" id="btn-collapse" title="Collapse All" role="button" aria-label="Collapse all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"/></svg>
            <span class="side-btn-label">Collapse</span>
        </div>
        <div class="side-divider" role="separator"></div>
        <div class="side-btn" id="btn-add" title="Add Node" role="button" aria-label="Add new node">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            <span class="side-btn-label">Add</span>
        </div>
        <div class="side-btn" id="btn-move" title="Move Mode" role="button" aria-label="Toggle move mode for dragging nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
            <span class="side-btn-label">Move</span>
        </div>
        <div class="side-btn" id="btn-voice" title="Voice AI - Click to speak" role="button" aria-label="Start voice AI assistant">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="4" y1="8" x2="4" y2="16"/><line x1="8" y1="5" x2="8" y2="19"/><line x1="12" y1="3" x2="12" y2="21"/><line x1="16" y1="5" x2="16" y2="19"/><line x1="20" y1="8" x2="20" y2="16"/></svg>
            <span class="side-btn-label">AI</span>
        </div>
        <div class="side-btn" id="btn-neural" title="Personal Neural Network" role="button" aria-label="Open neural network panel">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="12" rx="10" ry="4"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60 12 12)"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120 12 12)"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>
            <span class="side-btn-label">Neural</span>
        </div>
        <div class="side-btn active" id="btn-autocam" title="Toggle Auto Camera" role="button" aria-label="Toggle automatic camera movement" aria-pressed="true">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>
            <span class="side-btn-label">Auto Cam</span>
        </div>
    </div>
    
    <!-- Voice AI Indicator -->
    <div id="voice-backdrop"></div>
    <div id="voice-indicator">
        <div class="voice-mode-toggle">
            <button class="voice-mode-btn active" id="voice-mode-speak" title="Speak">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
            </button>
            <button class="voice-mode-btn" id="voice-mode-type" title="Type">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="6" y1="12" x2="18" y2="12"/><line x1="6" y1="16" x2="18" y2="16"/></svg>
            </button>
        </div>
        <div class="voice-icon" id="voice-icon">
            <svg id="voice-icon-mic" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            <svg id="voice-icon-brain" style="display:none" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4h.09c.49 0 .97-.07 1.41-.2"/><path d="M12 2a4 4 0 0 1 4 4c0 .74-.2 1.43-.56 2.02A4 4 0 0 1 18 12c0 1.2-.52 2.27-1.35 3A4 4 0 0 1 18 18a4 4 0 0 1-4 4h-.09c-.49 0-.97-.07-1.41-.2"/><path d="M12 2v20"/><path d="M9 10h6"/><path d="M9 14h6"/></svg>
        </div>
        <div class="voice-status" id="voice-status">Listening...</div>
        <div class="voice-transcript" id="voice-transcript">Say something...</div>
        <div class="voice-text-input-wrapper" id="voice-text-wrapper" style="display: none;">
            <textarea id="voice-text-input" placeholder="Describe what you want to add or ask..." rows="3"></textarea>
            <button class="voice-text-submit" id="voice-text-submit">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                Send to AI
            </button>
        </div>
        <div class="voice-hint" id="voice-hint">Tap anywhere or press Escape to cancel</div>
        <button class="voice-cancel" id="voice-cancel">Cancel</button>
    </div>
    
    <!-- API Key Modal -->
    <div id="api-key-modal">
        <div class="api-key-content">
            <div class="api-key-title">Voice AI Settings</div>
            <div class="api-key-desc">Enter your Anthropic API key to enable voice-powered node creation. Your key is stored locally and never sent anywhere except Anthropic's API.</div>
            <div class="api-key-status" id="api-key-status">No API key configured</div>
            <input type="password" class="api-key-input" id="api-key-input" placeholder="sk-ant-api03-...">
            <div class="api-key-buttons">
                <button class="api-key-btn secondary" id="api-key-cancel">Cancel</button>
                <button class="api-key-btn primary" id="api-key-save">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Quick Capture -->
    <div id="quick-capture">
        <div class="quick-capture-wrapper">
            <input type="text" id="quick-input" placeholder="What's on your mind? Press Enter to add..." autocomplete="off">
            <button class="quick-btn secondary" id="quick-link" title="Add Link" aria-label="Add link from URL">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
            </button>
            <button class="quick-btn secondary" id="quick-ai" title="AI Suggest">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a4 4 0 0 1 4 4v1a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/><path d="M16 15a4 4 0 0 1 4 4v2H4v-2a4 4 0 0 1 4-4h8z"/><circle cx="12" cy="10" r="2"/></svg>
            </button>
            <button class="quick-btn primary" id="quick-add">
                Add
            </button>
        </div>
    </div>
    
    <!-- Link Modal -->
    <div id="link-modal" class="modal-overlay">
        <div class="link-modal-content">
            <div class="link-modal-header">
                <h3>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                    Add Link
                </h3>
                <button class="link-modal-close" id="link-modal-close" aria-label="Close">×</button>
            </div>
            
            <div class="link-input-group">
                <label for="link-url">Paste URL</label>
                <input type="url" id="link-url" placeholder="https://..." autocomplete="off">
                <button class="link-fetch-btn" id="link-fetch">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M21 12a9 9 0 1 1-9-9"/><polyline points="21 3 21 9 15 9"/></svg>
                    Fetch
                </button>
            </div>
            
            <div class="link-preview" id="link-preview" style="display:none;">
                <div class="link-preview-loading" id="link-preview-loading">
                    <div class="loading-spinner"></div>
                    Fetching link info...
                </div>
                <div class="link-preview-content" id="link-preview-content" style="display:none;">
                    <img class="link-preview-image" id="link-preview-image" alt="">
                    <div class="link-preview-info">
                        <input type="text" class="link-preview-title" id="link-preview-title" placeholder="Title">
                        <textarea class="link-preview-description" id="link-preview-description" placeholder="Description (optional)" rows="2"></textarea>
                        <div class="link-preview-source" id="link-preview-source"></div>
                        <div class="link-transcript-status" id="link-transcript-status" style="display:none;"></div>
                    </div>
                </div>
            </div>
            
            <div class="link-category" id="link-category" style="display:none;">
                <label>AI Suggested Placement</label>
                <div class="link-category-suggestion" id="link-category-suggestion">
                    <span class="link-category-name" id="link-category-name">Loading...</span>
                    <span class="link-category-confidence" id="link-category-confidence"></span>
                </div>
                <div class="link-category-alt" id="link-category-alt"></div>
            </div>
            
            <div class="link-modal-actions">
                <button class="link-btn secondary" id="link-cancel">Cancel</button>
                <button class="link-btn primary" id="link-add" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    Add to Map
                </button>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div class="info-header">
            <div class="info-color" id="info-color">
                <div class="info-color-picker" id="info-color-picker"></div>
            </div>
            <div class="info-title-area">
                <input type="text" id="info-title" value="Node Title" />
                <div id="info-meta">
                    <span id="info-children">0 children</span>
                    <span id="info-source"></span>
                </div>
            </div>
            <button class="info-expand-toggle" id="info-expand-toggle" aria-label="Expand panel">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="expand-icon"><polyline points="6 15 12 9 18 15"/></svg>
            </button>
            <div class="info-close" id="info-close">
                <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </div>
        </div>
        
        <!-- Expanded Section -->
        <div class="info-expanded" id="info-expanded">
            <!-- Description -->
            <div class="info-section">
                <label class="info-section-label">Description</label>
                <textarea id="info-description" placeholder="Add a description..." rows="2"></textarea>
            </div>
            
            <!-- Path to Node -->
            <div class="info-section" id="info-path-section">
                <label class="info-section-label">Path</label>
                <div class="info-path" id="info-path"></div>
            </div>
            
            <!-- Link Info (if this node has a link) -->
            <div class="info-section" id="info-link-section" style="display: none;">
                <label class="info-section-label">Linked Content</label>
                <div class="info-link-card" id="info-link-card">
                    <img class="info-link-thumbnail" id="info-link-thumbnail" alt="" style="display: none;">
                    <div class="info-link-details">
                        <a href="#" id="info-link-full-url" target="_blank" rel="noopener noreferrer">
                            <img class="info-link-favicon-small" id="info-link-favicon-small" src="" alt="">
                            <span id="info-link-full-domain"></span>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;flex-shrink:0;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
                        </a>
                        <div class="info-link-meta" id="info-link-meta"></div>
                    </div>
                </div>
            </div>
            
            <!-- Transcript Section (if this node has a transcript) -->
            <div class="info-section" id="info-transcript-section" style="display: none;">
                <label class="info-section-label">
                    <span>📝 Transcript</span>
                    <span class="info-transcript-chars" id="info-transcript-chars"></span>
                </label>
                <div class="info-transcript-wrapper">
                    <div class="info-transcript-preview" id="info-transcript-preview"></div>
                    <button class="info-transcript-toggle" id="info-transcript-toggle">Show full transcript</button>
                </div>
                <div class="info-transcript-full" id="info-transcript-full" style="display: none;">
                    <div class="info-transcript-text" id="info-transcript-text"></div>
                </div>
            </div>
            
            <!-- Node Metadata -->
            <div class="info-section info-metadata">
                <div class="info-meta-item" id="info-created-section" style="display: none;">
                    <span class="info-meta-label">Created</span>
                    <span class="info-meta-value" id="info-created"></span>
                </div>
                <div class="info-meta-item" id="info-added-by-section">
                    <span class="info-meta-label">Added by</span>
                    <span class="info-meta-value" id="info-added-by">You</span>
                </div>
            </div>
        </div>
        
        <div class="info-link" id="info-link" style="display: none;">
            <a href="#" id="info-link-url" target="_blank" rel="noopener noreferrer">
                <img id="info-link-favicon" src="" alt="">
                <span id="info-link-domain"></span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
            </a>
        </div>
        <div class="info-slider">
            <span class="info-slider-label">Importance</span>
            <div class="info-slider-wrapper">
                <input type="range" id="info-importance" min="0.5" max="2" step="0.1" value="1" />
            </div>
        </div>
        <div class="info-actions" role="group" aria-label="Node actions">
            <button class="info-action danger" id="action-delete" aria-label="Delete this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                Delete
            </button>
            <button class="info-action secondary" id="action-dive" aria-label="Dive into this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
                Dive
            </button>
            <button class="info-action secondary" id="action-organize" aria-label="Organize children by type" style="display: none;">
                <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
                Organize
            </button>
            <button class="info-action ai" id="action-brainstorm" aria-label="AI brainstorm ideas for this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
                Brainstorm
            </button>
            <button class="info-action primary" id="action-add" aria-label="Add a child node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                Add Child
            </button>
        </div>
    </div>
    
    <!-- Keyboard Hints -->
    <div id="keyboard-hints">
        <div class="key-hint"><kbd>⌘K</kbd> Search</div>
        <div class="key-hint"><kbd>Tab</kbd> Add child</div>
        <div class="key-hint"><kbd>Enter</kbd> Add sibling</div>
        <div class="key-hint"><kbd>Space</kbd> Expand</div>
        <div class="key-hint"><kbd>?</kbd> Help</div>
    </div>
    
    <!-- Spotlight Search -->
    <div id="spotlight-overlay">
        <div class="spotlight-container">
            <div class="spotlight-input-wrapper">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                <input type="text" id="spotlight-input" placeholder="Search nodes, commands, or type to create..." autocomplete="off">
                <span class="spotlight-hint">esc</span>
            </div>
            <div class="spotlight-results" id="spotlight-results">
                <div class="spotlight-section">
                    <div class="spotlight-section-title">Quick Actions</div>
                    <div class="spotlight-item" data-action="new-node">
                        <div class="spotlight-item-icon" style="background: var(--accent);">+</div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">Create New Node</div>
                            <div class="spotlight-item-subtitle">Add a new thought to your map</div>
                        </div>
                        <div class="spotlight-item-shortcut"><kbd>Tab</kbd></div>
                    </div>
                    <div class="spotlight-item" data-action="brainstorm">
                        <div class="spotlight-item-icon" style="background: linear-gradient(135deg, var(--purple), var(--pink));">✨</div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">AI Brainstorm</div>
                            <div class="spotlight-item-subtitle">Generate ideas for selected node</div>
                        </div>
                    </div>
                </div>
                <div class="spotlight-section" id="spotlight-nodes-section">
                    <div class="spotlight-section-title">Nodes</div>
                    <div id="spotlight-nodes-list"></div>
                </div>
            </div>
            <div class="spotlight-footer">
                <div class="spotlight-footer-hint"><kbd>↑↓</kbd> Navigate</div>
                <div class="spotlight-footer-hint"><kbd>↵</kbd> Select</div>
                <div class="spotlight-footer-hint"><kbd>esc</kbd> Close</div>
            </div>
        </div>
    </div>
    
    <!-- Radial Menu -->
    <div id="radial-menu">
        <div class="radial-toggle">
            <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="12" cy="5" r="2"/><circle cx="12" cy="19" r="2"/></svg>
        </div>
        <div class="radial-item" data-action="add" title="Add Child">
            <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        </div>
        <div class="radial-item" data-action="edit" title="Edit">
            <svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
        </div>
        <div class="radial-item" data-action="dive" title="Dive In">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
        </div>
        <div class="radial-item" data-action="brainstorm" title="AI Brainstorm">
            <svg viewBox="0 0 24 24"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
        </div>
        <div class="radial-item" data-action="delete" title="Delete">
            <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </div>
    </div>
    
    <!-- Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modal-title">Add Node</h2>
                <p class="modal-subtitle" id="modal-subtitle">Create a new thought</p>
            </div>
            <div class="form-group">
                <label class="form-label">Name</label>
                <input type="text" class="form-input" id="input-name" placeholder="What's this thought about?">
            </div>
            <div class="form-group">
                <label class="form-label">Description (optional)</label>
                <textarea class="form-input" id="input-desc" placeholder="Add more details..."></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Color</label>
                <div class="color-grid" id="color-grid"></div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn cancel" id="modal-cancel">Cancel</button>
                <button class="modal-btn submit" id="modal-submit">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div id="toast-container"></div>
    
    <!-- Neural Network Panel -->
    <div id="neural-panel">
        <div class="neural-header">
            <div class="neural-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4c.74 0 1.43-.2 2-.56A4 4 0 0 0 16 22a4 4 0 0 0 4-4c0-1.2-.52-2.27-1.35-3A4 4 0 0 0 20 12a4 4 0 0 0-2.56-3.98c.36-.59.56-1.28.56-2.02a4 4 0 0 0-4-4"/>
                    <circle cx="12" cy="12" r="2"/>
                </svg>
                Your Neural Net
            </div>
            <div class="neural-close" id="neural-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </div>
        </div>
        
        <div class="neural-status">
            <div class="neural-status-row">
                <span>Status</span>
                <span class="neural-status-value" id="neural-status-text">Initializing...</span>
            </div>
            <div class="neural-status-row">
                <span>Learned Categories</span>
                <span class="neural-status-value" id="neural-category-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Expansion Patterns</span>
                <span class="neural-status-value" id="neural-pattern-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Cached Embeddings</span>
                <span class="neural-status-value" id="neural-embedding-count">0</span>
            </div>
            <div class="neural-progress" id="neural-progress" style="display: none;">
                <div class="neural-progress-bar" id="neural-progress-bar"></div>
            </div>
        </div>
        
        <div class="neural-categories" id="neural-categories" style="display: none;">
            <div class="neural-categories-title">Learned Categories</div>
            <div class="neural-category-list" id="neural-category-list"></div>
        </div>
        
        <div class="neural-actions">
            <button class="neural-btn primary" id="neural-train-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                </svg>
                Train on My Mind Map
            </button>
            <button class="neural-btn primary" id="neural-smart-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                </svg>
                Smart Expand Selected
            </button>
            <button class="neural-btn secondary" id="neural-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><circle cx="12" cy="17" r="0.5"/>
                </svg>
                Find Related Nodes
            </button>
            <button class="neural-btn secondary" id="neural-reset-btn">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>
                </svg>
                Reset Neural Network
            </button>
        </div>
        
        <div class="neural-suggestions" id="neural-suggestions" style="display: none;">
            <div class="neural-suggestions-title">AI Suggestions</div>
            <div id="neural-suggestions-list"></div>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <!-- TensorFlow.js and Universal Sentence Encoder -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>
    
    <script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ═══════════════════════════════════════════════════════════════════
    // CONSOLIDATED CONFIGURATION - All constants in one place
    // ═══════════════════════════════════════════════════════════════════
    const CONFIG = {
        // Storage Keys
        STORAGE_KEY: 'mynd-v6c',
        ONBOARDING_KEY: 'mynd-onboarded-v17',
        THEME_KEY: 'mynd-theme-v8',
        API_KEY: 'mynd-api-key',
        
        // Color Palettes for each theme
        THEME_COLORS: {
            // Sandstone - Natural earthy tones (graphite first for root)
            sandstone: [
                '#3A3A3A', '#B17457', '#8B9D83', '#C4887A', '#6B7C7A',
                '#4A4947', '#9AABA0', '#D8D2C2', '#A89078', '#7A8B70',
                '#5E6B5A', '#C0A898', '#8A9488', '#D4C4B0', '#6B6B63',
                '#A09080', '#C8B8A0', '#787870'
            ],
            // Coral - Soft pastels, flat cartoon look
            coral: [
                '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
                '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
                '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
                '#A0C8D0', '#E0C0C0', '#C8C8C8'
            ],
            // Ember - Warm gradient from burnt orange to cream (rich orange first for root)
            ember: [
                '#C04818', '#E85820', '#F07028', '#F88830', '#FFA040',
                '#FFB858', '#FFD070', '#FFE088', '#D4C4A0', '#B0A080',
                '#907860', '#C89060', '#E8A848', '#F0C060', '#D8B078',
                '#A88858', '#C8A070', '#E8D098'
            ],
            // Frost - Cool soft blues and grays (white first for root)
            frost: [
                '#FFFFFF', '#5B8DEF', '#7DA8F5', '#6B9BD0', '#8FB8E8',
                '#5D7D9A', '#7A9AB8', '#4A6A8A', '#98B8D8', '#6888A8',
                '#88A8C8', '#5878A0', '#A8C8E8', '#7898B8', '#6080A0',
                '#90B0D0', '#4868A0', '#B0D0F0'
            ],
            // Obsidian - Coral accent with cool grays
            obsidian: [
                '#EF8354', '#F59B70', '#BFC0C0', '#4F5D75', '#7A8899',
                '#E8956A', '#8D99AE', '#F0A880', '#6B7B8C', '#D08060',
                '#9EAAB8', '#C87850', '#5A6A7A', '#E09070', '#A8B4C0',
                '#B07058', '#7888A0', '#D4A088'
            ]
        },
        
        // Legacy fallback (will be mapped to coral)
        COLORS: [
            '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
            '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
            '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
            '#A0C8D0', '#E0C0C0', '#C8C8C8'
        ],
        
        COLORS_PROFESSIONAL: [
            '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
            '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
            '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
            '#A0C8D0', '#E0C0C0', '#C8C8C8'
        ],
        
        // Spring Physics
        SPRING: {
            stiffness: 0.15,
            damping: 0.88
        },
        
        // Node Sizes
        NODE_SIZES: {
            root: 1.8,
            level1: 0.85,
            level2: 0.6,
            default: 0.45,
            minSize: 0.25
        },
        
        // Layout
        LAYOUT: {
            level1Radius: 6.0,
            level1RadiusExpanded: 8,
            level2Radius: 5.5,
            level3Radius: 4.0,
            spreadAngle: Math.PI * 1.2,
            descendantSpacingFactor: 0.25,
            maxDescendantPush: 7
        },
        
        // Animation - consolidated timing constants
        ANIMATION: {
            springLerpBase: 0.12,
            springLerpSlow: 0.06,
            springLerpMedium: 0.08,
            scaleLerp: 0.15,
            positionThreshold: 0.001,
            scaleThreshold: 0.001,
            animatingThreshold: 0.01,
            cameraArcDuration: 600,
            cameraFollowSpeed: 0.03
        },
        
        // Timing (ms)
        TIMING: {
            expandStagger: 50,
            collapseStagger: 40,
            collapseHideDelay: 200,
            toastDuration: 3000,
            labelUpdateInterval: 100
        },
        
        // Label Decluttering
        LABELS: {
            padding: 12,
            fadeSpeed: 0.12,
            minOpacity: 0.03,
            basePriority: 100,
            selectedPriority: 1000,
            rootPriority: 500,
            depthPenalty: 10,
            declutterInterval: 3, // frames between declutter runs
            // Label sprite rendering
            fontSize: 42,
            spritePadding: 20,
            minWidth: 60,
            charWidth: 8,
            scaleFactor: 20,
            minDistance: 5
        },
        
        // Particles
        PARTICLES: {
            count: 200,
            spread: 100,
            baseSize: 0.15,
            opacity: 0.4,
            rotationSpeed: 0.02
        },
        
        // Neural Network Settings
        NEURAL_NET: {
            STORAGE_KEY: 'mynd-neural-model-v1',
            EMBEDDINGS_KEY: 'mynd-embeddings-v1',
            embeddingDim: 512, // Universal Sentence Encoder output dimension
            hiddenUnits: 128,
            learningRate: 0.01,
            minTrainingNodes: 5,
            batchSize: 16,
            epochs: 50
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // PERSONAL NEURAL NETWORK - TensorFlow.js Integration
    // ═══════════════════════════════════════════════════════════════════
    class PersonalNeuralNet {
        constructor() {
            this.encoder = null;
            this.categoryModel = null;
            this.connectionModel = null;
            this.predictionModel = null; // New: Predicts likely child nodes
            this.expansionPatterns = new Map(); // Learned parent->children patterns
            this.embeddings = new Map(); // Cache embeddings for nodes
            this.isReady = false;
            this.isTraining = false;
            this.trainingProgress = 0;
            this.categories = []; // Learned categories (top-level nodes)
            this.commonPatterns = []; // Frequently seen expansion patterns
            this.callbacks = {
                onReady: [],
                onTrainingStart: [],
                onTrainingProgress: [],
                onTrainingComplete: [],
                onPrediction: [],
                onSuggestion: []
            };
        }
        
        // Initialize the encoder and load any saved models
        async initialize() {
            try {
                console.log('🧠 Initializing Personal Neural Network...');
                
                // Load Universal Sentence Encoder
                if (typeof use !== 'undefined') {
                    try {
                        this.encoder = await use.load();
                        console.log('✓ Universal Sentence Encoder loaded');
                    } catch (loadError) {
                        // Model fetch blocked (common in preview environments)
                        console.warn('⚠️ Neural network: Model loading blocked (preview environment)');
                        console.warn('   Neural features will work when running locally or hosted');
                        this.loadError = 'Preview environment - run locally for neural features';
                        return false;
                    }
                } else {
                    console.warn('Universal Sentence Encoder not available');
                    this.loadError = 'TensorFlow.js not loaded';
                    return false;
                }
                
                // Try to load saved models
                await this.loadModels();
                
                // Load cached embeddings
                this.loadEmbeddings();
                
                this.isReady = true;
                this.emit('onReady');
                console.log('✓ Personal Neural Network ready');
                return true;
            } catch (error) {
                console.warn('Neural network unavailable:', error.message);
                this.loadError = error.message;
                return false;
            }
        }
        
        // Event system
        on(event, callback) {
            if (this.callbacks[event]) {
                this.callbacks[event].push(callback);
            }
        }
        
        emit(event, data) {
            if (this.callbacks[event]) {
                this.callbacks[event].forEach(cb => cb(data));
            }
        }
        
        // Generate embedding for text
        async getEmbedding(text) {
            if (!this.encoder) return null;
            
            const cacheKey = text.toLowerCase().trim();
            if (this.embeddings.has(cacheKey)) {
                return this.embeddings.get(cacheKey);
            }
            
            try {
                const embeddings = await this.encoder.embed([text]);
                const embedding = await embeddings.array();
                const vector = embedding[0];
                
                this.embeddings.set(cacheKey, vector);
                return vector;
            } catch (error) {
                console.error('Embedding error:', error);
                return null;
            }
        }
        
        // Get embeddings for multiple texts efficiently
        async getEmbeddings(texts) {
            if (!this.encoder) return null;
            
            try {
                const embeddings = await this.encoder.embed(texts);
                const vectors = await embeddings.array();
                
                // Cache them
                texts.forEach((text, i) => {
                    const cacheKey = text.toLowerCase().trim();
                    this.embeddings.set(cacheKey, vectors[i]);
                });
                
                return vectors;
            } catch (error) {
                console.error('Batch embedding error:', error);
                return null;
            }
        }
        
        // Build the category prediction model
        buildCategoryModel(numCategories) {
            const model = tf.sequential();
            
            // Input: 512-dim embedding
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: CONFIG.NEURAL_NET.hiddenUnits,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: 64,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: probability for each category
            model.add(tf.layers.dense({
                units: numCategories,
                activation: 'softmax'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the connection prediction model
        buildConnectionModel() {
            const model = tf.sequential();
            
            // Input: concatenated embeddings of two nodes (512 + 512 = 1024)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim * 2],
                units: 256,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: 64,
                activation: 'relu'
            }));
            
            // Output: connection probability and connection type
            // [shouldConnect, isParentChild, isSibling, isRelated]
            model.add(tf.layers.dense({
                units: 4,
                activation: 'sigmoid'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the node prediction model - predicts likely child node embeddings
        buildPredictionModel() {
            const model = tf.sequential();
            
            // Input: parent node embedding (512)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: 256,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: 256,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: predicted "average child" embedding (512)
            // This represents the semantic centroid of expected children
            model.add(tf.layers.dense({
                units: CONFIG.NEURAL_NET.embeddingDim,
                activation: 'linear' // Linear for embedding space
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate * 0.5),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }
        
        // Prepare training data from the mind map structure
        async prepareTrainingData(store) {
            const allNodes = [];
            const categoryLabels = [];
            
            // Collect all nodes with their text and category
            const collectNodes = (node, category = null, depth = 0) => {
                if (depth === 0) {
                    // Root node - skip
                } else if (depth === 1) {
                    // This is a category (top-level node)
                    category = node.label;
                    if (!this.categories.includes(category)) {
                        this.categories.push(category);
                    }
                }
                
                if (depth > 0 && category) {
                    const text = node.description 
                        ? `${node.label}. ${node.description}`
                        : node.label;
                    allNodes.push({
                        id: node.id,
                        text: text,
                        label: node.label,
                        category: category,
                        categoryIndex: this.categories.indexOf(category),
                        depth: depth,
                        parentId: null, // Will be set below
                        children: node.children?.map(c => c.id) || []
                    });
                }
                
                if (node.children) {
                    node.children.forEach(child => {
                        collectNodes(child, category || node.label, depth + 1);
                    });
                }
            };
            
            collectNodes(store.data);
            
            // Set parent IDs
            const setParents = (node, parentId = null) => {
                const nodeData = allNodes.find(n => n.id === node.id);
                if (nodeData) {
                    nodeData.parentId = parentId;
                }
                if (node.children) {
                    node.children.forEach(child => setParents(child, node.id));
                }
            };
            setParents(store.data);
            
            if (allNodes.length < CONFIG.NEURAL_NET.minTrainingNodes) {
                console.log(`Need at least ${CONFIG.NEURAL_NET.minTrainingNodes} nodes to train`);
                return null;
            }
            
            // Get embeddings for all node texts
            const texts = allNodes.map(n => n.text);
            const embeddings = await this.getEmbeddings(texts);
            
            if (!embeddings) return null;
            
            // Prepare category training data
            const categoryData = {
                inputs: [],
                outputs: []
            };
            
            allNodes.forEach((node, i) => {
                if (node.categoryIndex >= 0) {
                    categoryData.inputs.push(embeddings[i]);
                    // One-hot encode the category
                    const oneHot = new Array(this.categories.length).fill(0);
                    oneHot[node.categoryIndex] = 1;
                    categoryData.outputs.push(oneHot);
                }
            });
            
            // Prepare connection training data
            const connectionData = {
                inputs: [],
                outputs: []
            };
            
            // Positive examples: actual parent-child and sibling pairs
            allNodes.forEach((node, i) => {
                // Parent-child connections
                node.children.forEach(childId => {
                    const childIndex = allNodes.findIndex(n => n.id === childId);
                    if (childIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[childIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 1, 0, 1]); // connected, parent-child, not sibling, related
                    }
                });
                
                // Sibling connections (same parent)
                const siblings = allNodes.filter(n => 
                    n.parentId === node.parentId && n.id !== node.id
                );
                siblings.slice(0, 3).forEach(sibling => {
                    const siblingIndex = allNodes.findIndex(n => n.id === sibling.id);
                    if (siblingIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[siblingIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 0, 1, 1]); // connected, not parent-child, sibling, related
                    }
                });
            });
            
            // Negative examples: random unconnected pairs
            const numNegative = Math.min(connectionData.inputs.length, allNodes.length * 2);
            for (let i = 0; i < numNegative; i++) {
                const idx1 = Math.floor(Math.random() * allNodes.length);
                const idx2 = Math.floor(Math.random() * allNodes.length);
                if (idx1 !== idx2) {
                    const node1 = allNodes[idx1];
                    const node2 = allNodes[idx2];
                    
                    // Check if they're not actually connected
                    const isConnected = node1.children.includes(node2.id) || 
                                       node2.children.includes(node1.id) ||
                                       node1.parentId === node2.parentId;
                    
                    if (!isConnected) {
                        const combined = [...embeddings[idx1], ...embeddings[idx2]];
                        connectionData.inputs.push(combined);
                        // Different categories = probably not related
                        const sameCategory = node1.category === node2.category;
                        connectionData.outputs.push([0, 0, 0, sameCategory ? 0.5 : 0]);
                    }
                }
            }
            
            // Prepare prediction training data (parent -> average child embedding)
            const predictionData = {
                inputs: [],
                outputs: [],
                patterns: [] // Store label patterns for pattern matching
            };
            
            // For each parent with children, create training pair
            allNodes.forEach((node, i) => {
                if (node.children.length > 0) {
                    // Get all child embeddings
                    const childEmbeddings = [];
                    const childLabels = [];
                    
                    node.children.forEach(childId => {
                        const childIndex = allNodes.findIndex(n => n.id === childId);
                        if (childIndex >= 0) {
                            childEmbeddings.push(embeddings[childIndex]);
                            childLabels.push(allNodes[childIndex].label);
                        }
                    });
                    
                    if (childEmbeddings.length > 0) {
                        // Input: parent embedding
                        predictionData.inputs.push(embeddings[i]);
                        
                        // Output: centroid (average) of child embeddings
                        const centroid = new Array(CONFIG.NEURAL_NET.embeddingDim).fill(0);
                        childEmbeddings.forEach(childEmb => {
                            childEmb.forEach((val, j) => {
                                centroid[j] += val / childEmbeddings.length;
                            });
                        });
                        predictionData.outputs.push(centroid);
                        
                        // Store pattern for label-based suggestions
                        predictionData.patterns.push({
                            parentLabel: node.label.toLowerCase(),
                            childLabels: childLabels
                        });
                    }
                }
            });
            
            // Store expansion patterns for quick lookup
            this.expansionPatterns.clear();
            predictionData.patterns.forEach(p => {
                // Normalize parent label for fuzzy matching
                const key = this.normalizeLabel(p.parentLabel);
                if (!this.expansionPatterns.has(key)) {
                    this.expansionPatterns.set(key, []);
                }
                this.expansionPatterns.get(key).push(...p.childLabels);
            });
            
            // Find common patterns across similar parents
            this.learnCommonPatterns(predictionData.patterns);
            
            return { categoryData, connectionData, predictionData, allNodes, embeddings };
        }
        
        // Normalize label for pattern matching
        normalizeLabel(label) {
            return label.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Learn common expansion patterns
        learnCommonPatterns(patterns) {
            // Group similar child labels across different parents
            const childFrequency = new Map();
            
            patterns.forEach(p => {
                p.childLabels.forEach(label => {
                    const normalized = this.normalizeLabel(label);
                    childFrequency.set(normalized, (childFrequency.get(normalized) || 0) + 1);
                });
            });
            
            // Find commonly used child labels (appear in multiple parent contexts)
            this.commonPatterns = Array.from(childFrequency.entries())
                .filter(([label, count]) => count >= 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([label]) => label);
            
            console.log(`✓ Learned ${this.commonPatterns.length} common expansion patterns`);
        }
        
        // Train the models on the user's mind map data
        async train(store) {
            if (!this.isReady || this.isTraining) {
                console.log('Neural network not ready or already training');
                return false;
            }
            
            this.isTraining = true;
            this.trainingProgress = 0;
            this.emit('onTrainingStart');
            
            try {
                console.log('🧠 Preparing training data...');
                const data = await this.prepareTrainingData(store);
                
                if (!data) {
                    this.isTraining = false;
                    return false;
                }
                
                const { categoryData, connectionData, predictionData } = data;
                
                // Train category model (0-33%)
                if (this.categories.length > 1 && categoryData.inputs.length > 0) {
                    console.log(`🧠 Training category model (${this.categories.length} categories)...`);
                    
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    
                    const xs = tf.tensor2d(categoryData.inputs);
                    const ys = tf.tensor2d(categoryData.outputs);
                    
                    await this.categoryModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: (epoch, logs) => {
                                this.trainingProgress = ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'category',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Category model trained');
                }
                
                // Train connection model (33-66%)
                if (connectionData.inputs.length > 10) {
                    console.log(`🧠 Training connection model (${connectionData.inputs.length} pairs)...`);
                    
                    this.connectionModel = this.buildConnectionModel();
                    
                    const xs = tf.tensor2d(connectionData.inputs);
                    const ys = tf.tensor2d(connectionData.outputs);
                    
                    await this.connectionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: (epoch, logs) => {
                                this.trainingProgress = 33 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'connection',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Connection model trained');
                }
                
                // Train prediction model (66-100%)
                if (predictionData.inputs.length > 5) {
                    console.log(`🧠 Training prediction model (${predictionData.inputs.length} parent-child pairs)...`);
                    
                    this.predictionModel = this.buildPredictionModel();
                    
                    const xs = tf.tensor2d(predictionData.inputs);
                    const ys = tf.tensor2d(predictionData.outputs);
                    
                    await this.predictionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: Math.min(CONFIG.NEURAL_NET.batchSize, predictionData.inputs.length),
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: (epoch, logs) => {
                                this.trainingProgress = 66 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 34;
                                this.emit('onTrainingProgress', {
                                    phase: 'prediction',
                                    progress: this.trainingProgress,
                                    loss: logs.loss
                                });
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Prediction model trained');
                }
                
                // Save models
                await this.saveModels();
                this.saveEmbeddings();
                
                this.isTraining = false;
                this.trainingProgress = 100;
                this.emit('onTrainingComplete', { categories: this.categories });
                
                console.log('✓ Training complete!');
                return true;
                
            } catch (error) {
                console.error('Training error:', error);
                this.isTraining = false;
                return false;
            }
        }
        
        // Predict the best category for new text
        async predictCategory(text) {
            if (!this.categoryModel || !this.encoder) return null;
            
            try {
                const embedding = await this.getEmbedding(text);
                if (!embedding) return null;
                
                const input = tf.tensor2d([embedding]);
                const prediction = this.categoryModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                // Get top predictions
                const results = this.categories.map((cat, i) => ({
                    category: cat,
                    probability: probs[0][i]
                })).sort((a, b) => b.probability - a.probability);
                
                this.emit('onPrediction', { type: 'category', results });
                return results;
                
            } catch (error) {
                console.error('Category prediction error:', error);
                return null;
            }
        }
        
        // Predict connection strength between two nodes
        async predictConnection(text1, text2) {
            if (!this.connectionModel || !this.encoder) return null;
            
            try {
                const [emb1, emb2] = await Promise.all([
                    this.getEmbedding(text1),
                    this.getEmbedding(text2)
                ]);
                
                if (!emb1 || !emb2) return null;
                
                const combined = [...emb1, ...emb2];
                const input = tf.tensor2d([combined]);
                const prediction = this.connectionModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                const result = {
                    shouldConnect: probs[0][0],
                    isParentChild: probs[0][1],
                    isSibling: probs[0][2],
                    isRelated: probs[0][3]
                };
                
                this.emit('onPrediction', { type: 'connection', result });
                return result;
                
            } catch (error) {
                console.error('Connection prediction error:', error);
                return null;
            }
        }
        
        // Find suggested connections for a node
        async suggestConnections(nodeText, store, maxSuggestions = 5) {
            if (!this.connectionModel) return [];
            
            const suggestions = [];
            const nodeEmbedding = await this.getEmbedding(nodeText);
            if (!nodeEmbedding) return [];
            
            // Get all nodes
            const allNodes = [];
            const collectNodes = (node, depth = 0) => {
                if (depth > 0) {
                    allNodes.push({
                        id: node.id,
                        label: node.label,
                        text: node.description ? `${node.label}. ${node.description}` : node.label
                    });
                }
                node.children?.forEach(child => collectNodes(child, depth + 1));
            };
            collectNodes(store.data);
            
            // Check connection with each node
            for (const other of allNodes) {
                const prediction = await this.predictConnection(nodeText, other.text);
                if (prediction && prediction.isRelated > 0.6) {
                    suggestions.push({
                        nodeId: other.id,
                        label: other.label,
                        ...prediction
                    });
                }
            }
            
            // Sort by relatedness and return top suggestions
            return suggestions
                .sort((a, b) => b.isRelated - a.isRelated)
                .slice(0, maxSuggestions);
        }
        
        // Predict likely children for a node using neural network + patterns
        async predictChildren(nodeText, existingChildren = [], maxSuggestions = 5) {
            const suggestions = [];
            
            // Method 1: Pattern-based suggestions (fast)
            const normalizedLabel = this.normalizeLabel(nodeText);
            
            // Check for exact and partial pattern matches
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    children.forEach(child => {
                        const normalizedChild = this.normalizeLabel(child);
                        // Skip if already exists
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedChild)) {
                            const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedChild);
                            if (existing) {
                                existing.confidence += 0.2;
                                existing.sources.push('pattern');
                            } else {
                                suggestions.push({
                                    label: child,
                                    confidence: 0.5,
                                    sources: ['pattern'],
                                    type: 'learned'
                                });
                            }
                        }
                    });
                }
            }
            
            // Method 2: Common pattern suggestions
            this.commonPatterns.forEach(pattern => {
                if (!existingChildren.some(e => this.normalizeLabel(e) === pattern)) {
                    const existing = suggestions.find(s => this.normalizeLabel(s.label) === pattern);
                    if (existing) {
                        existing.confidence += 0.1;
                        existing.sources.push('common');
                    } else {
                        suggestions.push({
                            label: pattern,
                            confidence: 0.3,
                            sources: ['common'],
                            type: 'common'
                        });
                    }
                }
            });
            
            // Method 3: Neural network prediction (find similar nodes)
            if (this.predictionModel && this.encoder) {
                try {
                    const parentEmbedding = await this.getEmbedding(nodeText);
                    if (parentEmbedding) {
                        // Predict the "expected child centroid"
                        const input = tf.tensor2d([parentEmbedding]);
                        const prediction = this.predictionModel.predict(input);
                        const predictedCentroid = await prediction.array();
                        
                        input.dispose();
                        prediction.dispose();
                        
                        // Find cached embeddings closest to the predicted centroid
                        const similarities = [];
                        for (const [text, embedding] of this.embeddings) {
                            const similarity = this.cosineSimilarity(predictedCentroid[0], embedding);
                            if (similarity > 0.5) {
                                similarities.push({ text, similarity });
                            }
                        }
                        
                        // Get top similar texts as suggestions
                        similarities
                            .sort((a, b) => b.similarity - a.similarity)
                            .slice(0, 5)
                            .forEach(s => {
                                const normalizedText = this.normalizeLabel(s.text);
                                if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedText)) {
                                    const existing = suggestions.find(sg => this.normalizeLabel(sg.label) === normalizedText);
                                    if (existing) {
                                        existing.confidence += s.similarity * 0.3;
                                        existing.sources.push('neural');
                                    } else {
                                        suggestions.push({
                                            label: s.text.split('.')[0], // Get just the label part
                                            confidence: s.similarity * 0.4,
                                            sources: ['neural'],
                                            type: 'neural'
                                        });
                                    }
                                }
                            });
                    }
                } catch (error) {
                    console.error('Neural prediction error:', error);
                }
            }
            
            // Sort by confidence and return top suggestions
            const results = suggestions
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, maxSuggestions)
                .map(s => ({
                    ...s,
                    confidence: Math.min(s.confidence, 1.0)
                }));
            
            this.emit('onSuggestion', { type: 'children', results });
            return results;
        }
        
        // Calculate cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (a.length !== b.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const denominator = Math.sqrt(normA) * Math.sqrt(normB);
            return denominator === 0 ? 0 : dotProduct / denominator;
        }
        
        // Get suggestions for a specific node (combines all methods)
        async getSuggestionsForNode(node, store) {
            const suggestions = {
                children: [],
                hasML: false,
                hasPatterns: false
            };
            
            if (!this.isReady) return suggestions;
            
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            const existingChildren = (node.children || []).map(c => c.label);
            
            // Get prediction-based suggestions
            const childSuggestions = await this.predictChildren(nodeText, existingChildren);
            
            if (childSuggestions.length > 0) {
                suggestions.children = childSuggestions;
                suggestions.hasML = childSuggestions.some(s => s.sources.includes('neural'));
                suggestions.hasPatterns = childSuggestions.some(s => 
                    s.sources.includes('pattern') || s.sources.includes('common')
                );
            }
            
            return suggestions;
        }
        
        // Check if a node has strong suggestions (for UI indicator)
        async hasStrongSuggestions(node) {
            if (!this.isReady || this.expansionPatterns.size === 0) return false;
            
            const normalizedLabel = this.normalizeLabel(node.label);
            const existingChildren = (node.children || []).map(c => this.normalizeLabel(c.label));
            
            // Quick check against patterns
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    // Check if there are un-added children
                    const newChildren = children.filter(c => 
                        !existingChildren.includes(this.normalizeLabel(c))
                    );
                    if (newChildren.length > 0) return true;
                }
            }
            
            return false;
        }
        
        // Generate AI-enhanced child suggestions using Claude
        async generateSmartSuggestions(node, store) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) return null;
            
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            // Get our ML predictions first
            const existingChildren = (node.children || []).map(c => c.label);
            const mlSuggestions = await this.predictChildren(nodeText, existingChildren, 3);
            
            // Get path context
            const path = store.getPath(node.id);
            const pathStr = path.map(n => n.label).join(' → ');
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 400,
                        messages: [{
                            role: 'user',
                            content: `You are MYND's AI core, helping expand a personal mind map.

NODE: "${node.label}"${node.description ? `\nDESCRIPTION: "${node.description}"` : ''}
PATH: ${pathStr}
EXISTING CHILDREN: ${existingChildren.length > 0 ? existingChildren.join(', ') : 'none'}

${mlSuggestions.length > 0 ? `LEARNED PATTERNS suggest these children:
${mlSuggestions.map(s => `- ${s.label} (${Math.round(s.confidence * 100)}% confidence, from: ${s.sources.join(', ')})`).join('\n')}

Build on these patterns while adding fresh perspectives.` : 'This is a new type of node - suggest creative expansions.'}

Generate 4-6 child nodes that would help expand this area. Consider:
- Building on learned patterns if they're relevant
- Adding new dimensions the user might not have considered
- Practical next steps or subcategories

Return ONLY a JSON array of objects:
[{"label": "Node Name", "reasoning": "Brief why"}, ...]`
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                const text = data.content[0].text;
                
                const jsonMatch = text.match(/\[[\s\S]*\]/);
                if (jsonMatch) {
                    const suggestions = JSON.parse(jsonMatch[0]);
                    return {
                        mlSuggestions,
                        aiSuggestions: suggestions,
                        combined: true
                    };
                }
                
                return { mlSuggestions, aiSuggestions: [], combined: false };
                
            } catch (error) {
                console.error('Smart suggestions error:', error);
                return { mlSuggestions, aiSuggestions: [], combined: false };
            }
        }
        
        // Use Claude to enhance predictions with semantic analysis
        async enhanceWithClaude(text, store) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) return null;
            
            try {
                // Get category predictions from our model first
                const categoryPredictions = await this.predictCategory(text);
                
                // Get current structure summary
                const categories = this.categories.join(', ');
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `You are helping categorize content for a personal mind map.

EXISTING CATEGORIES: ${categories}

NEW CONTENT: "${text}"

${categoryPredictions ? `LOCAL MODEL PREDICTIONS (confidence scores):
${categoryPredictions.slice(0, 3).map(p => `- ${p.category}: ${(p.probability * 100).toFixed(1)}%`).join('\n')}` : ''}

Analyze this content and provide:
1. The best matching existing category (or suggest a new one if none fit)
2. Suggested parent node within that category
3. Related concepts that could be sibling nodes
4. A brief reasoning for your categorization

Return as JSON:
{
  "category": "Category Name",
  "confidence": 0.0-1.0,
  "suggestedParent": "Parent Node Name",
  "relatedConcepts": ["concept1", "concept2"],
  "reasoning": "Brief explanation"
}`
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                const text_response = data.content[0].text;
                
                // Parse JSON from response
                const jsonMatch = text_response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
                
                return null;
                
            } catch (error) {
                console.error('Claude enhancement error:', error);
                return null;
            }
        }
        
        // Save models to localStorage (as JSON weights)
        async saveModels() {
            try {
                const modelData = {
                    categories: this.categories,
                    commonPatterns: this.commonPatterns,
                    expansionPatterns: Array.from(this.expansionPatterns.entries()),
                    categoryWeights: null,
                    connectionWeights: null,
                    predictionWeights: null
                };
                
                if (this.categoryModel) {
                    const categoryWeights = [];
                    for (const layer of this.categoryModel.layers) {
                        const weights = layer.getWeights();
                        const layerWeights = [];
                        for (const w of weights) {
                            layerWeights.push({
                                shape: w.shape,
                                data: Array.from(await w.data())
                            });
                        }
                        categoryWeights.push(layerWeights);
                    }
                    modelData.categoryWeights = categoryWeights;
                }
                
                if (this.connectionModel) {
                    const connectionWeights = [];
                    for (const layer of this.connectionModel.layers) {
                        const weights = layer.getWeights();
                        const layerWeights = [];
                        for (const w of weights) {
                            layerWeights.push({
                                shape: w.shape,
                                data: Array.from(await w.data())
                            });
                        }
                        connectionWeights.push(layerWeights);
                    }
                    modelData.connectionWeights = connectionWeights;
                }
                
                if (this.predictionModel) {
                    const predictionWeights = [];
                    for (const layer of this.predictionModel.layers) {
                        const weights = layer.getWeights();
                        const layerWeights = [];
                        for (const w of weights) {
                            layerWeights.push({
                                shape: w.shape,
                                data: Array.from(await w.data())
                            });
                        }
                        predictionWeights.push(layerWeights);
                    }
                    modelData.predictionWeights = predictionWeights;
                }
                
                localStorage.setItem(CONFIG.NEURAL_NET.STORAGE_KEY, JSON.stringify(modelData));
                console.log('✓ Models saved to localStorage');
                
            } catch (error) {
                console.error('Failed to save models:', error);
            }
        }
        
        // Load models from localStorage
        async loadModels() {
            try {
                const saved = localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                if (!saved) return false;
                
                const modelData = JSON.parse(saved);
                this.categories = modelData.categories || [];
                this.commonPatterns = modelData.commonPatterns || [];
                
                // Load expansion patterns
                if (modelData.expansionPatterns) {
                    this.expansionPatterns = new Map(modelData.expansionPatterns);
                    console.log(`✓ Loaded ${this.expansionPatterns.size} expansion patterns`);
                }
                
                if (modelData.categoryWeights && this.categories.length > 0) {
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    let layerIndex = 0;
                    for (const layer of this.categoryModel.layers) {
                        const savedWeights = modelData.categoryWeights[layerIndex];
                        if (savedWeights && savedWeights.length > 0) {
                            const tensors = savedWeights.map(w => 
                                tf.tensor(w.data, w.shape)
                            );
                            layer.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                        }
                        layerIndex++;
                    }
                    console.log('✓ Category model loaded');
                }
                
                if (modelData.connectionWeights) {
                    this.connectionModel = this.buildConnectionModel();
                    let layerIndex = 0;
                    for (const layer of this.connectionModel.layers) {
                        const savedWeights = modelData.connectionWeights[layerIndex];
                        if (savedWeights && savedWeights.length > 0) {
                            const tensors = savedWeights.map(w => 
                                tf.tensor(w.data, w.shape)
                            );
                            layer.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                        }
                        layerIndex++;
                    }
                    console.log('✓ Connection model loaded');
                }
                
                if (modelData.predictionWeights) {
                    this.predictionModel = this.buildPredictionModel();
                    let layerIndex = 0;
                    for (const layer of this.predictionModel.layers) {
                        const savedWeights = modelData.predictionWeights[layerIndex];
                        if (savedWeights && savedWeights.length > 0) {
                            const tensors = savedWeights.map(w => 
                                tf.tensor(w.data, w.shape)
                            );
                            layer.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                        }
                        layerIndex++;
                    }
                    console.log('✓ Prediction model loaded');
                }
                
                return true;
                
            } catch (error) {
                console.error('Failed to load models:', error);
                return false;
            }
        }
        
        // Save embeddings cache
        saveEmbeddings() {
            try {
                const data = {};
                this.embeddings.forEach((value, key) => {
                    data[key] = value;
                });
                localStorage.setItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY, JSON.stringify(data));
            } catch (error) {
                console.error('Failed to save embeddings:', error);
            }
        }
        
        // Load embeddings cache
        loadEmbeddings() {
            try {
                const saved = localStorage.getItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.entries(data).forEach(([key, value]) => {
                        this.embeddings.set(key, value);
                    });
                    console.log(`✓ Loaded ${this.embeddings.size} cached embeddings`);
                }
            } catch (error) {
                console.error('Failed to load embeddings:', error);
            }
        }
        
        // Get model statistics
        getStats() {
            return {
                isReady: this.isReady,
                isTraining: this.isTraining,
                trainingProgress: this.trainingProgress,
                categories: this.categories,
                hasCategoryModel: !!this.categoryModel,
                hasConnectionModel: !!this.connectionModel,
                hasPredictionModel: !!this.predictionModel,
                expansionPatterns: this.expansionPatterns.size,
                commonPatterns: this.commonPatterns.length,
                cachedEmbeddings: this.embeddings.size,
                loadError: this.loadError || null
            };
        }
        
        // Clear all learned data
        async reset() {
            if (this.categoryModel) {
                this.categoryModel.dispose();
                this.categoryModel = null;
            }
            if (this.connectionModel) {
                this.connectionModel.dispose();
                this.connectionModel = null;
            }
            if (this.predictionModel) {
                this.predictionModel.dispose();
                this.predictionModel = null;
            }
            this.categories = [];
            this.commonPatterns = [];
            this.expansionPatterns.clear();
            this.embeddings.clear();
            localStorage.removeItem(CONFIG.NEURAL_NET.STORAGE_KEY);
            localStorage.removeItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
            console.log('✓ Neural network reset');
        }
    }
    
    // Global neural network instance
    const neuralNet = new PersonalNeuralNet();
    
    // ═══════════════════════════════════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════
    const Utils = {
        // Smoother easing functions for transitions
        easing: {
            smoothStep: t => t * t * (3 - 2 * t),
            smootherStep: t => t * t * t * (t * (t * 6 - 15) + 10),
            outCubic: t => 1 - Math.pow(1 - t, 3),
            outQuart: t => 1 - Math.pow(1 - t, 4)
        },
        
        // Check if theme is dark
        isDarkTheme() {
            const theme = document.documentElement.getAttribute('data-theme') || 'coral';
            return ['obsidian'].includes(theme);
        }
    };
    
    // Get colors based on current theme
    function getThemeColors() {
        const theme = document.documentElement.getAttribute('data-theme') || 'coral';
        return CONFIG.THEME_COLORS[theme] || CONFIG.THEME_COLORS.sandstone;
    }
    
    // Map a color from one palette to another by index
    function remapColor(color, fromPalette, toPalette) {
        const index = fromPalette.findIndex(c => c.toLowerCase() === color.toLowerCase());
        if (index >= 0 && index < toPalette.length) {
            return toPalette[index];
        }
        // If not found in palette, return null to signal we need special handling
        return null;
    }
    
    // Update all node colors for theme change
    function updateNodeColorsForTheme(oldTheme, newTheme) {
        const fromPalette = CONFIG.THEME_COLORS[oldTheme] || CONFIG.THEME_COLORS.coral;
        const toPalette = CONFIG.THEME_COLORS[newTheme] || CONFIG.THEME_COLORS.coral;
        
        if (typeof nodes === 'undefined' || !nodes) return;
        
        // First pass: build a map of old colors to new colors
        // This ensures nodes with the same old color get the same new color
        const colorMap = new Map();
        let unmappedColorIndex = 1; // Start at 1 to skip root color
        
        nodes.forEach((mesh) => {
            const oldColor = mesh.userData.color?.toLowerCase();
            if (!oldColor || colorMap.has(oldColor)) return;
            
            // Try to find exact match in palette
            const mappedColor = remapColor(mesh.userData.color, fromPalette, toPalette);
            if (mappedColor) {
                colorMap.set(oldColor, mappedColor);
            } else {
                // Assign next available color from new palette (skipping root color at index 0)
                colorMap.set(oldColor, toPalette[unmappedColorIndex % toPalette.length]);
                unmappedColorIndex++;
                // Reset to 1 if we've gone through all colors (skip 0 which is root)
                if (unmappedColorIndex >= toPalette.length) unmappedColorIndex = 1;
            }
        });
        
        // Second pass: apply the color mapping
        nodes.forEach((mesh) => {
            let newColor;
            
            // Root node always gets the first color of the new palette
            if (mesh.userData.id === 'mynd') {
                newColor = toPalette[0];
            } else {
                const oldColor = mesh.userData.color?.toLowerCase();
                newColor = colorMap.get(oldColor) || toPalette[1];
            }
            
            // Always update colors when switching themes
            mesh.userData.color = newColor;
            mesh.material.color.set(newColor);
            mesh.material.emissive.set(newColor);
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            // Update connection line color
            if (mesh.userData.connectionLine) {
                mesh.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update stored data
            store.updateNode(mesh.userData.id, { color: newColor });
        });
        
        // Also update label colors if switching between light/dark themes
        const wasLight = !['obsidian'].includes(oldTheme);
        const isLight = !['obsidian'].includes(newTheme);
        if (wasLight !== isLight) {
            updateLabelsForTheme();
        }
    }
    
    // Update color pickers for current theme
    function updateColorPickers() {
        const colors = getThemeColors();
        const colorGrid = document.getElementById('color-grid');
        const infoColorPicker = document.getElementById('info-color-picker');
        
        if (colorGrid) {
            colorGrid.innerHTML = colors.map(color => 
                `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
            ).join('');
        }
        
        if (infoColorPicker) {
            infoColorPicker.innerHTML = colors.slice(0, 12).map(color => 
                `<span style="background:${color}" data-color="${color}"></span>`
            ).join('');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // EVENT BUS
    // ═══════════════════════════════════════════════════════════════════
    class EventBus {
        constructor() { this.listeners = new Map(); }
        on(event, cb) { 
            if (!this.listeners.has(event)) this.listeners.set(event, new Set()); 
            this.listeners.get(event).add(cb); 
            return () => this.off(event, cb); 
        }
        off(event, cb) { this.listeners.get(event)?.delete(cb); }
        emit(event, data) { this.listeners.get(event)?.forEach(cb => cb(data)); }
    }
    const bus = new EventBus();

    // ═══════════════════════════════════════════════════════════════════
    // DATA STORE
    // ═══════════════════════════════════════════════════════════════════
    const defaultData = {
        id: 'mynd',
        label: 'My Mind',
        color: '#A8D5E5',
        description: '',
        children: []
    };

    class Store {
        constructor() {
            this.data = this.load();
            this.selectedNodeId = null;
            this.expandedNodes = new Set();
            this.undoStack = [];
            this.maxUndoSteps = 50;
        }
        
        load() {
            try {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate basic structure
                    if (parsed && parsed.id && parsed.label) {
                        return parsed;
                    }
                    console.warn('Invalid saved data structure, using defaults');
                }
            } catch (e) {
                console.warn('Failed to parse saved data, using defaults:', e.message);
            }
            return JSON.parse(JSON.stringify(defaultData));
        }
        
        save() {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.data));
                bus.emit('data:saved');
            } catch (e) {
                console.warn('Failed to save data:', e.message);
            }
        }
        
        saveSnapshot(name = 'change') {
            this.undoStack.push({
                data: JSON.parse(JSON.stringify(this.data)),
                expandedNodes: new Set(this.expandedNodes),
                actionName: name
            });
            if (this.undoStack.length > this.maxUndoSteps) this.undoStack.shift();
            bus.emit('undo:changed');
        }
        
        undo() {
            if (this.undoStack.length === 0) return { success: false };
            const snapshot = this.undoStack.pop();
            this.data = snapshot.data;
            this.expandedNodes = snapshot.expandedNodes;
            this.save();
            bus.emit('data:undone', { actionName: snapshot.actionName });
            bus.emit('undo:changed');
            return { success: true, actionName: snapshot.actionName };
        }
        
        canUndo() {
            return this.undoStack.length > 0;
        }
        
        findNode(id, node = this.data) {
            if (node.id === id) return node;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }
        
        findParent(id, node = this.data, parent = null) {
            if (node.id === id) return parent;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findParent(id, child, node);
                    if (found !== undefined) return found;
                }
            }
            return undefined;
        }
        
        getPath(id) {
            const path = [];
            const build = (node, target, current = []) => {
                current.push(node);
                if (node.id === target) {
                    path.push(...current);
                    return true;
                }
                if (node.children) {
                    for (const child of node.children) {
                        if (build(child, target, [...current])) return true;
                    }
                }
                return false;
            };
            build(this.data, id);
            return path;
        }
        
        getAllNodes(node = this.data, result = []) {
            result.push(node);
            if (node.children) {
                node.children.forEach(c => this.getAllNodes(c, result));
            }
            return result;
        }
        
        searchNodes(query) {
            const q = query.toLowerCase();
            return this.getAllNodes().filter(n => 
                n.label.toLowerCase().includes(q) || 
                (n.description && n.description.toLowerCase().includes(q))
            );
        }
        
        addNode(parentId, nodeData) {
            const parent = this.findNode(parentId);
            if (!parent) return null;
            
            this.saveSnapshot('Add node');
            if (!parent.children) parent.children = [];
            
            const newNode = {
                id: nodeData.id || `node-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                label: nodeData.label || 'New Node',
                color: nodeData.color || parent.color,
                description: nodeData.description || '',
                source: nodeData.source || 'user',
                createdAt: nodeData.createdAt || new Date().toISOString(),
                children: []
            };
            
            // Include link data if present
            if (nodeData.link) {
                newNode.link = nodeData.link;
                newNode.source = nodeData.source || 'link';
            }
            
            // Include importance if specified
            if (nodeData.importance) {
                newNode.importance = nodeData.importance;
            }
            
            parent.children.push(newNode);
            this.expandedNodes.add(parentId);
            this.save();
            bus.emit('node:added', { parent, node: newNode });
            return newNode;
        }
        
        updateNode(id, updates) {
            const node = this.findNode(id);
            if (!node) return null;
            
            this.saveSnapshot('Edit node');
            Object.assign(node, updates);
            this.save();
            bus.emit('node:updated', { node });
            return node;
        }
        
        deleteNode(id) {
            if (id === this.data.id) return false;
            
            const parent = this.findParent(id);
            if (!parent || !parent.children) return false;
            
            const index = parent.children.findIndex(c => c.id === id);
            if (index === -1) return false;
            
            this.saveSnapshot('Delete node');
            const deleted = parent.children.splice(index, 1)[0];
            this.save();
            bus.emit('node:deleted', { parentId: parent.id, node: deleted });
            return true;
        }
        
        moveNode(nodeId, newParentId) {
            // Can't move root
            if (nodeId === this.data.id) return false;
            // Can't move to itself
            if (nodeId === newParentId) return false;
            
            const node = this.findNode(nodeId);
            const oldParent = this.findParent(nodeId);
            const newParent = this.findNode(newParentId);
            
            if (!node || !oldParent || !newParent) return false;
            
            // Can't move to a descendant
            const isDescendant = (parent, targetId) => {
                if (parent.id === targetId) return true;
                for (const child of (parent.children || [])) {
                    if (isDescendant(child, targetId)) return true;
                }
                return false;
            };
            if (isDescendant(node, newParentId)) return false;
            
            this.saveSnapshot('Move node');
            
            // Remove from old parent
            const index = oldParent.children.findIndex(c => c.id === nodeId);
            if (index === -1) return false;
            oldParent.children.splice(index, 1);
            
            // Add to new parent
            if (!newParent.children) newParent.children = [];
            newParent.children.push(node);
            
            this.save();
            bus.emit('node:moved', { nodeId, oldParentId: oldParent.id, newParentId });
            return true;
        }
        
        reset(rootLabel = 'My Mind') {
            const newData = JSON.parse(JSON.stringify(defaultData));
            newData.label = rootLabel;
            this.data = newData;
            this.expandedNodes.clear();
            this.undoStack = [];
            this.save();
            bus.emit('data:reset');
        }
        
        exportJSON() {
            // Include neural network data in export
            const exportData = {
                version: 2, // Version to identify new format
                map: this.data,
                neural: {
                    modelData: null,
                    embeddings: null
                }
            };
            
            // Get neural network data from localStorage
            try {
                const modelData = localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                const embeddings = localStorage.getItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
                
                if (modelData) {
                    exportData.neural.modelData = JSON.parse(modelData);
                }
                if (embeddings) {
                    exportData.neural.embeddings = JSON.parse(embeddings);
                }
            } catch (e) {
                console.warn('Could not export neural data:', e);
            }
            
            return JSON.stringify(exportData, null, 2);
        }
        
        importJSON(json) {
            try {
                const parsed = JSON.parse(json);
                
                // Handle both old format (direct map data) and new format (with neural)
                let mapData;
                let neuralData = null;
                
                if (parsed.version === 2 && parsed.map) {
                    // New format with neural data
                    mapData = parsed.map;
                    neuralData = parsed.neural;
                } else if (parsed.id && parsed.label) {
                    // Old format - just map data
                    mapData = parsed;
                } else {
                    throw new Error('Invalid format');
                }
                
                if (!mapData.id || !mapData.label) throw new Error('Invalid map format');
                
                this.saveSnapshot('Import');
                this.data = mapData;
                this.expandedNodes.clear();
                this.save();
                
                // Restore neural network data if present
                if (neuralData) {
                    try {
                        if (neuralData.modelData) {
                            localStorage.setItem(CONFIG.NEURAL_NET.STORAGE_KEY, JSON.stringify(neuralData.modelData));
                            console.log('✓ Neural model data restored');
                        }
                        if (neuralData.embeddings) {
                            localStorage.setItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY, JSON.stringify(neuralData.embeddings));
                            console.log('✓ Neural embeddings restored');
                        }
                        
                        // Reload neural network with restored data
                        if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                            neuralNet.loadModels();
                            neuralNet.loadEmbeddings();
                        }
                    } catch (e) {
                        console.warn('Could not restore neural data:', e);
                    }
                }
                
                bus.emit('data:imported');
                return true;
            } catch (e) {
                console.error('Import error:', e);
                return false;
            }
        }
    }
    
    const store = new Store();

    // ═══════════════════════════════════════════════════════════════════
    // CONNECTION MANAGER - Batched Connection Updates for Performance
    // ═══════════════════════════════════════════════════════════════════
    const ConnectionManager = {
        pendingUpdates: new Set(),
        
        // Queue a connection for update (called during animation)
        queueUpdate(childMesh) {
            this.pendingUpdates.add(childMesh);
        },
        
        // Process all pending updates in a single batch
        processBatch() {
            if (this.pendingUpdates.size === 0) return;
            
            this.pendingUpdates.forEach(childMesh => {
                const line = childMesh.userData.connectionLine;
                if (!line || !childMesh.userData.parent) return;
                
                const parentMesh = nodes.get(childMesh.userData.parent.id);
                if (!parentMesh) return;
                
                const points = [parentMesh.position.clone(), childMesh.position.clone()];
                line.geometry.setFromPoints(points);
            });
            
            this.pendingUpdates.clear();
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // LABEL SYSTEM - Smart Decluttering with Camera Movement Detection
    // ═══════════════════════════════════════════════════════════════════
    const LabelSystem = {
        lastCameraPosition: null,
        lastCameraTarget: null,
        needsUpdate: true,
        frameCounter: 0,
        
        // Initialize tracking vectors (called after scene init)
        init(camera, controls) {
            this.lastCameraPosition = camera.position.clone();
            this.lastCameraTarget = controls.target.clone();
        },
        
        // Check if camera has moved significantly
        checkCameraMovement(camera, controls) {
            if (!this.lastCameraPosition) return;
            
            const posDiff = camera.position.distanceToSquared(this.lastCameraPosition);
            const targetDiff = controls.target.distanceToSquared(this.lastCameraTarget);
            
            if (posDiff > 0.01 || targetDiff > 0.01) {
                this.lastCameraPosition.copy(camera.position);
                this.lastCameraTarget.copy(controls.target);
                this.needsUpdate = true;
            }
        },
        
        // Mark labels as needing update (call when nodes change)
        markDirty() {
            this.needsUpdate = true;
        },
        
        // Run decluttering - only when needed
        update(camera, nodesMap) {
            this.frameCounter++;
            
            // Only run every N frames unless marked dirty
            if (!this.needsUpdate && this.frameCounter % CONFIG.LABELS.declutterInterval !== 0) {
                return;
            }
            
            this.needsUpdate = false;
            const cfg = CONFIG.LABELS;
            const visibleLabels = [];
            
            nodesMap.forEach(mesh => {
                if (!mesh.visible || !mesh.userData.labelSprite) return;
                
                const sprite = mesh.userData.labelSprite;
                const pos = mesh.position.clone().project(camera);
                
                // Behind camera
                if (pos.z > 1) {
                    sprite.material.opacity = Math.max(0, sprite.material.opacity - cfg.fadeSpeed);
                    return;
                }
                
                const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                const dist = camera.position.distanceTo(mesh.position);
                const textLength = (mesh.userData.label || '').length;
                const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                
                const depth = mesh.userData.depth || 0;
                const isSelected = mesh.userData.selected;
                const isRoot = mesh.userData.level === 0;
                const priority = isSelected ? cfg.selectedPriority : 
                                (isRoot ? cfg.rootPriority : cfg.basePriority - depth * cfg.depthPenalty);
                
                visibleLabels.push({
                    sprite,
                    x: screenX,
                    y: screenY,
                    width: labelWidth,
                    height: labelHeight,
                    priority,
                    baseOpacity: mesh.userData.labelBaseOpacity || 1,
                    shouldShow: true
                });
            });
            
            // Sort by priority (highest first)
            visibleLabels.sort((a, b) => b.priority - a.priority);
            
            // Hide overlapping labels (lower priority ones)
            for (let i = 0; i < visibleLabels.length; i++) {
                if (!visibleLabels[i].shouldShow) continue;
                
                for (let j = i + 1; j < visibleLabels.length; j++) {
                    if (!visibleLabels[j].shouldShow) continue;
                    
                    const a = visibleLabels[i];
                    const b = visibleLabels[j];
                    
                    const overlapX = Math.abs(a.x - b.x) < (a.width + b.width) / 2 + cfg.padding;
                    const overlapY = Math.abs(a.y - b.y) < (a.height + b.height) / 2 + cfg.padding;
                    
                    if (overlapX && overlapY) {
                        visibleLabels[j].shouldShow = false;
                    }
                }
            }
            
            // Apply smooth fade transitions
            visibleLabels.forEach(label => {
                const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
                const currentOpacity = label.sprite.material.opacity;
                label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * cfg.fadeSpeed;
                if (label.sprite.material.opacity < cfg.minOpacity) {
                    label.sprite.material.opacity = 0;
                }
            });
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // UTILITIES
    // ═══════════════════════════════════════════════════════════════════
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    
    function throttle(fn, delay) {
        let lastCall = 0;
        let timeoutId = null;
        return function(...args) {
            const now = Date.now();
            const remaining = delay - (now - lastCall);
            if (remaining <= 0) {
                if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
                lastCall = now;
                fn.apply(this, args);
            } else if (!timeoutId) {
                timeoutId = setTimeout(() => {
                    lastCall = Date.now();
                    timeoutId = null;
                    fn.apply(this, args);
                }, remaining);
            }
        };
    }
    
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    function easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    // ═══════════════════════════════════════════════════════════════════
    // HAPTIC FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const haptic = {
        light: () => navigator.vibrate?.(10),
        medium: () => navigator.vibrate?.(20),
        heavy: () => navigator.vibrate?.([30, 50, 30]),
        success: () => navigator.vibrate?.([10, 50, 10, 50, 10]),
        error: () => navigator.vibrate?.([50, 100, 50])
    };

    // ═══════════════════════════════════════════════════════════════════
    // AUDIO FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const audio = {
        ctx: null,
        getCtx() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            return this.ctx;
        },
        play(freq, duration = 0.1, type = 'sine', volume = 0.1) {
            try {
                const ctx = this.getCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = volume;
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {}
        },
        pop: () => audio.play(600, 0.08),
        expand: () => audio.play(800, 0.1),
        collapse: () => audio.play(400, 0.1),
        select: () => audio.play(500, 0.05),
        success: () => { audio.play(523, 0.1); setTimeout(() => audio.play(659, 0.1), 100); },
        error: () => audio.play(200, 0.2)
    };

    // ═══════════════════════════════════════════════════════════════════
    // CELEBRATION SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    function createCelebration(x, y, color = '#7c3aed', count = 6) {
        const container = document.body;
        
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.className = 'celebration-particle';
            
            const size = 3 + Math.random() * 4;
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
            const velocity = 40 + Math.random() * 60;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity;
            
            particle.style.cssText = `
                left: ${x}px;
                top: ${y}px;
                width: ${size}px;
                height: ${size}px;
                background: ${color};
                opacity: 0.7;
            `;
            
            container.appendChild(particle);
            
            let px = x, py = y, opacity = 0.7;
            const gravity = 100;
            const startTime = performance.now();
            const duration = 400 + Math.random() * 200;
            
            function animate(time) {
                const elapsed = (time - startTime) / 1000;
                const progress = Math.min(elapsed / (duration / 1000), 1);
                
                px += vx * 0.016;
                py += vy * 0.016 + gravity * elapsed * 0.016;
                opacity = 0.7 * (1 - progress);
                
                particle.style.left = px + 'px';
                particle.style.top = py + 'px';
                particle.style.opacity = opacity;
                particle.style.transform = `scale(${1 - progress * 0.3})`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // TOAST NOTIFICATIONS
    // ═══════════════════════════════════════════════════════════════════
    function showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: '✓',
            error: '✕',
            info: 'ℹ'
        };
        
        toast.innerHTML = `<span>${icons[type] || ''}</span> ${escapeHTML(message)}`;
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('exiting');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }

    // ═══════════════════════════════════════════════════════════════════
    // THEME MANAGER
    // ═══════════════════════════════════════════════════════════════════
    const themeManager = {
        current: 'coral',
        themes: ['sandstone', 'coral', 'ember', 'frost', 'obsidian'],
        
        init() {
            const saved = localStorage.getItem(CONFIG.THEME_KEY);
            if (saved && this.themes.includes(saved)) {
                this.set(saved, true); // Skip color update on init
            } else {
                // Default to sandstone for new users
                this.set('coral', true);
            }
        },
        
        set(theme, skipColorUpdate = false) {
            const oldTheme = this.current;
            this.current = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem(CONFIG.THEME_KEY, theme);
            
            // Update theme picker UI
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.toggle('active', opt.dataset.theme === theme);
            });
            
            // Update node colors when switching themes (different palettes)
            if (!skipColorUpdate && oldTheme !== theme) {
                updateNodeColorsForTheme(oldTheme, theme);
            }
            
            bus.emit('theme:changed', { theme, oldTheme });
        },
        
        toggle() {
            const currentIndex = this.themes.indexOf(this.current);
            const nextIndex = (currentIndex + 1) % this.themes.length;
            this.set(this.themes[nextIndex]);
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // THREE.JS SCENE
    // ═══════════════════════════════════════════════════════════════════
    let scene, camera, renderer, controls;
    let nodes = new Map();
    let connections = [];
    let selectedNode = null;
    let currentContextId = null;
    let focusMode = false;
    let particleSystem = null;
    let cameraTargetGoal = new THREE.Vector3(0, 0, 0);
    let userInteracting = false;
    
    // Camera arc animation
    let cameraArcAnimation = null;
    let autoCameraEnabled = true;

    function initScene() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const isMobile = window.innerWidth <= 768;
        camera.position.set(0, isMobile ? 18 : 14, isMobile ? 50 : 40);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Add click handler for node selection
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        
        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.12;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 8;
        controls.maxDistance = 80;
        controls.enablePan = true;
        controls.panSpeed = 0.8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.enableZoom = false; // Disable default zoom, we handle it custom
        
        // Track user interaction with controls
        controls.addEventListener('start', () => { 
            userInteracting = true; 
            // Don't cancel arc animation - let it complete
        });
        controls.addEventListener('end', () => { 
            userInteracting = false;
            cameraTargetGoal.copy(controls.target); // Sync after interaction
        });
        
        // Zoom to pointer - custom zoom behavior
        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Cancel any arc animation
            cameraArcAnimation = null;
            
            // Get mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a ray from camera through mouse position
            const zoomRaycaster = new THREE.Raycaster();
            zoomRaycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            // Find point on a plane at the target distance
            const targetDistance = camera.position.distanceTo(controls.target);
            const zoomPoint = zoomRaycaster.ray.at(targetDistance, new THREE.Vector3());
            
            // Calculate zoom factor
            const zoomSpeed = 0.001;
            const zoomDelta = event.deltaY * zoomSpeed;
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, currentDistance * (1 + zoomDelta)));
            
            // Move target towards zoom point while zooming in, away while zooming out
            const zoomFactor = 1 - (newDistance / currentDistance);
            const targetShift = new THREE.Vector3().subVectors(zoomPoint, controls.target).multiplyScalar(zoomFactor * 0.5);
            controls.target.add(targetShift);
            cameraTargetGoal.copy(controls.target); // Sync the goal
            
            // Update camera distance
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            
            controls.update();
        }, { passive: false });
        
        // Pinch-to-zoom for mobile
        let initialPinchDistance = null;
        let initialCameraDistance = null;
        
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraDistance = camera.position.distanceTo(controls.target);
            }
        }, { passive: true });
        
        renderer.domElement.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2 && initialPinchDistance !== null) {
                event.preventDefault();
                
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const pinchRatio = initialPinchDistance / currentPinchDistance;
                const newDistance = Math.max(
                    controls.minDistance, 
                    Math.min(controls.maxDistance, initialCameraDistance * pinchRatio)
                );
                
                // Update camera distance
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                
                controls.update();
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', () => {
            initialPinchDistance = null;
            initialCameraDistance = null;
        }, { passive: true });
        
        // Ambient particles
        createAmbientParticles();
        
        // Lighting - bright for accurate colors
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.3);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);
        
        // Build initial scene
        currentContextId = store.data.id;
        
        // Initialize label system with camera tracking
        LabelSystem.init(camera, controls);
        
        buildScene();
        
        // Resize handler
        window.addEventListener('resize', throttle(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, 100));
        
        // Start animation loop
        animate();
    }

    function createAmbientParticles() {
        const particleCount = 200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            
            // Subtle purple/blue tints
            colors[i * 3] = 0.5 + Math.random() * 0.3;
            colors[i * 3 + 1] = 0.3 + Math.random() * 0.3;
            colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
            
            sizes[i] = 0.5 + Math.random() * 1.5;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }

    // Count all descendants of a node
    function countDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        let count = data.children.length;
        data.children.forEach(child => {
            count += countDescendants(child);
        });
        return count;
    }
    
    // Count visible (expanded) descendants
    function countVisibleDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        if (!store.expandedNodes.has(data.id)) return 0;
        
        let count = data.children.length;
        data.children.forEach(child => {
            count += countVisibleDescendants(child);
        });
        return count;
    }
    
    // Get max depth of expanded descendants
    function getExpandedDepth(data, currentDepth = 0) {
        if (!data.children || data.children.length === 0) return currentDepth;
        if (!store.expandedNodes.has(data.id)) return currentDepth;
        
        let maxDepth = currentDepth;
        data.children.forEach(child => {
            const childDepth = getExpandedDepth(child, currentDepth + 1);
            if (childDepth > maxDepth) maxDepth = childDepth;
        });
        return maxDepth;
    }

    function calculatePositions(data, parentPos = [0, 0, 0], level = 0, parentAngle = 0, total = 1, index = 0) {
        data.level = level;
        
        // Size based on level - smaller for deeper nodes
        if (level === 0) data.size = CONFIG.NODE_SIZES.root;
        else if (level === 1) data.size = CONFIG.NODE_SIZES.level1;
        else if (level === 2) data.size = CONFIG.NODE_SIZES.level2;
        else data.size = Math.max(0.25, CONFIG.NODE_SIZES.default - (level - 3) * 0.06);
        
        // Check descendants for spacing
        const hasChildren = data.children && data.children.length > 0;
        const childCount = hasChildren ? data.children.length : 0;
        const isExpanded = store.expandedNodes.has(data.id);
        const visibleDescendants = countVisibleDescendants(data);
        const expandedDepth = getExpandedDepth(data);
        
        // Position calculation
        let baseRadius;
        if (level === 0) {
            baseRadius = 0;
        } else if (level === 1) {
            // Level 1: Grow proportionally with descendants
            baseRadius = CONFIG.LAYOUT.level1Radius;
            baseRadius += Math.max(0, (total - 4) * 0.8);
            // Push based on visible descendants
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.min(visibleDescendants * 0.25, 7);
            }
            // Extra push for deep branches
            if (expandedDepth > 1) {
                baseRadius += Math.min((expandedDepth - 1) * 1.2, 5);
            }
        } else if (level === 2) {
            // Level 2: More aggressive spacing to spread out
            baseRadius = CONFIG.LAYOUT.level2Radius;
            baseRadius += Math.max(0, (total - 2) * 0.8);
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.min(visibleDescendants * 0.5, 8);
            }
        } else {
            // Level 3+: Scale based on siblings and descendants
            baseRadius = Math.max(2.5, CONFIG.LAYOUT.level3Radius - (level - 3) * 0.2);
            baseRadius += Math.max(0, (total - 2) * 0.6);
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.min(visibleDescendants * 0.4, 5);
            }
        }
        
        if (level === 0) {
            data.position = [0, 0, 0];
            data.basePosition = [0, 0, 0];
            data.expandedPosition = [0, 0, 0];
            data.branchAngle = 0;
        } else if (level === 1) {
            // Spread evenly around center
            const angleStep = (Math.PI * 2) / Math.max(total, 1);
            const startAngle = -Math.PI / 2;
            const angle = startAngle + angleStep * index;
            const verticalOffset = (index % 2 === 0 ? 0.3 : -0.3) + (index % 3 - 1) * 0.2;
            
            data.basePosition = [Math.cos(angle) * baseRadius, verticalOffset, Math.sin(angle) * baseRadius];
            data.expandedPosition = [...data.basePosition];
            data.position = [...data.basePosition];
            data.branchAngle = angle;
        } else {
            // Branch outward from parent
            // Spread angle scales with number of siblings
            const baseSpread = Math.PI * 0.5;
            const siblingSpread = Math.min(total * 0.15, Math.PI * 0.4);
            const spreadAngle = Math.min(baseSpread + siblingSpread, Math.PI * 1.1);
            const halfSpread = spreadAngle / 2;
            const outwardAngle = Math.atan2(parentPos[2], parentPos[0]);
            
            let childAngle;
            if (total === 1) {
                childAngle = outwardAngle;
            } else {
                childAngle = outwardAngle - halfSpread + (spreadAngle / (total - 1)) * index;
            }
            
            // Vertical spread scales with siblings
            const verticalSpacing = 0.4 + Math.min(total * 0.05, 0.3);
            const verticalOffset = (index - (total - 1) / 2) * verticalSpacing;
            
            data.basePosition = [
                parentPos[0] + Math.cos(childAngle) * baseRadius,
                parentPos[1] + verticalOffset,
                parentPos[2] + Math.sin(childAngle) * baseRadius
            ];
            data.expandedPosition = [...data.basePosition];
            data.position = [...data.basePosition];
            data.branchAngle = childAngle;
        }
        
        // Recursively process children
        if (data.children) {
            data.children.forEach((child, i) => {
                calculatePositions(child, data.basePosition, level + 1, data.branchAngle || 0, data.children.length, i);
            });
        }
        
        return data;
    }

    function createNodeMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            emissive: new THREE.Color(color),
            emissiveIntensity: 0.3,
            roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 1
        });
    }

    function createLabelSprite(text, color, hasLink = false) {
        const labelText = text || 'Untitled';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = CONFIG.LABELS.fontSize;
        const padding = CONFIG.LABELS.spritePadding;
        
        // Add extra width for link icon if needed
        const linkIconSize = hasLink ? 16 : 0;
        const linkPadding = hasLink ? 6 : 0;
        
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        const textWidth = ctx.measureText(labelText).width;
        const width = textWidth + padding * 2 + linkIconSize + linkPadding;
        const height = fontSize + padding * 1.4;
        
        canvas.width = width * 2;
        canvas.height = height * 2;
        ctx.scale(2, 2);
        
        // Background - check for dark themes
        const theme = document.documentElement.getAttribute('data-theme') || 'coral';
        const isDark = ['obsidian'].includes(theme);
        
        ctx.fillStyle = isDark ? 'rgba(18, 18, 26, 0.9)' : 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(1, 1, width - 2, height - 2, 14);
        ctx.fill();
        ctx.stroke();
        
        // Link icon if has link
        if (hasLink) {
            ctx.save();
            ctx.strokeStyle = color || '#6366f1';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            
            const iconX = padding + 2;
            const iconY = height / 2;
            const iconSize = 10;
            
            // Draw link icon (two interlocking chain links)
            ctx.beginPath();
            ctx.moveTo(iconX + 3, iconY - 2);
            ctx.lineTo(iconX + 6, iconY - 5);
            ctx.arc(iconX + 8, iconY - 3, 3, -Math.PI * 0.75, Math.PI * 0.25);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(iconX + 9, iconY + 2);
            ctx.lineTo(iconX + 6, iconY + 5);
            ctx.arc(iconX + 4, iconY + 3, 3, Math.PI * 0.25, -Math.PI * 0.75, true);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Text
        ctx.fillStyle = isDark ? '#ffffff' : '#1f2937';
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const textX = hasLink ? (width + linkIconSize + linkPadding) / 2 : width / 2;
        ctx.fillText(labelText, textX, height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: true,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        const aspect = width / height;
        const spriteHeight = 0.5;
        sprite.scale.set(spriteHeight * aspect, spriteHeight, 1);
        
        return sprite;
    }

    function createNodeMesh(data, parent = null) {
        // Geometry
        const geometry = new THREE.SphereGeometry(data.size, 32, 32);
        const material = createNodeMaterial(data.color);
        const mesh = new THREE.Mesh(geometry, material);
        
        // Position
        const isExpanded = store.expandedNodes.has(data.id);
        const startPos = isExpanded && data.expandedPosition ? data.expandedPosition : data.position;
        mesh.position.set(...startPos);
        
        // User data
        mesh.userData = { ...data, parent };
        mesh.userData.isExpanded = isExpanded;
        mesh.userData.baseSize = 1; // Store base scale for importance adjustment
        mesh.userData.importance = data.importance || 1;
        
        // Apply importance scale
        const importanceScale = data.importance || 1;
        mesh.scale.set(importanceScale, importanceScale, importanceScale);
        
        mesh.userData.spring = {
            velocity: new THREE.Vector3(),
            target: new THREE.Vector3(...startPos),
            scaleVelocity: 0,
            scaleTarget: importanceScale,
            floatOffset: Math.random() * Math.PI * 2,
            floatSpeed: 0.15 + Math.random() * 0.1
        };
        
        // Outline
        const outlineGeometry = new THREE.SphereGeometry(data.size * 1.03, 32, 32);
        const outlineMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color(data.color).multiplyScalar(0.3),
            side: THREE.BackSide,
            transparent: true,
            opacity: 1
        });
        const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
        outline.position.copy(mesh.position);
        outline.scale.set(importanceScale, importanceScale, importanceScale);
        scene.add(outline);
        mesh.userData.outlineMesh = outline;
        
        // Label - with link indicator if this node has a link
        const hasLink = !!data.link;
        const label = createLabelSprite(data.label, data.color, hasLink);
        const labelOffset = data.level === 0 ? -data.size - 0.6 : -data.size - 0.35;
        label.position.set(0, labelOffset, 0);
        label.visible = true;  // All labels visible by default
        mesh.add(label);
        mesh.userData.labelSprite = label;
        
        // Store link data if present
        if (data.link) {
            mesh.userData.link = data.link;
        }
        
        scene.add(mesh);
        
        // Visibility for collapsed nodes
        const parentIsExpanded = parent && store.expandedNodes.has(parent.id);
        if (data.level >= 2 && !parentIsExpanded) {
            mesh.visible = false;
            outline.visible = false;
            label.visible = false;
            mesh.userData.collapsed = true;
        }
        
        // Connection to parent
        if (parent) {
            const connection = createConnection(parent, data, mesh);
            if (connection) {
                mesh.userData.connectionLine = connection;
                if (data.level >= 2 && !parentIsExpanded) {
                    connection.visible = false;
                }
            }
        }
        
        nodes.set(data.id, mesh);
        
        // Create children
        if (data.children) {
            data.children.forEach(child => createNodeMesh(child, data));
        }
        
        return mesh;
    }

    function createConnection(parentData, childData, childMesh) {
        const parentMesh = nodes.get(parentData.id);
        if (!parentMesh) return null;
        
        // Straight line from parent to child
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        const material = new THREE.LineBasicMaterial({
            color: new THREE.Color(childData.color).multiplyScalar(0.6),
            transparent: true,
            opacity: 0.6,
            linewidth: 2
        });
        
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        connections.push(line);
        
        return line;
    }

    function updateConnection(childMesh, parentMesh) {
        const line = childMesh.userData.connectionLine;
        if (!line) return;
        
        // Straight line update
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        line.geometry.setFromPoints(points);
    }

    function buildScene() {
        // Clear existing
        nodes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.userData.outlineMesh) {
                scene.remove(mesh.userData.outlineMesh);
                mesh.userData.outlineMesh.geometry.dispose();
                mesh.userData.outlineMesh.material.dispose();
            }
            if (mesh.userData.labelSprite) {
                mesh.userData.labelSprite.material.map?.dispose();
                mesh.userData.labelSprite.material.dispose();
            }
            mesh.geometry.dispose();
            mesh.material.dispose();
        });
        
        connections.forEach(conn => {
            scene.remove(conn);
            conn.geometry.dispose();
            conn.material.dispose();
        });
        
        nodes.clear();
        connections.length = 0;
        selectedNode = null;
        
        // Get context node
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) {
            currentContextId = store.data.id;
            return buildScene();
        }
        
        // Calculate positions and create meshes
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        createNodeMesh(processedData);
        
        // Restore expanded state
        store.expandedNodes.forEach(nodeId => {
            const mesh = nodes.get(nodeId);
            if (mesh && mesh.userData.children?.length > 0) {
                expandNode(mesh, false);
            }
        });
        
        updateDepthIndicator();
        
        // Mark labels for declutter recalculation
        LabelSystem.markDirty();
    }
    
    // Smoothly update node positions without rebuilding scene
    function updateNodePositions() {
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) return;
        
        // Recalculate positions
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        
        // Update spring targets for existing visible nodes
        function updatePositionsRecursive(data) {
            const mesh = nodes.get(data.id);
            if (mesh && mesh.visible) {
                const newPos = new THREE.Vector3(data.position[0], data.position[1], data.position[2]);
                mesh.userData.spring.target.copy(newPos);
                mesh.userData.basePosition = [...data.position];
            }
            
            if (data.children) {
                data.children.forEach(child => updatePositionsRecursive(child));
            }
        }
        
        updatePositionsRecursive(processedData);
    }

    function updateLabelsForTheme() {
        // Just update label sprite textures without rebuilding the scene
        nodes.forEach(mesh => {
            if (mesh.userData.labelSprite) {
                const oldSprite = mesh.userData.labelSprite;
                const newSprite = createLabelSprite(mesh.userData.label, mesh.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                
                // Labels are children of mesh, not scene
                mesh.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                
                mesh.add(newSprite);
                mesh.userData.labelSprite = newSprite;
            }
        });
    }

    function expandNode(mesh, animate = true) {
        if (!mesh.userData.children?.length) return;
        if (mesh.userData.isExpanded) return;
        
        mesh.userData.isExpanded = true;
        store.expandedNodes.add(mesh.userData.id);
        
        // Store old positions of all visible nodes before rebuild
        const oldPositions = new Map();
        nodes.forEach((m, id) => {
            if (m.visible) {
                oldPositions.set(id, m.position.clone());
            }
        });
        
        // Rebuild scene to recalculate positions with proper spacing
        buildScene();
        
        // Re-get the mesh after rebuild
        const newMesh = nodes.get(mesh.userData.id);
        if (newMesh && animate) {
            // Restore old positions for existing nodes so they animate smoothly
            oldPositions.forEach((oldPos, id) => {
                const m = nodes.get(id);
                if (m && m.visible) {
                    m.position.copy(oldPos);
                    if (m.userData.outlineMesh) {
                        m.userData.outlineMesh.position.copy(oldPos);
                    }
                }
            });
            
            // Start children from parent position for animation
            newMesh.userData.children?.forEach((childData) => {
                const childMesh = nodes.get(childData.id);
                if (childMesh) {
                    const parentPos = newMesh.position.clone();
                    childMesh.position.copy(parentPos);
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.position.copy(parentPos);
                    const importance = childMesh.userData.importance || 1;
                    childMesh.scale.set(0.5 * importance, 0.5 * importance, 0.5 * importance);
                    childMesh.material.opacity = 0.3;
                }
            });
        }
        
        if (animate) {
            audio.expand();
            haptic.light();
        }
    }
    
    function expandAllDescendants(mesh, animate = true, isFirst = true) {
        if (!mesh.userData.children?.length) return;
        
        // First expand this node's direct children
        if (!mesh.userData.isExpanded) {
            expandNode(mesh, animate && isFirst);
        }
        
        // Then recursively expand all descendants with staggered delay
        mesh.userData.children.forEach((childData, i) => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.userData.children?.length > 0) {
                setTimeout(() => {
                    expandAllDescendants(childMesh, animate, false);
                }, animate ? 80 * (i + 1) : 0);
            }
        });
        
        if (animate && isFirst) {
            showToast('Expanded all descendants', 'info');
        }
    }

    function collapseNode(mesh, animate = true, depth = 0) {
        if (!mesh.userData.children?.length) return 0;
        if (!mesh.userData.isExpanded) return 0;
        
        mesh.userData.isExpanded = false;
        store.expandedNodes.delete(mesh.userData.id);
        
        const parentPos = mesh.position.clone();
        const childCount = mesh.userData.children.length;
        const staggerDelay = CONFIG.TIMING.collapseStagger;
        const hideDelay = CONFIG.TIMING.collapseHideDelay;
        
        // First recursively collapse all grandchildren and get max delay
        let maxNestedDelay = 0;
        mesh.userData.children.forEach((childData) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            if (childMesh.userData.isExpanded) {
                const nestedDelay = collapseNode(childMesh, animate, depth + 1);
                maxNestedDelay = Math.max(maxNestedDelay, nestedDelay);
            }
        });
        
        // Wait for nested collapses to finish, then collapse this level
        const baseDelay = maxNestedDelay;
        const thisLevelDuration = childCount * staggerDelay + hideDelay;
        
        mesh.userData.children.forEach((childData, index) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            childMesh.userData.collapsed = true;
            childMesh.userData.collapseId = Date.now(); // Track this collapse operation
            const thisCollapseId = childMesh.userData.collapseId;
            
            const itemDelay = baseDelay + index * staggerDelay;
            
            if (animate) {
                setTimeout(() => {
                    // Only proceed if this collapse wasn't cancelled by an expand
                    if (childMesh.userData.collapseId !== thisCollapseId) return;
                    
                    // Hide connection line and label immediately
                    if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;
                    if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                    
                    // Animate back to parent position
                    childMesh.userData.spring.target.copy(parentPos);
                    childMesh.userData.spring.scaleTarget = 0.1;
                }, itemDelay);
                
                // Hide node after animation completes
                setTimeout(() => {
                    // Only hide if this collapse wasn't cancelled
                    if (childMesh.userData.collapseId !== thisCollapseId) return;
                    if (!childMesh.userData.collapsed) return;
                    
                    childMesh.visible = false;
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                }, itemDelay + hideDelay);
            } else {
                childMesh.visible = false;
                if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;
            }
        });
        
        if (animate && depth === 0) {
            audio.collapse();
            haptic.light();
            
            // Smoothly update positions after collapse animation (don't rebuild)
            const totalDuration = baseDelay + thisLevelDuration + 100;
            setTimeout(() => updateNodePositions(), totalDuration);
        }
        
        // Return total time for this level and nested
        return baseDelay + thisLevelDuration;
    }

    function toggleExpand(mesh) {
        if (mesh.userData.isExpanded) {
            collapseNode(mesh);
        } else {
            expandNode(mesh);
        }
    }

    function selectNode(mesh, isDoubleClick = false) {
        const nodeId = mesh.userData.id;
        const wasAlreadySelected = selectedNode === mesh;
        
        // Deselect previous
        if (selectedNode && selectedNode !== mesh) {
            selectedNode.userData.selected = false;
        }
        
        // Check for link node double-click - open URL
        if (isDoubleClick && mesh.userData.link?.url) {
            window.open(mesh.userData.link.url, '_blank');
            showToast('Opening link...', 'info');
            // Still select the node but don't expand
            selectedNode = mesh;
            mesh.userData.selected = true;
            store.selectedNodeId = mesh.userData.id;
            audio.select();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Expand/collapse logic:
        // - Single click on collapsed node: expand direct children only
        // - Single click on expanded node: collapse all descendants
        // - Double click: expand all layers of children
        if (mesh.userData.children?.length > 0) {
            if (isDoubleClick) {
                // Double click: expand all descendants
                expandAllDescendants(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else if (!mesh.userData.isExpanded) {
                // Single click on collapsed: expand direct children only
                expandNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else {
                // Single click on expanded: collapse all descendants
                collapseNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            }
        }
        
        selectedNode = mesh;
        mesh.userData.selected = true;
        store.selectedNodeId = mesh.userData.id;
        
        // Skip camera animation if auto-camera is disabled
        if (!autoCameraEnabled) {
            audio.select();
            haptic.light();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Start smooth camera animation - horizontal arc rotation
        // Use spring target position (final position) rather than current animated position
        const nodePos = mesh.userData.spring?.target?.clone() || mesh.position.clone();
        
        // Check if node has children - zoom out more if it does
        const nodeData = store.findNode(mesh.userData.id);
        const hasChildren = nodeData?.children?.length > 0;
        const childCount = nodeData?.children?.length || 0;
        
        // Get current camera spherical coordinates relative to current target
        const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
        const currentRadius = currentOffset.length();
        const currentTheta = Math.atan2(currentOffset.x, currentOffset.z); // horizontal angle
        const currentPhi = Math.acos(Math.max(-1, Math.min(1, currentOffset.y / currentRadius))); // vertical angle
        
        // Calculate target angle - where the node is
        const nodeAngle = Math.atan2(nodePos.x, nodePos.z);
        const nodeDist2D = Math.sqrt(nodePos.x * nodePos.x + nodePos.z * nodePos.z);
        
        // End target - look directly at the selected node (centered)
        const endTarget = nodePos.clone();
        cameraTargetGoal.copy(endTarget);
        
        // Calculate end camera angle - offset so root node appears to the RIGHT of selected node
        // Subtract angle offset so we're viewing from an angle, not straight through the root
        const endTheta = nodeDist2D > 0.5 ? nodeAngle - Math.PI * 0.35 : currentTheta;
        
        // Zoom out more if node has children - scale based on child count
        const isMobile = window.innerWidth <= 768;
        const baseRadius = isMobile ? 22 : 18;
        const childZoomBonus = hasChildren ? Math.min(childCount * 4, 20) : 0; // up to 20 extra for many children
        const endRadius = Math.max(baseRadius + childZoomBonus, nodeDist2D + 14 + childZoomBonus);
        const endPhi = Math.PI * 0.35; // consistent downward viewing angle
        
        // Calculate shortest angle difference for arc boost
        let angleDiff = endTheta - currentTheta;
        if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        // Arc boost - how much to zoom out at midpoint (more for bigger rotations)
        const arcBoost = Math.abs(angleDiff) > 0.5 ? 3 : 1;
        
        cameraArcAnimation = {
            startTime: performance.now(),
            duration: 800, // Faster, smoother
            startTarget: controls.target.clone(),
            endTarget: endTarget,
            startTheta: currentTheta,
            endTheta: endTheta,
            startPhi: currentPhi,
            endPhi: endPhi,
            startRadius: currentRadius,
            endRadius: endRadius,
            arcBoost: arcBoost,
            useSpherical: true,
            startCameraPos: camera.position.clone()
        };
        
        audio.select();
        haptic.light();
        
        bus.emit('node:selected', { data: mesh.userData });
    }

    function deselectNode() {
        if (selectedNode) {
            selectedNode.userData.selected = false;
            selectedNode = null;
            store.selectedNodeId = null;
        }
        bus.emit('node:deselected');
    }

    function diveIntoNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node || !node.children?.length) return;
        
        currentContextId = nodeId;
        buildScene();
        
        // Camera animation
        const mesh = nodes.get(nodeId);
        if (mesh) {
            const targetPos = new THREE.Vector3(0, 8, 25);
            const startPos = camera.position.clone();
            const duration = 800;
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = easeOutCubic(progress);
                
                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.set(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            animateCamera();
        }
        
        audio.expand();
        haptic.medium();
        showToast(`Diving into "${node.label}"`, 'info');
    }

    function surfaceUp() {
        const currentNode = store.findNode(currentContextId);
        if (!currentNode || currentContextId === store.data.id) return;
        
        const parent = store.findParent(currentContextId);
        if (!parent) {
            currentContextId = store.data.id;
        } else {
            currentContextId = parent.id;
        }
        
        buildScene();
        audio.collapse();
        haptic.medium();
    }

    function updateDepthIndicator() {
        const indicator = document.getElementById('depth-indicator');
        const pathEl = document.getElementById('depth-path');
        
        if (currentContextId === store.data.id) {
            indicator.classList.remove('active');
            return;
        }
        
        const path = store.getPath(currentContextId);
        if (path.length === 0) {
            indicator.classList.remove('active');
            return;
        }
        
        pathEl.innerHTML = path.map((n, i) => {
            const isLast = i === path.length - 1;
            return `<span class="depth-item ${isLast ? 'current' : ''}">${escapeHTML(n.label)}</span>` +
                   (isLast ? '' : '<span style="margin: 0 4px;">›</span>');
        }).join('');
        
        indicator.classList.add('active');
    }

    function resetCamera() {
        const isMobile = window.innerWidth <= 768;
        const targetPos = new THREE.Vector3(0, isMobile ? 12 : 8, isMobile ? 35 : 25);
        const startPos = camera.position.clone();
        const duration = 600;
        const startTime = Date.now();
        
        // Reset camera target goal to origin
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function zoomToFitMap(extraZoom = 0) {
        // Calculate bounds of all visible nodes
        let maxDist = 0;
        nodes.forEach(mesh => {
            if (mesh.visible) {
                const dist = mesh.position.length();
                maxDist = Math.max(maxDist, dist);
            }
        });
        
        const isMobile = window.innerWidth <= 768;
        // Zoom out enough to see all nodes plus some padding
        const targetDist = Math.max(maxDist * 2.5 + extraZoom, isMobile ? 40 : 30);
        const targetPos = new THREE.Vector3(0, targetDist * 0.4, targetDist);
        const startPos = camera.position.clone();
        const duration = 800;
        const startTime = Date.now();
        
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function expandAll() {
        const isMobile = window.innerWidth <= 768;
        
        // Get all nodes that need expanding, sorted by level (shallowest first)
        const toExpand = [];
        nodes.forEach(mesh => {
            if (mesh.userData.children?.length && !mesh.userData.isExpanded) {
                toExpand.push(mesh);
            }
        });
        
        if (toExpand.length === 0) {
            showToast('All nodes already expanded', 'info');
            return;
        }
        
        // Sort by level (shallowest first)
        toExpand.sort((a, b) => (a.userData.level || 0) - (b.userData.level || 0));
        
        // Slower stagger on mobile to reduce lag
        const staggerTime = isMobile ? 150 : 60;
        
        // Expand with staggered animation
        toExpand.forEach((mesh, index) => {
            setTimeout(() => {
                if (!mesh.userData.isExpanded) {
                    expandNode(mesh, true);
                }
            }, index * staggerTime);
        });
        
        // Zoom out to see expanded map
        const totalDuration = toExpand.length * staggerTime;
        setTimeout(() => {
            zoomToFitMap(10);
        }, Math.min(totalDuration + 200, 1500));
        
        showToast('Expanding all nodes...', 'success');
    }

    function collapseAll() {
        const isMobile = window.innerWidth <= 768;
        
        // Get all expanded nodes, sorted by level (deepest first for proper collapse order)
        // Skip root node (level 0) - keep level 1 nodes visible but collapse their children
        const toCollapse = [];
        nodes.forEach(mesh => {
            // Only collapse nodes that are expanded AND have level >= 1 (not the root)
            if (mesh.userData.isExpanded && (mesh.userData.level || 0) >= 1) {
                toCollapse.push(mesh);
            }
        });
        
        if (toCollapse.length === 0) {
            showToast('Already collapsed', 'info');
            return;
        }
        
        // Sort by level descending (deepest first)
        toCollapse.sort((a, b) => (b.userData.level || 0) - (a.userData.level || 0));
        
        // Slower stagger on mobile
        const staggerTime = isMobile ? 100 : 50;
        
        // Collapse with staggered animation
        toCollapse.forEach((mesh, index) => {
            setTimeout(() => {
                if (mesh.userData.isExpanded) {
                    collapseNode(mesh, true);
                }
            }, index * staggerTime);
        });
        
        // Zoom to fit after collapse
        const totalDuration = toCollapse.length * staggerTime;
        setTimeout(() => {
            zoomToFitMap(0);
        }, Math.min(totalDuration + 500, 2000));
        
        showToast('Collapsing nodes...', 'success');
    }

    // Label decluttering - hide labels that overlap with others
    function declutterLabels() {
        const visibleLabels = [];
        const padding = 12; // pixels of padding between labels
        
        // Collect all visible labels with their screen positions
        nodes.forEach(mesh => {
            if (!mesh.visible || !mesh.userData.labelSprite) return;
            
            const sprite = mesh.userData.labelSprite;
            const pos = mesh.position.clone();
            pos.project(camera);
            
            // Skip if behind camera
            if (pos.z > 1) {
                sprite.material.opacity = 0;
                return;
            }
            
            // Convert to screen coordinates
            const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            
            // Get approximate label size in screen pixels based on text length
            const dist = camera.position.distanceTo(mesh.position);
            const textLength = (mesh.userData.label || '').length;
            const cfg = CONFIG.LABELS;
            const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            
            // Priority: selected nodes > root > by depth (shallower = higher priority)
            const depth = mesh.userData.depth || 0;
            const isSelected = mesh.userData.selected;
            const isRoot = mesh.userData.id === 'root';
            const priority = isSelected ? cfg.selectedPriority : (isRoot ? cfg.rootPriority : cfg.basePriority - depth * cfg.depthPenalty);
            
            visibleLabels.push({
                sprite,
                mesh,
                x: screenX,
                y: screenY,
                width: labelWidth,
                height: labelHeight,
                priority,
                baseOpacity: mesh.userData.labelBaseOpacity || 1,
                shouldShow: true
            });
        });
        
        // Sort by priority (higher priority labels get shown first)
        visibleLabels.sort((a, b) => b.priority - a.priority);
        
        // Check for overlaps and hide lower priority labels
        for (let i = 0; i < visibleLabels.length; i++) {
            if (!visibleLabels[i].shouldShow) continue;
            
            const labelA = visibleLabels[i];
            
            for (let j = i + 1; j < visibleLabels.length; j++) {
                if (!visibleLabels[j].shouldShow) continue;
                
                const labelB = visibleLabels[j];
                
                // Check for rectangle overlap
                const overlapX = Math.abs(labelA.x - labelB.x) < (labelA.width + labelB.width) / 2 + padding;
                const overlapY = Math.abs(labelA.y - labelB.y) < (labelA.height + labelB.height) / 2 + padding;
                
                if (overlapX && overlapY) {
                    // Hide the lower priority label (labelB since array is sorted)
                    visibleLabels[j].shouldShow = false;
                }
            }
        }
        
        // Apply visibility with smooth fade
        visibleLabels.forEach(label => {
            const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
            const currentOpacity = label.sprite.material.opacity;
            // Smooth transition
            label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * 0.12;
            // Clamp very small values to 0
            if (label.sprite.material.opacity < 0.03) {
                label.sprite.material.opacity = 0;
            }
        });
    }

    // Animation loop - modularized and optimized
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        const cfg = CONFIG.ANIMATION;
        
        // Animate particles
        if (particleSystem) {
            particleSystem.rotation.y = time * CONFIG.PARTICLES.rotationSpeed;
            particleSystem.rotation.x = Math.sin(time * 0.01) * 0.1;
        }
        
        // Spring physics for nodes
        nodes.forEach(mesh => {
            if (!mesh.visible) return;
            
            const spring = mesh.userData.spring;
            if (!spring) return;
            
            // Check if node is still animating (position or scale)
            const posDiff = mesh.position.distanceTo(spring.target);
            const scaleDiff = Math.abs(mesh.scale.x - spring.scaleTarget);
            const isAnimating = posDiff > cfg.animatingThreshold || scaleDiff > cfg.animatingThreshold;
            
            // Adaptive lerp - slower for longer distances (smoother repositioning)
            const lerpFactor = posDiff > 3 ? cfg.springLerpSlow : 
                              (posDiff > 1.5 ? cfg.springLerpMedium : cfg.springLerpBase);
            
            // Smooth position lerp
            if (posDiff > cfg.positionThreshold) {
                mesh.position.lerp(spring.target, lerpFactor);
            } else if (posDiff > 0) {
                mesh.position.copy(spring.target);
            }
            
            // Outline follows
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.position.copy(mesh.position);
            }
            
            // Smooth scale lerp
            const currentScale = mesh.scale.x;
            if (scaleDiff > cfg.scaleThreshold) {
                const newScale = currentScale + (spring.scaleTarget - currentScale) * cfg.scaleLerp;
                mesh.scale.set(newScale, newScale, newScale);
            } else {
                mesh.scale.set(spring.scaleTarget, spring.scaleTarget, spring.scaleTarget);
            }
            
            if (mesh.userData.outlineMesh) {
                const s = mesh.scale.x * 1.03;
                mesh.userData.outlineMesh.scale.set(s, s, s);
            }
            
            // Opacity for new nodes
            if (mesh.material.opacity < 1) {
                mesh.material.opacity = Math.min(1, mesh.material.opacity + 0.1);
            }
            
            // Queue connection updates for batch processing
            if (isAnimating && mesh.userData.connectionLine && mesh.userData.parent) {
                ConnectionManager.queueUpdate(mesh);
            }
            
            // Label visibility and scale (less frequent updates)
            if (mesh.userData.labelSprite && (!mesh.userData.lastLabelUpdate || time - mesh.userData.lastLabelUpdate > CONFIG.TIMING.labelUpdateInterval / 1000)) {
                mesh.userData.lastLabelUpdate = time;
                const dist = camera.position.distanceTo(mesh.position);
                const labelScale = 0.6 * Math.max(0.5, Math.min(1.2, dist / 15));
                const aspect = mesh.userData.labelSprite.scale.x / mesh.userData.labelSprite.scale.y;
                mesh.userData.labelSprite.scale.set(labelScale * aspect, labelScale, 1);
                mesh.userData.labelBaseOpacity = Math.max(0.7, Math.min(1, 35 / dist));
            }
            
            // Selection glow
            if (mesh.userData.selected) {
                mesh.material.emissiveIntensity = 0.4 + Math.sin(time * 4) * 0.2;
            } else {
                mesh.material.emissiveIntensity = 0.5;
            }
        });
        
        // Batch process all connection updates
        ConnectionManager.processBatch();
        
        // Smart label decluttering - checks camera movement and runs only when needed
        LabelSystem.checkCameraMovement(camera, controls);
        LabelSystem.update(camera, nodes);
        
        // Smooth camera animation (runs even during interaction if animation is active)
        if (cameraArcAnimation) {
            const elapsed = performance.now() - cameraArcAnimation.startTime;
            const progress = Math.min(elapsed / cameraArcAnimation.duration, 1);
            
            // Use smootherStep for silkier transitions
            const ease = Utils.easing.smootherStep(progress);
            
            // Lerp target position
            controls.target.lerpVectors(
                cameraArcAnimation.startTarget,
                cameraArcAnimation.endTarget,
                ease
            );
            
            if (cameraArcAnimation.useSpherical) {
                // Spherical interpolation for smooth horizontal rotation
                let startTheta = cameraArcAnimation.startTheta;
                let endTheta = cameraArcAnimation.endTheta;
                
                // Take shortest path around the circle
                let deltaTheta = endTheta - startTheta;
                if (deltaTheta > Math.PI) deltaTheta -= Math.PI * 2;
                if (deltaTheta < -Math.PI) deltaTheta += Math.PI * 2;
                
                const currentTheta = startTheta + deltaTheta * ease;
                
                // Vertical angle - keep relatively constant, slight interpolation
                const currentPhi = cameraArcAnimation.startPhi + 
                    (cameraArcAnimation.endPhi - cameraArcAnimation.startPhi) * ease;
                
                // Radius with arc boost - zoom out in middle, back in at end
                const arcProgress = Math.sin(progress * Math.PI); // peaks at 0.5
                const baseRadius = cameraArcAnimation.startRadius + 
                    (cameraArcAnimation.endRadius - cameraArcAnimation.startRadius) * ease;
                const currentRadius = baseRadius + arcProgress * cameraArcAnimation.arcBoost;
                
                // Convert spherical back to cartesian, relative to current target
                const newOffset = new THREE.Vector3(
                    Math.sin(currentTheta) * Math.sin(currentPhi) * currentRadius,
                    Math.cos(currentPhi) * currentRadius,
                    Math.cos(currentTheta) * Math.sin(currentPhi) * currentRadius
                );
                
                camera.position.copy(controls.target).add(newOffset);
            } else if (cameraArcAnimation.endCameraPos) {
                // Fallback linear interpolation
                camera.position.lerpVectors(
                    cameraArcAnimation.startCameraPos,
                    cameraArcAnimation.endCameraPos,
                    ease
                );
            }
            
            cameraTargetGoal.copy(controls.target);
            
            // Clear animation when done
            if (progress >= 1) {
                cameraArcAnimation = null;
            }
        } else if (!userInteracting) {
            // Normal slow follow when no arc animation and not interacting
            const targetDiff = new THREE.Vector3().subVectors(cameraTargetGoal, controls.target);
            const step = targetDiff.multiplyScalar(CONFIG.ANIMATION.cameraFollowSpeed);
            controls.target.add(step);
            camera.position.add(step);
        }
        
        controls.update();
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════════════════════
    // UI INTERACTIONS
    // ═══════════════════════════════════════════════════════════════════
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let moveMode = false;
    let draggedNode = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let dragOffset = new THREE.Vector3();
    let childOffsets = new Map(); // Store offsets for children when dragging expanded node
    let pointerDownTime = 0;
    let pointerDownPos = { x: 0, y: 0 };
    let clickedOnEmpty = false;
    let lastClickTime = 0;
    let lastClickedNodeId = null;

    // Get all visible descendants of a node
    function getVisibleDescendants(mesh, descendants = []) {
        if (!mesh.userData.children) return descendants;
        mesh.userData.children.forEach(childData => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.visible) {
                descendants.push(childMesh);
                getVisibleDescendants(childMesh, descendants);
            }
        });
        return descendants;
    }

    function onPointerDown(event) {
        if (event.target.closest('#info-panel, #side-panel, #top-controls, #quick-capture, #spotlight-overlay, #modal-overlay, #menu-dropdown, #theme-picker, #depth-indicator, #radial-menu, #voice-indicator, #voice-backdrop, #api-key-modal')) {
            return;
        }
        
        pointerDownTime = Date.now();
        pointerDownPos = { x: event.clientX, y: event.clientY };
        clickedOnEmpty = false;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const meshes = Array.from(nodes.values()).filter(m => m.visible);
        const intersects = raycaster.intersectObjects(meshes);
        
        if (intersects.length > 0) {
            const mesh = intersects[0].object;
            
            // Move mode - start dragging immediately, don't select (which might collapse)
            if (moveMode) {
                draggedNode = mesh;
                controls.enabled = false;
                renderer.domElement.style.cursor = 'grabbing';
                
                // Set up drag plane facing camera
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), mesh.position);
                
                // Calculate offset
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragOffset.subVectors(mesh.position, intersectPoint);
                
                // Store offsets for all visible descendants so they move with parent
                childOffsets.clear();
                const descendants = getVisibleDescendants(mesh);
                descendants.forEach(childMesh => {
                    const offset = childMesh.position.clone().sub(mesh.position);
                    childOffsets.set(childMesh.userData.id, offset);
                });
            } else {
                // Check for double-click on same node
                const now = Date.now();
                const isDoubleClick = (now - lastClickTime < 350) && (lastClickedNodeId === mesh.userData.id);
                
                lastClickTime = now;
                lastClickedNodeId = mesh.userData.id;
                
                selectNode(mesh, isDoubleClick);
            }
        } else {
            // Clicked on empty space - track for potential deselect on pointer up
            clickedOnEmpty = true;
            lastClickedNodeId = null;
        }
    }
    
    function onPointerMove(event) {
        if (!draggedNode || !moveMode) return;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectPoint);
        
        if (intersectPoint) {
            const newPos = intersectPoint.add(dragOffset);
            draggedNode.userData.spring.target.copy(newPos);
            draggedNode.userData.basePosition = [newPos.x, newPos.y, newPos.z];
            
            // Move all children with the parent
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh && childMesh.visible) {
                    const childNewPos = newPos.clone().add(offset);
                    childMesh.userData.spring.target.copy(childNewPos);
                    childMesh.userData.basePosition = [childNewPos.x, childNewPos.y, childNewPos.z];
                    
                    // Update child's connection line
                    if (childMesh.userData.connectionLine && childMesh.userData.parent) {
                        const parentMesh = nodes.get(childMesh.userData.parent.id);
                        if (parentMesh) {
                            updateConnection(childMesh, parentMesh);
                        }
                    }
                }
            });
            
            // Update connection line for dragged node
            if (draggedNode.userData.connectionLine && draggedNode.userData.parent) {
                const parentMesh = nodes.get(draggedNode.userData.parent.id);
                if (parentMesh) {
                    updateConnection(draggedNode, parentMesh);
                }
            }
        }
    }
    
    function onPointerUp(event) {
        if (draggedNode && moveMode) {
            // Save final positions to store
            const nodeData = store.findNode(draggedNode.userData.id);
            if (nodeData) {
                const pos = draggedNode.userData.spring.target;
                nodeData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
            }
            
            // Save child positions too
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh) {
                    const childData = store.findNode(childId);
                    if (childData) {
                        const pos = childMesh.userData.spring.target;
                        childData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
                    }
                }
            });
            
            store.save();
            childOffsets.clear();
            draggedNode = null;
            controls.enabled = true;
            renderer.domElement.style.cursor = 'grab';
        }
        
        // Only deselect on single click (not drag) on empty space
        if (clickedOnEmpty) {
            const timeDiff = Date.now() - pointerDownTime;
            const dx = event.clientX - pointerDownPos.x;
            const dy = event.clientY - pointerDownPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Single click = short time and minimal movement
            if (timeDiff < 300 && distance < 10) {
                deselectNode();
            }
            clickedOnEmpty = false;
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // KEYBOARD SHORTCUTS
    // ═══════════════════════════════════════════════════════════════════
    document.addEventListener('keydown', (e) => {
        // Cmd/Ctrl + K for spotlight
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            toggleSpotlight();
            return;
        }
        
        // Ignore if in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch (e.key) {
            case 'Tab':
                e.preventDefault();
                if (selectedNode) {
                    openModal('add', selectedNode.userData.id);
                } else if (currentContextId) {
                    openModal('add', currentContextId);
                }
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedNode && selectedNode.userData.parent) {
                    openModal('add', selectedNode.userData.parent.id);
                }
                break;
                
            case ' ':
                e.preventDefault();
                if (selectedNode) {
                    toggleExpand(selectedNode);
                }
                break;
                
            case 'Escape':
                if (voiceAI.isRecording || voiceAI.isProcessing) {
                    voiceAI.stop();
                }
                closeSpotlight();
                closeModal();
                deselectNode();
                break;
                
            case 'Backspace':
            case 'Delete':
                if (selectedNode && selectedNode.userData.id !== store.data.id) {
                    if (confirm(`Delete "${selectedNode.userData.label}"?`)) {
                        store.deleteNode(selectedNode.userData.id);
                        buildScene();
                        showToast('Node deleted', 'success');
                    }
                }
                break;
                
            case 'e':
                if (selectedNode) {
                    openModal('edit', selectedNode.userData.id);
                }
                break;
                
            case 'd':
                if (selectedNode && selectedNode.userData.children?.length) {
                    diveIntoNode(selectedNode.userData.id);
                }
                break;
                
            case 'u':
                surfaceUp();
                break;
                
            case '?':
                showKeyboardHints();
                break;
                
            case 'z':
                if (e.metaKey || e.ctrlKey) {
                    e.preventDefault();
                    const result = store.undo();
                    if (result.success) {
                        buildScene();
                        showToast(`Undid: ${result.actionName}`, 'info');
                    }
                }
                break;
        }
    });

    function showKeyboardHints() {
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 3000);
    }

    // ═══════════════════════════════════════════════════════════════════
    // SPOTLIGHT SEARCH
    // ═══════════════════════════════════════════════════════════════════
    const spotlightOverlay = document.getElementById('spotlight-overlay');
    const spotlightInput = document.getElementById('spotlight-input');
    const spotlightNodesList = document.getElementById('spotlight-nodes-list');
    let spotlightOpen = false;

    function toggleSpotlight() {
        spotlightOpen = !spotlightOpen;
        if (spotlightOpen) {
            spotlightOverlay.classList.add('active');
            spotlightInput.value = '';
            spotlightInput.focus();
            updateSpotlightResults('');
        } else {
            spotlightOverlay.classList.remove('active');
        }
    }

    function closeSpotlight() {
        spotlightOpen = false;
        spotlightOverlay.classList.remove('active');
    }

    spotlightOverlay.addEventListener('click', (e) => {
        if (e.target === spotlightOverlay) closeSpotlight();
    });

    spotlightInput.addEventListener('input', (e) => {
        updateSpotlightResults(e.target.value);
    });

    spotlightInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeSpotlight();
        } else if (e.key === 'Enter') {
            const selected = document.querySelector('.spotlight-item.selected');
            if (selected) {
                selected.click();
            } else if (spotlightInput.value.trim()) {
                // Create new node with input text
                const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
                store.addNode(parentId, { label: spotlightInput.value.trim() });
                buildScene();
                closeSpotlight();
                showToast(`Created "${spotlightInput.value.trim()}"`, 'success');
            }
        }
    });

    function updateSpotlightResults(query) {
        const results = query ? store.searchNodes(query) : store.getAllNodes().slice(0, 8);
        
        spotlightNodesList.innerHTML = results.map(node => `
            <div class="spotlight-item" data-id="${node.id}">
                <div class="spotlight-item-icon" style="background: ${node.color};"></div>
                <div class="spotlight-item-content">
                    <div class="spotlight-item-title">${escapeHTML(node.label)}</div>
                    <div class="spotlight-item-subtitle">${node.children?.length || 0} children</div>
                </div>
            </div>
        `).join('');
        
        // Add click handlers
        spotlightNodesList.querySelectorAll('.spotlight-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                const mesh = nodes.get(id);
                if (mesh) {
                    selectNode(mesh);
                    
                    // Pan camera to node
                    const targetPos = mesh.position.clone();
                    controls.target.lerp(targetPos, 0.5);
                }
                closeSpotlight();
            });
        });
    }

    // Quick actions in spotlight
    document.querySelectorAll('.spotlight-item[data-action]').forEach(item => {
        item.addEventListener('click', () => {
            const action = item.dataset.action;
            switch (action) {
                case 'new-node':
                    openModal('add', selectedNode?.userData.id || currentContextId);
                    break;
                case 'brainstorm':
                    if (selectedNode) {
                        brainstormNode(selectedNode.userData.id);
                    }
                    break;
            }
            closeSpotlight();
        });
    });

    // ═══════════════════════════════════════════════════════════════════
    // MODAL SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const modalOverlay = document.getElementById('modal-overlay');
    const modalTitle = document.getElementById('modal-title');
    const inputName = document.getElementById('input-name');
    const inputDesc = document.getElementById('input-desc');
    const colorGrid = document.getElementById('color-grid');
    let modalMode = 'add';
    let modalParentId = null;
    let modalEditId = null;
    let selectedColor = getThemeColors()[0];

    // Create color swatches
    colorGrid.innerHTML = getThemeColors().map(color => 
        `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
    ).join('');

    colorGrid.addEventListener('click', (e) => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            selectedColor = swatch.dataset.color;
            colorGrid.querySelectorAll('.color-swatch').forEach(s => 
                s.classList.toggle('selected', s.dataset.color === selectedColor)
            );
        }
    });

    function openModal(mode, targetId) {
        modalMode = mode;
        modalOverlay.classList.add('active');
        
        if (mode === 'add') {
            modalParentId = targetId;
            modalEditId = null;
            modalTitle.textContent = 'Add New Node';
            document.getElementById('modal-submit').textContent = 'Create';
            inputName.value = '';
            inputDesc.value = '';
            
            const parent = store.findNode(targetId);
            selectedColor = parent?.color || getThemeColors()[0];
        } else {
            modalEditId = targetId;
            modalParentId = null;
            modalTitle.textContent = 'Edit Node';
            document.getElementById('modal-submit').textContent = 'Save';
            
            const node = store.findNode(targetId);
            if (node) {
                inputName.value = node.label;
                inputDesc.value = node.description || '';
                selectedColor = node.color;
            }
        }
        
        colorGrid.querySelectorAll('.color-swatch').forEach(s => 
            s.classList.toggle('selected', s.dataset.color === selectedColor)
        );
        
        inputName.focus();
    }

    function closeModal() {
        modalOverlay.classList.remove('active');
        modalParentId = null;
        modalEditId = null;
    }

    function submitModal() {
        const name = inputName.value.trim();
        if (!name) {
            showToast('Please enter a name', 'error');
            return;
        }
        
        if (modalMode === 'add' && modalParentId) {
            const newNode = store.addNode(modalParentId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            if (newNode) {
                buildScene();
                
                // Celebration!
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, selectedColor, 6);
                    selectNode(mesh);
                }
                
                audio.success();
                haptic.success();
                showToast(`Created "${name}"`, 'success');
            }
        } else if (modalMode === 'edit' && modalEditId) {
            store.updateNode(modalEditId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            buildScene();
            showToast(`Updated "${name}"`, 'success');
        }
        
        closeModal();
    }

    document.getElementById('modal-cancel').addEventListener('click', closeModal);
    document.getElementById('modal-submit').addEventListener('click', submitModal);
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) closeModal();
    });
    
    // Enter key to submit modal
    inputName.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitModal();
        }
    });
    inputDesc.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            submitModal();
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // AI BRAINSTORM
    // ═══════════════════════════════════════════════════════════════════
    async function brainstormNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                showToast('API key required for AI features', 'error');
                return;
            }
        }
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 300,
                    messages: [{
                        role: 'user',
                        content: `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${node.label}"${description ? `\n- Description: "${description}"` : ''}
- Path to root: ${context}
- Existing children: ${siblings || 'none yet'}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of strings with the node labels. Make them concise but meaningful.
Example: ["Daily Habits", "Weekly Reviews", "Long-term Vision"]`
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            const ideas = JSON.parse(text);
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    store.addNode(nodeId, { label: idea, color: node.color });
                });
                
                // Mark node as expanded BEFORE building scene so children are visible
                store.expandedNodes.add(nodeId);
                
                buildScene();
                
                // Get the mesh and ensure it's marked as expanded
                const mesh = nodes.get(nodeId);
                if (mesh) {
                    mesh.userData.isExpanded = true;
                    
                    // Make sure all children are visible
                    mesh.userData.children?.forEach(childData => {
                        const childMesh = nodes.get(childData.id);
                        if (childMesh) {
                            childMesh.visible = true;
                            if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = true;
                            if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = true;
                            if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = true;
                            childMesh.userData.collapsed = false;
                        }
                    });
                    
                    // Celebration
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, node.color, 8);
                }
                
                audio.success();
                haptic.success();
                showToast(`Added ${ideas.length} new ideas!`, 'success');
            }
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast('Failed to generate ideas. Check your API key.', 'error');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // INFO PANEL
    // ═══════════════════════════════════════════════════════════════════
    const infoPanel = document.getElementById('info-panel');
    const infoTitle = document.getElementById('info-title');
    const infoColor = document.getElementById('info-color');
    const infoColorPicker = document.getElementById('info-color-picker');
    const infoChildren = document.getElementById('info-children');
    
    // Populate color picker
    infoColorPicker.innerHTML = getThemeColors().slice(0, 12).map(color => 
        `<span style="background:${color}" data-color="${color}"></span>`
    ).join('');
    
    // Toggle color picker
    infoColor.addEventListener('click', (e) => {
        if (e.target === infoColor || e.target === infoColorPicker) {
            infoColorPicker.classList.toggle('active');
        }
    });
    
    // Select color from picker
    infoColorPicker.addEventListener('click', (e) => {
        const colorEl = e.target.closest('[data-color]');
        if (colorEl && selectedNode) {
            const newColor = colorEl.dataset.color;
            store.updateNode(selectedNode.userData.id, { color: newColor });
            selectedNode.userData.color = newColor;
            selectedNode.material.color.set(newColor);
            selectedNode.material.emissive.set(newColor);
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            if (selectedNode.userData.connectionLine) {
                selectedNode.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update label with new color
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(selectedNode.userData.label, newColor);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            infoColor.style.background = newColor;
            infoColorPicker.classList.remove('active');
            showToast('Color updated', 'success');
        }
    });
    
    // Inline title editing
    infoTitle.addEventListener('change', () => {
        if (selectedNode && infoTitle.value.trim()) {
            store.updateNode(selectedNode.userData.id, { label: infoTitle.value.trim() });
            selectedNode.userData.label = infoTitle.value.trim();
            // Update label sprite
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(infoTitle.value.trim(), selectedNode.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            showToast('Name updated', 'success');
        }
    });
    
    // Enter key to save and blur info title
    infoTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            infoTitle.blur();
        }
    });
    
    // Importance slider
    const infoImportance = document.getElementById('info-importance');
    infoImportance.addEventListener('input', () => {
        if (selectedNode) {
            const scale = parseFloat(infoImportance.value);
            selectedNode.userData.importance = scale;
            store.updateNode(selectedNode.userData.id, { importance: scale });
            
            // Update node size
            const baseSize = selectedNode.userData.baseSize || 1;
            const newSize = baseSize * scale;
            selectedNode.scale.set(newSize, newSize, newSize);
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.scale.set(newSize * 1.03, newSize * 1.03, newSize * 1.03);
            }
            
            // Update spring scale target
            selectedNode.userData.spring.scaleTarget = newSize;
        }
    });
    
    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.info-color')) {
            infoColorPicker.classList.remove('active');
        }
    });

    bus.on('node:selected', ({ data }) => {
        infoTitle.value = data.label || 'Untitled';
        infoColor.style.background = data.color || '#888888';
        infoChildren.textContent = `${data.children?.length || 0} children`;
        infoColorPicker.classList.remove('active');
        
        // Set importance slider
        infoImportance.value = data.importance || 1;
        
        // Show source badge (AI, Link, etc.)
        const sourceEl = document.getElementById('info-source');
        const source = data.source || data.link?.source;
        if (source === 'ai' || source === 'brainstorm' || source === 'smart-expand') {
            sourceEl.textContent = '✨ AI';
            sourceEl.className = 'ai';
        } else if (source === 'link' || data.link) {
            sourceEl.textContent = '🔗 Link';
            sourceEl.className = 'link';
        } else {
            sourceEl.textContent = '';
            sourceEl.className = '';
        }
        
        // Populate expanded section
        // Description
        document.getElementById('info-description').value = data.description || '';
        
        // Path breadcrumbs
        const pathSection = document.getElementById('info-path-section');
        const pathContainer = document.getElementById('info-path');
        const path = store.getPath(data.id);
        
        if (path.length > 1) {
            pathSection.style.display = 'block';
            pathContainer.innerHTML = path.map((node, index) => {
                const isLast = index === path.length - 1;
                const separator = !isLast ? '<span class="info-path-separator">›</span>' : '';
                return `
                    <div class="info-path-item ${isLast ? 'info-path-current' : ''}" data-node-id="${node.id}">
                        <span class="info-path-color" style="background: ${node.color || '#888888'}"></span>
                        <span class="info-path-name">${node.label || 'Untitled'}</span>
                    </div>
                    ${separator}
                `;
            }).join('');
            
            // Add click handlers
            pathContainer.querySelectorAll('.info-path-item:not(.info-path-current)').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const nodeMesh = nodes.get(nodeId);
                    if (nodeMesh) {
                        selectNode(nodeMesh);
                        focusOnNode(nodeMesh);
                    }
                });
            });
        } else {
            pathSection.style.display = 'none';
        }
        
        // Show/hide link info (collapsed view)
        const linkSection = document.getElementById('info-link');
        if (data.link?.url) {
            linkSection.style.display = 'block';
            document.getElementById('info-link-url').href = data.link.url;
            document.getElementById('info-link-favicon').src = data.link.favicon || '';
            document.getElementById('info-link-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
        } else {
            linkSection.style.display = 'none';
        }
        
        // Link info (expanded view)
        const linkExpandedSection = document.getElementById('info-link-section');
        if (data.link?.url) {
            linkExpandedSection.style.display = 'block';
            
            // Thumbnail
            const thumbnail = document.getElementById('info-link-thumbnail');
            if (data.link.image) {
                thumbnail.src = data.link.image;
                thumbnail.style.display = 'block';
            } else {
                thumbnail.style.display = 'none';
            }
            
            // URL and domain
            document.getElementById('info-link-full-url').href = data.link.url;
            document.getElementById('info-link-favicon-small').src = data.link.favicon || '';
            document.getElementById('info-link-full-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
            
            // Meta info
            const meta = [];
            if (data.link.type) meta.push(data.link.type);
            if (data.link.author) meta.push(`by ${data.link.author}`);
            if (data.link.addedAt) {
                const date = new Date(data.link.addedAt);
                meta.push(`added ${date.toLocaleDateString()}`);
            }
            document.getElementById('info-link-meta').textContent = meta.join(' • ');
        } else {
            linkExpandedSection.style.display = 'none';
        }
        
        // Transcript section
        const transcriptSection = document.getElementById('info-transcript-section');
        if (data.link?.transcript) {
            transcriptSection.style.display = 'block';
            
            const transcript = data.link.transcript;
            const charCount = transcript.length;
            document.getElementById('info-transcript-chars').textContent = `${Math.round(charCount / 100) / 10}k chars`;
            
            // Show preview (first 300 chars)
            document.getElementById('info-transcript-preview').textContent = 
                transcript.substring(0, 300) + (transcript.length > 300 ? '...' : '');
            
            // Full transcript
            document.getElementById('info-transcript-text').textContent = transcript;
            
            // Reset toggle state
            document.getElementById('info-transcript-full').style.display = 'none';
            document.getElementById('info-transcript-toggle').textContent = 'Show full transcript';
        } else {
            transcriptSection.style.display = 'none';
        }
        
        // Node metadata
        // Created date
        const createdSection = document.getElementById('info-created-section');
        if (data.createdAt) {
            createdSection.style.display = 'flex';
            const date = new Date(data.createdAt);
            document.getElementById('info-created').textContent = date.toLocaleDateString();
        } else {
            createdSection.style.display = 'none';
        }
        
        // Added by
        const addedByValue = document.getElementById('info-added-by');
        if (data.source === 'brainstorm') {
            addedByValue.textContent = '✨ AI Brainstorm';
        } else if (data.source === 'smart-expand') {
            addedByValue.textContent = '✨ Smart Expand';
        } else if (data.source === 'link' || data.link) {
            addedByValue.textContent = '🔗 Link Import';
        } else if (data.source === 'onboarding') {
            addedByValue.textContent = '📋 Onboarding';
        } else {
            addedByValue.textContent = 'You';
        }
        
        // Show/hide dive button
        document.getElementById('action-dive').style.display = 
            data.children?.length ? 'flex' : 'none';
        
        // Show/hide delete button (can't delete root in current context)
        document.getElementById('action-delete').style.display = 
            data.id !== currentContextId ? 'flex' : 'none';
        
        // Show/hide organize button (show if node has 3+ link children from same domain)
        const organizeBtn = document.getElementById('action-organize');
        if (data.children && data.children.length >= 2) {
            // Count links by domain
            const domainCounts = {};
            data.children.forEach(child => {
                if (child.link?.domain || child.link?.url) {
                    let domain = child.link.domain;
                    if (!domain && child.link.url) {
                        try {
                            domain = new URL(child.link.url).hostname;
                        } catch (e) {}
                    }
                    if (domain) {
                        domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                        domainCounts[domain] = (domainCounts[domain] || 0) + 1;
                    }
                }
            });
            // Show if any domain has 2+ items
            const hasMultiple = Object.values(domainCounts).some(count => count >= 2);
            organizeBtn.style.display = hasMultiple ? 'flex' : 'none';
        } else {
            organizeBtn.style.display = 'none';
        }
        
        // Hide quick capture, show info panel
        document.getElementById('quick-capture').style.display = 'none';
        infoPanel.classList.add('active');
    });

    bus.on('node:deselected', () => {
        infoPanel.classList.remove('active');
        infoPanel.classList.remove('expanded');
        infoColorPicker.classList.remove('active');
        // Show quick capture again
        document.getElementById('quick-capture').style.display = 'block';
    });
    
    // Info panel expand toggle
    document.getElementById('info-expand-toggle').addEventListener('click', () => {
        infoPanel.classList.toggle('expanded');
    });
    
    // Description save on blur
    document.getElementById('info-description').addEventListener('blur', (e) => {
        if (selectedNode) {
            const nodeData = store.findNode(selectedNode.userData.id);
            if (nodeData) {
                nodeData.description = e.target.value.trim();
                selectedNode.userData.description = nodeData.description;
                store.save();
            }
        }
    });
    
    // Transcript toggle
    document.getElementById('info-transcript-toggle').addEventListener('click', () => {
        const fullSection = document.getElementById('info-transcript-full');
        const toggleBtn = document.getElementById('info-transcript-toggle');
        
        if (fullSection.style.display === 'none') {
            fullSection.style.display = 'block';
            toggleBtn.textContent = 'Hide full transcript';
        } else {
            fullSection.style.display = 'none';
            toggleBtn.textContent = 'Show full transcript';
        }
    });

    document.getElementById('info-close').addEventListener('click', deselectNode);

    document.getElementById('action-dive').addEventListener('click', () => {
        if (selectedNode) diveIntoNode(selectedNode.userData.id);
    });

    document.getElementById('action-add').addEventListener('click', () => {
        if (selectedNode) openModal('add', selectedNode.userData.id);
    });

    document.getElementById('action-brainstorm').addEventListener('click', () => {
        if (selectedNode) brainstormNodeEnhanced(selectedNode.userData.id);
    });

    document.getElementById('action-delete').addEventListener('click', () => {
        if (selectedNode && selectedNode.userData.id !== store.data.id) {
            if (confirm(`Delete "${selectedNode.userData.label}" and all its children?`)) {
                store.deleteNode(selectedNode.userData.id);
                deselectNode();
                buildScene();
                showToast('Node deleted', 'success');
            }
        }
    });
    
    // Organize button - groups children by domain/platform
    document.getElementById('action-organize').addEventListener('click', async () => {
        if (!selectedNode) return;
        
        const nodeId = selectedNode.userData.id;
        const nodeData = store.findNode(nodeId);
        if (!nodeData || !nodeData.children) return;
        
        // Group children by domain
        const domainGroups = {};
        nodeData.children.forEach(child => {
            if (child.link?.domain || child.link?.url) {
                let domain = child.link.domain;
                if (!domain && child.link.url) {
                    try {
                        domain = new URL(child.link.url).hostname;
                    } catch (e) {}
                }
                if (domain) {
                    domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            }
        });
        
        // Create folders for domains with 2+ items
        let totalMoved = 0;
        let foldersCreated = 0;
        
        for (const [domain, items] of Object.entries(domainGroups)) {
            if (items.length >= 2) {
                // Get friendly folder name
                const folderName = LinkManager.getDomainFolderName(domain);
                
                // Check if folder already exists
                const existingFolder = nodeData.children.find(c => 
                    c.label.toLowerCase() === folderName.toLowerCase() && !c.link
                );
                
                let folderId;
                if (existingFolder) {
                    folderId = existingFolder.id;
                } else {
                    // Create folder
                    const folder = store.addNode(nodeId, {
                        label: folderName,
                        description: `Collection of ${folderName} content`,
                        color: nodeData.color,
                        source: 'smart-organize'
                    });
                    folderId = folder.id;
                    foldersCreated++;
                }
                
                // Move items to folder
                for (const item of items) {
                    if (store.moveNode(item.id, folderId)) {
                        totalMoved++;
                    }
                }
            }
        }
        
        if (totalMoved > 0) {
            buildScene();
            showToast(`📁 Created ${foldersCreated} folders, organized ${totalMoved} items`, 'success');
            
            // Re-select the node to update info panel
            setTimeout(() => {
                const mesh = nodes.get(nodeId);
                if (mesh) selectNode(mesh);
            }, 100);
        } else {
            showToast('No items to organize', 'info');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // QUICK CAPTURE
    // ═══════════════════════════════════════════════════════════════════
    const quickInput = document.getElementById('quick-input');

    quickInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && quickInput.value.trim()) {
            const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
            const newNode = store.addNode(parentId, { label: quickInput.value.trim() });
            
            if (newNode) {
                buildScene();
                
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, newNode.color, 6);
                    selectNode(mesh);
                }
                
                audio.pop();
                haptic.light();
                showToast(`Added "${newNode.label}"`, 'success');
            }
            
            quickInput.value = '';
        }
    });

    document.getElementById('quick-add').addEventListener('click', () => {
        if (quickInput.value.trim()) {
            quickInput.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));
        }
    });

    document.getElementById('quick-ai').addEventListener('click', () => {
        if (selectedNode) {
            brainstormNode(selectedNode.userData.id);
        } else {
            showToast('Select a node first', 'info');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // SIDE PANEL BUTTONS
    // ═══════════════════════════════════════════════════════════════════
    document.getElementById('btn-home').addEventListener('click', resetCamera);
    document.getElementById('btn-expand').addEventListener('click', expandAll);
    document.getElementById('btn-collapse').addEventListener('click', collapseAll);
    
    document.getElementById('btn-add').addEventListener('click', () => {
        const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
        openModal('add', parentId);
    });
    
    // Move mode toggle
    const moveBtnEl = document.getElementById('btn-move');
    
    moveBtnEl.addEventListener('click', () => {
        moveMode = !moveMode;
        moveBtnEl.classList.toggle('active', moveMode);
        if (moveMode) {
            showToast('Move mode: Drag nodes to reposition', 'info');
            renderer.domElement.style.cursor = 'grab';
        } else {
            showToast('Move mode disabled', 'info');
            renderer.domElement.style.cursor = 'default';
        }
    });
    
    // Auto camera toggle
    const autoCamBtn = document.getElementById('btn-autocam');
    autoCamBtn.addEventListener('click', () => {
        autoCameraEnabled = !autoCameraEnabled;
        autoCamBtn.classList.toggle('active', autoCameraEnabled);
        showToast(autoCameraEnabled ? 'Auto camera enabled' : 'Auto camera disabled', 'info');
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // VOICE AI SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const voiceAI = {
        recognition: null,
        isRecording: false,
        isProcessing: false,
        apiKey: localStorage.getItem(CONFIG.API_KEY) || '',
        
        init() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Speech recognition not supported');
                return false;
            }
            
            this.recognition = new SpeechRecognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = true;
            this.recognition.lang = 'en-US';
            
            this.recognition.onstart = () => {
                console.log('Voice recognition started');
            };
            
            this.recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                document.getElementById('voice-transcript').textContent = transcript || 'Listening...';
            };
            
            this.recognition.onend = () => {
                if (this.isRecording) {
                    const transcript = document.getElementById('voice-transcript').textContent;
                    if (transcript && transcript !== 'Listening...' && transcript !== 'Say something...') {
                        this.processWithAI(transcript);
                    } else {
                        this.stop();
                    }
                }
            };
            
            this.recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showToast('Microphone access denied', 'error');
                }
                this.stop();
            };
            
            return true;
        },
        
        start() {
            console.log('Voice start called, apiKey exists:', !!this.apiKey);
            
            if (!this.apiKey) {
                this.showSettings();
                return;
            }
            
            // Show UI immediately
            this.isRecording = true;
            this.updateUI('recording');
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            if (!this.recognition && !this.init()) {
                showToast('Voice not supported in this browser', 'error');
                this.stop();
                return;
            }
            
            try {
                this.recognition.start();
                haptic.medium();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                this.stop();
                showToast('Failed to start voice recognition', 'error');
            }
        },
        
        // Start only the recording part (called from mode toggle)
        startRecording() {
            if (!this.recognition && !this.init()) {
                showToast('Voice not supported in this browser', 'error');
                return;
            }
            
            this.isRecording = true;
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            try {
                this.recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }
        },
        
        stop() {
            this.isRecording = false;
            this.isProcessing = false;
            if (this.recognition) {
                try { this.recognition.stop(); } catch (e) {}
            }
            this.updateUI('idle');
        },
        
        updateUI(state) {
            const voiceBtn = document.getElementById('btn-voice');
            const indicator = document.getElementById('voice-indicator');
            const backdrop = document.getElementById('voice-backdrop');
            const icon = document.getElementById('voice-icon');
            const micIcon = document.getElementById('voice-icon-mic');
            const brainIcon = document.getElementById('voice-icon-brain');
            const status = document.getElementById('voice-status');
            
            voiceBtn.classList.remove('recording', 'processing', 'active');
            indicator.classList.remove('active');
            backdrop.classList.remove('active');
            icon.classList.remove('recording', 'processing');
            
            if (state === 'recording') {
                voiceBtn.classList.add('recording');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('recording');
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                status.textContent = 'Listening...';
            } else if (state === 'processing') {
                voiceBtn.classList.add('processing');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('processing');
                micIcon.style.display = 'none';
                brainIcon.style.display = 'block';
                status.textContent = 'Thinking...';
            } else {
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                
                // Reset to speak mode
                document.getElementById('voice-mode-speak').classList.add('active');
                document.getElementById('voice-mode-type').classList.remove('active');
                document.getElementById('voice-icon').style.display = 'block';
                document.getElementById('voice-status').style.display = 'block';
                document.getElementById('voice-transcript').style.display = 'block';
                document.getElementById('voice-text-wrapper').style.display = 'none';
                document.getElementById('voice-text-input').value = '';
                document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
            }
        },
        
        async processWithAI(transcript) {
            this.isRecording = false;
            this.isProcessing = true;
            this.updateUI('processing');
            
            // Fix common speech recognition errors
            let cleanedTranscript = transcript.trim()
                .replace(/\bnote\b/gi, 'node')
                .replace(/\bnotes\b/gi, 'nodes')
                .replace(/\bknow\b/gi, 'node')
                .replace(/\bno\b(?=\s+called)/gi, 'node')
                .replace(/\bmode\b(?=\s+called)/gi, 'node')
                .replace(/\badd a no\b/gi, 'add a node')
                .replace(/\bnew no\b/gi, 'new node')
                .replace(/\bcreate a no\b/gi, 'create a node');
            
            console.log('Original transcript:', transcript);
            console.log('Cleaned transcript:', cleanedTranscript);
            
            try {
                // Build context about current mind map
                const allNodes = store.getAllNodes();
                const nodeContext = allNodes.slice(0, 30).map(n => ({
                    id: n.id,
                    label: n.label,
                    color: n.color,
                    hasChildren: n.children && n.children.length > 0
                }));
                
                const selectedNodeData = store.selectedNodeId ? store.findNode(store.selectedNodeId) : null;
                const currentContext = selectedNodeData ? `"${selectedNodeData.label}" (id: ${selectedNodeData.id})` : 'root "My Mind"';
                
                const prompt = `You are the AI core of MYND, a 3D mind mapping application that visually represents a user's entire internal world—their thoughts, desires, goals, memories, and aspirations as an interconnected, explorable space.

YOUR ROLE:
You are a supportive guide, not a dictator. Your purpose is to:
- Help users build and evolve their personal mind map through voice commands
- Extract meaning from what users share and translate it into visual nodes
- Foster self-awareness by helping users see patterns and connections
- Empower users to take control of their lives through organized thinking
- Be insightful and nonjudgmental—every thought has value in this space

VOICE COMMAND CONTEXT:
The user just spoke a voice command. Interpret their intent and respond with an action.

IMPORTANT: When user says "note", "notes", "no", "know" - they mean "NODE" or "NODES" (this is a mind map, not a note-taking app).

USER COMMAND: "${cleanedTranscript}"

CURRENT STATE:
- Selected node: ${currentContext}
- Existing nodes: ${JSON.stringify(nodeContext)}

AVAILABLE COLORS (use exact hex codes):
Orange=#EF8354, Teal=#4ECDC4, Purple=#9B5DE5, Yellow=#F7B731, Pink=#FF6B9D, Blue=#45B7D1, Green=#26DE81, Lavender=#A29BFE, Red=#FF4444, White=#FFFFFF, Black=#222222, Lime=#32CD32, Cyan=#00CED1, Gold=#FFD700

ACTIONS:
1. "add" - Create a new node to expand their mental landscape
2. "edit" - Refine an existing thought (change label or color)
3. "delete" - Remove a node that no longer serves them

RESPOND WITH JSON ONLY:
{
  "action": "add|edit|delete",
  "label": "Node Name (properly capitalized, meaningful)",
  "color": "#HEX or null",
  "targetId": "for edit/delete: node id",
  "parentId": "for add: use 'selected' (default), 'root', or specific node id"
}

EXAMPLES:
- "add a node called Christmas and make it green" → {"action":"add","label":"Christmas","color":"#26DE81","parentId":"selected"}
- "I want to track my fitness goals" → {"action":"add","label":"Fitness Goals","color":"#4ECDC4","parentId":"selected"}
- "new red node called urgent" → {"action":"add","label":"Urgent","color":"#FF4444","parentId":"selected"}
- "create vacation planning under goals" → {"action":"add","label":"Vacation Planning","color":null,"parentId":"goals"}
- "make goals blue" → {"action":"edit","label":null,"targetId":"goals","color":"#45B7D1"}
- "rename ideas to brainstorm" → {"action":"edit","label":"Brainstorm","targetId":"ideas","color":null}
- "delete the black node" → {"action":"delete","targetId":"node-black"}

Interpret the user's intent thoughtfully. If they're sharing a thought, goal, or idea, help them add it meaningfully to their mind map.

JSON only, no other text:`;

                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': this.apiKey.trim(),
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 300,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API Error:', response.status, errorData);
                    
                    if (response.status === 401) {
                        throw new Error('Invalid API key. Check your key in Voice AI Settings.');
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                    } else if (response.status === 400) {
                        throw new Error('Bad request. The voice input may be too long.');
                    } else if (response.status === 500 || response.status === 503) {
                        throw new Error('AI service temporarily unavailable. Try again shortly.');
                    } else if (errorData.error?.message) {
                        throw new Error(errorData.error.message);
                    } else {
                        throw new Error(`Connection error (${response.status}). Check your internet.`);
                    }
                }
                
                const data = await response.json();
                
                if (!data.content || !data.content[0] || !data.content[0].text) {
                    throw new Error('Empty response from AI. Try speaking more clearly.');
                }
                
                const content = data.content[0].text;
                console.log('AI response:', content);
                
                // Parse the JSON response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Could not understand that. Try a clearer command like "add node called Work"');
                }
                
                let result;
                try {
                    result = JSON.parse(jsonMatch[0]);
                } catch (parseError) {
                    throw new Error('AI response was unclear. Try rephrasing your command.');
                }
                
                console.log('Parsed result:', result);
                
                // Handle different actions
                if (result.action === 'delete' && result.targetId) {
                    const targetNode = store.findNode(result.targetId);
                    if (targetNode && targetNode.id !== store.data.id) {
                        const label = targetNode.label;
                        if (store.deleteNode(result.targetId)) {
                            showToast(`Deleted "${label}"`, 'success');
                            haptic.success();
                        }
                    } else {
                        showToast(`Couldn't find node to delete`, 'error');
                        haptic.error();
                    }
                } else if (result.action === 'edit' && result.targetId) {
                    const targetNode = store.findNode(result.targetId);
                    if (targetNode) {
                        const updates = {};
                        if (result.label) updates.label = result.label;
                        if (result.color && result.color !== 'null') updates.color = result.color;
                        store.updateNode(result.targetId, updates);
                        showToast(`Updated "${targetNode.label}"`, 'success');
                        haptic.success();
                    } else {
                        showToast(`Couldn't find node to edit`, 'error');
                        haptic.error();
                    }
                } else {
                    // Default: add node
                    let parentId;
                    if (result.parentId === 'selected') {
                        parentId = store.selectedNodeId || store.data.id;
                    } else if (result.parentId === 'root') {
                        parentId = store.data.id;
                    } else {
                        parentId = result.parentId || store.selectedNodeId || store.data.id;
                    }
                    
                    const parentNode = store.findNode(parentId);
                    if (!parentNode) {
                        parentId = store.selectedNodeId || store.data.id;
                    }
                    
                    const nodeData = { label: result.label };
                    if (result.color && result.color !== 'null' && result.color !== null) {
                        nodeData.color = result.color;
                    }
                    
                    store.addNode(parentId, nodeData);
                    
                    // Rebuild scene and show celebration
                    buildScene();
                    const newNode = store.findNode(parentId);
                    if (newNode) {
                        const mesh = nodes.get(parentId);
                        if (mesh) {
                            const screenPos = mesh.position.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                            createCelebration(x, y, nodeData.color || newNode.color, 12);
                        }
                    }
                    
                    const colorNote = nodeData.color ? ` (${nodeData.color})` : '';
                    showToast(`Added "${result.label}"${colorNote}`, 'success');
                    haptic.success();
                }
                
            } catch (error) {
                console.error('AI processing error:', error);
                showToast(error.message || 'Failed to process', 'error');
                haptic.error();
            } finally {
                this.stop();
            }
        },
        
        showSettings() {
            showApiKeyModal();
        },
        
        hideSettings() {
            hideApiKeyModal();
        },
        
        saveApiKey() {
            saveApiKeyFromModal();
        }
    };
    
    // Voice button click handler
    document.getElementById('btn-voice').addEventListener('click', () => {
        if (voiceAI.isRecording || voiceAI.isProcessing) {
            voiceAI.stop();
        } else {
            voiceAI.start();
        }
    });
    
    // Standalone API key modal function with optional callback
    let apiKeyModalCallback = null;
    
    function showApiKeyModal(callback) {
        apiKeyModalCallback = callback || null;
        const modal = document.getElementById('api-key-modal');
        const input = document.getElementById('api-key-input');
        const status = document.getElementById('api-key-status');
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        
        if (apiKey) {
            input.value = apiKey;
            status.textContent = '✓ API key configured';
            status.classList.add('configured');
        } else {
            input.value = '';
            status.textContent = 'Enter your Anthropic API key for AI features';
            status.classList.remove('configured');
        }
        
        modal.classList.add('active');
        input.focus();
    }
    
    function hideApiKeyModal() {
        document.getElementById('api-key-modal').classList.remove('active');
        apiKeyModalCallback = null;
    }
    
    function saveApiKeyFromModal() {
        const input = document.getElementById('api-key-input');
        const key = input.value.trim();
        
        if (key) {
            voiceAI.apiKey = key;
            localStorage.setItem(CONFIG.API_KEY, key);
            showToast('API key saved', 'success');
            
            document.getElementById('api-key-modal').classList.remove('active');
            
            // Call callback if provided (for onboarding flow)
            if (apiKeyModalCallback) {
                const cb = apiKeyModalCallback;
                apiKeyModalCallback = null;
                cb();
            }
        } else {
            showToast('Please enter an API key', 'error');
        }
    }
    
    // Voice indicator event handlers
    document.getElementById('voice-cancel').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-backdrop').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-indicator').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) voiceAI.stop();
    });
    
    // Voice mode toggle (speak vs type)
    let voiceInputMode = 'speak'; // 'speak' or 'type'
    
    document.getElementById('voice-mode-speak').addEventListener('click', () => {
        voiceInputMode = 'speak';
        document.getElementById('voice-mode-speak').classList.add('active');
        document.getElementById('voice-mode-type').classList.remove('active');
        
        // Show voice UI, hide text UI
        document.getElementById('voice-icon').style.display = 'block';
        document.getElementById('voice-status').style.display = 'block';
        document.getElementById('voice-transcript').style.display = 'block';
        document.getElementById('voice-text-wrapper').style.display = 'none';
        document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
        
        // Start voice recognition if not already processing
        if (!voiceAI.isProcessing) {
            voiceAI.startRecording();
        }
    });
    
    document.getElementById('voice-mode-type').addEventListener('click', () => {
        voiceInputMode = 'type';
        document.getElementById('voice-mode-type').classList.add('active');
        document.getElementById('voice-mode-speak').classList.remove('active');
        
        // Hide voice UI, show text UI
        document.getElementById('voice-icon').style.display = 'none';
        document.getElementById('voice-status').textContent = 'Type your request';
        document.getElementById('voice-status').style.display = 'block';
        document.getElementById('voice-transcript').style.display = 'none';
        document.getElementById('voice-text-wrapper').style.display = 'block';
        document.getElementById('voice-hint').textContent = 'Press Enter or click Send to submit';
        
        // Stop voice recognition
        if (voiceAI.recognition) {
            try { voiceAI.recognition.stop(); } catch (e) {}
        }
        
        // Focus text input
        document.getElementById('voice-text-input').focus();
    });
    
    // Voice text input submit
    document.getElementById('voice-text-submit').addEventListener('click', () => {
        const text = document.getElementById('voice-text-input').value.trim();
        if (text) {
            voiceAI.processWithAI(text);
            document.getElementById('voice-text-input').value = '';
        }
    });
    
    // Enter key in text input
    document.getElementById('voice-text-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('voice-text-submit').click();
        }
    });
    
    // API key modal handlers
    document.getElementById('api-key-save').addEventListener('click', () => saveApiKeyFromModal());
    document.getElementById('api-key-cancel').addEventListener('click', () => hideApiKeyModal());
    document.getElementById('api-key-modal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) hideApiKeyModal();
    });

    // ═══════════════════════════════════════════════════════════════════
    // TOP CONTROLS
    // ═══════════════════════════════════════════════════════════════════
    const themePicker = document.getElementById('theme-picker');
    
    document.getElementById('theme-btn').addEventListener('click', () => {
        themePicker.classList.toggle('active');
        document.getElementById('menu-dropdown').classList.remove('active');
    });
    
    document.querySelectorAll('.theme-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const oldTheme = document.documentElement.getAttribute('data-theme') || 'coral';
            const newTheme = opt.dataset.theme;
            themeManager.set(newTheme);
            themePicker.classList.remove('active');
            // Remap node colors to new theme palette FIRST
            updateNodeColorsForTheme(oldTheme, newTheme);
            // Update label sprites with new colors
            updateLabelsForTheme();
            // Update color pickers for theme
            updateColorPickers();
        });
    });

    const menuDropdown = document.getElementById('menu-dropdown');
    
    document.getElementById('menu-btn').addEventListener('click', () => {
        menuDropdown.classList.toggle('active');
        themePicker.classList.remove('active');
    });
    
    document.getElementById('menu-search').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        toggleSpotlight();
    });
    
    document.getElementById('menu-new').addEventListener('click', () => {
        if (confirm('Start a new map? This will clear your current map.')) {
            store.reset();
            currentContextId = store.data.id;
            
            // Reset onboarding state and show questionnaire
            currentQuestion = 0;
            questionAnswers = [];
            mapName = 'My Mind';
            localStorage.removeItem(CONFIG.ONBOARDING_KEY);
            
            // Re-create onboarding overlay if it was removed
            if (!document.getElementById('onboarding-overlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'onboarding-overlay';
                overlay.innerHTML = `
                    <div class="onboarding-content" id="onboarding-welcome">
                        <div class="onboarding-logo">M</div>
                        <h1 class="onboarding-title">Create New Map</h1>
                        <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
                        <div class="onboarding-input-wrapper">
                            <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
                        </div>
                        <div class="onboarding-choices">
                            <div class="onboarding-choice ai" id="onboarding-ai">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                                </div>
                                <div class="onboarding-choice-title">AI-Assisted Setup</div>
                                <div class="onboarding-choice-desc">Answer a few questions and let AI build your personalized mind map</div>
                            </div>
                            <div class="onboarding-choice scratch" id="onboarding-scratch">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                                </div>
                                <div class="onboarding-choice-title">Start from Scratch</div>
                                <div class="onboarding-choice-desc">Begin with a simple template and build your own structure</div>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-questionnaire" id="onboarding-questionnaire">
                        <div class="question-header">
                            <div class="question-logo">M</div>
                            <div class="question-progress">
                                <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                                <div class="question-progress-bar">
                                    <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="question-text" id="question-text"></div>
                        <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
                        <div class="question-actions">
                            <span class="question-skip" id="question-skip-btn">Skip this question</span>
                            <div class="question-nav">
                                <button class="question-btn secondary" id="question-back" style="display: none;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                                    Back
                                </button>
                                <button class="question-btn primary" id="question-next">
                                    Next
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-processing" id="onboarding-processing">
                        <div class="processing-spinner"></div>
                        <div class="processing-title">Building your mind map...</div>
                        <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Re-attach event listeners to the NEW overlay specifically
                overlay.querySelector('.onboarding-choice.ai').addEventListener('click', () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    
                    // Check for API key first
                    const apiKey = localStorage.getItem(CONFIG.API_KEY);
                    if (!apiKey) {
                        showApiKeyModal(() => {
                            showQuestionnaire();
                        });
                    } else {
                        showQuestionnaire();
                    }
                });
                
                overlay.querySelector('.onboarding-choice.scratch').addEventListener('click', () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    createBasicMapStructure();
                });
                
                overlay.querySelector('#onboarding-name').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                        
                        // Check for API key first
                        const apiKey = localStorage.getItem(CONFIG.API_KEY);
                        if (!apiKey) {
                            showApiKeyModal(() => {
                                showQuestionnaire();
                            });
                        } else {
                            showQuestionnaire();
                        }
                    }
                });
                
                document.getElementById('question-next').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-back').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion > 0) {
                        currentQuestion--;
                        updateQuestionUI();
                    }
                });
                
                document.getElementById('question-skip-btn').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = '';
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('question-next').click();
                    }
                });
            }
            
            document.getElementById('onboarding-overlay').style.display = 'flex';
            document.getElementById('onboarding-overlay').classList.remove('fade-out');
        }
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-save').addEventListener('click', () => {
        const json = store.exportJSON();
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `mynd-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        // Check if neural data was included
        const hasNeural = json.includes('"neural"');
        showToast(hasNeural ? 'Map + neural data saved!' : 'Map saved!', 'success');
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-load').addEventListener('click', () => {
        document.getElementById('file-input').click();
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-shortcuts').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 5000);
    });
    
    document.getElementById('menu-voice-settings').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        voiceAI.showSettings();
    });
    
    document.getElementById('menu-help').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        showToast('MYND: 3D Mind Mapping\n\nClick nodes to expand/collapse\nDouble-click to expand all\nDrag to rotate view\nUse sidebar for actions', 'info', 5000);
    });
    
    document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const content = event.target.result;
                if (store.importJSON(content)) {
                    currentContextId = store.data.id;
                    buildScene();
                    
                    // Check if neural data was included
                    const hasNeural = content.includes('"neural"') && content.includes('"modelData"');
                    if (hasNeural) {
                        showToast('Map + neural data loaded!', 'success');
                        // Update neural UI if it's initialized
                        if (typeof NeuralUI !== 'undefined') {
                            NeuralUI.updateStatus();
                        }
                    } else {
                        showToast('Map loaded!', 'success');
                    }
                } else {
                    showToast('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }
        e.target.value = '';
    });

    // Undo button
    const undoBtn = document.getElementById('undo-btn');
    
    undoBtn.addEventListener('click', () => {
        const result = store.undo();
        if (result.success) {
            buildScene();
            showToast(`Undid: ${result.actionName}`, 'info');
        }
    });
    
    bus.on('undo:changed', () => {
        undoBtn.disabled = !store.canUndo();
    });

    // Depth back button
    document.getElementById('depth-back').addEventListener('click', surfaceUp);

    // Close dropdowns on outside click
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#theme-btn, #theme-picker')) {
            themePicker.classList.remove('active');
        }
        if (!e.target.closest('#menu-btn, #menu-dropdown')) {
            menuDropdown.classList.remove('active');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // ONBOARDING
    // ═══════════════════════════════════════════════════════════════════
    const onboardingQuestions = [
        "What's one goal you want to make real progress on in the next 30 days?",
        "What's your ultimate dream career or life achievement?",
        "What's something you've been meaning to get around to but keep putting off?",
        "Is there a skill you're currently learning or want to develop?",
        "What area of your life feels cluttered, overwhelming, or in need of better organization?",
        "What do you do to recharge or find joy outside of work and responsibilities?"
    ];
    
    let currentQuestion = 0;
    let questionAnswers = [];
    let mapName = 'My Mind';
    
    function checkOnboarding() {
        const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
        const overlay = document.getElementById('onboarding-overlay');
        if (onboarded) {
            // Already onboarded - hide overlay
            overlay.style.display = 'none';
        } else {
            // Show onboarding
            overlay.style.display = 'flex';
        }
    }
    
    function updateQuestionUI() {
        document.getElementById('question-current').textContent = currentQuestion + 1;
        document.getElementById('question-progress-fill').style.width = `${((currentQuestion + 1) / onboardingQuestions.length) * 100}%`;
        document.getElementById('question-text').textContent = onboardingQuestions[currentQuestion];
        document.getElementById('question-input').value = questionAnswers[currentQuestion] || '';
        document.getElementById('question-input').placeholder = 'Type your answer here...';
        document.getElementById('question-back').style.display = currentQuestion > 0 ? 'flex' : 'none';
        
        const nextBtn = document.getElementById('question-next');
        if (currentQuestion === onboardingQuestions.length - 1) {
            nextBtn.innerHTML = 'Finish <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
        } else {
            nextBtn.innerHTML = 'Next <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>';
        }
        
        // Focus input
        setTimeout(() => document.getElementById('question-input').focus(), 100);
    }
    
    function showQuestionnaire() {
        document.getElementById('onboarding-welcome').style.display = 'none';
        document.getElementById('onboarding-questionnaire').classList.add('active');
        updateQuestionUI();
    }
    
    function showProcessing() {
        document.getElementById('onboarding-questionnaire').classList.remove('active');
        document.getElementById('onboarding-processing').classList.add('active');
    }
    
    async function processOnboardingAnswers() {
        showProcessing();
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        
        // If no API key, create basic structure without AI
        if (!apiKey) {
            createBasicMapStructure();
            return;
        }
        
        try {
            const answersContext = onboardingQuestions.map((q, i) => 
                `Q${i+1}: ${q}\nA${i+1}: ${questionAnswers[i] || '(skipped)'}`
            ).join('\n\n');
            
            console.log('🚀 Calling AI with answers:', answersContext);
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4000,
                    temperature: 0,
                    system: `You create mind map structures as JSON. You ALWAYS include nested children. You NEVER create flat structures. Every node at level 1 MUST have children, and those children MUST have their own children. You ALWAYS create EXACTLY 4 top-level nodes.`,
                    messages: [{
                        role: 'user',
                        content: `Based on these answers, create a mind map with EXACTLY this structure:
- EXACTLY 4 main categories (Level 1) - no more, no less
- Each category has 2-3 topics (Level 2)
- Each topic has 2-3 actions (Level 3)

User's answers:
${answersContext}

Return this EXACT JSON structure (with your own labels based on answers):

{"nodes":[{"label":"Goals","color":"#60a5fa","children":[{"label":"Short Term","children":[{"label":"Action 1"},{"label":"Action 2"}]},{"label":"Long Term","children":[{"label":"Action 1"},{"label":"Action 2"}]}]},{"label":"Growth","color":"#2dd4bf","children":[{"label":"Skills","children":[{"label":"Step 1"},{"label":"Step 2"}]},{"label":"Learning","children":[{"label":"Resource 1"},{"label":"Resource 2"}]}]},{"label":"Projects","color":"#c084fc","children":[{"label":"Current","children":[{"label":"Task 1"},{"label":"Task 2"}]},{"label":"Planned","children":[{"label":"Idea 1"},{"label":"Idea 2"}]}]},{"label":"Wellness","color":"#4ade80","children":[{"label":"Physical","children":[{"label":"Habit 1"},{"label":"Habit 2"}]},{"label":"Mental","children":[{"label":"Practice 1"},{"label":"Practice 2"}]}]}]}

Replace placeholder labels with real content from user's answers. MUST have exactly 4 top-level nodes. JSON only.`
                    }]
                })
            });
            
            if (!response.ok) {
                const errData = await response.json().catch(() => ({}));
                console.error('❌ API error:', response.status, errData);
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const content = data.content?.[0]?.text || '';
            console.log('📝 AI response:', content);
            
            // Find JSON in response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            
            if (jsonMatch) {
                try {
                    const structure = JSON.parse(jsonMatch[0]);
                    console.log('✅ Parsed structure:', structure);
                    console.log('📊 Top level nodes:', structure.nodes?.length);
                    
                    // Validate structure has nested children
                    if (structure.nodes?.[0]?.children?.[0]?.children) {
                        console.log('✅ Structure has 3 levels - using AI result');
                        createMapFromStructure(structure);
                    } else {
                        console.error('❌ Structure missing nested children, using fallback');
                        createBasicMapStructure();
                    }
                } catch (parseError) {
                    console.error('❌ JSON parse error:', parseError);
                    createBasicMapStructure();
                }
            } else {
                console.error('❌ No JSON found in response');
                createBasicMapStructure();
            }
        } catch (error) {
            console.error('Onboarding AI error:', error);
            createBasicMapStructure();
        }
    }
    
    function createMapFromStructure(structure) {
        // Update root label and clear any existing children
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear existing children
        
        // Get colors from current theme
        const themeColors = getThemeColors();
        
        console.log('🏗️ Creating map from structure, nodes:', structure.nodes?.length);
        
        // Add nodes from AI structure (3 levels deep)
        if (structure.nodes && Array.isArray(structure.nodes)) {
            // Limit to max 4 top-level nodes
            const topNodes = structure.nodes.slice(0, 4);
            
            topNodes.forEach((category, categoryIndex) => {
                // Use theme colors for top-level categories - start from index 1 (skip root color)
                const categoryColor = themeColors[(categoryIndex % 4) + 1];
                console.log('📁 Adding category:', category.label, 'color:', categoryColor);
                
                const categoryNode = store.addNode(store.data.id, {
                    label: category.label,
                    color: categoryColor,
                    source: 'onboarding'
                });
                
                if (!categoryNode) {
                    console.error('Failed to create category node');
                    return;
                }
                
                // Layer 2: Children of category - INHERIT parent color
                if (category.children && Array.isArray(category.children)) {
                    category.children.forEach((child) => {
                        console.log('  📄 Adding child:', child.label, 'inheriting color:', categoryColor);
                        
                        const childNode = store.addNode(categoryNode.id, {
                            label: child.label,
                            color: categoryColor,  // Inherit parent color
                            source: 'onboarding'
                        });
                        
                        if (!childNode) {
                            console.error('Failed to create child node');
                            return;
                        }
                        
                        // Layer 3: Grandchildren - INHERIT parent color
                        if (child.children && Array.isArray(child.children)) {
                            child.children.forEach((grandchild) => {
                                console.log('    📌 Adding grandchild:', grandchild.label, 'inheriting color:', categoryColor);
                                store.addNode(childNode.id, {
                                    label: grandchild.label,
                                    color: categoryColor,  // Inherit from top-level parent
                                    source: 'onboarding'
                                });
                            });
                        }
                    });
                }
            });
        }
        
        store.save();
        buildScene();
        completeOnboarding();
        
        // Auto-train neural network on newly created map
        if (neuralNet.isReady) {
            console.log('🧠 Auto-training neural network on new map...');
            setTimeout(() => {
                neuralNet.train(store).then(() => {
                    console.log('✓ Neural network trained on initial map');
                });
            }, 3000); // Delay to let the scene fully build
        }
    }
    
    function createBasicMapStructure() {
        console.log('📝 Creating basic structure from scratch');
        // Create basic structure without AI
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear any existing children
        
        // Use colors from current theme palette
        const colors = getThemeColors();
        
        // Add default categories for starting from scratch
        // Using distinct colors that don't match root (orange)
        const categories = [
            { label: 'Goals', color: colors[4] },      // Blue
            { label: 'Ideas', color: colors[3] },      // Yellow
            { label: 'To Do', color: colors[7] },      // Purple
            { label: 'Wants', color: colors[2] }       // Teal
        ];
        
        categories.forEach(cat => {
            store.addNode(store.data.id, cat);
        });
        
        store.save();
        buildScene();
        completeOnboarding();
    }

    // AI-Assisted Setup choice - use class selector for clarity
    document.querySelector('#onboarding-overlay .onboarding-choice.ai').addEventListener('click', () => {
        console.log('AI Assist clicked');
        mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
        
        // Check for API key first
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            // Show API key modal first
            showApiKeyModal(() => {
                // After API key is saved, show questionnaire
                showQuestionnaire();
            });
        } else {
            showQuestionnaire();
        }
    });
    
    // Start from Scratch choice - use class selector for clarity
    document.querySelector('#onboarding-overlay .onboarding-choice.scratch').addEventListener('click', () => {
        console.log('Start from Scratch clicked');
        mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
        createBasicMapStructure();
    });
    
    document.querySelector('#onboarding-overlay #onboarding-name').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
            
            // Check for API key first
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) {
                showApiKeyModal(() => {
                    showQuestionnaire();
                });
            } else {
                showQuestionnaire();
            }
        }
    });
    
    document.getElementById('question-next').addEventListener('click', () => {
        // Save current answer
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            // All questions answered
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-back').addEventListener('click', () => {
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        if (currentQuestion > 0) {
            currentQuestion--;
            updateQuestionUI();
        }
    });
    
    document.getElementById('question-skip-btn').addEventListener('click', () => {
        questionAnswers[currentQuestion] = '';
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('question-next').click();
        }
    });

    function completeOnboarding() {
        localStorage.setItem(CONFIG.ONBOARDING_KEY, 'true');
        const overlay = document.getElementById('onboarding-overlay');
        overlay.classList.add('fade-out');
        setTimeout(() => overlay.remove(), 800);
    }

    // ═══════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    async function init() {
        try {
            // Check onboarding first - hide overlay immediately if already completed
            const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
            if (onboarded) {
                document.getElementById('onboarding-overlay').style.display = 'none';
            }
            
            themeManager.init();
            initScene();
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                setTimeout(() => document.getElementById('loading').remove(), 500);
            }, 500);
            
            // Show keyboard hints briefly
            setTimeout(() => {
                if (window.innerWidth > 768) {
showKeyboardHints();
                }
            }, 2000);
            
            console.log('✨ MYND initialized successfully');
            
        } catch (error) {
            console.error('Initialization failed:', error);
            const loading = document.getElementById('loading');
            if (loading) {
                loading.innerHTML = `
                    <div class="loading-content">
                        <div class="loading-logo" style="background: #f87171;">!</div>
                        <div class="loading-text" style="color: #f87171;">Failed to load</div>
                        <p style="margin-top: 16px; color: var(--text-muted); font-size: 13px;">${error.message}</p>
                    </div>
                `;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // NEURAL NETWORK UI INTEGRATION
    // ═══════════════════════════════════════════════════════════════════
    
    const NeuralUI = {
        panel: null,
        isOpen: false,
        
        init() {
            this.panel = document.getElementById('neural-panel');
            this.bindEvents();
            this.initNeuralNetwork();
        },
        
        bindEvents() {
            // Toggle panel
            document.getElementById('btn-neural')?.addEventListener('click', () => {
                this.toggle();
            });
            
            // Close button
            document.getElementById('neural-close')?.addEventListener('click', () => {
                this.close();
            });
            
            // Train button
            document.getElementById('neural-train-btn')?.addEventListener('click', () => {
                this.trainNetwork();
            });
            
            // Suggest connections button
            document.getElementById('neural-suggest-btn')?.addEventListener('click', () => {
                this.suggestConnections();
            });
            
            // Reset button
            document.getElementById('neural-reset-btn')?.addEventListener('click', () => {
                this.resetNetwork();
            });
            
            // Smart suggest button
            document.getElementById('neural-smart-suggest-btn')?.addEventListener('click', () => {
                this.smartExpand();
            });
            
            // Close when clicking outside
            document.addEventListener('click', (e) => {
                if (this.isOpen && 
                    !this.panel.contains(e.target) && 
                    !e.target.closest('#btn-neural')) {
                    this.close();
                }
            });
        },
        
        async initNeuralNetwork() {
            // Initialize neural network in background
            const success = await neuralNet.initialize();
            
            if (success) {
                document.getElementById('neural-train-btn').disabled = false;
                this.updateStatus();
                
                // Set up event listeners
                neuralNet.on('onTrainingStart', () => {
                    document.getElementById('neural-train-btn').disabled = true;
                    document.getElementById('neural-train-btn').innerHTML = `
                        <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2"/>
                        </svg>
                        Training...
                    `;
                    document.getElementById('neural-progress').style.display = 'block';
                });
                
                neuralNet.on('onTrainingProgress', (data) => {
                    document.getElementById('neural-progress-bar').style.width = `${data.progress}%`;
                    document.getElementById('neural-status-text').textContent = 
                        `Training ${data.phase} (${Math.round(data.progress)}%)`;
                    document.getElementById('neural-status-text').className = 'neural-status-value training';
                });
                
                neuralNet.on('onTrainingComplete', (data) => {
                    document.getElementById('neural-train-btn').disabled = false;
                    document.getElementById('neural-train-btn').innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Mind Map
                    `;
                    document.getElementById('neural-progress').style.display = 'none';
                    document.getElementById('neural-suggest-btn').disabled = false;
                    this.updateStatus();
                    showToast('Neural network trained successfully!', 'success');
                });
                
                // Auto-train on first load if no model exists but enough nodes do
                const stats = neuralNet.getStats();
                if (!stats.hasCategoryModel && !stats.hasPredictionModel) {
                    // Count nodes
                    let nodeCount = 0;
                    const countNodes = (node) => {
                        nodeCount++;
                        node.children?.forEach(countNodes);
                    };
                    countNodes(store.data);
                    
                    if (nodeCount >= CONFIG.NEURAL_NET.minTrainingNodes) {
                        console.log('🧠 Auto-training on first load...');
                        setTimeout(() => {
                            neuralNet.train(store);
                        }, 2000); // Delay to let UI settle
                    }
                }
            } else {
                // Show helpful message about why neural network isn't available
                const statusText = document.getElementById('neural-status-text');
                statusText.textContent = 'Unavailable';
                statusText.className = 'neural-status-value';
                statusText.title = neuralNet.loadError || 'Model loading failed';
                
                // Add explanation in the panel
                const statusDiv = document.querySelector('.neural-status');
                if (statusDiv && neuralNet.loadError) {
                    const hint = document.createElement('div');
                    hint.style.cssText = 'font-size: 11px; color: var(--text-tertiary); margin-top: 8px; line-height: 1.4;';
                    hint.innerHTML = '💡 Neural features require running locally or hosted. Copy the HTML file and open in your browser.';
                    statusDiv.appendChild(hint);
                }
            }
        },
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        open() {
            this.panel.classList.add('active');
            this.isOpen = true;
            document.getElementById('btn-neural').classList.add('active');
            this.updateStatus();
        },
        
        close() {
            this.panel.classList.remove('active');
            this.isOpen = false;
            document.getElementById('btn-neural').classList.remove('active');
        },
        
        updateStatus() {
            const stats = neuralNet.getStats();
            
            // Update status text
            const statusText = document.getElementById('neural-status-text');
            if (stats.isTraining) {
                statusText.textContent = 'Training...';
                statusText.className = 'neural-status-value training';
            } else if (stats.isReady) {
                statusText.textContent = stats.hasPredictionModel ? 'Trained' : 'Ready';
                statusText.className = 'neural-status-value ready';
            } else {
                statusText.textContent = 'Not Ready';
                statusText.className = 'neural-status-value';
            }
            
            // Update counts
            document.getElementById('neural-category-count').textContent = stats.categories.length;
            document.getElementById('neural-pattern-count').textContent = stats.expansionPatterns;
            document.getElementById('neural-embedding-count').textContent = stats.cachedEmbeddings;
            
            // Update categories list
            const categoriesSection = document.getElementById('neural-categories');
            const categoryList = document.getElementById('neural-category-list');
            
            if (stats.categories.length > 0) {
                categoriesSection.style.display = 'block';
                categoryList.innerHTML = stats.categories.map(cat => 
                    `<span class="neural-category-tag">${cat}</span>`
                ).join('');
            } else {
                categoriesSection.style.display = 'none';
            }
            
            // Enable/disable buttons based on model availability
            document.getElementById('neural-suggest-btn').disabled = !stats.hasCategoryModel;
            document.getElementById('neural-smart-suggest-btn').disabled = !stats.hasPredictionModel;
        },
        
        async trainNetwork() {
            if (neuralNet.isTraining) return;
            
            showToast('Starting neural network training...', 'info');
            const success = await neuralNet.train(store);
            
            if (!success) {
                showToast('Need more nodes to train (minimum 5)', 'error');
                document.getElementById('neural-train-btn').disabled = false;
                document.getElementById('neural-train-btn').innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                    </svg>
                    Train on My Mind Map
                `;
                document.getElementById('neural-progress').style.display = 'none';
            }
        },
        
        async suggestConnections() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            const nodeText = nodeData.description 
                ? `${nodeData.label}. ${nodeData.description}`
                : nodeData.label;
            
            showToast('Analyzing connections...', 'info');
            
            // Get suggestions from neural network
            const suggestions = await neuralNet.suggestConnections(nodeText, store);
            
            // Also get Claude enhancement if API key available
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            let claudeSuggestion = null;
            if (apiKey) {
                claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
            }
            
            this.displaySuggestions(suggestions, claudeSuggestion);
        },
        
        displaySuggestions(neuralSuggestions, claudeSuggestion) {
            const suggestionsSection = document.getElementById('neural-suggestions');
            const suggestionsList = document.getElementById('neural-suggestions-list');
            
            if (neuralSuggestions.length === 0 && !claudeSuggestion) {
                suggestionsSection.style.display = 'none';
                showToast('No strong connections found', 'info');
                return;
            }
            
            suggestionsSection.style.display = 'block';
            let html = '';
            
            // Neural network suggestions - these navigate to related nodes
            if (neuralSuggestions.length > 0) {
                html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">Related nodes in your map:</div>`;
                neuralSuggestions.forEach(s => {
                    html += `
                        <div class="neural-suggestion" data-node-id="${s.nodeId}">
                            <span class="neural-suggestion-text">${s.label}</span>
                            <span class="neural-suggestion-score">${Math.round(s.isRelated * 100)}%</span>
                        </div>
                    `;
                });
            }
            
            // Claude suggestion - this can move the node
            if (claudeSuggestion) {
                const suggestedParent = claudeSuggestion.suggestedParent || claudeSuggestion.category;
                html += `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin: ${neuralSuggestions.length > 0 ? '12px' : '0'} 0 8px 0;">AI reorganization suggestion:</div>
                    <div class="neural-suggestion claude-suggestion" data-suggested-parent="${suggestedParent}" style="border-left: 3px solid var(--accent); cursor: pointer;">
                        <div>
                            <div class="neural-suggestion-text" style="font-weight: 600;">
                                Move to "${suggestedParent}"
                            </div>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">
                                ${claudeSuggestion.reasoning || 'Click to reorganize'}
                            </div>
                        </div>
                        <span class="neural-suggestion-score">${Math.round((claudeSuggestion.confidence || 0.8) * 100)}%</span>
                    </div>
                `;
                
                // Show related concepts
                if (claudeSuggestion.relatedConcepts?.length > 0) {
                    html += `
                        <div style="margin-top: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">Related concepts to add:</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${claudeSuggestion.relatedConcepts.join(', ')}
                            </div>
                        </div>
                    `;
                }
            }
            
            suggestionsList.innerHTML = html;
            
            // Add click handlers to navigate to related nodes
            suggestionsList.querySelectorAll('.neural-suggestion[data-node-id]').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const mesh = nodes.get(nodeId);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                        this.close();
                    }
                });
            });
            
            // Add click handler for Claude's reorganization suggestion
            const claudeSuggestionEl = suggestionsList.querySelector('.claude-suggestion[data-suggested-parent]');
            if (claudeSuggestionEl && selectedNode) {
                claudeSuggestionEl.addEventListener('click', () => {
                    const suggestedParent = claudeSuggestionEl.dataset.suggestedParent;
                    const nodeToMove = selectedNode.userData.id;
                    const nodeData = store.findNode(nodeToMove);
                    
                    if (!nodeData || nodeToMove === 'mynd') {
                        showToast("Can't move root node", 'error');
                        return;
                    }
                    
                    // Find the suggested parent node
                    const findNodeByLabel = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNodeByLabel(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const newParent = findNodeByLabel(store.data, suggestedParent);
                    
                    if (!newParent) {
                        showToast(`Couldn't find "${suggestedParent}"`, 'error');
                        return;
                    }
                    
                    if (newParent.id === nodeToMove) {
                        showToast("Can't move node into itself", 'error');
                        return;
                    }
                    
                    // Confirm the move
                    if (confirm(`Move "${nodeData.label}" under "${newParent.label}"?`)) {
                        // Use store.moveNode
                        if (store.moveNode(nodeToMove, newParent.id)) {
                            // Update color to match new parent
                            nodeData.color = newParent.color;
                            store.save();
                            buildScene();
                            
                            // Focus on the moved node in its new location
                            setTimeout(() => {
                                const movedMesh = nodes.get(nodeToMove);
                                if (movedMesh) {
                                    selectNode(movedMesh);
                                    focusOnNode(movedMesh);
                                }
                            }, 100);
                            
                            this.close();
                            showToast(`Moved to "${newParent.label}"`, 'success');
                        } else {
                            showToast('Failed to move node', 'error');
                        }
                    }
                });
            }
        },
        
        async resetNetwork() {
            if (confirm('Reset neural network? This will clear all learned patterns.')) {
                await neuralNet.reset();
                this.updateStatus();
                document.getElementById('neural-suggestions').style.display = 'none';
                document.getElementById('neural-suggest-btn').disabled = true;
                document.getElementById('neural-smart-suggest-btn').disabled = true;
                showToast('Neural network reset', 'info');
            }
        },
        
        async smartExpand() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            showToast('Generating smart suggestions...', 'info');
            
            try {
                // Get AI-enhanced suggestions
                const result = await neuralNet.generateSmartSuggestions(nodeData, store);
                
                if (!result) {
                    showToast('Failed to generate suggestions', 'error');
                    return;
                }
                
                // Display suggestions in the panel
                const suggestionsSection = document.getElementById('neural-suggestions');
                const suggestionsList = document.getElementById('neural-suggestions-list');
                
                let html = '';
                
                // Show ML-based suggestions first
                if (result.mlSuggestions && result.mlSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">From learned patterns:</div>`;
                    result.mlSuggestions.forEach(s => {
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ml">
                                <span class="neural-suggestion-text">${s.label}</span>
                                <span class="neural-suggestion-score">${Math.round(s.confidence * 100)}%</span>
                            </div>
                        `;
                    });
                }
                
                // Show AI suggestions
                if (result.aiSuggestions && result.aiSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin: 12px 0 8px 0;">AI recommendations:</div>`;
                    result.aiSuggestions.forEach(s => {
                        // Escape the reasoning for use in data attribute
                        const escapedReasoning = (s.reasoning || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ai" data-description="${escapedReasoning}" style="border-left: 3px solid var(--accent);">
                                <div>
                                    <span class="neural-suggestion-text">${s.label}</span>
                                    ${s.reasoning ? `<div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${s.reasoning}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Add "Add All" button if we have suggestions
                if (result.mlSuggestions?.length > 0 || result.aiSuggestions?.length > 0) {
                    html += `
                        <button class="neural-btn primary" id="neural-add-all-btn" style="margin-top: 12px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Add All Suggestions
                        </button>
                    `;
                }
                
                suggestionsList.innerHTML = html;
                suggestionsSection.style.display = 'block';
                
                // Add click handlers for individual suggestions
                suggestionsList.querySelectorAll('.neural-suggestion[data-label]').forEach(el => {
                    el.addEventListener('click', () => {
                        if (el.classList.contains('added')) return; // Already added
                        
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        const suggestionType = el.dataset.type; // 'ml' or 'ai'
                        const parentId = selectedNode.userData.id;
                        const parentNode = store.findNode(parentId);
                        
                        store.addNode(parentId, { 
                            label, 
                            description,
                            color: parentNode?.color,
                            source: 'smart-expand'
                        });
                        
                        buildScene();
                        
                        // Expand the parent node if collapsed
                        const parentMesh = nodes.get(parentId);
                        if (parentMesh && !parentMesh.userData.isExpanded) {
                            expandNode(parentMesh);
                        }
                        
                        // Mark as added instead of removing
                        el.classList.add('added');
                        el.style.opacity = '0.5';
                        el.style.pointerEvents = 'none';
                        
                        // Add checkmark
                        const score = el.querySelector('.neural-suggestion-score');
                        if (score) {
                            score.textContent = '✓';
                            score.style.background = '#22c55e';
                            score.style.color = 'white';
                        }
                        
                        // Update "Add All" button to show remaining count
                        const remaining = suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').length;
                        const addAllBtn = document.getElementById('neural-add-all-btn');
                        if (addAllBtn) {
                            if (remaining === 0) {
                                addAllBtn.style.display = 'none';
                            } else {
                                addAllBtn.innerHTML = `
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                                    </svg>
                                    Add Remaining (${remaining})
                                `;
                            }
                        }
                        
                        showToast(`Added "${label}"`, 'success');
                        audio.add();
                    });
                });
                
                // Add click handler for "Add All" button
                document.getElementById('neural-add-all-btn')?.addEventListener('click', () => {
                    const parentId = selectedNode.userData.id;
                    const parentNode = store.findNode(parentId);
                    let added = 0;
                    
                    // Only add suggestions that haven't been added yet
                    suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').forEach(el => {
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        if (label) {
                            store.addNode(parentId, { 
                                label, 
                                description,
                                color: parentNode?.color,
                                source: 'smart-expand'
                            });
                            added++;
                            
                            // Mark as added
                            el.classList.add('added');
                            el.style.opacity = '0.5';
                            el.style.pointerEvents = 'none';
                            const score = el.querySelector('.neural-suggestion-score');
                            if (score) {
                                score.textContent = '✓';
                                score.style.background = '#22c55e';
                                score.style.color = 'white';
                            }
                        }
                    });
                    
                    if (added === 0) {
                        showToast('All suggestions already added', 'info');
                        return;
                    }
                    
                    buildScene();
                    
                    // Expand the parent
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                    
                    // Hide the button
                    document.getElementById('neural-add-all-btn').style.display = 'none';
                    showToast(`Added ${added} nodes`, 'success');
                    audio.ai();
                });
                
            } catch (error) {
                console.error('Smart expand error:', error);
                showToast('Failed to generate suggestions', 'error');
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ENHANCED BRAINSTORM WITH NEURAL NETWORK
    // ═══════════════════════════════════════════════════════════════════
    
    async function brainstormNodeEnhanced(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                showToast('API key required for AI features', 'error');
                return;
            }
        }
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            // Get neural network predictions if available
            let neuralContext = '';
            if (neuralNet.isReady && neuralNet.categories.length > 0) {
                const nodeText = description ? `${node.label}. ${description}` : node.label;
                const predictions = await neuralNet.predictCategory(nodeText);
                
                if (predictions && predictions.length > 0) {
                    const topPredictions = predictions.slice(0, 3)
                        .filter(p => p.probability > 0.1)
                        .map(p => `${p.category} (${Math.round(p.probability * 100)}%)`);
                    
                    if (topPredictions.length > 0) {
                        neuralContext = `\n\nNEURAL NETWORK ANALYSIS:
The user's personalized neural network suggests this content relates to: ${topPredictions.join(', ')}
Consider these learned patterns when generating suggestions.`;
                    }
                }
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 300,
                    messages: [{
                        role: 'user',
                        content: `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${node.label}"${description ? `\n- Description: "${description}"` : ''}
- Path to root: ${context}
- Existing children: ${siblings || 'none yet'}${neuralContext}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of strings with the node labels. Make them concise but meaningful.
Example: ["Daily Habits", "Weekly Reviews", "Long-term Vision"]`
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            const ideas = JSON.parse(text);
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    store.addNode(nodeId, { label: idea, color: node.color, source: 'brainstorm' });
                });
                
                buildScene();
                
                // Focus on the parent node
                const parentMesh = nodes.get(nodeId);
                if (parentMesh) {
                    selectNode(parentMesh);
                    
                    // Expand if collapsed
                    if (!parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
                
                showToast(`Added ${ideas.length} ideas`, 'success');
                audio.ai();
                
                // Update embeddings for new nodes in background
                if (neuralNet.isReady) {
                    ideas.forEach(async (idea) => {
                        await neuralNet.getEmbedding(idea);
                    });
                    neuralNet.saveEmbeddings();
                }
            }
            
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast('Failed to generate ideas', 'error');
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SMART NODE PLACEMENT - Uses neural network for intelligent categorization
    // ═══════════════════════════════════════════════════════════════════
    
    async function smartAddNode(label, description = '') {
        if (!neuralNet.isReady || neuralNet.categories.length === 0) {
            // Fall back to adding under root or selected node
            const parentId = selectedNode?.userData.id || 'mynd';
            const parentNode = store.findNode(parentId);
            const newNode = store.addNode(parentId, { 
                label, 
                description,
                color: parentNode?.color 
            });
            buildScene();
            return newNode;
        }
        
        const nodeText = description ? `${label}. ${description}` : label;
        
        // Get predictions
        const predictions = await neuralNet.predictCategory(nodeText);
        
        if (predictions && predictions.length > 0 && predictions[0].probability > 0.5) {
            // High confidence - place under predicted category
            const categoryLabel = predictions[0].category;
            
            // Find the category node
            const categoryNode = store.data.children?.find(c => c.label === categoryLabel);
            
            if (categoryNode) {
                // Get Claude suggestion for specific parent within category
                const claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
                
                let parentId = categoryNode.id;
                
                // Try to find more specific parent if Claude suggests one
                if (claudeSuggestion?.suggestedParent) {
                    const findNode = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNode(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const specificParent = findNode(categoryNode, claudeSuggestion.suggestedParent);
                    if (specificParent) {
                        parentId = specificParent.id;
                    }
                }
                
                const parentNode = store.findNode(parentId);
                const newNode = store.addNode(parentId, { 
                    label, 
                    description,
                    color: parentNode?.color 
                });
                
                buildScene();
                
                // Focus on the new node
                setTimeout(() => {
                    const mesh = nodes.get(newNode.id);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                    }
                }, 100);
                
                showToast(`Added to ${categoryLabel}`, 'success');
                return newNode;
            }
        }
        
        // Low confidence or no prediction - ask user or add to root
        const parentId = selectedNode?.userData.id || 'mynd';
        const parentNode = store.findNode(parentId);
        const newNode = store.addNode(parentId, { 
            label, 
            description,
            color: parentNode?.color 
        });
        
        buildScene();
        return newNode;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // AUTO-TRAIN ON SIGNIFICANT CHANGES
    // ═══════════════════════════════════════════════════════════════════
    
    let nodeCountAtLastTrain = 0;
    const AUTO_TRAIN_THRESHOLD = 10; // Train when 10 new nodes added
    
    bus.on('data:saved', () => {
        if (!neuralNet.isReady || neuralNet.isTraining) return;
        
        // Count total nodes
        let nodeCount = 0;
        const countNodes = (node) => {
            nodeCount++;
            node.children?.forEach(countNodes);
        };
        countNodes(store.data);
        
        // Auto-train if significant new nodes
        if (nodeCount - nodeCountAtLastTrain >= AUTO_TRAIN_THRESHOLD) {
            console.log('🧠 Auto-training neural network (new nodes detected)');
            neuralNet.train(store).then(() => {
                nodeCountAtLastTrain = nodeCount;
            });
        }
    });

    // Start the app
    init();
    
    // ═══════════════════════════════════════════════════════════════════
    // LINK MANAGER - Add links from URLs
    // ═══════════════════════════════════════════════════════════════════
    const LinkManager = {
        modal: null,
        currentLink: null,
        selectedCategory: null,
        pasteToast: null,
        
        init() {
            this.modal = document.getElementById('link-modal');
            this.createPasteToast();
            this.bindEvents();
        },
        
        createPasteToast() {
            // Create a special toast for link paste detection
            const toast = document.createElement('div');
            toast.id = 'link-paste-toast';
            toast.innerHTML = `
                <div class="link-paste-content">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;flex-shrink:0;">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                    </svg>
                    <span class="link-paste-text">Link detected</span>
                    <button class="link-paste-add">Add to Map</button>
                    <button class="link-paste-dismiss">✕</button>
                </div>
            `;
            document.body.appendChild(toast);
            this.pasteToast = toast;
            
            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                #link-paste-toast {
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%) translateY(100px);
                    background: var(--bg-primary);
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                    border: 1px solid var(--bg-tertiary);
                    z-index: 10001;
                    opacity: 0;
                    pointer-events: none;
                    transition: all 0.3s ease;
                }
                
                #link-paste-toast.visible {
                    transform: translateX(-50%) translateY(0);
                    opacity: 1;
                    pointer-events: auto;
                }
                
                .link-paste-content {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 12px 16px;
                    color: var(--text-primary);
                }
                
                .link-paste-text {
                    font-size: 14px;
                    font-weight: 500;
                    max-width: 200px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                
                .link-paste-add {
                    background: var(--accent);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                
                .link-paste-add:hover {
                    filter: brightness(1.1);
                }
                
                .link-paste-dismiss {
                    background: none;
                    border: none;
                    color: var(--text-tertiary);
                    font-size: 16px;
                    cursor: pointer;
                    padding: 4px;
                    line-height: 1;
                }
                
                .link-paste-dismiss:hover {
                    color: var(--text-primary);
                }
                
                @media (max-width: 768px) {
                    #link-paste-toast {
                        bottom: 140px;
                        left: 16px;
                        right: 16px;
                        transform: translateX(0) translateY(100px);
                    }
                    
                    #link-paste-toast.visible {
                        transform: translateX(0) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);
        },
        
        bindEvents() {
            // Open modal
            document.getElementById('quick-link')?.addEventListener('click', () => {
                this.open();
            });
            
            // Close modal
            document.getElementById('link-modal-close')?.addEventListener('click', () => {
                this.close();
            });
            
            document.getElementById('link-cancel')?.addEventListener('click', () => {
                this.close();
            });
            
            // Close on overlay click
            this.modal?.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.close();
                }
            });
            
            // Close on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.modal?.classList.contains('active')) {
                    this.close();
                }
            });
            
            // Fetch button
            document.getElementById('link-fetch')?.addEventListener('click', () => {
                this.fetchLink();
            });
            
            // Enter in URL input
            document.getElementById('link-url')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.fetchLink();
                }
            });
            
            // Auto-detect URL paste in modal
            document.getElementById('link-url')?.addEventListener('paste', (e) => {
                setTimeout(() => this.fetchLink(), 100);
            });
            
            // Add to map
            document.getElementById('link-add')?.addEventListener('click', () => {
                this.addToMap();
            });
            
            // SMART PASTE DETECTION - Global paste listener
            document.addEventListener('paste', (e) => {
                this.handleGlobalPaste(e);
            });
            
            // Paste toast buttons
            this.pasteToast?.querySelector('.link-paste-add')?.addEventListener('click', () => {
                this.addPastedLink();
            });
            
            this.pasteToast?.querySelector('.link-paste-dismiss')?.addEventListener('click', () => {
                this.hidePasteToast();
            });
        },
        
        // Check if text is a valid URL
        isURL(text) {
            if (!text || typeof text !== 'string') return false;
            text = text.trim();
            
            // Quick pattern check
            if (!text.match(/^https?:\/\//i) && !text.match(/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}/i)) {
                return false;
            }
            
            // Add protocol if missing
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            
            try {
                new URL(text);
                return true;
            } catch {
                return false;
            }
        },
        
        // Normalize URL (add protocol if missing)
        normalizeURL(text) {
            text = text.trim();
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            return text;
        },
        
        // Handle paste anywhere in the document
        handleGlobalPaste(e) {
            // Ignore if we're in an input field (let normal paste work)
            const activeEl = document.activeElement;
            const isInput = activeEl && (
                activeEl.tagName === 'INPUT' || 
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.isContentEditable
            );
            
            // Allow paste in link-url input (handled separately)
            if (activeEl?.id === 'link-url') return;
            
            // If in another input, only intercept if it's clearly a URL being pasted into quick-input
            if (isInput && activeEl?.id !== 'quick-input') return;
            
            // Get clipboard text
            const text = e.clipboardData?.getData('text')?.trim();
            if (!text || !this.isURL(text)) return;
            
            // Don't show if modal is already open
            if (this.modal?.classList.contains('active')) return;
            
            // If pasting into quick-input, intercept it
            if (activeEl?.id === 'quick-input') {
                e.preventDefault();
            }
            
            // Store the URL and show toast
            this.pendingURL = this.normalizeURL(text);
            this.showPasteToast(this.pendingURL);
        },
        
        showPasteToast(url) {
            // Get domain for display
            try {
                const domain = new URL(url).hostname.replace('www.', '');
                this.pasteToast.querySelector('.link-paste-text').textContent = domain;
            } catch {
                this.pasteToast.querySelector('.link-paste-text').textContent = 'Link detected';
            }
            
            this.pasteToast.classList.add('visible');
            
            // Auto-hide after 5 seconds
            clearTimeout(this.pasteToastTimeout);
            this.pasteToastTimeout = setTimeout(() => {
                this.hidePasteToast();
            }, 5000);
        },
        
        hidePasteToast() {
            this.pasteToast.classList.remove('visible');
            clearTimeout(this.pasteToastTimeout);
        },
        
        addPastedLink() {
            if (!this.pendingURL) return;
            
            this.hidePasteToast();
            this.openWithURL(this.pendingURL);
            this.pendingURL = null;
        },
        
        openWithURL(url) {
            this.open();
            document.getElementById('link-url').value = url;
            // Auto-fetch
            setTimeout(() => this.fetchLink(), 100);
        },
        
        open() {
            this.modal.classList.add('active');
            this.reset();
            document.getElementById('link-url').focus();
        },
        
        close() {
            this.modal.classList.remove('active');
            this.reset();
        },
        
        reset() {
            document.getElementById('link-url').value = '';
            document.getElementById('link-preview').style.display = 'none';
            document.getElementById('link-category').style.display = 'none';
            document.getElementById('link-add').disabled = true;
            this.currentLink = null;
            this.selectedCategory = null;
        },
        
        async fetchLink() {
            const url = document.getElementById('link-url').value.trim();
            
            if (!url) {
                showToast('Please enter a URL', 'error');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }
            
            // Show loading
            document.getElementById('link-preview').style.display = 'block';
            document.getElementById('link-preview-loading').style.display = 'flex';
            document.getElementById('link-preview-content').style.display = 'none';
            
            try {
                // Extract metadata
                const metadata = await this.extractMetadata(url);
                this.currentLink = metadata;
                
                // Show preview
                this.showPreview(metadata);
                
                // Get AI categorization
                await this.categorizeLink(metadata);
                
                // Enable add button
                document.getElementById('link-add').disabled = false;
                
                // For video content, try to fetch transcript in background
                if (metadata.type === 'video') {
                    this.fetchAndProcessTranscript(url, metadata);
                }
                
            } catch (error) {
                console.error('Failed to fetch link:', error);
                showToast('Failed to fetch link info', 'error');
                document.getElementById('link-preview').style.display = 'none';
            }
        },
        
        async fetchAndProcessTranscript(url, metadata) {
            // Show transcript loading indicator
            const transcriptStatus = document.getElementById('link-transcript-status');
            if (transcriptStatus) {
                transcriptStatus.style.display = 'flex';
                transcriptStatus.innerHTML = `
                    <svg class="spinner" viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" opacity="0.25"/>
                        <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                    </svg>
                    <span>Fetching transcript...</span>
                `;
            }
            
            try {
                const transcriptData = await this.fetchTranscript(url, metadata);
                
                if (transcriptData && transcriptData.text) {
                    // Store transcript with current link
                    this.currentLink.transcript = transcriptData.text;
                    this.currentLink.transcriptSource = transcriptData.source;
                    
                    // Update status
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span style="color: #22c55e;">Transcript found (${Math.round(transcriptData.text.length / 100) / 10}k chars)</span>
                        `;
                    }
                    
                    // Generate AI summary if we have API key and no description yet
                    const currentDescription = document.getElementById('link-preview-description').value.trim();
                    if (!currentDescription || currentDescription.startsWith('Video by')) {
                        const summary = await this.generateAISummary(transcriptData.text, metadata);
                        if (summary) {
                            document.getElementById('link-preview-description').value = summary;
                            this.currentLink.description = summary;
                            this.currentLink.aiSummary = summary;
                            
                            // Update status
                            if (transcriptStatus) {
                                transcriptStatus.innerHTML = `
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span style="color: #22c55e;">✨ AI summary generated</span>
                                `;
                            }
                        }
                    }
                } else {
                    // No transcript available
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                            <span>No transcript available</span>
                        `;
                    }
                }
            } catch (error) {
                console.warn('Transcript fetch failed:', error);
                if (transcriptStatus) {
                    transcriptStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <circle cx="12" cy="16" r="1" fill="currentColor"/>
                        </svg>
                        <span>Transcript fetch failed</span>
                    `;
                }
            }
        },
        
        async extractMetadata(url) {
            const urlObj = new URL(url);
            const domain = urlObj.hostname.replace('www.', '');
            
            // Basic metadata from URL
            const metadata = {
                url: url,
                domain: domain,
                title: '',
                description: '',
                image: '',
                favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`,
                type: this.detectContentType(url, domain),
                source: 'url' // Track where we got the data
            };
            
            // Method 1: YouTube oEmbed (free, no API key needed)
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                try {
                    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
                    const response = await fetch(oembedUrl);
                    if (response.ok) {
                        const data = await response.json();
                        metadata.title = data.title || '';
                        metadata.description = `Video by ${data.author_name}`;
                        metadata.image = data.thumbnail_url || '';
                        metadata.author = data.author_name;
                        metadata.source = 'youtube';
                        console.log('✓ Got YouTube metadata via oEmbed');
                        return metadata;
                    }
                } catch (e) {
                    console.warn('YouTube oEmbed failed:', e);
                }
            }
            
            // Method 2: Free metadata API (jsonlink.io)
            // Works for TikTok, Twitter, Instagram, articles, etc.
            try {
                const metaApiUrl = `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`;
                const response = await fetch(metaApiUrl);
                if (response.ok) {
                    const data = await response.json();
                    if (data.title || data.description) {
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.images?.[0] || '';
                        metadata.author = data.author || data.site_name || '';
                        metadata.source = 'jsonlink';
                        console.log('✓ Got metadata via jsonlink.io');
                        
                        // For TikTok, the description often IS the video caption
                        if (domain.includes('tiktok.com') && metadata.description) {
                            // Move caption to title if title is generic
                            if (!metadata.title || metadata.title.includes('TikTok')) {
                                metadata.title = metadata.description.slice(0, 100) + (metadata.description.length > 100 ? '...' : '');
                                metadata.description = metadata.author ? `Video by ${metadata.author}` : '';
                            }
                        }
                        
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('jsonlink.io failed:', e);
            }
            
            // Method 3: Try microlink.io as backup
            try {
                const microlinkUrl = `https://api.microlink.io?url=${encodeURIComponent(url)}`;
                const response = await fetch(microlinkUrl);
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success' && result.data) {
                        const data = result.data;
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.image?.url || '';
                        metadata.author = data.author || data.publisher || '';
                        metadata.source = 'microlink';
                        console.log('✓ Got metadata via microlink.io');
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('microlink.io failed:', e);
            }
            
            // Method 4: Use Claude AI to guess from URL (if we have API key)
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (apiKey && !metadata.title) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 300,
                            messages: [{
                                role: 'user',
                                content: `Extract information about this URL: ${url}

Based on the URL pattern and domain, provide your best guess for:
1. A short, descriptive title (what the content is likely about)
2. A brief description (1-2 sentences max)
3. The type of content (video, article, product, social post, etc.)

Return ONLY JSON:
{"title": "...", "description": "...", "type": "..."}`
                            }]
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const text = data.content[0].text;
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const info = JSON.parse(jsonMatch[0]);
                            metadata.title = info.title || metadata.title;
                            metadata.description = info.description || metadata.description;
                            metadata.type = info.type || metadata.type;
                            metadata.source = 'ai';
                            console.log('✓ Got metadata via Claude AI');
                        }
                    }
                } catch (e) {
                    console.warn('Could not get AI metadata:', e);
                }
            }
            
            // Fallback: Parse title from URL
            if (!metadata.title) {
                const path = urlObj.pathname.split('/').filter(Boolean).pop() || '';
                metadata.title = path
                    .replace(/[-_]/g, ' ')
                    .replace(/\.(html|php|aspx?)$/i, '')
                    .replace(/\b\w/g, l => l.toUpperCase()) || domain;
                metadata.source = 'fallback';
            }
            
            return metadata;
        },
        
        detectContentType(url, domain) {
            const lowerUrl = url.toLowerCase();
            const lowerDomain = domain.toLowerCase();
            
            // Video platforms
            if (['youtube.com', 'youtu.be', 'vimeo.com', 'tiktok.com', 'twitch.tv'].some(d => lowerDomain.includes(d))) {
                return 'video';
            }
            
            // Social media
            if (['twitter.com', 'x.com', 'facebook.com', 'instagram.com', 'linkedin.com', 'reddit.com', 'threads.net'].some(d => lowerDomain.includes(d))) {
                return 'social';
            }
            
            // Shopping
            if (['amazon.com', 'ebay.com', 'etsy.com', 'shopify.com', 'shop'].some(d => lowerDomain.includes(d)) || lowerUrl.includes('/product')) {
                return 'product';
            }
            
            // News/Articles
            if (['medium.com', 'substack.com', 'news', 'blog', 'article'].some(d => lowerUrl.includes(d))) {
                return 'article';
            }
            
            // Code
            if (['github.com', 'gitlab.com', 'stackoverflow.com', 'codepen.io'].some(d => lowerDomain.includes(d))) {
                return 'code';
            }
            
            return 'link';
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // VIDEO TRANSCRIPT EXTRACTION
        // ═══════════════════════════════════════════════════════════════════
        
        async fetchTranscript(url, metadata) {
            const domain = metadata.domain;
            console.log('📝 Attempting transcript fetch for:', domain);
            
            let transcript = null;
            let transcriptSource = null;
            
            // YouTube transcripts
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                transcript = await this.fetchYouTubeTranscript(url);
                if (transcript) transcriptSource = 'youtube-captions';
            }
            
            // TikTok transcripts
            else if (domain.includes('tiktok.com')) {
                transcript = await this.fetchTikTokTranscript(url);
                if (transcript) transcriptSource = 'tiktok-captions';
            }
            
            // Instagram Reels
            else if (domain.includes('instagram.com') && url.includes('/reel')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'instagram-captions';
            }
            
            // Twitter/X videos
            else if ((domain.includes('twitter.com') || domain.includes('x.com')) && url.includes('/video')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'twitter-captions';
            }
            
            if (transcript) {
                console.log(`✓ Got transcript (${transcript.length} chars) from ${transcriptSource}`);
                return { text: transcript, source: transcriptSource };
            }
            
            console.log('✗ No transcript available');
            return null;
        },
        
        extractYouTubeVideoId(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([^&\n?#]+)/,
                /youtube\.com\/shorts\/([^&\n?#]+)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        },
        
        async fetchYouTubeTranscript(url) {
            const videoId = this.extractYouTubeVideoId(url);
            if (!videoId) {
                console.warn('Could not extract YouTube video ID');
                return null;
            }
            
            console.log('📺 Fetching YouTube transcript for:', videoId);
            
            // Method 1: Try youtubetranscript.com API (free, no key needed)
            try {
                const response = await fetch(`https://youtubetranscript.com/?server_vid2=${videoId}`);
                if (response.ok) {
                    const text = await response.text();
                    // Parse the XML response
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/xml');
                    const textElements = doc.querySelectorAll('text');
                    
                    if (textElements.length > 0) {
                        const transcript = Array.from(textElements)
                            .map(el => el.textContent)
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (transcript.length > 50) {
                            console.log('✓ Got YouTube transcript via youtubetranscript.com');
                            return transcript;
                        }
                    }
                }
            } catch (e) {
                console.warn('youtubetranscript.com failed:', e);
            }
            
            // Method 2: Try kome.ai transcript API
            try {
                const response = await fetch(`https://kome.ai/api/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript) {
                        console.log('✓ Got YouTube transcript via kome.ai');
                        return data.transcript;
                    }
                }
            } catch (e) {
                console.warn('kome.ai failed:', e);
            }
            
            // Method 3: Try tactiq.io API
            try {
                const response = await fetch(`https://tactiq-apps-prod.tactiq.io/transcript?videoId=${videoId}&langCode=en`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.captions && data.captions.length > 0) {
                        const transcript = data.captions.map(c => c.text).join(' ');
                        console.log('✓ Got YouTube transcript via tactiq.io');
                        return transcript;
                    }
                }
            } catch (e) {
                console.warn('tactiq.io failed:', e);
            }
            
            return null;
        },
        
        extractTikTokVideoId(url) {
            // TikTok URLs: tiktok.com/@user/video/1234567890
            const match = url.match(/\/video\/(\d+)/);
            return match ? match[1] : null;
        },
        
        async fetchTikTokTranscript(url) {
            console.log('📱 Fetching TikTok transcript...');
            
            // Method 1: Try supdata.ai (has free tier for transcripts)
            try {
                const response = await fetch(`https://api.supdata.ai/v1/tiktok/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript || data.text) {
                        console.log('✓ Got TikTok transcript via supdata.ai');
                        return data.transcript || data.text;
                    }
                }
            } catch (e) {
                console.warn('supdata.ai failed:', e);
            }
            
            // Note: tikwm.com only returns captions/descriptions, not actual spoken transcripts
            // So we don't use it as a transcript source
            
            return null;
        },
        
        async fetchGenericTranscript(url) {
            // Try generic video transcript services
            console.log('🎬 Trying generic transcript fetch...');
            
            // Could add more services here as they become available
            // For now, return null - user can add description manually
            return null;
        },
        
        async generateAISummary(transcript, metadata) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey || !transcript) return null;
            
            console.log('🤖 Generating AI summary from transcript...');
            
            // Truncate transcript if too long (keep first 4000 chars)
            const truncatedTranscript = transcript.length > 4000 
                ? transcript.substring(0, 4000) + '...' 
                : transcript;
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `Summarize this ${metadata.type || 'video'} transcript in 2-3 sentences. Focus on the key points and takeaways. Be concise.

Title: ${metadata.title || 'Unknown'}
Author: ${metadata.author || 'Unknown'}

Transcript:
${truncatedTranscript}

Summary:`
                        }]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const summary = data.content[0].text.trim();
                    console.log('✓ Generated AI summary');
                    return summary;
                }
            } catch (e) {
                console.warn('AI summary generation failed:', e);
            }
            
            return null;
        },
        
        showPreview(metadata) {
            document.getElementById('link-preview-loading').style.display = 'none';
            document.getElementById('link-preview-content').style.display = 'flex';
            
            // Set preview content
            const img = document.getElementById('link-preview-image');
            if (metadata.image) {
                img.src = metadata.image;
                img.style.display = 'block';
                img.style.objectFit = 'cover';
                img.style.padding = '0';
                img.style.background = 'var(--bg-tertiary)';
            } else {
                // Use a placeholder with the favicon
                img.src = metadata.favicon;
                img.style.objectFit = 'contain';
                img.style.padding = '20px';
                img.style.background = 'var(--bg-tertiary)';
            }
            
            document.getElementById('link-preview-title').value = metadata.title;
            document.getElementById('link-preview-description').value = metadata.description;
            
            // Source indicator
            const sourceLabels = {
                'youtube': '✓ YouTube',
                'jsonlink': '✓ Real data',
                'microlink': '✓ Real data',
                'ai': '✨ AI guess',
                'fallback': '⚠️ From URL'
            };
            const sourceLabel = sourceLabels[metadata.source] || '';
            
            document.getElementById('link-preview-source').innerHTML = `
                <img src="${metadata.favicon}" alt="">
                ${metadata.domain} • ${metadata.type}
                ${sourceLabel ? `<span style="margin-left: 8px; opacity: 0.7;">${sourceLabel}</span>` : ''}
            `;
        },
        
        async categorizeLink(metadata) {
            const categories = neuralNet.categories;
            
            if (categories.length === 0) {
                // No trained categories, use default placement
                this.selectedCategory = null;
                document.getElementById('link-category').style.display = 'none';
                return;
            }
            
            document.getElementById('link-category').style.display = 'block';
            document.getElementById('link-category-name').textContent = 'Analyzing...';
            document.getElementById('link-category-confidence').textContent = '';
            document.getElementById('link-category-alt').innerHTML = '';
            
            // Use neural network + Claude to categorize
            const contentText = `${metadata.title}. ${metadata.description}. ${metadata.type} from ${metadata.domain}`;
            
            try {
                // Get neural network predictions
                const predictions = await neuralNet.predictCategory(contentText);
                
                if (predictions && predictions.length > 0) {
                    // Show top prediction
                    const top = predictions[0];
                    this.selectedCategory = top.category;
                    
                    document.getElementById('link-category-name').textContent = top.category;
                    document.getElementById('link-category-confidence').textContent = `${Math.round(top.probability * 100)}%`;
                    
                    // Show alternatives
                    const alts = predictions.slice(1, 4);
                    document.getElementById('link-category-alt').innerHTML = alts.map(p => `
                        <div class="link-category-alt-item" data-category="${p.category}">
                            ${p.category} (${Math.round(p.probability * 100)}%)
                        </div>
                    `).join('');
                    
                    // Handle alt selection
                    document.querySelectorAll('.link-category-alt-item').forEach(el => {
                        el.addEventListener('click', () => {
                            this.selectedCategory = el.dataset.category;
                            document.querySelectorAll('.link-category-alt-item').forEach(e => e.classList.remove('selected'));
                            el.classList.add('selected');
                            document.getElementById('link-category-name').textContent = el.dataset.category;
                        });
                    });
                } else {
                    // No predictions available
                    document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                    this.selectedCategory = categories[0] || null;
                }
                
            } catch (error) {
                console.error('Categorization error:', error);
                document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                this.selectedCategory = categories[0] || null;
            }
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // SMART ORGANIZATION - Creates sub-folders when patterns detected
        // ═══════════════════════════════════════════════════════════════════
        
        async smartOrganize(parentId, newItemDomain, newItemType) {
            const parentNode = store.findNode(parentId);
            if (!parentNode || !parentNode.children) {
                console.log('📁 SmartOrganize: No parent or no children');
                return { parentId, organized: false };
            }
            
            // Analyze siblings for patterns
            const siblings = parentNode.children;
            const domainGroups = {};
            
            console.log(`📁 SmartOrganize: Analyzing ${siblings.length} siblings in "${parentNode.label}"`);
            
            // Group existing children by domain (check both link.domain and URL)
            siblings.forEach(child => {
                let domain = null;
                
                // Try to get domain from link.domain
                if (child.link?.domain) {
                    domain = this.normalizeDomain(child.link.domain);
                }
                // Also try to extract from URL if domain is missing
                else if (child.link?.url) {
                    try {
                        const urlObj = new URL(child.link.url);
                        domain = this.normalizeDomain(urlObj.hostname);
                    } catch (e) {}
                }
                
                if (domain) {
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            });
            
            console.log('📁 SmartOrganize: Domain groups:', Object.keys(domainGroups).map(k => `${k}: ${domainGroups[k].length}`).join(', '));
            
            const normalizedNewDomain = this.normalizeDomain(newItemDomain);
            console.log(`📁 SmartOrganize: New item domain: "${newItemDomain}" → normalized: "${normalizedNewDomain}"`);
            
            // Check if we should create a domain-based sub-folder
            // Trigger: 1+ existing items from same domain (so 2+ total after adding new one)
            if (normalizedNewDomain && domainGroups[normalizedNewDomain]?.length >= 1) {
                const existingSameDomain = domainGroups[normalizedNewDomain];
                const folderName = this.getDomainFolderName(normalizedNewDomain);
                
                console.log(`📁 SmartOrganize: Found ${existingSameDomain.length} existing items from ${normalizedNewDomain}`);
                
                // Check if folder already exists
                const existingFolder = siblings.find(s => 
                    s.label.toLowerCase() === folderName.toLowerCase() && 
                    !s.link // It's a folder, not a link
                );
                
                if (existingFolder) {
                    // Folder exists, just use it as parent
                    console.log(`📁 SmartOrganize: "${folderName}" folder already exists, using it`);
                    return { parentId: existingFolder.id, organized: false };
                }
                
                // Create new sub-folder
                console.log(`📁 SmartOrganize: Creating "${folderName}" folder and moving ${existingSameDomain.length} existing items`);
                
                const folderNode = store.addNode(parentId, {
                    label: folderName,
                    description: `Collection of ${folderName} content`,
                    color: parentNode.color,
                    source: 'smart-organize'
                });
                
                // Move existing same-domain items into the folder
                let movedCount = 0;
                for (const item of existingSameDomain) {
                    const moved = store.moveNode(item.id, folderNode.id);
                    if (moved) movedCount++;
                    console.log(`📁 SmartOrganize: Moving "${item.label}" → ${moved ? 'success' : 'failed'}`);
                }
                
                showToast(`📁 Created "${folderName}" folder and organized ${movedCount} existing items`, 'success');
                
                return { parentId: folderNode.id, organized: true, folderName };
            }
            
            // Check if parent has too many children (> 7) and we should suggest AI organization
            if (siblings.length > 7 && localStorage.getItem(CONFIG.API_KEY)) {
                console.log('⚠️ Parent has many children, consider reorganizing');
            }
            
            return { parentId, organized: false };
        },
        
        normalizeDomain(domain) {
            if (!domain) return null;
            // Remove www. and common subdomains, then lowercase
            return domain
                .replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '')
                .toLowerCase();
        },
        
        getDomainFolderName(domain) {
            // Map common domains to friendly folder names
            const domainNames = {
                'tiktok.com': 'TikToks',
                'youtube.com': 'YouTube Videos',
                'youtu.be': 'YouTube Videos',
                'instagram.com': 'Instagram',
                'twitter.com': 'Twitter/X',
                'x.com': 'Twitter/X',
                'reddit.com': 'Reddit Posts',
                'github.com': 'GitHub Repos',
                'medium.com': 'Medium Articles',
                'substack.com': 'Substack',
                'linkedin.com': 'LinkedIn',
                'facebook.com': 'Facebook',
                'pinterest.com': 'Pinterest',
                'spotify.com': 'Spotify',
                'soundcloud.com': 'SoundCloud',
                'twitch.tv': 'Twitch',
                'vimeo.com': 'Vimeo'
            };
            
            return domainNames[domain] || `${domain.split('.')[0].charAt(0).toUpperCase() + domain.split('.')[0].slice(1)} Links`;
        },
        
        async addToMap() {
            if (!this.currentLink) return;
            
            // Get user-edited values
            const title = document.getElementById('link-preview-title').value.trim() || this.currentLink.title;
            const description = document.getElementById('link-preview-description').value.trim();
            
            // Find parent node (selected category or selected node or root)
            let parentId = store.data.id;
            
            if (this.selectedCategory) {
                // Find the category node
                const findCategory = (node) => {
                    if (node.label === this.selectedCategory) return node;
                    for (const child of (node.children || [])) {
                        const found = findCategory(child);
                        if (found) return found;
                    }
                    return null;
                };
                const categoryNode = findCategory(store.data);
                if (categoryNode) {
                    parentId = categoryNode.id;
                }
            } else if (selectedNode && selectedNode.userData.id !== 'mynd') {
                parentId = selectedNode.userData.id;
            }
            
            // Smart organization - check if we should create a sub-folder
            const organizeResult = await this.smartOrganize(
                parentId, 
                this.currentLink.domain, 
                this.currentLink.type
            );
            parentId = organizeResult.parentId;
            
            const parentNode = store.findNode(parentId);
            
            // Build link data with transcript if available
            const linkData = {
                url: this.currentLink.url,
                domain: this.currentLink.domain,
                type: this.currentLink.type,
                favicon: this.currentLink.favicon,
                image: this.currentLink.image || null,
                author: this.currentLink.author || null,
                source: this.currentLink.source || 'unknown',
                addedAt: new Date().toISOString()
            };
            
            // Include transcript if available
            if (this.currentLink.transcript) {
                linkData.transcript = this.currentLink.transcript;
                linkData.transcriptSource = this.currentLink.transcriptSource;
            }
            
            // Include AI summary if generated
            if (this.currentLink.aiSummary) {
                linkData.aiSummary = this.currentLink.aiSummary;
            }
            
            // Add the link node
            const newNode = store.addNode(parentId, {
                label: title,
                description: description,
                color: parentNode?.color,
                link: linkData
            });
            
            // Rebuild scene
            buildScene();
            
            // Focus on the new node
            setTimeout(() => {
                const newMesh = nodes.get(newNode.id);
                if (newMesh) {
                    selectNode(newMesh);
                    focusOnNode(newMesh);
                    
                    // Expand parent if collapsed
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
            }, 100);
            
            this.close();
            showToast(`Added "${title}" to ${this.selectedCategory || 'map'}`, 'success');
            audio.add();
        }
    };
    
    // Initialize Link Manager
    setTimeout(() => {
        LinkManager.init();
    }, 50);
    
    // Initialize Neural Network UI after app init
    setTimeout(() => {
        NeuralUI.init();
    }, 100);

    </script>
</body>
</html>
