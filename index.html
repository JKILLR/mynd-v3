<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MYND — Your Mind, Visualized</title>
    <meta name="theme-color" content="#0a0a0f">
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* ═══════════════════════════════════════════════════════════
           THEME SYSTEM - 6 Modern Themes
           ═══════════════════════════════════════════════════════════ */
        :root {
            /* Base/Shared Variables */
            --font-display: 'Space Grotesk', sans-serif;
            --font-body: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            
            --space-1: 4px; --space-2: 8px; --space-3: 12px; --space-4: 16px; 
            --space-5: 20px; --space-6: 24px; --space-7: 32px; --space-8: 40px;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            
            --duration-instant: 100ms;
            --duration-fast: 200ms;
            --duration-normal: 350ms;
            --duration-slow: 500ms;
            --duration-slower: 800ms;
            
            --z-bg: 0;
            --z-canvas: 1;
            --z-ui: 100;
            --z-dropdown: 150;
            --z-overlay: 200;
            --z-spotlight: 250;
            --z-modal: 300;
            --z-toast: 400;
            
            /* Default to Sandstone theme */
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --glass-blur: 20px;
            --nebula-1: rgba(177, 116, 87, 0.08);
            --nebula-2: rgba(74, 73, 71, 0.06);
            --nebula-3: rgba(216, 210, 194, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
            --shadow-glow: 0 0 24px var(--accent-glow);
            
            /* AI/Brainstorm button colors */
            --purple: #8B5CF6;
            --pink: #EC4899;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 1: SANDSTONE - Natural/Professional (Default)
           Inspired by: Milk, Light Stone, Desert Clay, Graphite
           ═══════════════════════════════════════════════════════════ */
        [data-theme="sandstone"] {
            --bg-deep: #F9F7F0;
            --bg-primary: #FAF9F6;
            --bg-secondary: #F5F3EE;
            --bg-tertiary: #EBE8E2;
            --bg-elevated: #E5E1D8;
            --text-primary: #2C2C2C;
            --text-secondary: #5A5A52;
            --text-muted: #8A8A7E;
            --accent: #C4978A;
            --accent-light: #D4A89A;
            --accent-glow: rgba(196, 151, 138, 0.3);
            --glass-bg: rgba(250, 249, 246, 0.92);
            --glass-border: rgba(0, 0, 0, 0.06);
            --nebula-1: rgba(196, 151, 138, 0.08);
            --nebula-2: rgba(74, 73, 71, 0.06);
            --nebula-3: rgba(216, 210, 194, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 16px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.08);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 2: CORAL - Ultra-flat Cartoon/Pastel
           Inspired by: Clean white UI, soft pastels, no shadows
           ═══════════════════════════════════════════════════════════ */
        [data-theme="coral"] {
            --bg-deep: #FAFAFA;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F5F5F5;
            --bg-tertiary: #EEEEEE;
            --bg-elevated: #E8E8E8;
            --text-primary: #1A1A1A;
            --text-secondary: #666666;
            --text-muted: #999999;
            --accent: #E87D7D;
            --accent-light: #F09999;
            --accent-glow: rgba(232, 125, 125, 0.2);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.04);
            --glass-blur: 0px;
            --nebula-1: rgba(0, 0, 0, 0);
            --nebula-2: rgba(0, 0, 0, 0);
            --nebula-3: rgba(0, 0, 0, 0);
            --shadow-sm: none;
            --shadow-md: none;
            --shadow-lg: none;
            --shadow-glow: none;
        }
        
        /* Minimal theme specific - remove all visual noise */
        [data-theme="coral"] .brand,
        [data-theme="coral"] .icon-btn,
        [data-theme="coral"] #side-panel,
        [data-theme="coral"] #info-panel,
        [data-theme="coral"] .modal-content,
        [data-theme="coral"] #theme-picker,
        [data-theme="coral"] #menu-dropdown {
            box-shadow: none !important;
            border: 1px solid #E0E0E0 !important;
        }
        
        [data-theme="coral"] .brand-logo {
            background: var(--accent) !important;
            box-shadow: none !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 3: EMBER - Warm Light
           Inspired by: Burnt orange to cream gradient on warm white
           ═══════════════════════════════════════════════════════════ */
        [data-theme="ember"] {
            --bg-deep: #FAF6F0;
            --bg-primary: #FDF9F4;
            --bg-secondary: #F5F0E8;
            --bg-tertiary: #EDE6DC;
            --bg-elevated: #E5DCD0;
            --text-primary: #2A2420;
            --text-secondary: #5A5048;
            --text-muted: #8A8078;
            --accent: #E87830;
            --accent-light: #F49848;
            --accent-glow: rgba(232, 120, 48, 0.3);
            --glass-bg: rgba(253, 249, 244, 0.95);
            --glass-border: rgba(42, 36, 32, 0.08);
            --nebula-1: rgba(232, 120, 48, 0.1);
            --nebula-2: rgba(244, 152, 72, 0.08);
            --nebula-3: rgba(255, 200, 100, 0.06);
            --shadow-sm: 0 2px 8px rgba(42, 36, 32, 0.06);
            --shadow-md: 0 4px 20px rgba(42, 36, 32, 0.08);
            --shadow-lg: 0 8px 40px rgba(42, 36, 32, 0.1);
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 4: FROST - Glassmorphism Light
           Inspired by: Frosted glass panels, soft backgrounds
           ═══════════════════════════════════════════════════════════ */
        [data-theme="frost"] {
            --bg-deep: #E8ECF0;
            --bg-primary: #F0F4F8;
            --bg-secondary: #E4E8EC;
            --bg-tertiary: #D8DDE4;
            --bg-elevated: #CCD4DC;
            --text-primary: #1A2030;
            --text-secondary: #4A5568;
            --text-muted: #718096;
            --accent: #5B8DEF;
            --accent-light: #7DA8F5;
            --accent-glow: rgba(91, 141, 239, 0.3);
            --glass-bg: rgba(255, 255, 255, 0.6);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-blur: 24px;
            --nebula-1: rgba(91, 141, 239, 0.1);
            --nebula-2: rgba(125, 168, 245, 0.08);
            --nebula-3: rgba(200, 220, 255, 0.1);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.08);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.1);
        }
        
        /* Frost theme glassmorphism enhancements */
        [data-theme="frost"] .brand,
        [data-theme="frost"] .icon-btn,
        [data-theme="frost"] #side-panel,
        [data-theme="frost"] #info-panel,
        [data-theme="frost"] .modal-content,
        [data-theme="frost"] #theme-picker,
        [data-theme="frost"] #menu-dropdown,
        [data-theme="frost"] .spotlight-container,
        [data-theme="frost"] #quick-capture {
            background: rgba(255, 255, 255, 0.55) !important;
            backdrop-filter: blur(24px) saturate(180%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(180%) !important;
            border: 1px solid rgba(255, 255, 255, 0.5) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           Theme 5: OBSIDIAN - Glassmorphism Dark
           Inspired by: Dark translucent panels, deep blue-gray
           ═══════════════════════════════════════════════════════════ */
        [data-theme="obsidian"] {
            --bg-deep: #1A1D24;
            --bg-primary: #20242C;
            --bg-secondary: #282D38;
            --bg-tertiary: #323844;
            --bg-elevated: #3C4452;
            --text-primary: #F0F2F5;
            --text-secondary: #A0A8B8;
            --text-muted: #687080;
            --accent: #EF8354;
            --accent-light: #F59B70;
            --accent-glow: rgba(239, 131, 84, 0.35);
            --glass-bg: rgba(32, 36, 44, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-blur: 24px;
            --nebula-1: rgba(239, 131, 84, 0.1);
            --nebula-2: rgba(79, 93, 117, 0.12);
            --nebula-3: rgba(191, 192, 192, 0.06);
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 20px rgba(0,0,0,0.4);
            --shadow-lg: 0 8px 40px rgba(0,0,0,0.5);
        }
        
        /* Obsidian theme glassmorphism enhancements */
        [data-theme="obsidian"] .brand,
        [data-theme="obsidian"] .icon-btn,
        [data-theme="obsidian"] #side-panel,
        [data-theme="obsidian"] #info-panel,
        [data-theme="obsidian"] .modal-content,
        [data-theme="obsidian"] #theme-picker,
        [data-theme="obsidian"] #menu-dropdown,
        [data-theme="obsidian"] .spotlight-container,
        [data-theme="obsidian"] #quick-capture {
            background: rgba(32, 36, 44, 0.7) !important;
            backdrop-filter: blur(24px) saturate(150%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(150%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
        }
        
        /* ═══════════════════════════════════════════════════════════
           BASE STYLES
           ═══════════════════════════════════════════════════════════ */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        
        html { 
            font-size: 16px; 
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body { 
            font-family: var(--font-body); 
            background: var(--bg-deep); 
            color: var(--text-primary); 
            overflow: hidden; 
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        button { font-family: inherit; cursor: pointer; border: none; background: none; color: inherit; }
        input, textarea { font-family: inherit; border: none; background: none; color: inherit; }
        
        /* Selection */
        ::selection { background: var(--accent); color: white; }

        /* ═══════════════════════════════════════════════════════════
           AMBIENT BACKGROUND - Living, Breathing Space
           ═══════════════════════════════════════════════════════════ */
        #ambient-bg {
            position: fixed;
            inset: 0;
            z-index: var(--z-bg);
            overflow: hidden;
            background: var(--bg-deep);
        }
        
        .nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0;
            animation: nebulaFloat 20s ease-in-out infinite, nebulaFade 3s ease-out forwards;
        }
        
        .nebula-1 {
            width: 600px; height: 600px;
            background: radial-gradient(circle, var(--nebula-1) 0%, transparent 70%);
            top: -10%; left: 10%;
            animation-delay: 0s;
        }
        
        .nebula-2 {
            width: 500px; height: 500px;
            background: radial-gradient(circle, var(--nebula-2) 0%, transparent 70%);
            bottom: -5%; right: 5%;
            animation-delay: -7s;
        }
        
        .nebula-3 {
            width: 700px; height: 700px;
            background: radial-gradient(circle, var(--nebula-3) 0%, transparent 70%);
            top: 30%; left: 50%;
            transform: translateX(-50%);
            animation-delay: -14s;
        }
        
        @keyframes nebulaFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(30px, -20px) scale(1.05); }
            50% { transform: translate(-20px, 30px) scale(0.95); }
            75% { transform: translate(-30px, -10px) scale(1.02); }
        }
        
        @keyframes nebulaFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particle container - handled by Three.js */
        #particle-bg {
            position: fixed;
            inset: 0;
            z-index: calc(var(--z-bg) + 1);
            pointer-events: none;
        }

        /* ═══════════════════════════════════════════════════════════
           CANVAS & 3D SCENE
           ═══════════════════════════════════════════════════════════ */
        #canvas-container { 
            position: fixed; 
            inset: 0; 
            z-index: var(--z-canvas); 
            touch-action: none;
        }

        /* ═══════════════════════════════════════════════════════════
           FOCUS MODE - Spotlight Effect
           ═══════════════════════════════════════════════════════════ */
        #focus-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-overlay);
            background: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
            pointer-events: none;
            transition: all var(--duration-slow) var(--ease-smooth);
        }
        
        #focus-overlay.active {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
        }
        
        .focus-spotlight {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-normal);
        }

        /* ═══════════════════════════════════════════════════════════
           HEADER & BRANDING
           ═══════════════════════════════════════════════════════════ */
        #header { 
            position: fixed; 
            top: var(--space-5); 
            left: var(--space-5); 
            z-index: var(--z-ui);
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }
        
        .brand { 
            display: flex; 
            align-items: center; 
            gap: var(--space-3); 
            padding: var(--space-3) var(--space-4);
            background: var(--glass-bg); 
            backdrop-filter: blur(var(--glass-blur)); 
            border: 1px solid var(--glass-border);
            border-radius: 16px; 
            box-shadow: var(--shadow-md);
            transition: all var(--duration-fast);
        }
        
        .brand:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .brand-logo { 
            width: 40px; 
            height: 40px; 
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px; 
            display: grid; 
            place-items: center; 
            font-family: var(--font-display);
            font-weight: 700; 
            font-size: 18px; 
            color: white;
            box-shadow: var(--shadow-glow);
        }
        
        .brand-text h1 { 
            font-family: var(--font-display); 
            font-size: 18px; 
            font-weight: 700; 
            letter-spacing: 1px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .brand-text p { 
            font-family: var(--font-mono); 
            font-size: 9px; 
            color: var(--text-muted); 
            letter-spacing: 2px; 
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════
           TOP CONTROLS
           ═══════════════════════════════════════════════════════════ */
        #top-controls {
            position: fixed;
            top: var(--space-5);
            right: var(--space-5);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-2);
            align-items: center;
        }
        
        .icon-btn {
            width: 44px;
            height: 44px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }
        
        .icon-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .icon-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .icon-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* ═══════════════════════════════════════════════════════════
           SPOTLIGHT SEARCH (Cmd+K)
           ═══════════════════════════════════════════════════════════ */
        #spotlight-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-spotlight);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: start center;
            padding-top: 15vh;
        }
        
        #spotlight-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast) var(--ease-out);
        }
        
        .spotlight-container {
            width: min(580px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: var(--shadow-lg), 0 0 60px rgba(0, 0, 0, 0.3);
            animation: spotlightIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes spotlightIn {
            from { opacity: 0; transform: scale(0.95) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .spotlight-input-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-5);
            border-bottom: 1px solid var(--glass-border);
        }
        
        .spotlight-input-wrapper svg {
            width: 24px;
            height: 24px;
            color: var(--accent);
            flex-shrink: 0;
        }
        
        #spotlight-input {
            flex: 1;
            font-size: 18px;
            font-weight: 500;
            background: transparent;
            outline: none;
        }
        
        #spotlight-input::placeholder {
            color: var(--text-muted);
        }
        
        .spotlight-hint {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        
        .spotlight-results {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .spotlight-section {
            padding: var(--space-2) var(--space-4);
        }
        
        .spotlight-section-title {
            font-family: var(--font-mono);
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: var(--space-2) 0;
        }
        
        .spotlight-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .spotlight-item:hover,
        .spotlight-item.selected {
            background: var(--bg-elevated);
        }
        
        .spotlight-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        
        .spotlight-item-content {
            flex: 1;
            min-width: 0;
        }
        
        .spotlight-item-title {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .spotlight-item-subtitle {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .spotlight-item-shortcut {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-1);
        }
        
        .spotlight-item-shortcut kbd {
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }
        
        .spotlight-empty {
            padding: var(--space-8);
            text-align: center;
            color: var(--text-muted);
        }
        
        .spotlight-footer {
            padding: var(--space-3) var(--space-5);
            border-top: 1px solid var(--glass-border);
            display: flex;
            gap: var(--space-5);
            justify-content: center;
        }
        
        .spotlight-footer-hint {
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .spotlight-footer-hint kbd {
            font-family: var(--font-mono);
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           QUICK CAPTURE BAR
           ═══════════════════════════════════════════════════════════ */
        #quick-capture {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
        }
        
        .quick-capture-wrapper {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-2);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
            outline: none;
            transition: all var(--duration-fast);
        }
        
        .quick-capture-wrapper:focus-within {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #quick-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            font-size: 15px;
            background: transparent;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            color: var(--text-primary);
            transition: opacity 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        #quick-input:focus {
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }
        
        #quick-input::placeholder {
            color: var(--text-muted);
            transition: opacity 0.3s ease;
        }
        
        .quick-btn {
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
        }
        
        .quick-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .quick-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .quick-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .quick-btn.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .quick-btn.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* ═══════════════════════════════════════════════════════════
           TOOLBAR TOGGLE - Mobile Only
           ═══════════════════════════════════════════════════════════ */
        #toolbar-toggle {
            display: none;
            position: fixed;
            bottom: 12px;
            right: 12px;
            width: 48px;
            height: 48px;
            border-radius: 14px;
            background: var(--accent);
            border: none;
            color: white;
            font-size: 22px;
            z-index: 1001;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            align-items: center;
            justify-content: center;
        }

        /* ═══════════════════════════════════════════════════════════
           SIDE PANEL - Controls
           ═══════════════════════════════════════════════════════════ */
        #side-panel {
            position: fixed;
            top: 50%;
            right: var(--space-3);
            transform: translateY(-50%);
            z-index: var(--z-ui);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            padding: var(--space-3);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            box-shadow: var(--shadow-md);
            transition: right 0.35s var(--ease-out);
        }
        
        /* Slide side panel when chat is open */
        body.chat-open #side-panel {
            right: 412px;
        }
        
        .side-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-1);
            padding: var(--space-2) var(--space-3);
            border-radius: 10px;
            color: var(--text-secondary);
            transition: all var(--duration-fast);
            cursor: pointer;
        }
        
        .side-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .side-btn.active {
            background: var(--accent);
            color: white;
        }
        
        #btn-voice.active {
            animation: pulse-recording 1s ease-in-out infinite;
            background: var(--accent);
            color: white;
        }
        
        #btn-voice.recording {
            background: #fb923c;
            color: white;
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        #btn-voice.processing {
            background: #2dd4bf;
            color: white;
        }
        
        @keyframes pulse-recording {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 var(--accent-glow); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px 5px var(--accent-glow); }
        }
        
        @keyframes voicePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 131, 84, 0.5); }
            50% { box-shadow: 0 0 0 12px rgba(239, 131, 84, 0); }
        }
        
        /* Voice Indicator Modal */
        #voice-backdrop {
            position: fixed;
            inset: 0;
            z-index: 449;
            background: rgba(0,0,0,0.5);
            display: none;
        }
        #voice-backdrop.active { display: block; }
        
        #voice-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 450;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: var(--space-6);
            text-align: center;
            display: none;
            min-width: 280px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        #voice-indicator.active {
            display: block;
            animation: fadeIn 0.2s ease-out;
        }
        
        .voice-icon {
            margin-bottom: var(--space-4);
            color: #fb923c;
        }
        .voice-icon.recording svg { animation: voiceIconPulse 1s ease-in-out infinite; }
        .voice-icon.processing { color: #2dd4bf; }
        @keyframes voiceIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .voice-status {
            font-family: var(--font-display);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .voice-transcript {
            font-size: 14px;
            color: var(--text-secondary);
            min-height: 40px;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-top: var(--space-3);
        }
        
        .voice-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: var(--space-3);
        }
        
        .voice-cancel {
            margin-top: var(--space-4);
            padding: var(--space-2) var(--space-4);
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        .voice-cancel:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Voice mode toggle */
        .voice-mode-toggle {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: var(--space-4);
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 10px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        
        .voice-mode-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            background: transparent;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .voice-mode-btn:hover {
            color: var(--text-primary);
        }
        
        .voice-mode-btn.active {
            background: var(--accent);
            color: white;
        }
        
        /* Voice text input */
        .voice-text-input-wrapper {
            margin-top: var(--space-3);
        }
        
        #voice-text-input {
            width: 100%;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            resize: none;
            min-height: 80px;
        }
        
        #voice-text-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        #voice-text-input::placeholder {
            color: var(--text-muted);
        }
        
        .voice-text-submit {
            margin-top: 10px;
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            transition: all 0.2s;
        }
        
        .voice-text-submit:hover {
            filter: brightness(1.1);
        }
        
        .voice-text-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* API Key Modal */
        #api-key-modal {
            position: fixed;
            inset: 0;
            z-index: 10001;
            background: rgba(30,34,51,0.8);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        #api-key-modal.active { display: grid; }
        
        .api-key-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-6);
            width: min(400px, calc(100vw - 32px));
        }
        
        .api-key-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .api-key-desc {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-4);
            line-height: 1.5;
        }
        
        .api-key-status {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: var(--space-3);
            padding: var(--space-2);
            background: var(--bg-tertiary);
            border-radius: 6px;
        }
        .api-key-status.configured { color: #4ECDC4; }
        
        .api-key-input {
            width: 100%;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
        }
        .api-key-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .api-key-buttons {
            display: flex;
            gap: var(--space-3);
            justify-content: flex-end;
        }
        
        .api-key-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border: none;
        }
        .api-key-btn.primary {
            background: var(--accent);
            color: white;
        }
        .api-key-btn.secondary {
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
        }
        
        /* Auth Modal */
        #auth-modal {
            position: fixed;
            inset: 0;
            z-index: 10002;
            background: rgba(30,34,51,0.9);
            backdrop-filter: blur(12px);
            display: none;
            place-items: center;
        }
        #auth-modal.active { display: grid; }
        
        .auth-content {
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: var(--space-6);
            width: min(400px, calc(100vw - 32px));
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }
        
        .auth-header {
            text-align: center;
            margin-bottom: var(--space-5);
        }
        
        .auth-logo {
            width: 56px;
            height: 56px;
            background: var(--accent);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 700;
            color: white;
            margin: 0 auto var(--space-4);
        }
        
        .auth-title {
            font-family: var(--font-display);
            font-size: 22px;
            font-weight: 600;
            margin-bottom: var(--space-1);
        }
        
        .auth-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .auth-divider {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            margin: var(--space-5) 0;
            color: var(--text-muted);
            font-size: 12px;
        }
        
        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--glass-border);
        }
        
        .auth-input {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: var(--space-3);
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .auth-input::placeholder {
            color: var(--text-muted);
        }
        
        .auth-btn {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all 0.2s;
        }
        
        .auth-btn.google {
            background: white;
            color: #333;
            border: 1px solid #ddd;
            margin-bottom: var(--space-3);
        }
        .auth-btn.google:hover {
            background: #f5f5f5;
        }
        
        .auth-btn.primary {
            background: var(--accent);
            color: white;
        }
        .auth-btn.primary:hover {
            filter: brightness(1.1);
        }
        
        .auth-btn.secondary {
            background: transparent;
            color: var(--text-secondary);
            padding: var(--space-2);
            margin-top: var(--space-3);
        }
        .auth-btn.secondary:hover {
            color: var(--text-primary);
        }
        
        .auth-toggle {
            text-align: center;
            margin-top: var(--space-4);
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .auth-toggle a {
            color: var(--accent);
            cursor: pointer;
            text-decoration: none;
        }
        .auth-toggle a:hover {
            text-decoration: underline;
        }
        
        .auth-error {
            background: rgba(220, 38, 38, 0.1);
            border: 1px solid rgba(220, 38, 38, 0.3);
            color: #dc2626;
            padding: var(--space-3);
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: var(--space-3);
            display: none;
        }
        .auth-error.active { display: block; }
        
        .auth-close {
            position: absolute;
            top: var(--space-4);
            right: var(--space-4);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-2);
        }
        .auth-close:hover {
            color: var(--text-primary);
        }
        
        /* User Account Button */
        #user-account-wrapper {
            position: relative;
        }
        
        #user-account-btn {
            display: flex !important;
            align-items: center;
            gap: var(--space-2);
            position: relative;
        }
        
        .user-avatar {
            width: 28px;
            height: 28px;
            min-width: 28px;
            min-height: 28px;
            border-radius: 50%;
            background: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: white;
            overflow: hidden;
        }
        
        .user-avatar svg {
            width: 16px;
            height: 16px;
            stroke: white;
            fill: none;
        }
        
        /* Sync Indicator */
        #sync-indicator {
            position: absolute;
            bottom: 6px;
            right: 6px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
            border: 2px solid var(--glass-bg);
            transition: background 0.3s;
            cursor: pointer;
        }
        #sync-indicator.synced {
            background: #22c55e;
        }
        #sync-indicator.syncing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }
        #sync-indicator.error {
            background: #ef4444;
        }
        #sync-indicator.connected {
            background: #22c55e;
            box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* User Dropdown Panel */
        #user-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            width: 280px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.2s var(--ease-out);
            z-index: var(--z-dropdown);
            overflow: hidden;
        }
        
        #user-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .user-dropdown-header {
            padding: 16px;
            border-bottom: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .user-dropdown-email {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .user-dropdown-signout {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
            transition: color 0.2s;
        }
        
        .user-dropdown-signout:hover {
            color: var(--accent);
        }
        
        .user-dropdown-section {
            padding: 12px;
        }
        
        .user-dropdown-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            padding: 0 4px;
        }
        
        .user-maps-list {
            max-height: 180px;
            overflow-y: auto;
        }
        
        .user-map-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .user-map-item:hover {
            background: var(--bg-tertiary);
        }
        
        .user-map-item.active {
            background: var(--accent-glow);
        }
        
        .user-map-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
        }
        
        .user-map-item.active .user-map-icon {
            background: var(--accent);
        }
        
        .user-map-info {
            flex: 1;
            min-width: 0;
        }
        
        .user-map-name {
            font-size: 0.85rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .user-map-date {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .user-map-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        
        .user-map-item:hover .user-map-actions {
            opacity: 1;
        }
        
        .user-map-action {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 4px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .user-map-action:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .user-map-action.delete:hover {
            color: #ef4444;
        }
        
        .user-maps-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .user-dropdown-actions {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 8px 12px;
            border-top: 1px solid var(--glass-border);
        }
        
        .user-dropdown-action {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            width: 100%;
        }
        
        .user-dropdown-action:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .user-dropdown-action svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }
        
        .user-dropdown-sync {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--glass-border);
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .user-dropdown-sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        
        .user-dropdown-sync-dot.synced {
            background: #22c55e;
        }
        
        .user-dropdown-sync-dot.syncing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }
        
        .user-dropdown-sync-dot.offline {
            background: var(--text-muted);
        }
        
        /* Offline state */
        .user-dropdown-offline {
            padding: 20px 16px;
            text-align: center;
        }
        
        .user-dropdown-offline-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        
        .user-dropdown-signin {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .user-dropdown-signin:hover {
            filter: brightness(1.1);
        }
        
        .side-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .side-btn-label {
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .side-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-1) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           INFO PANEL - Node Details
           ═══════════════════════════════════════════════════════════ */
        #info-panel {
            position: fixed;
            bottom: var(--space-5);
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            z-index: var(--z-ui);
            width: min(600px, calc(100vw - 40px));
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: var(--space-2);
            opacity: 0;
            pointer-events: none;
            transition: all var(--duration-normal) var(--ease-out);
        }
        
        #info-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }
        
        .info-header {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            margin-bottom: var(--space-1);
        }
        
        .info-color {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            position: relative;
            transition: transform var(--duration-fast);
        }
        
        .info-color:hover {
            transform: scale(1.05);
        }
        
        .info-color-picker {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 8px;
            display: none;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            z-index: 10;
            box-shadow: var(--shadow-lg);
        }
        
        .info-color-picker.active {
            display: grid;
        }
        
        .info-color-picker span {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: transform var(--duration-fast);
        }
        
        .info-color-picker span:hover {
            transform: scale(1.15);
        }
        
        .info-title-area {
            flex: 1;
            min-width: 0;
        }
        
        #info-title {
            font-family: var(--font-display);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 0;
            cursor: text;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-primary);
            outline: none;
            width: 100%;
            transition: all var(--duration-fast);
        }
        
        #info-title:hover {
            background: var(--bg-elevated);
        }
        
        #info-title:focus {
            background: var(--bg-elevated);
            border-color: var(--accent);
        }
        
        #info-meta {
            font-size: 10px;
            color: var(--text-muted);
            display: flex;
            gap: var(--space-2);
            padding-left: 6px;
        }
        
        .info-link {
            padding: 8px 12px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .info-link a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-secondary);
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .info-link a:hover {
            background: var(--bg-tertiary);
            color: var(--accent);
        }
        
        .info-link img {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .info-link span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-close {
            width: 22px;
            height: 22px;
            border-radius: 6px;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-close:hover {
            background: var(--accent);
            color: white;
        }
        
        /* Expand Toggle Button */
        .info-expand-toggle {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-elevated);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .info-expand-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-expand-toggle .expand-icon {
            width: 16px;
            height: 16px;
            transition: transform 0.3s ease;
        }
        
        #info-panel.expanded .info-expand-toggle .expand-icon {
            transform: rotate(180deg);
        }
        
        /* Expanded Section */
        .info-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            opacity: 0;
        }
        
        #info-panel.expanded .info-expanded {
            max-height: 400px;
            opacity: 1;
            padding: 12px 0;
            border-top: 1px solid var(--bg-tertiary);
            margin-top: 8px;
        }
        
        .info-section {
            margin-bottom: 12px;
        }
        
        .info-section:last-child {
            margin-bottom: 0;
        }
        
        .info-section-label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        #info-description {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            resize: none;
            min-height: 60px;
            max-height: 60px;
            transition: border-color 0.2s, min-height 0.3s ease, max-height 0.3s ease;
        }
        
        #info-description:focus {
            outline: none;
            border-color: var(--accent);
            min-height: 120px;
            max-height: 200px;
            resize: vertical;
        }
        
        #info-description::placeholder {
            color: var(--text-muted);
        }
        
        /* Context Question Feature */
        .info-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .info-section-header .info-section-label {
            margin-bottom: 0;
        }
        
        .context-question-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid var(--text-muted);
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0.6;
        }
        
        .context-question-btn:hover {
            opacity: 1;
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .context-question-btn.hidden {
            display: none;
        }
        
        .context-question-popover {
            display: none;
            margin-top: 8px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            border-radius: 10px;
            animation: fadeSlideIn 0.2s ease;
        }
        
        .context-question-popover.active {
            display: block;
        }
        
        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .context-question-text {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .context-question-input-wrapper {
            display: flex;
            gap: 8px;
        }
        
        #context-question-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        #context-question-input:focus {
            border-color: var(--accent);
        }
        
        .context-question-submit {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .context-question-submit:hover {
            transform: scale(1.05);
        }
        
        .context-question-submit:active {
            transform: scale(0.95);
        }
        
        .context-question-submit svg {
            width: 16px;
            height: 16px;
        }
        
        /* Path Breadcrumbs */
        .info-path {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        
        .info-path-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 120px;
        }
        
        .info-path-item:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-path-item:hover .info-path-color {
            box-shadow: 0 0 0 2px rgba(255,255,255,0.5);
        }
        
        .info-path-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .info-path-name {
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .info-path-separator {
            color: var(--text-muted);
            font-size: 10px;
        }
        
        .info-path-current {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Link Card in Expanded View */
        .info-link-card {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-link-thumbnail {
            width: 80px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
            background: var(--bg-tertiary);
        }
        
        .info-link-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }
        
        .info-link-details a {
            display: flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 13px;
            transition: color 0.2s;
        }
        
        .info-link-details a:hover {
            color: var(--accent);
        }
        
        .info-link-favicon-small {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .info-link-meta {
            font-size: 11px;
            color: var(--text-tertiary);
        }
        
        /* Transcript Section */
        #info-transcript-section .info-section-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .info-transcript-chars {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .info-transcript-wrapper {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .info-transcript-preview {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            max-height: 60px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        
        .info-transcript-toggle {
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .info-transcript-toggle:hover {
            background: var(--accent);
            color: white;
        }
        
        .info-transcript-full {
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .info-transcript-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        /* Metadata Section */
        .info-metadata {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }
        
        .info-meta-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .info-meta-label {
            font-size: 10px;
            color: var(--text-tertiary);
        }
        
        .info-meta-value {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        #info-source {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            color: var(--text-tertiary);
        }
        
        #info-source:empty {
            display: none;
        }
        
        #info-source.ai {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }
        
        #info-source.link {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .info-slider {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-1) 0;
            margin-bottom: var(--space-2);
        }
        
        .info-slider-label {
            font-size: 10px;
            color: var(--text-muted);
            min-width: 55px;
        }
        
        .info-slider-wrapper {
            flex: 1;
            position: relative;
            height: 14px;
            display: flex;
            align-items: center;
        }
        
        .info-slider-wrapper::after {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--text-muted);
            pointer-events: none;
        }
        
        .info-slider input[type="range"] {
            flex: 1;
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-elevated);
            border-radius: 2px;
            outline: none;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: transform 0.15s;
        }
        
        .info-slider input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .info-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }
        
        .info-actions {
            display: flex;
            gap: var(--space-1);
            flex-wrap: nowrap;
        }
        
        .info-add-link {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .info-add-link-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
        }
        
        .info-add-link-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .info-add-link-input::placeholder {
            color: var(--text-tertiary);
        }
        
        .info-add-link-btn {
            padding: 8px;
            border-radius: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--duration-fast);
        }
        
        .info-add-link-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        
        .info-add-link-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .info-action {
            flex: 1;
            min-width: 60px;
            padding: 6px var(--space-2);
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all var(--duration-fast);
        }
        
        .info-action svg {
            width: 12px;
            height: 12px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .info-action.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .info-action.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .info-action.secondary {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .info-action.ai {
            background: linear-gradient(135deg, var(--purple) 0%, var(--pink) 100%);
            color: white;
        }
        
        .info-action.ai:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.4);
        }
        
        .info-action.danger {
            background: var(--bg-elevated);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
        }
        
        .info-action.danger:hover {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        /* ═══════════════════════════════════════════════════════════
           MODAL SYSTEM
           ═══════════════════════════════════════════════════════════ */
        .modal-overlay {
            position: fixed;
            inset: 0;
            z-index: var(--z-modal);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            place-items: center;
        }
        
        .modal-overlay.active {
            display: grid;
            animation: fadeIn var(--duration-fast);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            width: min(480px, calc(100vw - 40px));
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: var(--space-7);
            box-shadow: var(--shadow-lg);
            animation: modalIn var(--duration-normal) var(--ease-spring);
        }
        
        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95) translateY(20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .modal-header {
            margin-bottom: var(--space-6);
        }
        
        .modal-title {
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }
        
        .modal-subtitle {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .form-group {
            margin-bottom: var(--space-5);
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--space-2);
        }
        
        .form-input {
            width: 100%;
            padding: var(--space-4);
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            font-size: 15px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        .form-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 20px var(--accent-glow);
        }
        
        .form-input::placeholder {
            color: var(--text-muted);
        }
        
        textarea.form-input {
            resize: vertical;
            min-height: 100px;
        }
        
        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--space-2);
        }
        
        .color-swatch {
            aspect-ratio: 1;
            border-radius: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all var(--duration-fast);
        }
        
        .color-swatch:hover {
            transform: scale(1.1);
        }
        
        .color-swatch.selected {
            border-color: white;
            box-shadow: 0 0 15px currentColor;
            transform: scale(1.1);
        }
        
        .modal-actions {
            display: flex;
            gap: var(--space-3);
            margin-top: var(--space-6);
        }
        
        .modal-btn {
            flex: 1;
            padding: var(--space-4);
            border-radius: 14px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        .modal-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .modal-btn.cancel:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .modal-btn.submit {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .modal-btn.submit:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        /* ═══════════════════════════════════════════════════════════
           NEURAL NETWORK PANEL
           ═══════════════════════════════════════════════════════════ */
        #neural-panel {
            position: fixed;
            bottom: 100px;
            right: var(--space-4);
            width: 320px;
            max-height: 60vh;
            background: var(--bg-secondary);
            backdrop-filter: blur(24px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-modal);
            padding: var(--space-5);
            z-index: var(--z-modal);
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: all var(--duration-normal) var(--ease-out);
            overflow-y: auto;
        }
        
        #neural-panel.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        
        .neural-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-4);
        }
        
        .neural-title {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .neural-title svg {
            width: 20px;
            height: 20px;
            stroke: var(--accent);
        }
        
        .neural-close {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-close:hover {
            background: var(--accent);
            color: white;
        }
        
        .neural-close svg {
            width: 14px;
            height: 14px;
        }
        
        .neural-status {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: var(--space-4);
            margin-bottom: var(--space-4);
        }
        
        .neural-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }
        
        .neural-status-row:last-child {
            margin-bottom: 0;
        }
        
        .neural-status-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .neural-status-value.ready {
            color: #22c55e;
        }
        
        .neural-status-value.training {
            color: var(--accent);
        }
        
        .neural-progress {
            width: 100%;
            height: 6px;
            background: var(--bg-elevated);
            border-radius: 3px;
            overflow: hidden;
            margin-top: var(--space-3);
        }
        
        .neural-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .neural-categories {
            margin-bottom: var(--space-4);
        }
        
        .neural-categories-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-2);
        }
        
        .neural-category-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-2);
        }
        
        .neural-category-tag {
            padding: var(--space-1) var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .neural-actions {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }
        
        .neural-btn {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border-radius: 12px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        .neural-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .neural-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .neural-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .neural-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .neural-btn.primary:active:not(:disabled) {
            transform: scale(0.98);
        }
        
        .neural-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .neural-btn.secondary:hover {
            background: var(--bg-elevated);
        }
        
        .neural-suggestions {
            margin-top: var(--space-4);
            padding-top: var(--space-4);
            border-top: 1px solid var(--glass-border);
        }
        
        .neural-suggestions-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-3);
        }
        
        .neural-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-3);
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .neural-suggestion:hover {
            background: var(--bg-elevated);
            transform: translateX(4px);
        }
        
        .neural-suggestion-text {
            font-size: 13px;
            color: var(--text-primary);
        }
        
        .neural-suggestion-score {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
            padding: 2px 8px;
            border-radius: 10px;
        }
        
        @media (max-width: 768px) {
            #neural-panel {
                left: var(--space-4);
                right: var(--space-4);
                width: auto;
                bottom: calc(var(--space-4) + 80px);
            }
        }

        /* ═══════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════ */
        #toast-container {
            position: fixed;
            top: var(--space-4);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
            pointer-events: none;
        }
        
        .toast {
            padding: 8px 16px;
            background: var(--bg-secondary);
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md);
            animation: toastIn var(--duration-normal) var(--ease-out);
            pointer-events: auto;
        }
        
        .toast span {
            font-size: 12px;
        }
        
        .toast.success {
            color: #22c55e;
        }
        
        .toast.success span {
            color: #22c55e;
        }
        
        .toast.error {
            color: #ef4444;
        }
        
        .toast.error span {
            color: #ef4444;
        }
        
        .toast.info {
            color: var(--text-primary);
        }
        
        .toast.info span {
            color: var(--accent);
        }
        
        .toast.exiting {
            animation: toastOut var(--duration-fast) var(--ease-out) forwards;
        }
        
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes toastOut {
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* ═══════════════════════════════════════════════════════════
           CELEBRATION PARTICLES
           ═══════════════════════════════════════════════════════════ */
        .celebration-particle {
            position: fixed;
            pointer-events: none;
            z-index: var(--z-toast);
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════
           DEPTH INDICATOR
           ═══════════════════════════════════════════════════════════ */
        #depth-indicator {
            position: fixed;
            top: var(--space-5);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: none;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            box-shadow: var(--shadow-md);
        }
        
        #depth-indicator.active {
            display: flex;
        }
        
        .depth-back {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .depth-back:hover {
            background: var(--accent);
            color: white;
        }
        
        .depth-back svg {
            width: 14px;
            height: 14px;
        }
        
        .depth-path {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .depth-item {
            color: var(--text-secondary);
        }
        
        .depth-item.current {
            color: var(--accent);
            font-weight: 600;
        }

        /* ═══════════════════════════════════════════════════════════
           RADIAL MENU
           ═══════════════════════════════════════════════════════════ */
        #radial-menu {
            position: fixed;
            z-index: var(--z-overlay);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--duration-fast);
        }
        
        #radial-menu.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-toggle {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 2px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: all var(--duration-fast);
        }
        
        .radial-toggle:hover,
        .radial-toggle.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        .radial-toggle svg {
            width: 14px;
            height: 14px;
        }
        
        .radial-item {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: all var(--duration-fast);
        }
        
        .radial-item.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .radial-item:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: translate(-50%, -50%) scale(1.15);
        }
        
        .radial-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* ═══════════════════════════════════════════════════════════
           ONBOARDING
           ═══════════════════════════════════════════════════════════ */
        #onboarding-overlay {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slower);
        }
        
        #onboarding-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .onboarding-content {
            text-align: center;
            max-width: 500px;
            padding: var(--space-6);
        }
        
        .onboarding-logo {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 42px;
            font-weight: 700;
            color: white;
            margin: 0 auto var(--space-7);
            box-shadow: var(--shadow-glow);
            animation: logoPulse 2s ease-in-out infinite;
        }
        
        @keyframes logoPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .onboarding-title {
            font-family: var(--font-display);
            font-size: 36px;
            font-weight: 700;
            margin-bottom: var(--space-3);
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .onboarding-subtitle {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: var(--space-8);
            line-height: 1.6;
        }
        
        .onboarding-input-wrapper {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-6);
        }
        
        #onboarding-name {
            flex: 1;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            outline: none;
            transition: all var(--duration-fast);
        }
        
        #onboarding-name:focus {
            border-color: var(--accent);
            box-shadow: var(--shadow-glow);
        }
        
        #onboarding-start {
            padding: var(--space-4) var(--space-6);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 600;
            transition: all var(--duration-fast);
        }
        
        #onboarding-start:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color var(--duration-fast);
        }
        
        .onboarding-skip:hover {
            color: var(--text-secondary);
        }
        
        /* Choice Buttons */
        .onboarding-choices {
            display: flex;
            gap: var(--space-4);
            margin-top: var(--space-6);
            margin-bottom: var(--space-4);
        }
        
        .onboarding-choice {
            flex: 1;
            padding: var(--space-5);
            background: var(--bg-secondary);
            border: 2px solid var(--glass-border);
            border-radius: 16px;
            cursor: pointer;
            transition: all var(--duration-fast);
            text-align: center;
        }
        
        .onboarding-choice:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }
        
        .onboarding-choice-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto var(--space-3);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .onboarding-choice-icon svg {
            width: 24px;
            height: 24px;
            stroke: white;
            fill: white;
            stroke-width: 2;
        }
        
        .onboarding-choice.ai .onboarding-choice-icon svg {
            stroke: none;
            fill: white;
        }
        
        .onboarding-choice.scratch .onboarding-choice-icon {
            background: linear-gradient(135deg, var(--text-secondary) 0%, var(--text-muted) 100%);
        }
        
        .onboarding-choice-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-2);
        }
        
        .onboarding-choice-desc {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        @media (max-width: 500px) {
            .onboarding-choices {
                flex-direction: column;
            }
        }
        
        /* Questionnaire Styles */
        .onboarding-questionnaire {
            display: none;
            text-align: left;
            max-width: 560px;
            width: 100%;
            padding: var(--space-6);
        }
        
        .onboarding-questionnaire.active {
            display: block;
        }
        
        .question-header {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }
        
        .question-logo {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        
        .question-progress {
            flex: 1;
        }
        
        .question-step {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: var(--space-2);
        }
        
        .question-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .question-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
            border-radius: 2px;
            transition: width 0.4s ease;
        }
        
        .question-text {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.4;
            margin-bottom: var(--space-6);
        }
        
        .question-input {
            width: 100%;
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            color: var(--text-primary);
            outline: none;
            transition: all var(--duration-fast);
            resize: none;
            min-height: 100px;
            font-family: inherit;
            line-height: 1.5;
        }
        
        .question-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(239, 131, 84, 0.15);
        }
        
        .question-input::placeholder {
            color: var(--text-muted);
        }
        
        .question-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-5);
        }
        
        .question-skip {
            font-size: 14px;
            color: var(--text-muted);
            cursor: pointer;
            padding: var(--space-2) var(--space-3);
            border-radius: 8px;
            transition: all var(--duration-fast);
        }
        
        .question-skip:hover {
            color: var(--text-secondary);
            background: var(--bg-tertiary);
        }
        
        .question-nav {
            display: flex;
            gap: var(--space-3);
        }
        
        .question-btn {
            padding: var(--space-3) var(--space-5);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            transition: all var(--duration-fast);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }
        
        .question-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .question-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .question-btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-light) 100%);
            color: white;
        }
        
        .question-btn.primary:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-glow);
        }
        
        .question-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .question-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* Processing state */
        .onboarding-processing {
            display: none;
            text-align: center;
            max-width: 400px;
            padding: var(--space-6);
        }
        
        .onboarding-processing.active {
            display: block;
        }
        
        .processing-spinner {
            width: 64px;
            height: 64px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto var(--space-6);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spin 1s linear infinite;
        }
        
        .processing-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-3);
        }
        
        .processing-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           KEYBOARD HINTS
           ═══════════════════════════════════════════════════════════ */
        #keyboard-hints {
            position: fixed;
            bottom: calc(var(--space-5) + 70px + 80px);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-ui);
            display: flex;
            gap: var(--space-4);
            padding: var(--space-3) var(--space-5);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--duration-fast);
        }
        
        #keyboard-hints.visible {
            opacity: 1;
        }
        
        .key-hint {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .key-hint kbd {
            font-family: var(--font-mono);
            font-size: 11px;
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--glass-border);
        }

        /* ═══════════════════════════════════════════════════════════
           LOADING STATE
           ═══════════════════════════════════════════════════════════ */
        #loading {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: var(--bg-deep);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity var(--duration-slow);
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            text-align: center;
        }
        
        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--glass-border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--space-4);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loader-text {
            font-family: var(--font-display);
            font-size: 18px;
            color: var(--text-secondary);
        }

        /* ═══════════════════════════════════════════════════════════
           THEME PICKER
           ═══════════════════════════════════════════════════════════ */
        #theme-picker {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-3);
            display: none;
            flex-direction: column;
            gap: var(--space-2);
            box-shadow: var(--shadow-lg);
        }
        
        #theme-picker.active {
            display: flex;
            animation: fadeIn var(--duration-fast);
        }
        
        .theme-option {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .theme-option:hover {
            background: var(--bg-elevated);
        }
        
        .theme-option.active {
            background: var(--accent);
            color: white;
        }
        
        .theme-preview {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            overflow: hidden;
        }
        
        .theme-preview span {
            flex: 1;
        }
        
        .theme-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* ═══════════════════════════════════════════════════════════
           MENU DROPDOWN
           ═══════════════════════════════════════════════════════════ */
        #menu-dropdown {
            position: fixed;
            top: 80px;
            right: var(--space-5);
            z-index: var(--z-overlay);
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: var(--space-2);
            min-width: 180px;
            display: none;
            box-shadow: var(--shadow-lg);
        }
        
        #menu-dropdown.active {
            display: block;
            animation: fadeIn var(--duration-fast);
        }
        
        .menu-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: 10px;
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all var(--duration-fast);
        }
        
        .menu-item:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .menu-item svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }
        
        .menu-divider {
            height: 1px;
            background: var(--glass-border);
            margin: var(--space-2) 0;
        }

        /* ═══════════════════════════════════════════════════════════
           RESPONSIVE DESIGN
           ═══════════════════════════════════════════════════════════ */
        @media (max-width: 768px) {
            :root {
                --space-5: 16px;
                --space-6: 20px;
            }
            
            #header {
                top: var(--space-4);
                left: var(--space-4);
            }
            
            .brand {
                padding: var(--space-2) var(--space-3);
            }
            
            .brand-logo {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .brand-text h1 {
                font-size: 16px;
            }
            
            #top-controls {
                top: var(--space-4);
                right: var(--space-4);
            }
            
            /* Hide quick capture on mobile */
            #quick-capture {
                display: none !important;
            }
            
            /* Toolbar slides up from bottom right on mobile */
            #side-panel {
                top: auto;
                bottom: 0;
                right: 0;
                transform: translateY(0);
                flex-direction: column;
                padding: var(--space-2);
                padding-bottom: var(--space-3);
                gap: var(--space-1);
                border-top-left-radius: 20px;
                border-top-right-radius: 0;
                border-bottom-left-radius: 0;
                border-bottom-right-radius: 0;
                transition: transform 0.3s ease, opacity 0.3s ease, bottom 0.3s ease, border-bottom-left-radius 0.3s ease;
                max-height: 75vh;
                overflow-y: auto;
            }
            
            #side-panel.collapsed {
                transform: translateY(calc(100% + 20px));
                opacity: 0;
                pointer-events: none;
            }
            
            /* Slide toolbar up when info panel is visible */
            #side-panel.info-visible {
                bottom: 180px;
                border-bottom-left-radius: 20px;
            }
            
            #toolbar-toggle {
                display: flex !important;
                align-items: center;
                justify-content: center;
                transition: opacity 0.2s ease, transform 0.2s ease, bottom 0.3s ease;
                bottom: 12px;
                right: 12px;
            }
            
            /* Move toggle up when info panel is visible */
            #toolbar-toggle.info-visible {
                bottom: 192px;
            }
            
            #toolbar-toggle.active {
                opacity: 0;
                pointer-events: none;
                transform: scale(0.8);
            }
            
            /* Toggle button inside toolbar */
            #side-panel .toolbar-close {
                display: flex !important;
            }
            
            #side-panel .side-btn {
                padding: var(--space-1) var(--space-2);
                flex-direction: column;
                gap: 2px;
                align-items: center;
                justify-content: center;
            }
            
            #side-panel .side-btn svg {
                width: 20px;
                height: 20px;
            }
            
            /* Show labels on mobile - below icons */
            .side-btn-label {
                display: block !important;
                font-size: 9px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }
            
            /* Hide dividers on mobile */
            .side-divider {
                display: none;
            }
            
            #info-panel {
                bottom: var(--space-4);
                width: calc(100vw - 32px);
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }
            
            #keyboard-hints {
                display: none !important;
            }
        }
        
        /* Link Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        /* Custom Confirm Modal */
        .confirm-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            padding: 20px;
            animation: fadeIn 0.2s var(--ease-out);
        }
        
        .confirm-modal-overlay.active {
            display: flex;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .confirm-modal {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 100%;
            max-width: 300px;
            padding: 24px 20px 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: scaleIn 0.25s var(--ease-spring);
        }
        
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .confirm-modal-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .confirm-modal-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--text-secondary);
        }
        
        .confirm-modal-icon.danger {
            background: rgba(239, 68, 68, 0.1);
        }
        
        .confirm-modal-icon.danger svg {
            stroke: #EF4444;
        }
        
        .confirm-modal-title {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        
        .confirm-modal-message {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 20px;
        }
        
        .confirm-modal-actions {
            display: flex;
            gap: 10px;
        }
        
        .confirm-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s var(--ease-out);
            border: none;
        }
        
        .confirm-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .confirm-btn-cancel:hover {
            background: var(--bg-elevated);
        }
        
        .confirm-btn-confirm {
            background: #EF4444;
            color: white;
        }
        
        .confirm-btn-confirm:hover {
            background: #DC2626;
        }
        
        .confirm-btn-confirm.primary {
            background: var(--accent);
        }
        
        .confirm-btn-confirm.primary:hover {
            filter: brightness(1.1);
        }
        
        .link-modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        .link-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        
        .link-modal-header h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }
        
        .link-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-tertiary);
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s;
        }
        
        .link-modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-input-group {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .link-input-group label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .link-input-group input {
            flex: 1;
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .link-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .link-fetch-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }
        
        .link-fetch-btn:hover {
            filter: brightness(1.1);
        }
        
        .link-preview {
            padding: 0 20px 20px;
        }
        
        .link-preview-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 24px;
            color: var(--text-tertiary);
            font-size: 13px;
        }
        
        .link-preview-content {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--bg-tertiary);
        }
        
        .link-preview-image {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--bg-tertiary);
            flex-shrink: 0;
        }
        
        .link-preview-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }
        
        .link-preview-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border: none;
            background: transparent;
            padding: 0;
            width: 100%;
        }
        
        .link-preview-title:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-description {
            font-size: 12px;
            color: var(--text-secondary);
            border: none;
            background: transparent;
            padding: 0;
            resize: none;
            font-family: inherit;
        }
        
        .link-preview-description:focus {
            outline: none;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            margin: -4px -8px;
            border-radius: 4px;
        }
        
        .link-preview-source {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .link-preview-source img {
            width: 14px;
            height: 14px;
            border-radius: 2px;
        }
        
        .link-transcript-status {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-transcript-status .spinner {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .link-category {
            padding: 0 20px 20px;
        }
        
        .link-category label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
        }
        
        .link-category-suggestion {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 2px solid var(--accent);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .link-category-suggestion:hover {
            background: var(--bg-tertiary);
        }
        
        .link-category-suggestion.selected {
            border-color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        .link-category-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .link-category-confidence {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }
        
        .link-category-alt {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .link-category-alt-item {
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .link-category-alt-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .link-category-alt-item.selected {
            border-color: var(--accent);
            color: var(--accent);
        }
        
        .link-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 20px;
            border-top: 1px solid var(--bg-tertiary);
        }
        
        .link-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }
        
        .link-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .link-btn.secondary:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .link-btn.primary {
            background: var(--accent);
            color: white;
        }
        
        .link-btn.primary:hover:not(:disabled) {
            filter: brightness(1.1);
        }
        
        .link-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Link indicator on nodes */
        .node-link-indicator {
            position: absolute;
            bottom: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .node-link-indicator svg {
            width: 10px;
            height: 10px;
            stroke: white;
        }
        
        /* ═══════════════════════════════════════════════════════════
           AI CHAT PANEL
           ═══════════════════════════════════════════════════════════ */
        #ai-chat-panel {
            position: fixed;
            right: -420px;
            top: 0;
            bottom: 0;
            width: 400px;
            max-width: calc(100vw - 20px);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            z-index: var(--z-modal);
            transition: right 0.35s var(--ease-out);
            box-shadow: -10px 0 40px rgba(0, 0, 0, 0.15);
        }
        
        #ai-chat-panel.open {
            right: 0;
        }
        
        /* Slide toggle button on left edge of chat panel */
        .chat-slide-toggle {
            position: absolute;
            left: -16px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 48px;
            background: var(--bg-secondary);
            border: 1px solid var(--glass-border);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .chat-slide-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            width: 20px;
            left: -20px;
        }
        
        .chat-slide-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform 0.2s;
        }
        
        #ai-chat-panel.open .chat-slide-toggle svg {
            transform: rotate(180deg);
        }
        
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .chat-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-icon svg {
            stroke: var(--accent);
        }
        
        .chat-title {
            font-family: var(--font-display);
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-primary);
        }
        
        .chat-header-actions {
            display: flex;
            gap: 8px;
        }
        
        .chat-header-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-header-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .chat-welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 40px 20px;
            gap: 12px;
        }
        
        .chat-welcome-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 8px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-welcome-icon svg {
            width: 24px;
            height: 24px;
            stroke: var(--accent);
        }
        
        .chat-title {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .chat-welcome-text {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.5;
            max-width: 280px;
        }
        
        .chat-welcome-examples {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
            max-width: 300px;
        }
        
        .chat-example-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        .chat-example-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--accent);
            transform: translateY(-1px);
        }
        
        /* Message Bubbles */
        .chat-message {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: 85%;
            animation: messageSlide 0.3s var(--ease-out);
        }
        
        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .chat-message.user {
            align-self: flex-end;
        }
        
        .chat-message.assistant {
            align-self: flex-start;
        }
        
        .chat-bubble {
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 0.95rem;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .chat-message.user .chat-bubble {
            background: var(--accent);
            color: white;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.assistant .chat-bubble {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
        }
        
        .chat-message-time {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0 4px;
        }
        
        .chat-message.user .chat-message-time {
            text-align: right;
        }
        
        /* Action indicators in messages */
        .chat-actions-indicator {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--glass-border);
        }
        
        .chat-action-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .chat-action-item.success {
            color: #26DE81;
        }
        
        .chat-action-item.pending {
            color: var(--accent);
        }
        
        .chat-action-icon {
            font-size: 0.9em;
        }
        
        /* Typing indicator */
        .chat-typing {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            border-bottom-left-radius: 4px;
            width: fit-content;
        }
        
        .chat-typing-dot {
            width: 8px;
            height: 8px;
            background: var(--text-muted);
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }
        
        .chat-typing-dot:nth-child(1) { animation-delay: 0s; }
        .chat-typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .chat-typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }
        
        /* Quick Suggestions */
        .chat-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 12px 20px;
            border-top: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-suggestion-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 8px 14px;
            font-size: 0.85rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-suggestion-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        /* Input Area */
        .chat-input-area {
            padding: 16px 20px;
            border-top: 1px solid var(--glass-border);
            background: var(--bg-secondary);
        }
        
        .chat-input-container {
            position: relative;
            display: flex;
            align-items: flex-end;
            gap: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 8px 12px;
            transition: border-color 0.2s;
        }
        
        .chat-input-container:focus-within {
            border-color: var(--accent);
        }
        
        .chat-input-container:has(.chat-voice-overlay.active),
        .chat-input-container.recording {
            border-color: #EF4444;
        }
        
        #chat-input {
            flex: 1;
            background: none;
            border: none;
            color: var(--text-primary);
            font-family: var(--font-body);
            font-size: 0.95rem;
            resize: none;
            max-height: 120px;
            line-height: 1.4;
            padding: 4px 0;
        }
        
        #chat-input::placeholder {
            color: var(--text-muted);
        }
        
        #chat-input:focus {
            outline: none;
        }
        
        .chat-voice-btn,
        .chat-send-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 6px;
            border-radius: 8px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .chat-voice-btn:hover,
        .chat-send-btn:hover:not(:disabled) {
            color: var(--accent);
            background: var(--bg-tertiary);
        }
        
        .chat-send-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .chat-send-btn:not(:disabled) {
            color: var(--accent);
        }
        
        .chat-voice-btn.recording {
            color: #EF4444;
            background: rgba(239, 68, 68, 0.1);
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        .chat-voice-btn.processing {
            color: var(--accent);
            background: rgba(var(--accent-rgb), 0.1);
        }
        
        @keyframes voicePulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
        }
        
        /* Voice recording overlay in chat input */
        .chat-voice-overlay {
            position: absolute;
            inset: 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .chat-voice-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .chat-voice-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chat-voice-bars {
            display: flex;
            align-items: center;
            gap: 3px;
            height: 24px;
        }
        
        .chat-voice-bar {
            width: 3px;
            height: 8px;
            background: #EF4444;
            border-radius: 2px;
            animation: voiceBar 0.8s ease-in-out infinite;
        }
        
        .chat-voice-bar:nth-child(1) { animation-delay: 0s; }
        .chat-voice-bar:nth-child(2) { animation-delay: 0.1s; }
        .chat-voice-bar:nth-child(3) { animation-delay: 0.2s; }
        .chat-voice-bar:nth-child(4) { animation-delay: 0.3s; }
        .chat-voice-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes voiceBar {
            0%, 100% { height: 8px; }
            50% { height: 20px; }
        }
        
        .chat-voice-status {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .chat-voice-status.recording {
            color: #EF4444;
        }
        
        .chat-voice-status.processing {
            color: var(--accent);
        }
        
        .chat-voice-cancel {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .chat-voice-cancel:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .chat-input-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-align: center;
        }
        
        .chat-hint-key {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.7rem;
        }
        
        /* Chat Toggle Button */
        .chat-toggle-btn {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2), 0 0 0 0 var(--accent-glow);
            transition: all 0.3s var(--ease-out);
            z-index: var(--z-ui);
        }
        
        .chat-toggle-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.25), 0 0 0 8px var(--accent-glow);
        }
        
        .chat-toggle-btn.hidden {
            transform: scale(0);
            opacity: 0;
            pointer-events: none;
        }
        
        /* Move toggle button when chat is open */
        body.chat-open .chat-toggle-btn {
            right: 424px;
        }
        
        .chat-toggle-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: #EF4444;
            border-radius: 50%;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            #ai-chat-panel {
                width: 100%;
                max-width: 100%;
                right: -100%;
            }
            
            .chat-slide-toggle {
                display: none;
            }
            
            .chat-toggle-btn {
                bottom: 80px;
                right: 16px;
                width: 50px;
                height: 50px;
            }
            
            body.chat-open .chat-toggle-btn {
                right: 16px;
            }
            
            body.chat-open #side-panel {
                right: var(--space-3);
            }
            
            .chat-welcome-examples {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Ambient Background -->
    <div id="ambient-bg">
        <div class="nebula nebula-1"></div>
        <div class="nebula nebula-2"></div>
        <div class="nebula nebula-3"></div>
    </div>
    <div id="particle-bg"></div>
    
    <!-- 3D Canvas -->
    <div id="canvas-container" role="application" aria-label="3D mind map visualization - use mouse to rotate, scroll to zoom"></div>
    
    <!-- Focus Mode Overlay -->
    <div id="focus-overlay"></div>
    
    <!-- Loading -->
    <div id="loading">
        <div class="loader">
            <div class="loader-spinner"></div>
            <div class="loader-text">Loading your mind...</div>
        </div>
    </div>
    
    <!-- Onboarding -->
    <div id="onboarding-overlay" style="display: flex;">
        <!-- Welcome Screen -->
        <div class="onboarding-content" id="onboarding-welcome">
            <div class="onboarding-logo">M</div>
            <h1 class="onboarding-title">Welcome to MYND</h1>
            <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
            <div class="onboarding-input-wrapper">
                <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
            </div>
            <div class="onboarding-choices">
                <div class="onboarding-choice ai" id="onboarding-ai">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                    </div>
                    <div class="onboarding-choice-title">AI-Assisted Setup</div>
                    <div class="onboarding-choice-desc">Answer a few questions and let AI build your personalized mind map</div>
                </div>
                <div class="onboarding-choice scratch" id="onboarding-scratch">
                    <div class="onboarding-choice-icon">
                        <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    </div>
                    <div class="onboarding-choice-title">Start from Scratch</div>
                    <div class="onboarding-choice-desc">Begin with a simple template and build your own structure</div>
                </div>
            </div>
        </div>
        
        <!-- Questionnaire -->
        <div class="onboarding-questionnaire" id="onboarding-questionnaire">
            <div class="question-header">
                <div class="question-logo">M</div>
                <div class="question-progress">
                    <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                    <div class="question-progress-bar">
                        <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                    </div>
                </div>
            </div>
            <div class="question-text" id="question-text">What's one goal you want to make real progress on in the next 30 days?</div>
            <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
            <div class="question-actions">
                <span class="question-skip" id="question-skip-btn">Skip this question</span>
                <div class="question-nav">
                    <button class="question-btn secondary" id="question-back" style="display: none;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                        Back
                    </button>
                    <button class="question-btn primary" id="question-next">
                        Next
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Processing -->
        <div class="onboarding-processing" id="onboarding-processing">
            <div class="processing-spinner"></div>
            <div class="processing-title">Building your mind map...</div>
            <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
        </div>
    </div>
    
    <!-- Header -->
    <div id="header">
        <div class="brand">
            <div class="brand-logo">M</div>
            <div class="brand-text">
                <h1>MYND</h1>
                <p>Mind Architect</p>
            </div>
        </div>
    </div>
    
    <!-- Top Controls -->
    <div id="top-controls">
        <div id="user-account-wrapper">
            <button class="icon-btn" id="user-account-btn" title="Account" aria-label="Account">
                <div class="user-avatar" id="user-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                </div>
                <div id="sync-indicator" title="Offline mode"></div>
            </button>
            
            <!-- User Dropdown -->
            <div id="user-dropdown">
                <!-- Logged in state -->
                <div id="user-dropdown-loggedin" style="display: none;">
                    <div class="user-dropdown-header">
                        <div class="user-dropdown-email" id="user-dropdown-email">user@email.com</div>
                        <button class="user-dropdown-signout" id="user-dropdown-signout">Sign out</button>
                    </div>
                    
                    <div class="user-dropdown-section">
                        <div class="user-dropdown-section-title">Your Maps</div>
                        <div class="user-maps-list" id="user-maps-list">
                            <!-- Maps loaded dynamically -->
                        </div>
                    </div>
                    
                    <div class="user-dropdown-actions">
                        <button class="user-dropdown-action" id="user-action-new">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            New Map
                        </button>
                        <button class="user-dropdown-action" id="user-action-import">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                            Import Map
                        </button>
                        <button class="user-dropdown-action" id="user-action-export">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            Export Map
                        </button>
                    </div>
                    
                    <div class="user-dropdown-sync" id="user-dropdown-sync">
                        <span class="user-dropdown-sync-dot synced"></span>
                        <span id="user-sync-status">Synced</span>
                    </div>
                </div>
                
                <!-- Logged out state -->
                <div id="user-dropdown-loggedout">
                    <div class="user-dropdown-offline">
                        <div class="user-dropdown-offline-text">
                            Sign in to save your maps to the cloud and access them anywhere
                        </div>
                        <button class="user-dropdown-signin" id="user-dropdown-signin">Sign In</button>
                    </div>
                    
                    <div class="user-dropdown-actions">
                        <button class="user-dropdown-action" id="user-action-import-offline">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                            Import Map
                        </button>
                        <button class="user-dropdown-action" id="user-action-export-offline">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            Export Map
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <button class="icon-btn" id="theme-btn" title="Theme" aria-label="Change color theme">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="4"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/></svg>
        </button>
        <button class="icon-btn" id="menu-btn" title="Menu" aria-label="Open menu">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
        <button class="icon-btn" id="undo-btn" title="Undo" aria-label="Undo last action" disabled>
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
        </button>
    </div>
    
    <!-- Theme Picker -->
    <div id="theme-picker">
        <div class="theme-option" data-theme="sandstone">
            <div class="theme-preview"><span style="background:#C4978A"></span><span style="background:#F9F7F0"></span></div>
            <span class="theme-name">Sandstone</span>
        </div>
        <div class="theme-option active" data-theme="coral">
            <div class="theme-preview"><span style="background:#E87D7D"></span><span style="background:#FFFFFF"></span></div>
            <span class="theme-name">Coral</span>
        </div>
        <div class="theme-option" data-theme="ember">
            <div class="theme-preview"><span style="background:#E87830"></span><span style="background:#FAF6F0"></span></div>
            <span class="theme-name">Ember</span>
        </div>
        <div class="theme-option" data-theme="frost">
            <div class="theme-preview"><span style="background:#5B8DEF"></span><span style="background:#E8ECF0"></span></div>
            <span class="theme-name">Frost</span>
        </div>
        <div class="theme-option" data-theme="obsidian">
            <div class="theme-preview"><span style="background:#EF8354"></span><span style="background:#1A1D24"></span></div>
            <span class="theme-name">Obsidian</span>
        </div>
    </div>
    
    <!-- Menu Dropdown -->
    <div id="menu-dropdown">
        <div class="menu-item" id="menu-search">
            <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
            Search
        </div>
        <div class="menu-item" id="menu-shortcuts">
            <svg viewBox="0 0 24 24"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h8M6 16h.01M10 16h.01M14 16h.01M18 16h.01"/></svg>
            Shortcuts
        </div>
        <div class="menu-item" id="menu-settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
            Settings
        </div>
        <div class="menu-item" id="menu-voice-settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
            Voice Settings
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-new">
            <svg viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>
            New Map
        </div>
        <div class="menu-item" id="menu-save">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            Save Map
        </div>
        <div class="menu-item" id="menu-load">
            <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
            Load Map
        </div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="menu-help">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
            Help
        </div>
    </div>
    
    <!-- Depth Indicator -->
    <div id="depth-indicator">
        <div class="depth-back" id="depth-back">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
        </div>
        <div class="depth-path" id="depth-path"></div>
    </div>
    
    <!-- Side Panel -->
    <button id="toolbar-toggle" onclick="document.getElementById('side-panel').classList.toggle('collapsed'); this.classList.toggle('active')">☰</button>
    <div id="side-panel" role="toolbar" aria-label="Mind map controls">
        <div class="side-btn" id="btn-home" title="Reset View" role="button" aria-label="Reset camera to home view">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
            <span class="side-btn-label">Home</span>
        </div>
        <div class="side-btn" id="btn-expand" title="Expand All" role="button" aria-label="Expand all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
            <span class="side-btn-label">Expand</span>
        </div>
        <div class="side-btn" id="btn-collapse" title="Collapse All" role="button" aria-label="Collapse all nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"/></svg>
            <span class="side-btn-label">Collapse</span>
        </div>
        <div class="side-divider" role="separator"></div>
        <div class="side-btn" id="btn-add" title="Add Node" role="button" aria-label="Add new node">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            <span class="side-btn-label">Add</span>
        </div>
        <div class="side-btn" id="btn-link" title="Add Link" role="button" aria-label="Add link from URL">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
            <span class="side-btn-label">Link</span>
        </div>
        <div class="side-btn" id="btn-move" title="Move Mode" role="button" aria-label="Toggle move mode for dragging nodes">
            <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>
            <span class="side-btn-label">Move</span>
        </div>
        <div class="side-btn" id="btn-voice" title="Voice AI - Click to speak" role="button" aria-label="Start voice AI assistant">
            <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="4" y1="8" x2="4" y2="16"/><line x1="8" y1="5" x2="8" y2="19"/><line x1="12" y1="3" x2="12" y2="21"/><line x1="16" y1="5" x2="16" y2="19"/><line x1="20" y1="8" x2="20" y2="16"/></svg>
            <span class="side-btn-label">AI</span>
        </div>
        <div class="side-btn" id="btn-neural" title="Personal Neural Network" role="button" aria-label="Open neural network panel">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="12" rx="10" ry="4"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60 12 12)"/><ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120 12 12)"/><circle cx="12" cy="12" r="2" fill="currentColor"/></svg>
            <span class="side-btn-label">Neural</span>
        </div>
        <div class="side-btn active" id="btn-autocam" title="Toggle Auto Camera" role="button" aria-label="Toggle automatic camera movement" aria-pressed="true">
            <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>
            <span class="side-btn-label">Auto Cam</span>
        </div>
        <!-- Close button for mobile -->
        <div class="side-btn toolbar-close" id="btn-toolbar-close" onclick="document.getElementById('side-panel').classList.add('collapsed'); document.getElementById('toolbar-toggle').classList.remove('active')" title="Close" role="button" aria-label="Close toolbar" style="display:none; margin-top:8px; background:var(--accent); color:white; border-radius:10px;">
            <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            <span class="side-btn-label">Close</span>
        </div>
    </div>
    
    <!-- Voice AI Indicator -->
    <div id="voice-backdrop"></div>
    <div id="voice-indicator">
        <div class="voice-mode-toggle">
            <button class="voice-mode-btn active" id="voice-mode-speak" title="Speak">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/></svg>
            </button>
            <button class="voice-mode-btn" id="voice-mode-type" title="Type">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="6" y1="8" x2="6" y2="8"/><line x1="10" y1="8" x2="10" y2="8"/><line x1="14" y1="8" x2="14" y2="8"/><line x1="18" y1="8" x2="18" y2="8"/><line x1="6" y1="12" x2="18" y2="12"/><line x1="6" y1="16" x2="18" y2="16"/></svg>
            </button>
        </div>
        <div class="voice-icon" id="voice-icon">
            <svg id="voice-icon-mic" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            <svg id="voice-icon-brain" style="display:none" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4h.09c.49 0 .97-.07 1.41-.2"/><path d="M12 2a4 4 0 0 1 4 4c0 .74-.2 1.43-.56 2.02A4 4 0 0 1 18 12c0 1.2-.52 2.27-1.35 3A4 4 0 0 1 18 18a4 4 0 0 1-4 4h-.09c-.49 0-.97-.07-1.41-.2"/><path d="M12 2v20"/><path d="M9 10h6"/><path d="M9 14h6"/></svg>
        </div>
        <div class="voice-status" id="voice-status">Listening...</div>
        <div class="voice-transcript" id="voice-transcript">Say something...</div>
        <div class="voice-text-input-wrapper" id="voice-text-wrapper" style="display: none;">
            <textarea id="voice-text-input" placeholder="Describe what you want to add or ask..." rows="3"></textarea>
            <button class="voice-text-submit" id="voice-text-submit">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                Send to AI
            </button>
        </div>
        <div class="voice-hint" id="voice-hint">Tap anywhere or press Escape to cancel</div>
        <button class="voice-cancel" id="voice-cancel">Cancel</button>
    </div>
    
    <!-- API Key Modal / Settings -->
    <div id="api-key-modal">
        <div class="api-key-content">
            <div class="api-key-title">Settings</div>
            
            <!-- API Key Section -->
            <div style="margin-bottom: 20px;">
                <div style="font-size: 12px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Anthropic API Key</div>
                <div class="api-key-desc">Required for voice AI, smart expand, and AI organization. Your key is stored locally.</div>
                <div class="api-key-status" id="api-key-status">No API key configured</div>
                <input type="password" class="api-key-input" id="api-key-input" placeholder="sk-ant-api03-...">
            </div>
            
            <!-- Neural Network Section -->
            <div style="margin-bottom: 20px; padding-top: 16px; border-top: 1px solid var(--glass-border);">
                <div style="font-size: 12px; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Neural Network</div>
                <div class="api-key-desc" id="neural-stats-settings">The neural network learns from your mind map to suggest related nodes.</div>
                <div style="display: flex; gap: 8px; margin-top: 10px;">
                    <button class="api-key-btn primary" id="neural-train-settings-btn" style="flex: 1;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    </button>
                    <button class="api-key-btn secondary" id="neural-reset-settings-btn" style="flex: 1; background: rgba(220, 38, 38, 0.1); border-color: rgba(220, 38, 38, 0.3); color: #dc2626;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>
                        </svg>
                        Reset
                    </button>
                </div>
            </div>
            
            <div class="api-key-buttons">
                <button class="api-key-btn secondary" id="api-key-cancel">Close</button>
                <button class="api-key-btn primary" id="api-key-save">Save API Key</button>
            </div>
        </div>
    </div>
    
    <!-- Auth Modal -->
    <div id="auth-modal">
        <div class="auth-content" style="position: relative;">
            <button class="auth-close" id="auth-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
            
            <div class="auth-header">
                <div class="auth-logo">M</div>
                <div class="auth-title" id="auth-title">Sign in to MYND</div>
                <div class="auth-subtitle" id="auth-subtitle">Sync your mind maps across devices</div>
            </div>
            
            <div class="auth-error" id="auth-error"></div>
            
            <!-- Google Sign In -->
            <button class="auth-btn google" id="auth-google">
                <svg viewBox="0 0 24 24" style="width:18px;height:18px;">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
            
            <div class="auth-divider">or</div>
            
            <!-- Email Form -->
            <form id="auth-form">
                <input type="email" class="auth-input" id="auth-email" placeholder="Email address" required>
                <input type="password" class="auth-input" id="auth-password" placeholder="Password" required>
                <button type="submit" class="auth-btn primary" id="auth-submit">Sign In</button>
            </form>
            
            <button class="auth-btn secondary" id="auth-forgot">Forgot password?</button>
            
            <div class="auth-toggle">
                <span id="auth-toggle-text">Don't have an account?</span>
                <a id="auth-toggle-link">Sign up</a>
            </div>
            
            <!-- Skip option for offline use -->
            <button class="auth-btn secondary" id="auth-skip" style="margin-top: var(--space-2); font-size: 12px;">
                Continue without account (offline only)
            </button>
        </div>
    </div>
    
    <!-- Quick Capture -->
    <div id="quick-capture">
        <div class="quick-capture-wrapper">
            <input type="text" id="quick-input" placeholder="What's on your mind?" autocomplete="off">
            <button class="quick-btn secondary" id="quick-link" title="Add Link" aria-label="Add link from URL">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
            </button>
            <button class="quick-btn primary" id="quick-add">
                Add
            </button>
        </div>
    </div>
    
    <!-- Link Modal -->
    <div id="link-modal" class="modal-overlay">
        <div class="link-modal-content">
            <div class="link-modal-header">
                <h3>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;vertical-align:middle;margin-right:8px;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                    Add Link
                </h3>
                <button class="link-modal-close" id="link-modal-close" aria-label="Close">×</button>
            </div>
            
            <div class="link-input-group">
                <label for="link-url">Paste URL</label>
                <input type="url" id="link-url" placeholder="https://..." autocomplete="off">
                <button class="link-fetch-btn" id="link-fetch">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M21 12a9 9 0 1 1-9-9"/><polyline points="21 3 21 9 15 9"/></svg>
                    Fetch
                </button>
            </div>
            
            <div class="link-preview" id="link-preview" style="display:none;">
                <div class="link-preview-loading" id="link-preview-loading">
                    <div class="loading-spinner"></div>
                    Fetching link info...
                </div>
                <div class="link-preview-content" id="link-preview-content" style="display:none;">
                    <img class="link-preview-image" id="link-preview-image" alt="">
                    <div class="link-preview-info">
                        <input type="text" class="link-preview-title" id="link-preview-title" placeholder="Title">
                        <textarea class="link-preview-description" id="link-preview-description" placeholder="Description (optional)" rows="2"></textarea>
                        <div class="link-preview-source" id="link-preview-source"></div>
                        <div class="link-transcript-status" id="link-transcript-status" style="display:none;"></div>
                    </div>
                </div>
            </div>
            
            <div class="link-category" id="link-category" style="display:none;">
                <label>AI Suggested Placement</label>
                <div class="link-category-suggestion" id="link-category-suggestion">
                    <span class="link-category-name" id="link-category-name">Loading...</span>
                    <span class="link-category-confidence" id="link-category-confidence"></span>
                </div>
                <div class="link-category-alt" id="link-category-alt"></div>
            </div>
            
            <div class="link-modal-actions">
                <button class="link-btn secondary" id="link-cancel">Cancel</button>
                <button class="link-btn primary" id="link-add" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                    Add to Map
                </button>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div class="info-header">
            <div class="info-color" id="info-color">
                <div class="info-color-picker" id="info-color-picker"></div>
            </div>
            <div class="info-title-area">
                <input type="text" id="info-title" value="Node Title" />
                <div id="info-meta">
                    <span id="info-children">0 children</span>
                    <span id="info-source"></span>
                </div>
            </div>
            <button class="info-expand-toggle" id="info-expand-toggle" aria-label="Expand panel">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="expand-icon"><polyline points="6 15 12 9 18 15"/></svg>
            </button>
            <div class="info-close" id="info-close">
                <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </div>
        </div>
        
        <!-- Expanded Section -->
        <div class="info-expanded" id="info-expanded">
            <!-- Description -->
            <div class="info-section">
                <div class="info-section-header">
                    <label class="info-section-label">Description</label>
                    <button class="context-question-btn" id="context-question-btn" title="Help me understand this better">
                        <span>?</span>
                    </button>
                </div>
                <textarea id="info-description" placeholder="Add a description..." rows="2"></textarea>
                <!-- Context Question Popover -->
                <div class="context-question-popover" id="context-question-popover">
                    <div class="context-question-text" id="context-question-text"></div>
                    <div class="context-question-input-wrapper">
                        <input type="text" id="context-question-input" placeholder="Type your answer..." autocomplete="off">
                        <button class="context-question-submit" id="context-question-submit">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Path to Node -->
            <div class="info-section" id="info-path-section">
                <label class="info-section-label">Path</label>
                <div class="info-path" id="info-path"></div>
            </div>
            
            <!-- Add Link (creates child node with link) -->
            <div class="info-section" id="info-add-link-section" style="display: none;">
                <label class="info-section-label">Add Child Link</label>
                <div class="info-add-link">
                    <input type="url" class="info-add-link-input" id="info-add-link-input" placeholder="Paste URL...">
                    <button class="info-add-link-btn" id="info-add-link-btn" title="Add link as child node">
                        <svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                    </button>
                </div>
            </div>
            
            <!-- Link Info (if this node has a link) -->
            <div class="info-section" id="info-link-section" style="display: none;">
                <label class="info-section-label">Linked Content</label>
                <div class="info-link-card" id="info-link-card">
                    <img class="info-link-thumbnail" id="info-link-thumbnail" alt="" style="display: none;">
                    <div class="info-link-details">
                        <a href="#" id="info-link-full-url" target="_blank" rel="noopener noreferrer">
                            <img class="info-link-favicon-small" id="info-link-favicon-small" src="" alt="">
                            <span id="info-link-full-domain"></span>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;flex-shrink:0;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
                        </a>
                        <div class="info-link-meta" id="info-link-meta"></div>
                    </div>
                </div>
            </div>
            
            <!-- Transcript Section (if this node has a transcript) -->
            <div class="info-section" id="info-transcript-section" style="display: none;">
                <label class="info-section-label">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;opacity:0.7;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                        Transcript
                    </span>
                    <span class="info-transcript-chars" id="info-transcript-chars"></span>
                </label>
                <div class="info-transcript-wrapper">
                    <div class="info-transcript-preview" id="info-transcript-preview"></div>
                    <button class="info-transcript-toggle" id="info-transcript-toggle">Show full transcript</button>
                </div>
                <div class="info-transcript-full" id="info-transcript-full" style="display: none;">
                    <div class="info-transcript-text" id="info-transcript-text"></div>
                </div>
            </div>
            
            <!-- Node Metadata -->
            <div class="info-section info-metadata">
                <div class="info-meta-item" id="info-created-section" style="display: none;">
                    <span class="info-meta-label">Created</span>
                    <span class="info-meta-value" id="info-created"></span>
                </div>
                <div class="info-meta-item" id="info-added-by-section">
                    <span class="info-meta-label">Added by</span>
                    <span class="info-meta-value" id="info-added-by">You</span>
                </div>
            </div>
        </div>
        
        <div class="info-link" id="info-link" style="display: none;">
            <a href="#" id="info-link-url" target="_blank" rel="noopener noreferrer">
                <img id="info-link-favicon" src="" alt="">
                <span id="info-link-domain"></span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;opacity:0.5;"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
            </a>
        </div>
        <div class="info-slider">
            <span class="info-slider-label">Importance</span>
            <div class="info-slider-wrapper">
                <input type="range" id="info-importance" min="0.5" max="2" step="0.1" value="1" />
            </div>
        </div>
        <div class="info-actions" role="group" aria-label="Node actions">
            <button class="info-action danger" id="action-delete" aria-label="Delete this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                Delete
            </button>
            <button class="info-action secondary" id="action-dive" aria-label="Dive into this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
                Dive
            </button>
            <button class="info-action secondary" id="action-organize" aria-label="Organize children by type" style="display: none;">
                <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7" rx="1"/><rect x="14" y="3" width="7" height="7" rx="1"/><rect x="3" y="14" width="7" height="7" rx="1"/><rect x="14" y="14" width="7" height="7" rx="1"/></svg>
                Organize
            </button>
            <button class="info-action ai" id="action-brainstorm" aria-label="AI brainstorm ideas for this node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
                Brainstorm
            </button>
            <button class="info-action primary" id="action-add" aria-label="Add a child node">
                <svg viewBox="0 0 24 24" aria-hidden="true"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                Add Child
            </button>
        </div>
    </div>
    
    <!-- Keyboard Hints -->
    <div id="keyboard-hints">
        <div class="key-hint"><kbd>⌘K</kbd> Search</div>
        <div class="key-hint"><kbd>Tab</kbd> Add child</div>
        <div class="key-hint"><kbd>Enter</kbd> Add sibling</div>
        <div class="key-hint"><kbd>Space</kbd> Expand</div>
        <div class="key-hint"><kbd>?</kbd> Help</div>
    </div>
    
    <!-- Spotlight Search -->
    <div id="spotlight-overlay">
        <div class="spotlight-container">
            <div class="spotlight-input-wrapper">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                <input type="text" id="spotlight-input" placeholder="Search nodes, commands, or type to create..." autocomplete="off">
                <span class="spotlight-hint">esc</span>
            </div>
            <div class="spotlight-results" id="spotlight-results">
                <div class="spotlight-section">
                    <div class="spotlight-section-title">Quick Actions</div>
                    <div class="spotlight-item" data-action="new-node">
                        <div class="spotlight-item-icon" style="background: var(--accent);">+</div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">Create New Node</div>
                            <div class="spotlight-item-subtitle">Add a new thought to your map</div>
                        </div>
                        <div class="spotlight-item-shortcut"><kbd>Tab</kbd></div>
                    </div>
                    <div class="spotlight-item" data-action="brainstorm">
                        <div class="spotlight-item-icon" style="background: linear-gradient(135deg, var(--purple), var(--pink));">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                            </svg>
                        </div>
                        <div class="spotlight-item-content">
                            <div class="spotlight-item-title">AI Brainstorm</div>
                            <div class="spotlight-item-subtitle">Generate ideas for selected node</div>
                        </div>
                    </div>
                </div>
                <div class="spotlight-section" id="spotlight-nodes-section">
                    <div class="spotlight-section-title">Nodes</div>
                    <div id="spotlight-nodes-list"></div>
                </div>
            </div>
            <div class="spotlight-footer">
                <div class="spotlight-footer-hint"><kbd>↑↓</kbd> Navigate</div>
                <div class="spotlight-footer-hint"><kbd>↵</kbd> Select</div>
                <div class="spotlight-footer-hint"><kbd>esc</kbd> Close</div>
            </div>
        </div>
    </div>
    
    <!-- Radial Menu -->
    <div id="radial-menu">
        <div class="radial-toggle">
            <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="2"/><circle cx="12" cy="5" r="2"/><circle cx="12" cy="19" r="2"/></svg>
        </div>
        <div class="radial-item" data-action="add" title="Add Child">
            <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        </div>
        <div class="radial-item" data-action="edit" title="Edit">
            <svg viewBox="0 0 24 24"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
        </div>
        <div class="radial-item" data-action="dive" title="Dive In">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>
        </div>
        <div class="radial-item" data-action="brainstorm" title="AI Brainstorm">
            <svg viewBox="0 0 24 24"><path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/></svg>
        </div>
        <div class="radial-item" data-action="delete" title="Delete">
            <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </div>
    </div>
    
    <!-- Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modal-title">Add Node</h2>
                <p class="modal-subtitle" id="modal-subtitle">Create a new thought</p>
            </div>
            <div class="form-group">
                <label class="form-label">Name</label>
                <input type="text" class="form-input" id="input-name" placeholder="What's this thought about?">
            </div>
            <div class="form-group">
                <label class="form-label">Description (optional)</label>
                <textarea class="form-input" id="input-desc" placeholder="Add more details..."></textarea>
            </div>
            <div class="form-group">
                <label class="form-label">Color</label>
                <div class="color-grid" id="color-grid"></div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn cancel" id="modal-cancel">Cancel</button>
                <button class="modal-btn submit" id="modal-submit">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div id="toast-container"></div>
    
    <!-- Custom Confirm Modal -->
    <div id="confirm-modal" class="confirm-modal-overlay">
        <div class="confirm-modal">
            <div class="confirm-modal-icon" id="confirm-modal-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
            </div>
            <div class="confirm-modal-title" id="confirm-modal-title">Confirm Action</div>
            <div class="confirm-modal-message" id="confirm-modal-message">Are you sure?</div>
            <div class="confirm-modal-actions">
                <button class="confirm-btn confirm-btn-cancel" id="confirm-modal-cancel">Cancel</button>
                <button class="confirm-btn confirm-btn-confirm" id="confirm-modal-confirm">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Neural Network Panel -->
    <div id="neural-panel">
        <div class="neural-header">
            <div class="neural-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2a4 4 0 0 0-4 4c0 .74.2 1.43.56 2.02A4 4 0 0 0 6 12c0 1.2.52 2.27 1.35 3A4 4 0 0 0 6 18a4 4 0 0 0 4 4c.74 0 1.43-.2 2-.56A4 4 0 0 0 16 22a4 4 0 0 0 4-4c0-1.2-.52-2.27-1.35-3A4 4 0 0 0 20 12a4 4 0 0 0-2.56-3.98c.36-.59.56-1.28.56-2.02a4 4 0 0 0-4-4"/>
                    <circle cx="12" cy="12" r="2"/>
                </svg>
                Your Neural Net
            </div>
            <div class="neural-close" id="neural-close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </div>
        </div>
        
        <div class="neural-status">
            <div class="neural-status-row">
                <span>Status</span>
                <span class="neural-status-value" id="neural-status-text">Initializing...</span>
            </div>
            <div class="neural-status-row">
                <span>Learned Categories</span>
                <span class="neural-status-value" id="neural-category-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Expansion Patterns</span>
                <span class="neural-status-value" id="neural-pattern-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Cached Embeddings</span>
                <span class="neural-status-value" id="neural-embedding-count">0</span>
            </div>
            <div class="neural-progress" id="neural-progress" style="display: none;">
                <div class="neural-progress-bar" id="neural-progress-bar"></div>
            </div>
        </div>
        
        <!-- Preference Learning Stats -->
        <div class="neural-status" id="neural-preference-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
                Preference Learning
            </div>
            <div class="neural-status-row">
                <span>Suggestions Accepted</span>
                <span class="neural-status-value" id="pref-accepted-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Suggestions Ignored</span>
                <span class="neural-status-value" id="pref-ignored-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Acceptance Rate</span>
                <span class="neural-status-value" id="pref-acceptance-rate">—</span>
            </div>
            <div class="neural-status-row" id="pref-style-row" style="display: none;">
                <span>Style Preference</span>
                <span class="neural-status-value" id="pref-style">—</span>
            </div>
        </div>
        
        <!-- Incremental Learning Stats -->
        <div class="neural-status" id="neural-incremental-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M23 6l-9.5 9.5-5-5L1 18"/>
                    <path d="M17 6h6v6"/>
                </svg>
                Live Learning
            </div>
            <div class="neural-status-row">
                <span>Pattern Weights</span>
                <span class="neural-status-value" id="incr-pattern-weights">0</span>
            </div>
            <div class="neural-status-row">
                <span>High Confidence</span>
                <span class="neural-status-value" id="incr-high-confidence">0</span>
            </div>
            <div class="neural-status-row">
                <span>Avg Weight</span>
                <span class="neural-status-value" id="incr-avg-weight">—</span>
            </div>
            <div class="neural-status-row" id="incr-pending-row" style="display: none;">
                <span>Pending Embeddings</span>
                <span class="neural-status-value" id="incr-pending">0</span>
            </div>
        </div>
        
        <!-- Semantic Memory Stats -->
        <div class="neural-status" id="neural-memory-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"/>
                    <path d="M12 6v6l4 2"/>
                </svg>
                Semantic Memory
            </div>
            <div class="neural-status-row">
                <span>Total Memories</span>
                <span class="neural-status-value" id="mem-total-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Important</span>
                <span class="neural-status-value" id="mem-important-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Avg Importance</span>
                <span class="neural-status-value" id="mem-avg-importance">—</span>
            </div>
        </div>
        
        <!-- User Profile Stats -->
        <div class="neural-status" id="neural-profile-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                    <circle cx="12" cy="7" r="4"/>
                </svg>
                User Profile
            </div>
            <div class="neural-status-row">
                <span>Nodes Tracked</span>
                <span class="neural-status-value" id="profile-nodes-count">0</span>
            </div>
            <div class="neural-status-row">
                <span>Preferred Depth</span>
                <span class="neural-status-value" id="profile-depth">—</span>
            </div>
            <div class="neural-status-row">
                <span>Naming Style</span>
                <span class="neural-status-value" id="profile-naming-style">—</span>
            </div>
            <div class="neural-status-row" id="profile-focus-row" style="display: none;">
                <span>Focus Areas</span>
                <span class="neural-status-value" id="profile-focus">—</span>
            </div>
            <div class="neural-status-row" id="profile-peak-row" style="display: none;">
                <span>Peak Hours</span>
                <span class="neural-status-value" id="profile-peak-hours">—</span>
            </div>
        </div>
        
        <!-- Relationship Types Stats -->
        <div class="neural-status" id="neural-relationship-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M4 6h16M4 12h16M4 18h7"/>
                    <circle cx="18" cy="18" r="3"/>
                </svg>
                Relationship Types
            </div>
            <div class="neural-status-row">
                <span>Classified</span>
                <span class="neural-status-value" id="rel-classified-count">0</span>
            </div>
            <div class="neural-status-row" id="rel-dominant-row" style="display: none;">
                <span>Dominant</span>
                <span class="neural-status-value" id="rel-dominant-type">—</span>
            </div>
            <div class="neural-status-row" id="rel-transfer-row" style="display: none;">
                <span>Transfer Ready</span>
                <span class="neural-status-value" id="rel-transfer-count">0</span>
            </div>
        </div>
        
        <!-- Concept Abstraction Stats -->
        <div class="neural-status" id="neural-concept-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <circle cx="12" cy="12" r="3"/>
                    <circle cx="12" cy="12" r="8" stroke-dasharray="4 2"/>
                </svg>
                Concept Abstraction
            </div>
            <div class="neural-status-row">
                <span>Schemas</span>
                <span class="neural-status-value" id="concept-schemas">0</span>
            </div>
            <div class="neural-status-row">
                <span>Clusters</span>
                <span class="neural-status-value" id="concept-clusters">0</span>
            </div>
            <div class="neural-status-row" id="concept-hierarchy-row" style="display: none;">
                <span>Hierarchies</span>
                <span class="neural-status-value" id="concept-hierarchies">0</span>
            </div>
            <div class="neural-status-row" id="concept-transfers-row" style="display: none;">
                <span>Transfers Applied</span>
                <span class="neural-status-value" id="concept-transfers">0</span>
            </div>
        </div>
        
        <!-- Meta-Learner Stats (How You Think) -->
        <div class="neural-status" id="neural-meta-stats" style="margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 14px; height: 14px;">
                    <path d="M12 2a8 8 0 0 1 8 8c0 3-2 5.5-4 7l-1 4H9l-1-4c-2-1.5-4-4-4-7a8 8 0 0 1 8-8z"/>
                    <path d="M9 22h6"/>
                </svg>
                Thinking Patterns
            </div>
            <div class="neural-status-row">
                <span>Building Style</span>
                <span class="neural-status-value" id="meta-building-style">Learning...</span>
            </div>
            <div class="neural-status-row">
                <span>Decision Speed</span>
                <span class="neural-status-value" id="meta-decision-speed">Learning...</span>
            </div>
            <div class="neural-status-row" id="meta-rhythm-row" style="display: none;">
                <span>Work Rhythm</span>
                <span class="neural-status-value" id="meta-rhythm">—</span>
            </div>
            <div class="neural-status-row" id="meta-selectivity-row" style="display: none;">
                <span>Selectivity</span>
                <span class="neural-status-value" id="meta-selectivity">—</span>
            </div>
            <div class="neural-status-row" id="meta-sessions-row" style="display: none;">
                <span>Sessions Analyzed</span>
                <span class="neural-status-value" id="meta-sessions">0</span>
            </div>
        </div>
        
        <!-- Meta-Learner Insights -->
        <div id="meta-insights-section" style="display: none; margin-top: 12px; border-top: 1px solid var(--bg-tertiary); padding-top: 12px;">
            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">Your Strengths</div>
            <div id="meta-strengths" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
        </div>
        
        <div class="neural-categories" id="neural-categories" style="display: none;">
            <div class="neural-categories-title">Learned Categories</div>
            <div class="neural-category-list" id="neural-category-list"></div>
        </div>
        
        <div class="neural-actions">
            <button class="neural-btn primary" id="neural-smart-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 1 1 7.072 0l-.548.547A3.374 3.374 0 0 0 14 18.469V19a2 2 0 1 1-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                </svg>
                Smart Expand Selected
            </button>
            <button class="neural-btn secondary" id="neural-suggest-btn" disabled>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><circle cx="12" cy="17" r="0.5"/>
                </svg>
                Find Related Nodes
            </button>
        </div>
        
        <div class="neural-suggestions" id="neural-suggestions" style="display: none;">
            <div class="neural-suggestions-title">AI Suggestions <span id="neural-suggestions-for" style="font-weight: 400; color: var(--text-secondary);"></span></div>
            <div id="neural-suggestions-list"></div>
        </div>
    </div>

    <!-- AI Chat Panel -->
    <div id="ai-chat-panel">
        <!-- Slide toggle on left edge -->
        <button class="chat-slide-toggle" id="chat-slide-toggle" title="Toggle chat">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 18 9 12 15 6"/>
            </svg>
        </button>
        
        <div class="chat-header">
            <div class="chat-header-left">
                <span class="chat-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                    </svg>
                </span>
                <span class="chat-title">MYND Chat</span>
            </div>
            <div class="chat-header-actions">
                <button class="chat-header-btn" id="chat-clear" title="Clear conversation">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="chat-messages" id="chat-messages">
            <div class="chat-welcome">
                <div class="chat-welcome-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                    </svg>
                </div>
                <div class="chat-welcome-title">Hi, I'm your MYND assistant</div>
                <div class="chat-welcome-text">
                    I can help you build and organize your mind map. Try asking me to:
                </div>
                <div class="chat-welcome-examples">
                    <button class="chat-example-btn">Help me brainstorm ideas for my goals</button>
                    <button class="chat-example-btn">What should I add to my fitness plan?</button>
                    <button class="chat-example-btn">Organize my project nodes</button>
                    <button class="chat-example-btn">What's the latest news on AI?</button>
                </div>
            </div>
        </div>
        
        <div class="chat-suggestions" id="chat-suggestions" style="display: none;">
            <!-- Quick reply suggestions appear here -->
        </div>
        
        <div class="chat-input-area">
            <div class="chat-input-container">
                <textarea 
                    id="chat-input" 
                    placeholder="Ask me anything..." 
                    rows="1"
                    aria-label="Chat message"
                ></textarea>
                <button class="chat-voice-btn" id="chat-voice-btn" title="Voice input">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z"/>
                        <path d="M19 10v2a7 7 0 01-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                </button>
                <button class="chat-send-btn" id="chat-send-btn" title="Send message" disabled>
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                </button>
                
                <!-- Voice recording overlay -->
                <div class="chat-voice-overlay" id="chat-voice-overlay">
                    <div class="chat-voice-indicator">
                        <div class="chat-voice-bars">
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                            <div class="chat-voice-bar"></div>
                        </div>
                        <span class="chat-voice-status recording" id="chat-voice-status">Listening...</span>
                    </div>
                    <button class="chat-voice-cancel" id="chat-voice-cancel">Cancel</button>
                </div>
            </div>
            <div class="chat-input-hint">
                <span class="chat-hint-key">Enter</span> to send · <span class="chat-hint-key">Shift+Enter</span> for new line
            </div>
        </div>
    </div>
    
    <!-- Chat Toggle Button (floating) -->
    <button id="chat-toggle-btn" class="chat-toggle-btn" title="Open AI Chat">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
        </svg>
        <span class="chat-toggle-badge" style="display: none;">1</span>
    </button>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <!-- TensorFlow.js and USE - Lazy loaded when AI features first used -->
    <!-- Scripts will be loaded dynamically by loadTensorFlow() -->
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ═══════════════════════════════════════════════════════════════════
    // CONSOLIDATED CONFIGURATION - All constants in one place
    // ═══════════════════════════════════════════════════════════════════
    const CONFIG = {
        // Storage Keys
        STORAGE_KEY: 'mynd-v6c',
        ONBOARDING_KEY: 'mynd-onboarded-v17',
        THEME_KEY: 'mynd-theme-v8',
        API_KEY: 'mynd-api-key',
        
        // Supabase Configuration
        SUPABASE_URL: 'https://diqjasswlujwtdgsreab.supabase.co',
        SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpcWphc3N3bHVqd3RkZ3NyZWFiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjQyNTksImV4cCI6MjA4MTAwMDI1OX0._APhMDa1-FooORV_s5-ki6HF02TAlc_TX5CvqC7yKr4',
        EDGE_FUNCTION_URL: 'https://diqjasswlujwtdgsreab.supabase.co/functions/v1/claude-api',
        
        // Color Palettes for each theme
        THEME_COLORS: {
            // Sandstone - Natural earthy tones (graphite first for root)
            sandstone: [
                '#3A3A3A', '#B17457', '#8B9D83', '#C4887A', '#6B7C7A',
                '#4A4947', '#9AABA0', '#D8D2C2', '#A89078', '#7A8B70',
                '#5E6B5A', '#C0A898', '#8A9488', '#D4C4B0', '#6B6B63',
                '#A09080', '#C8B8A0', '#787870'
            ],
            // Coral - Soft pastels, flat cartoon look
            coral: [
                '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
                '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
                '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
                '#A0C8D0', '#E0C0C0', '#C8C8C8'
            ],
            // Ember - Warm gradient from burnt orange to cream (rich orange first for root)
            ember: [
                '#C04818', '#E85820', '#F07028', '#F88830', '#FFA040',
                '#FFB858', '#FFD070', '#FFE088', '#D4C4A0', '#B0A080',
                '#907860', '#C89060', '#E8A848', '#F0C060', '#D8B078',
                '#A88858', '#C8A070', '#E8D098'
            ],
            // Frost - Cool soft blues and grays (white first for root)
            frost: [
                '#FFFFFF', '#5B8DEF', '#7DA8F5', '#6B9BD0', '#8FB8E8',
                '#5D7D9A', '#7A9AB8', '#4A6A8A', '#98B8D8', '#6888A8',
                '#88A8C8', '#5878A0', '#A8C8E8', '#7898B8', '#6080A0',
                '#90B0D0', '#4868A0', '#B0D0F0'
            ],
            // Obsidian - Coral accent with cool grays
            obsidian: [
                '#EF8354', '#F59B70', '#BFC0C0', '#4F5D75', '#7A8899',
                '#E8956A', '#8D99AE', '#F0A880', '#6B7B8C', '#D08060',
                '#9EAAB8', '#C87850', '#5A6A7A', '#E09070', '#A8B4C0',
                '#B07058', '#7888A0', '#D4A088'
            ]
        },
        
        // Legacy fallback (will be mapped to coral)
        COLORS: [
            '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
            '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
            '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
            '#A0C8D0', '#E0C0C0', '#C8C8C8'
        ],
        
        COLORS_PROFESSIONAL: [
            '#A8D5E5', '#E87D7D', '#B8A9C9', '#95D5B2', '#F5C396',
            '#89CFF0', '#F4A4A4', '#C3B1E1', '#A7E8BD', '#FFD8A8',
            '#98D8C8', '#EFA8A8', '#D4C4E0', '#BEE5B0', '#F8C8A8',
            '#A0C8D0', '#E0C0C0', '#C8C8C8'
        ],
        
        // Spring Physics
        SPRING: {
            stiffness: 0.15,
            damping: 0.88
        },
        
        // Node Sizes
        NODE_SIZES: {
            root: 1.8,
            level1: 0.85,
            level2: 0.6,
            default: 0.45,
            minSize: 0.25
        },
        
        // Layout
        LAYOUT: {
            level1Radius: 6.0,
            level1RadiusExpanded: 8,
            level2Radius: 5.5,
            level3Radius: 4.0,
            spreadAngle: Math.PI * 1.2,
            descendantSpacingFactor: 0.25,
            maxDescendantPush: 7
        },
        
        // Animation - consolidated timing constants
        ANIMATION: {
            springLerpBase: 0.12,
            springLerpSlow: 0.06,
            springLerpMedium: 0.08,
            scaleLerp: 0.15,
            positionThreshold: 0.001,
            scaleThreshold: 0.001,
            animatingThreshold: 0.01,
            cameraArcDuration: 600,
            cameraFollowSpeed: 0.03
        },
        
        // Timing (ms)
        TIMING: {
            expandStagger: 50,
            collapseStagger: 40,
            collapseHideDelay: 200,
            toastDuration: 3000,
            labelUpdateInterval: 100
        },
        
        // Label Decluttering
        LABELS: {
            padding: 12,
            fadeSpeed: 0.12,
            minOpacity: 0.03,
            basePriority: 100,
            selectedPriority: 1000,
            rootPriority: 500,
            depthPenalty: 10,
            declutterInterval: 3, // frames between declutter runs
            // Label sprite rendering
            fontSize: 42,
            spritePadding: 20,
            minWidth: 60,
            charWidth: 8,
            scaleFactor: 20,
            minDistance: 5
        },
        
        // Particles
        PARTICLES: {
            count: 200,
            spread: 100,
            baseSize: 0.15,
            opacity: 0.4,
            rotationSpeed: 0.02
        },
        
        // Neural Network Settings
        NEURAL_NET: {
            STORAGE_KEY: 'mynd-neural-model-v1',
            EMBEDDINGS_KEY: 'mynd-embeddings-v1',
            DB_NAME: 'mynd-neural-db',
            DB_VERSION: 1,
            STORE_NAME: 'models',
            embeddingDim: 512, // Universal Sentence Encoder output dimension
            hiddenUnits: 128,
            learningRate: 0.01,
            minTrainingNodes: 5,
            batchSize: 16,
            epochs: 50
        }
    };
    
    // Mobile detection and performance adjustments
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
    const isLowPowerDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
    
    if (isMobile || isLowPowerDevice) {
        // Reduce training intensity for mobile/low-power devices
        CONFIG.NEURAL_NET.epochs = isMobile ? 8 : 12;
        CONFIG.NEURAL_NET.batchSize = isMobile ? 8 : 12;
        CONFIG.NEURAL_NET.hiddenUnits = isMobile ? 64 : 96;
        console.log(`📱 Mobile/low-power mode: epochs=${CONFIG.NEURAL_NET.epochs}, batch=${CONFIG.NEURAL_NET.batchSize}`);
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE CLIENT INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    let supabase = null;
    
    function initSupabase() {
        if (supabase) return supabase;
        
        if (CONFIG.SUPABASE_URL === 'YOUR_SUPABASE_URL' || 
            CONFIG.SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
            console.warn('Supabase not configured - running in local-only mode');
            return null;
        }
        
        try {
            supabase = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
            console.log('✓ Supabase client initialized');
            return supabase;
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
            return null;
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // TENSORFLOW LAZY LOADER - Only load when AI features are used
    // ═══════════════════════════════════════════════════════════════════
    const TensorFlowLoader = {
        loaded: false,
        loading: false,
        loadPromise: null,
        
        async load() {
            // Already loaded
            if (this.loaded && typeof tf !== 'undefined' && typeof use !== 'undefined') {
                return true;
            }
            
            // Already loading - return existing promise
            if (this.loading && this.loadPromise) {
                return this.loadPromise;
            }
            
            this.loading = true;
            
            this.loadPromise = new Promise(async (resolve, reject) => {
                try {
                    console.log('📦 Loading TensorFlow.js (first AI feature used)...');
                    showToast('Loading AI engine...', 'info');
                    
                    // Load TensorFlow.js
                    await this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js');
                    
                    // Load Universal Sentence Encoder
                    await this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js');
                    
                    // Initialize GPU backend
                    if (typeof tf !== 'undefined') {
                        try {
                            await tf.setBackend('webgl');
                            await tf.ready();
                            console.log(`✓ TensorFlow.js loaded with ${tf.getBackend()} backend`);
                        } catch (e) {
                            console.log('WebGL not available, using CPU');
                        }
                    }
                    
                    this.loaded = true;
                    this.loading = false;
                    showToast('AI engine ready', 'success');
                    resolve(true);
                    
                } catch (error) {
                    console.error('Failed to load TensorFlow:', error);
                    this.loading = false;
                    showToast('Failed to load AI engine', 'error');
                    reject(error);
                }
            });
            
            return this.loadPromise;
        },
        
        loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        },
        
        isLoaded() {
            return this.loaded && typeof tf !== 'undefined' && typeof use !== 'undefined';
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // ANIMATION THROTTLING - Reduce CPU when idle
    // ═══════════════════════════════════════════════════════════════════
    const AnimationController = {
        isIdle: false,
        idleTimeout: null,
        lastInteraction: Date.now(),
        isTabVisible: true,
        targetFPS: 60,
        frameInterval: 1000 / 60,
        lastFrameTime: 0,
        animatingNodes: 0,
        
        init() {
            // Track tab visibility
            document.addEventListener('visibilitychange', () => {
                this.isTabVisible = !document.hidden;
                if (this.isTabVisible) {
                    this.wake();
                }
            });
            
            // Track user interaction
            ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'wheel', 'keydown'].forEach(event => {
                document.addEventListener(event, () => this.wake(), { passive: true });
            });
        },
        
        wake() {
            this.lastInteraction = Date.now();
            this.isIdle = false;
            this.targetFPS = 60;
            this.frameInterval = 1000 / 60;
            
            clearTimeout(this.idleTimeout);
            this.idleTimeout = setTimeout(() => this.checkIdle(), 3000);
        },
        
        checkIdle() {
            const timeSinceInteraction = Date.now() - this.lastInteraction;
            
            if (timeSinceInteraction > 3000 && this.animatingNodes === 0) {
                this.isIdle = true;
                this.targetFPS = 15; // Reduce to 15fps when idle
                this.frameInterval = 1000 / 15;
            }
        },
        
        shouldRenderFrame(currentTime) {
            // Always skip if tab is hidden
            if (!this.isTabVisible) return false;
            
            // Throttle based on target FPS
            if (currentTime - this.lastFrameTime < this.frameInterval) {
                return false;
            }
            
            this.lastFrameTime = currentTime;
            return true;
        },
        
        setAnimatingCount(count) {
            this.animatingNodes = count;
            if (count > 0) this.wake();
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE AUTH - User authentication management
    // ═══════════════════════════════════════════════════════════════════
    const SupabaseAuth = {
        user: null,
        listeners: [],
        
        async init() {
            if (!supabase) return null;
            
            // Get initial session
            const { data: { session } } = await supabase.auth.getSession();
            this.user = session?.user || null;
            
            // Listen for auth changes
            supabase.auth.onAuthStateChange((event, session) => {
                const previousUser = this.user;
                this.user = session?.user || null;
                
                console.log(`Auth state changed: ${event}`, this.user?.email || 'logged out');
                
                // Notify listeners
                this.listeners.forEach(callback => callback(this.user, previousUser, event));
            });
            
            return this.user;
        },
        
        onAuthChange(callback) {
            this.listeners.push(callback);
        },
        
        async signInWithGoogle() {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signInWithOAuth({
                provider: 'google',
                options: {
                    redirectTo: window.location.origin + window.location.pathname
                }
            });
            
            if (error) {
                console.error('Google sign-in error:', error);
                showToast('Sign in failed: ' + error.message, 'error');
            }
            
            return { data, error };
        },
        
        async signInWithEmail(email, password) {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signInWithPassword({
                email,
                password
            });
            
            if (error) {
                console.error('Email sign-in error:', error);
                showToast('Sign in failed: ' + error.message, 'error');
            }
            
            return { data, error };
        },
        
        async signUpWithEmail(email, password) {
            if (!supabase) {
                showToast('Cloud sync not configured', 'error');
                return { error: 'Supabase not configured' };
            }
            
            const { data, error } = await supabase.auth.signUp({
                email,
                password,
                options: {
                    emailRedirectTo: window.location.origin + window.location.pathname
                }
            });
            
            if (error) {
                console.error('Sign-up error:', error);
                showToast('Sign up failed: ' + error.message, 'error');
            } else if (data.user && !data.session) {
                showToast('Check your email to confirm your account', 'success');
            }
            
            return { data, error };
        },
        
        async signOut() {
            if (!supabase) return;
            
            const { error } = await supabase.auth.signOut();
            if (error) {
                console.error('Sign-out error:', error);
                showToast('Sign out failed', 'error');
            } else {
                showToast('Signed out successfully', 'success');
            }
            
            return { error };
        },
        
        async resetPassword(email) {
            if (!supabase) return { error: 'Supabase not configured' };
            
            const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
                redirectTo: window.location.origin + window.location.pathname
            });
            
            if (error) {
                showToast('Password reset failed: ' + error.message, 'error');
            } else {
                showToast('Check your email for reset instructions', 'success');
            }
            
            return { data, error };
        },
        
        isLoggedIn() {
            return !!this.user;
        },
        
        getUser() {
            return this.user;
        },
        
        getUserEmail() {
            return this.user?.email || null;
        },
        
        getUserId() {
            return this.user?.id || null;
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // SUPABASE SYNC - Cloud data synchronization with Real-time
    // ═══════════════════════════════════════════════════════════════════
    const SupabaseSync = {
        currentMapId: null,
        syncEnabled: false,
        syncDebounceTimer: null,
        isSyncing: false,
        lastSyncTime: null,
        realtimeChannel: null,
        isReceivingUpdate: false, // Flag to prevent echo
        lastKnownVersion: null,
        
        async init() {
            if (!supabase || !SupabaseAuth.isLoggedIn()) {
                this.syncEnabled = false;
                return;
            }
            
            this.syncEnabled = true;
            console.log('✓ Supabase sync enabled');
            
            // Set up auth state change listener for reconnection
            supabase.auth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_OUT') {
                    this.unsubscribeFromRealtime();
                    this.syncEnabled = false;
                } else if (event === 'SIGNED_IN' && session) {
                    this.syncEnabled = true;
                }
            });
        },
        
        // ─── Real-time Subscription ────────────────────────────────────────
        
        async subscribeToRealtime(mapId) {
            if (!this.syncEnabled || !mapId) return;
            
            // Unsubscribe from previous channel if exists
            this.unsubscribeFromRealtime();
            
            console.log('📡 Subscribing to real-time updates for map:', mapId);
            
            this.realtimeChannel = supabase
                .channel(`map-${mapId}`)
                .on(
                    'postgres_changes',
                    {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'mind_maps',
                        filter: `id=eq.${mapId}`
                    },
                    (payload) => this.handleRealtimeUpdate(payload)
                )
                .subscribe((status) => {
                    console.log('📡 Realtime subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        this.updateSyncIndicator('connected');
                    } else if (status === 'CHANNEL_ERROR') {
                        this.updateSyncIndicator('error');
                    }
                });
        },
        
        unsubscribeFromRealtime() {
            if (this.realtimeChannel) {
                console.log('📡 Unsubscribing from real-time updates');
                supabase.removeChannel(this.realtimeChannel);
                this.realtimeChannel = null;
            }
        },
        
        handleRealtimeUpdate(payload) {
            // Ignore if we just sent this update (echo prevention)
            if (this.isReceivingUpdate) {
                console.log('📡 Ignoring echo update');
                return;
            }
            
            const newData = payload.new;
            const updatedAt = new Date(newData.updated_at).getTime();
            
            // Check if this is newer than our last known version
            if (this.lastKnownVersion && updatedAt <= this.lastKnownVersion) {
                console.log('📡 Ignoring older update');
                return;
            }
            
            console.log('📡 Received real-time update from another device');
            
            // Show notification to user
            this.showSyncNotification(newData);
        },
        
        showSyncNotification(newData) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'sync-notification';
            notification.innerHTML = `
                <div class="sync-notification-content">
                    <div class="sync-notification-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 0 1-9 9m9-9a9 9 0 0 0-9-9m9 9H3m9 9a9 9 0 0 1-9-9m9 9c1.66 0 3-4.03 3-9s-1.34-9-3-9m0 18c-1.66 0-3-4.03-3-9s1.34-9 3-9m-9 9a9 9 0 0 1 9-9"/>
                        </svg>
                    </div>
                    <div class="sync-notification-text">
                        <strong>Changes from another device</strong>
                        <span>Your map was updated elsewhere</span>
                    </div>
                    <div class="sync-notification-actions">
                        <button class="sync-btn sync-btn-refresh">Load Changes</button>
                        <button class="sync-btn sync-btn-dismiss">Keep Mine</button>
                    </div>
                </div>
            `;
            
            // Add styles if not present
            if (!document.getElementById('sync-notification-styles')) {
                const style = document.createElement('style');
                style.id = 'sync-notification-styles';
                style.textContent = `
                    .sync-notification {
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: var(--glass-bg);
                        backdrop-filter: blur(20px);
                        border: 1px solid var(--accent);
                        border-radius: 12px;
                        padding: 16px 20px;
                        z-index: 10000;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                        animation: slideDown 0.3s var(--ease-out);
                        max-width: 340px;
                        width: 90%;
                    }
                    @keyframes slideDown {
                        from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        to { opacity: 1; transform: translateX(-50%) translateY(0); }
                    }
                    .sync-notification-content {
                        display: flex;
                        flex-direction: column;
                        gap: 12px;
                    }
                    .sync-notification-icon {
                        text-align: center;
                    }
                    .sync-notification-icon svg {
                        width: 32px;
                        height: 32px;
                        stroke: var(--accent);
                    }
                    .sync-notification-text {
                        text-align: center;
                    }
                    .sync-notification-text strong {
                        display: block;
                        color: var(--text-primary);
                        margin-bottom: 4px;
                    }
                    .sync-notification-text span {
                        color: var(--text-secondary);
                        font-size: 0.9rem;
                    }
                    .sync-notification-actions {
                        display: flex;
                        gap: 10px;
                        justify-content: center;
                    }
                    .sync-btn {
                        padding: 8px 16px;
                        border-radius: 8px;
                        font-size: 0.9rem;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .sync-btn-refresh {
                        background: var(--accent);
                        color: white;
                        border: none;
                    }
                    .sync-btn-refresh:hover {
                        filter: brightness(1.1);
                    }
                    .sync-btn-dismiss {
                        background: transparent;
                        color: var(--text-secondary);
                        border: 1px solid var(--border-color);
                    }
                    .sync-btn-dismiss:hover {
                        background: var(--bg-tertiary);
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Handle button clicks
            notification.querySelector('.sync-btn-refresh').addEventListener('click', async () => {
                notification.remove();
                await this.loadAndApplyRemoteChanges(newData);
            });
            
            notification.querySelector('.sync-btn-dismiss').addEventListener('click', () => {
                notification.remove();
                // Force save our version
                this.forceSave();
            });
            
            // Auto-dismiss after 30 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 30000);
        },
        
        async loadAndApplyRemoteChanges(newData) {
            try {
                showToast('Loading changes...', 'info');
                
                // Apply the remote data
                if (newData.data) {
                    store.data = newData.data;
                    store.save();
                    this.lastKnownVersion = new Date(newData.updated_at).getTime();
                    
                    // Rebuild the scene
                    buildScene();
                    
                    showToast('Map updated from cloud', 'success');
                }
            } catch (error) {
                console.error('Failed to apply remote changes:', error);
                showToast('Failed to load changes', 'error');
            }
        },
        
        async forceSave() {
            this.isReceivingUpdate = true;
            await this.saveMap(store.data, store.data.label || 'My Mind');
            this.isReceivingUpdate = false;
            showToast('Your version saved to cloud', 'success');
        },
        
        // ─── Mind Map Operations ─────────────────────────────────────────
        
        async loadUserMaps() {
            if (!this.syncEnabled) return [];
            
            const { data, error } = await supabase
                .from('mind_maps')
                .select('id, name, updated_at, created_at')
                .order('updated_at', { ascending: false });
            
            if (error) {
                console.error('Failed to load maps:', error);
                return [];
            }
            
            return data || [];
        },
        
        async loadMap(mapId) {
            if (!this.syncEnabled) return null;
            
            const { data, error } = await supabase
                .from('mind_maps')
                .select('*')
                .eq('id', mapId)
                .single();
            
            if (error) {
                console.error('Failed to load map:', error);
                return null;
            }
            
            this.currentMapId = mapId;
            this.lastKnownVersion = new Date(data.updated_at).getTime();
            
            // Subscribe to real-time updates for this map
            await this.subscribeToRealtime(mapId);
            
            return data;
        },
        
        async saveMap(mapData, mapName = 'My Mind') {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            // Set flag to prevent echo
            this.isReceivingUpdate = true;
            
            // If we have a current map, update it
            if (this.currentMapId) {
                const { data, error } = await supabase
                    .from('mind_maps')
                    .update({
                        name: mapName,
                        data: mapData,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', this.currentMapId)
                    .select()
                    .single();
                
                // Reset flag after a short delay (to account for realtime latency)
                setTimeout(() => { this.isReceivingUpdate = false; }, 1000);
                
                if (error) {
                    console.error('Failed to update map:', error);
                    return null;
                }
                
                this.lastSyncTime = Date.now();
                this.lastKnownVersion = new Date(data.updated_at).getTime();
                return data;
            }
            
            // Otherwise create new map
            const { data, error } = await supabase
                .from('mind_maps')
                .insert({
                    user_id: userId,
                    name: mapName,
                    data: mapData
                })
                .select()
                .single();
            
            setTimeout(() => { this.isReceivingUpdate = false; }, 1000);
            
            if (error) {
                console.error('Failed to create map:', error);
                return null;
            }
            
            this.currentMapId = data.id;
            this.lastSyncTime = Date.now();
            this.lastKnownVersion = new Date(data.updated_at).getTime();
            
            // Subscribe to real-time updates for the new map
            await this.subscribeToRealtime(data.id);
            
            return data;
        },
        
        async deleteMap(mapId) {
            if (!this.syncEnabled) return false;
            
            const { error } = await supabase
                .from('mind_maps')
                .delete()
                .eq('id', mapId);
            
            if (error) {
                console.error('Failed to delete map:', error);
                return false;
            }
            
            if (this.currentMapId === mapId) {
                this.currentMapId = null;
                this.unsubscribeFromRealtime();
            }
            
            return true;
        },
        
        async renameMap(mapId, newName) {
            if (!this.syncEnabled) return false;
            
            const { error } = await supabase
                .from('mind_maps')
                .update({ name: newName, updated_at: new Date().toISOString() })
                .eq('id', mapId);
            
            if (error) {
                console.error('Failed to rename map:', error);
                return false;
            }
            
            return true;
        },
        
        async duplicateMap(mapId, newName) {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            // Load the original map
            const original = await this.loadMap(mapId);
            if (!original) return null;
            
            // Create a copy
            const { data, error } = await supabase
                .from('mind_maps')
                .insert({
                    user_id: userId,
                    name: newName,
                    data: original.data
                })
                .select()
                .single();
            
            if (error) {
                console.error('Failed to duplicate map:', error);
                return null;
            }
            
            return data;
        },
        
        // Debounced save for real-time editing
        scheduleSave(mapData, mapName) {
            if (!this.syncEnabled) return;
            
            if (this.syncDebounceTimer) {
                clearTimeout(this.syncDebounceTimer);
            }
            
            // Update indicator to show pending
            this.updateSyncIndicator('syncing');
            
            this.syncDebounceTimer = setTimeout(async () => {
                if (this.isSyncing) return;
                
                this.isSyncing = true;
                await this.saveMap(mapData, mapName);
                this.isSyncing = false;
                
                // Update sync indicator
                this.updateSyncIndicator('synced');
            }, 2000); // Sync every 2 seconds of inactivity
        },
        
        updateSyncIndicator(status = 'synced') {
            const indicator = document.getElementById('sync-indicator');
            if (!indicator) return;
            
            indicator.classList.remove('synced', 'syncing', 'error', 'connected');
            
            switch (status) {
                case 'synced':
                    indicator.classList.add('synced');
                    indicator.title = 'Synced to cloud';
                    break;
                case 'syncing':
                    indicator.classList.add('syncing');
                    indicator.title = 'Syncing...';
                    break;
                case 'connected':
                    indicator.classList.add('synced');
                    indicator.title = 'Connected - Real-time sync active';
                    break;
                case 'error':
                    indicator.classList.add('error');
                    indicator.title = 'Sync error';
                    break;
            }
        },
        
        // ─── Neural Patterns Operations ──────────────────────────────────
        
        async loadNeuralPatterns() {
            if (!this.syncEnabled) return new Map();
            
            const { data, error } = await supabase
                .from('neural_patterns')
                .select('*');
            
            if (error) {
                console.error('Failed to load neural patterns:', error);
                return new Map();
            }
            
            // Convert to Map format used by PersonalNeuralNet
            const patterns = new Map();
            for (const row of data || []) {
                patterns.set(row.pattern_key, {
                    weight: row.weight,
                    occurrences: row.occurrences,
                    accepted: row.accepted,
                    sources: row.sources || [],
                    relationshipType: row.relationship_type,
                    relationshipConfidence: row.relationship_confidence
                });
            }
            
            return patterns;
        },
        
        async saveNeuralPattern(patternKey, patternData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('neural_patterns')
                .upsert({
                    user_id: userId,
                    pattern_key: patternKey,
                    weight: patternData.weight,
                    occurrences: patternData.occurrences,
                    accepted: patternData.accepted,
                    sources: patternData.sources,
                    relationship_type: patternData.relationshipType,
                    relationship_confidence: patternData.relationshipConfidence
                }, {
                    onConflict: 'user_id,pattern_key'
                });
            
            if (error) {
                console.error('Failed to save neural pattern:', error);
            }
        },
        
        async saveAllNeuralPatterns(patternsMap) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const patterns = Array.from(patternsMap.entries()).map(([key, data]) => ({
                user_id: userId,
                pattern_key: key,
                weight: data.weight,
                occurrences: data.occurrences,
                accepted: data.accepted,
                sources: data.sources,
                relationship_type: data.relationshipType,
                relationship_confidence: data.relationshipConfidence
            }));
            
            if (patterns.length === 0) return;
            
            const { error } = await supabase
                .from('neural_patterns')
                .upsert(patterns, {
                    onConflict: 'user_id,pattern_key'
                });
            
            if (error) {
                console.error('Failed to save neural patterns:', error);
            }
        },
        
        // ─── User Profile Operations ─────────────────────────────────────
        
        async loadUserProfile() {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            const { data, error } = await supabase
                .from('user_profiles')
                .select('*')
                .eq('user_id', userId)
                .single();
            
            if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
                console.error('Failed to load user profile:', error);
            }
            
            return data;
        },
        
        async saveUserProfile(profileData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('user_profiles')
                .upsert({
                    user_id: userId,
                    building_style: profileData.buildingStyle || {},
                    exploration_style: profileData.explorationStyle || {},
                    refinement_style: profileData.refinementStyle || {},
                    decision_style: profileData.decisionStyle || {},
                    session_rhythm: profileData.sessionRhythm || {},
                    branch_commitment: profileData.branchCommitment || {},
                    cognitive_patterns: profileData.cognitivePatterns || {},
                    preferences: profileData.preferences || {},
                    insights: profileData.insights || {}
                }, {
                    onConflict: 'user_id'
                });
            
            if (error) {
                console.error('Failed to save user profile:', error);
            }
        },
        
        // ─── Concept Abstractions Operations ─────────────────────────────
        
        async loadConceptAbstractions() {
            if (!this.syncEnabled) return null;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return null;
            
            const { data, error } = await supabase
                .from('concept_abstractions')
                .select('*')
                .eq('user_id', userId)
                .single();
            
            if (error && error.code !== 'PGRST116') {
                console.error('Failed to load concept abstractions:', error);
            }
            
            return data;
        },
        
        async saveConceptAbstractions(abstractionData) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('concept_abstractions')
                .upsert({
                    user_id: userId,
                    schemas: abstractionData.schemas || {},
                    clusters: abstractionData.clusters || {},
                    hierarchy_patterns: abstractionData.hierarchyPatterns || {},
                    stats: abstractionData.stats || {}
                }, {
                    onConflict: 'user_id'
                });
            
            if (error) {
                console.error('Failed to save concept abstractions:', error);
            }
        },
        
        // ─── Semantic Memories Operations ────────────────────────────────
        
        async loadSemanticMemories() {
            if (!this.syncEnabled) return [];
            
            const { data, error } = await supabase
                .from('semantic_memories')
                .select('*')
                .order('created_at', { ascending: false })
                .limit(200);
            
            if (error) {
                console.error('Failed to load semantic memories:', error);
                return [];
            }
            
            return data || [];
        },
        
        async saveSemanticMemory(memory) {
            if (!this.syncEnabled) return;
            
            const userId = SupabaseAuth.getUserId();
            if (!userId) return;
            
            const { error } = await supabase
                .from('semantic_memories')
                .insert({
                    user_id: userId,
                    event: memory.event,
                    context: memory.context,
                    importance: memory.importance,
                    metadata: memory.metadata,
                    embedding: memory.embedding
                });
            
            if (error) {
                console.error('Failed to save semantic memory:', error);
            }
        },
        
        // ─── Full Sync ───────────────────────────────────────────────────
        
        async performFullSync(store, neuralNet, metaLearner, conceptAbstractor) {
            if (!this.syncEnabled) return;
            
            console.log('Starting full cloud sync...');
            
            try {
                // Save current map
                await this.saveMap(store.exportData(), store.data?.label || 'My Mind');
                
                // Save neural patterns
                if (neuralNet?.patternWeights) {
                    await this.saveAllNeuralPatterns(neuralNet.patternWeights);
                }
                
                // Save user profile (MetaLearner data)
                if (metaLearner) {
                    await this.saveUserProfile({
                        buildingStyle: metaLearner.buildingStyle,
                        explorationStyle: metaLearner.explorationStyle,
                        refinementStyle: metaLearner.refinementStyle,
                        decisionStyle: metaLearner.decisionStyle,
                        sessionRhythm: metaLearner.sessionRhythm,
                        branchCommitment: metaLearner.branchCommitment,
                        cognitivePatterns: metaLearner.cognitivePatterns,
                        insights: metaLearner.insights
                    });
                }
                
                // Save concept abstractions
                if (conceptAbstractor) {
                    await this.saveConceptAbstractions({
                        schemas: Object.fromEntries(conceptAbstractor.schemas || []),
                        clusters: Object.fromEntries(conceptAbstractor.clusters || []),
                        hierarchyPatterns: Object.fromEntries(conceptAbstractor.hierarchyPatterns || []),
                        stats: conceptAbstractor.stats
                    });
                }
                
                console.log('✓ Full sync complete');
                showToast('Synced to cloud', 'success');
                this.updateSyncIndicator();
                
            } catch (error) {
                console.error('Full sync failed:', error);
                showToast('Sync failed', 'error');
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // INDEXEDDB STORAGE FOR NEURAL NETWORK
    // ═══════════════════════════════════════════════════════════════════
    const NeuralDB = {
        db: null,
        
        async init() {
            if (this.db) return this.db;
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CONFIG.NEURAL_NET.DB_NAME, CONFIG.NEURAL_NET.DB_VERSION);
                
                request.onerror = () => {
                    console.error('Failed to open IndexedDB:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    console.log('✓ IndexedDB initialized for neural network storage');
                    resolve(this.db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create object store for model data
                    if (!db.objectStoreNames.contains(CONFIG.NEURAL_NET.STORE_NAME)) {
                        db.createObjectStore(CONFIG.NEURAL_NET.STORE_NAME, { keyPath: 'id' });
                        console.log('✓ Created IndexedDB object store');
                    }
                };
            });
        },
        
        async save(key, data) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.put({ id: key, data: data, timestamp: Date.now() });
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB save error:', error);
                return false;
            }
        },
        
        async load(key) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.get(key);
                    
                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result.data);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB load error:', error);
                return null;
            }
        },
        
        async delete(key) {
            try {
                await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.delete(key);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB delete error:', error);
                return false;
            }
        },
        
        async getSize() {
            try {
                await this.init();
                
                return new Promise((resolve) => {
                    const transaction = this.db.transaction([CONFIG.NEURAL_NET.STORE_NAME], 'readonly');
                    const store = transaction.objectStore(CONFIG.NEURAL_NET.STORE_NAME);
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const totalSize = JSON.stringify(request.result).length;
                        resolve(totalSize);
                    };
                    request.onerror = () => resolve(0);
                });
            } catch (error) {
                return 0;
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // USER PREFERENCE TRACKER - Learns from accepted/rejected suggestions
    // ═══════════════════════════════════════════════════════════════════
    class PreferenceTracker {
        constructor() {
            this.pendingSuggestions = new Map(); // sessionId -> { parentLabel, parentId, suggestions, timestamp }
            this.currentSessionId = null;
            
            // Preference history
            this.history = {
                accepted: [],  // { label, parentLabel, type, timestamp, context }
                ignored: [],   // { label, parentLabel, type, timestamp, context }
            };
            
            // Aggregated insights (computed from history)
            this.insights = {
                acceptanceRateByType: { ml: { accepted: 0, total: 0 }, ai: { accepted: 0, total: 0 } },
                preferredPatterns: {},      // label patterns user tends to accept
                avoidedPatterns: {},        // label patterns user tends to ignore
                preferredParentChildPairs: [], // successful parent->child relationships
                topAcceptedLabels: [],      // most frequently accepted suggestion labels
                topIgnoredLabels: [],       // most frequently ignored suggestion labels
                stylePreferences: {
                    prefersActionLabels: 0,    // -1 to 1 scale
                    prefersShortLabels: 0,     // -1 to 1 scale  
                    prefersDescriptive: 0,     // -1 to 1 scale
                }
            };
            
            this.maxHistorySize = 500; // Keep last 500 decisions
            this.loaded = false;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('preference-history');
                if (saved) {
                    this.history = saved.history || this.history;
                    this.insights = { ...this.insights, ...saved.insights };
                    console.log(`✓ Loaded preference history: ${this.history.accepted.length} accepted, ${this.history.ignored.length} ignored`);
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load preference history:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('preference-history', {
                    history: this.history,
                    insights: this.insights,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save preference history:', error);
            }
        }
        
        // Start tracking a new suggestion session
        startSession(parentId, parentLabel, suggestions) {
            // First, finalize any pending session (mark unclicked as ignored)
            this.finalizePendingSession();
            
            // Create new session
            this.currentSessionId = `session_${Date.now()}`;
            this.pendingSuggestions.set(this.currentSessionId, {
                parentId,
                parentLabel,
                suggestions: suggestions.map(s => ({
                    label: s.label,
                    type: s.type || 'ai',
                    confidence: s.confidence,
                    accepted: false
                })),
                timestamp: Date.now()
            });
            
            console.log(`📊 Preference tracking: Started session for "${parentLabel}" with ${suggestions.length} suggestions`);
            return this.currentSessionId;
        }
        
        // Record that user accepted a suggestion
        recordAccept(label, type = 'ai') {
            if (!this.currentSessionId) return;
            
            const session = this.pendingSuggestions.get(this.currentSessionId);
            if (!session) return;
            
            // Mark as accepted in pending
            const suggestion = session.suggestions.find(s => s.label === label);
            if (suggestion) {
                suggestion.accepted = true;
            }
            
            // Add to accepted history
            const record = {
                label,
                parentLabel: session.parentLabel,
                parentId: session.parentId,
                type,
                timestamp: Date.now(),
                context: this.extractContext(label)
            };
            
            this.history.accepted.push(record);
            this.trimHistory();
            this.updateInsights();
            this.save();
            
            console.log(`✓ Preference: Accepted "${label}" (${type}) under "${session.parentLabel}"`);
        }
        
        // Finalize pending session - mark unaccepted suggestions as ignored
        finalizePendingSession() {
            if (!this.currentSessionId) return;
            
            const session = this.pendingSuggestions.get(this.currentSessionId);
            if (!session) return;
            
            // Record ignored suggestions
            const ignored = session.suggestions.filter(s => !s.accepted);
            ignored.forEach(s => {
                this.history.ignored.push({
                    label: s.label,
                    parentLabel: session.parentLabel,
                    parentId: session.parentId,
                    type: s.type,
                    timestamp: Date.now(),
                    context: this.extractContext(s.label)
                });
            });
            
            if (ignored.length > 0) {
                console.log(`📊 Preference: Ignored ${ignored.length} suggestions from "${session.parentLabel}"`);
                
                // Create semantic memory for significant rejections (3+ ignored in one session)
                if (ignored.length >= 3 && typeof semanticMemory !== 'undefined') {
                    const ignoredLabels = ignored.map(s => s.label).slice(0, 3).join(', ');
                    semanticMemory.addMemory(
                        'suggestion_rejected',
                        `User ignored multiple suggestions under "${session.parentLabel}": ${ignoredLabels}`,
                        { parentLabel: session.parentLabel, ignoredCount: ignored.length, ignoredLabels: ignored.map(s => s.label) }
                    );
                }
            }
            
            // Cleanup
            this.pendingSuggestions.delete(this.currentSessionId);
            this.currentSessionId = null;
            
            this.trimHistory();
            this.updateInsights();
            this.save();
        }
        
        // Extract context features from a label
        extractContext(label) {
            const words = label.split(/\s+/);
            const actionVerbs = ['do', 'make', 'create', 'build', 'start', 'finish', 'complete', 'review', 'plan', 'design', 'implement', 'develop', 'write', 'read', 'learn', 'practice', 'track', 'monitor', 'analyze', 'improve'];
            const isAction = actionVerbs.some(v => label.toLowerCase().startsWith(v) || label.toLowerCase().includes(v));
            
            return {
                wordCount: words.length,
                charCount: label.length,
                isAction,
                hasNumbers: /\d/.test(label),
                isQuestion: label.includes('?'),
                startsWithVerb: actionVerbs.some(v => label.toLowerCase().startsWith(v)),
                firstWord: words[0]?.toLowerCase() || ''
            };
        }
        
        // Keep history within size limit
        trimHistory() {
            if (this.history.accepted.length > this.maxHistorySize) {
                this.history.accepted = this.history.accepted.slice(-this.maxHistorySize);
            }
            if (this.history.ignored.length > this.maxHistorySize) {
                this.history.ignored = this.history.ignored.slice(-this.maxHistorySize);
            }
        }
        
        // Update aggregated insights from history
        updateInsights() {
            // Reset counters
            this.insights.acceptanceRateByType = { 
                ml: { accepted: 0, total: 0 }, 
                ai: { accepted: 0, total: 0 } 
            };
            
            // Count by type
            this.history.accepted.forEach(r => {
                const type = r.type || 'ai';
                if (this.insights.acceptanceRateByType[type]) {
                    this.insights.acceptanceRateByType[type].accepted++;
                    this.insights.acceptanceRateByType[type].total++;
                }
            });
            
            this.history.ignored.forEach(r => {
                const type = r.type || 'ai';
                if (this.insights.acceptanceRateByType[type]) {
                    this.insights.acceptanceRateByType[type].total++;
                }
            });
            
            // Compute label frequency
            const acceptedLabels = {};
            const ignoredLabels = {};
            
            this.history.accepted.forEach(r => {
                acceptedLabels[r.label] = (acceptedLabels[r.label] || 0) + 1;
            });
            
            this.history.ignored.forEach(r => {
                ignoredLabels[r.label] = (ignoredLabels[r.label] || 0) + 1;
            });
            
            // Top accepted/ignored
            this.insights.topAcceptedLabels = Object.entries(acceptedLabels)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([label, count]) => ({ label, count }));
                
            this.insights.topIgnoredLabels = Object.entries(ignoredLabels)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([label, count]) => ({ label, count }));
            
            // Compute parent->child success pairs
            const parentChildSuccess = {};
            this.history.accepted.forEach(r => {
                const key = `${r.parentLabel}→${r.label}`;
                parentChildSuccess[key] = (parentChildSuccess[key] || 0) + 1;
            });
            
            this.insights.preferredParentChildPairs = Object.entries(parentChildSuccess)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([pair, count]) => ({ pair, count }));
            
            // Analyze style preferences
            this.analyzeStylePreferences();
        }
        
        // Analyze what style of labels user prefers
        analyzeStylePreferences() {
            const accepted = this.history.accepted.slice(-100); // Recent 100
            const ignored = this.history.ignored.slice(-100);
            
            if (accepted.length + ignored.length < 10) return; // Not enough data
            
            // Action labels
            const acceptedActions = accepted.filter(r => r.context?.isAction).length;
            const ignoredActions = ignored.filter(r => r.context?.isAction).length;
            const totalActions = acceptedActions + ignoredActions;
            if (totalActions > 5) {
                this.insights.stylePreferences.prefersActionLabels = 
                    (acceptedActions / totalActions) * 2 - 1; // -1 to 1 scale
            }
            
            // Short labels (1-2 words)
            const acceptedShort = accepted.filter(r => r.context?.wordCount <= 2).length;
            const ignoredShort = ignored.filter(r => r.context?.wordCount <= 2).length;
            const totalShort = acceptedShort + ignoredShort;
            if (totalShort > 5) {
                this.insights.stylePreferences.prefersShortLabels = 
                    (acceptedShort / totalShort) * 2 - 1;
            }
            
            // Descriptive (3+ words)
            const acceptedDesc = accepted.filter(r => r.context?.wordCount >= 3).length;
            const ignoredDesc = ignored.filter(r => r.context?.wordCount >= 3).length;
            const totalDesc = acceptedDesc + ignoredDesc;
            if (totalDesc > 5) {
                this.insights.stylePreferences.prefersDescriptive = 
                    (acceptedDesc / totalDesc) * 2 - 1;
            }
        }
        
        // Get acceptance rate for a type (or overall)
        getAcceptanceRate(type = null) {
            if (type) {
                const stats = this.insights.acceptanceRateByType[type];
                if (!stats || stats.total === 0) return null;
                return stats.accepted / stats.total;
            }
            
            const totalAccepted = this.history.accepted.length;
            const totalIgnored = this.history.ignored.length;
            const total = totalAccepted + totalIgnored;
            if (total === 0) return null;
            return totalAccepted / total;
        }
        
        // Generate insights string for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Acceptance rates
            const mlRate = this.getAcceptanceRate('ml');
            const aiRate = this.getAcceptanceRate('ai');
            const overallRate = this.getAcceptanceRate();
            
            if (overallRate !== null && this.history.accepted.length + this.history.ignored.length >= 10) {
                insights.push(`User acceptance rate: ${Math.round(overallRate * 100)}% overall`);
                
                if (mlRate !== null && this.insights.acceptanceRateByType.ml.total >= 5) {
                    insights.push(`  - ML suggestions: ${Math.round(mlRate * 100)}%`);
                }
                if (aiRate !== null && this.insights.acceptanceRateByType.ai.total >= 5) {
                    insights.push(`  - AI suggestions: ${Math.round(aiRate * 100)}%`);
                }
            }
            
            // Style preferences
            const style = this.insights.stylePreferences;
            if (style.prefersActionLabels > 0.3) {
                insights.push('User prefers action-oriented labels (verbs like "Plan X", "Review Y")');
            } else if (style.prefersActionLabels < -0.3) {
                insights.push('User prefers noun-based labels over action verbs');
            }
            
            if (style.prefersShortLabels > 0.3) {
                insights.push('User prefers concise 1-2 word labels');
            } else if (style.prefersDescriptive > 0.3) {
                insights.push('User prefers descriptive multi-word labels');
            }
            
            // Frequently accepted patterns
            if (this.insights.preferredParentChildPairs.length > 0) {
                const topPairs = this.insights.preferredParentChildPairs.slice(0, 3);
                if (topPairs.some(p => p.count >= 2)) {
                    insights.push('Frequently accepted patterns:');
                    topPairs.filter(p => p.count >= 2).forEach(p => {
                        insights.push(`  - ${p.pair}`);
                    });
                }
            }
            
            // Frequently ignored patterns (to avoid)
            if (this.insights.topIgnoredLabels.length > 0) {
                const topIgnored = this.insights.topIgnoredLabels.filter(l => l.count >= 3).slice(0, 3);
                if (topIgnored.length > 0) {
                    insights.push('Avoid these frequently-rejected suggestions:');
                    topIgnored.forEach(l => {
                        insights.push(`  - "${l.label}" (rejected ${l.count}x)`);
                    });
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI display
        getStats() {
            return {
                totalAccepted: this.history.accepted.length,
                totalIgnored: this.history.ignored.length,
                mlAcceptanceRate: this.getAcceptanceRate('ml'),
                aiAcceptanceRate: this.getAcceptanceRate('ai'),
                overallAcceptanceRate: this.getAcceptanceRate(),
                topAccepted: this.insights.topAcceptedLabels.slice(0, 5),
                topIgnored: this.insights.topIgnoredLabels.slice(0, 5),
                stylePreferences: this.insights.stylePreferences
            };
        }
        
        // Reset all preference data
        async reset() {
            this.history = { accepted: [], ignored: [] };
            this.insights = {
                acceptanceRateByType: { ml: { accepted: 0, total: 0 }, ai: { accepted: 0, total: 0 } },
                preferredPatterns: {},
                avoidedPatterns: {},
                preferredParentChildPairs: [],
                topAcceptedLabels: [],
                topIgnoredLabels: [],
                stylePreferences: {
                    prefersActionLabels: 0,
                    prefersShortLabels: 0,
                    prefersDescriptive: 0,
                }
            };
            this.pendingSuggestions.clear();
            this.currentSessionId = null;
            await NeuralDB.delete('preference-history');
            console.log('✓ Preference tracker reset');
        }
    }
    
    // Create global preference tracker instance
    const preferenceTracker = new PreferenceTracker();
    
    // ═══════════════════════════════════════════════════════════════════
    // SEMANTIC MEMORY SYSTEM - Long-term context awareness
    // ═══════════════════════════════════════════════════════════════════
    class SemanticMemory {
        constructor() {
            this.memories = [];
            this.maxMemories = 200; // Keep last 200 memories
            this.minImportance = 0.2; // Minimum importance to keep
            this.decayRate = 0.995; // Daily decay multiplier
            this.loaded = false;
            this.encoder = null; // Will be set from neuralNet
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('semantic-memories');
                if (saved && saved.memories) {
                    this.memories = saved.memories;
                    console.log(`✓ Loaded ${this.memories.length} semantic memories`);
                    
                    // Apply decay based on time since last load
                    if (saved.lastDecay) {
                        const daysSinceDecay = (Date.now() - saved.lastDecay) / (1000 * 60 * 60 * 24);
                        if (daysSinceDecay >= 1) {
                            this.applyDecay(Math.floor(daysSinceDecay));
                        }
                    }
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load semantic memories:', error);
                this.loaded = true;
            }
        }
        
        // Set encoder reference (called from neuralNet after it loads)
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('semantic-memories', {
                    memories: this.memories,
                    lastDecay: Date.now(),
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save semantic memories:', error);
            }
        }
        
        // Create a new memory
        async addMemory(event, context, metadata = {}) {
            // Generate embedding for the context
            let embedding = null;
            if (this.encoder) {
                try {
                    const embeddings = await this.encoder.embed([context]);
                    const embeddingArray = await embeddings.array();
                    embedding = embeddingArray[0];
                    embeddings.dispose();
                } catch (error) {
                    console.error('Failed to generate memory embedding:', error);
                }
            }
            
            // Calculate importance based on event type
            let importance = this.calculateImportance(event, metadata);
            
            const memory = {
                id: `mem_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                event,
                context,
                embedding,
                importance,
                timestamp: Date.now(),
                metadata
            };
            
            this.memories.push(memory);
            
            // Prune if over limit
            this.pruneMemories();
            
            console.log(`🧠 Memory stored: "${context.substring(0, 50)}..." (importance: ${importance.toFixed(2)})`);
            
            // Debounced save
            this.scheduleSave();
            
            return memory;
        }
        
        // Calculate importance based on event type
        calculateImportance(event, metadata) {
            const baseImportance = {
                'suggestion_accepted': 0.7,
                'suggestion_rejected': 0.4,
                'pattern_emerged': 0.8,
                'node_created_manual': 0.5,
                'node_deleted': 0.3,
                'brainstorm_completed': 0.6,
                'preference_pattern': 0.75,
                'session_insight': 0.65
            };
            
            let importance = baseImportance[event] || 0.5;
            
            // Boost for repeated patterns
            if (metadata.occurrences && metadata.occurrences > 1) {
                importance = Math.min(1.0, importance + 0.1 * (metadata.occurrences - 1));
            }
            
            // Boost for high confidence patterns
            if (metadata.confidence && metadata.confidence > 0.7) {
                importance = Math.min(1.0, importance + 0.1);
            }
            
            return importance;
        }
        
        // Find memories relevant to a query using embedding similarity
        async recallMemories(query, limit = 5, minSimilarity = 0.4) {
            if (!this.encoder || this.memories.length === 0) {
                return [];
            }
            
            try {
                // Get embedding for query
                const queryEmbeddings = await this.encoder.embed([query]);
                const queryEmbedding = (await queryEmbeddings.array())[0];
                queryEmbeddings.dispose();
                
                // Score all memories with embeddings
                const scored = this.memories
                    .filter(m => m.embedding)
                    .map(m => ({
                        memory: m,
                        similarity: this.cosineSimilarity(queryEmbedding, m.embedding),
                        // Combine similarity with importance and recency
                        score: this.calculateRecallScore(m, this.cosineSimilarity(queryEmbedding, m.embedding))
                    }))
                    .filter(s => s.similarity >= minSimilarity)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, limit);
                
                return scored.map(s => ({
                    ...s.memory,
                    similarity: s.similarity,
                    score: s.score
                }));
            } catch (error) {
                console.error('Memory recall error:', error);
                return [];
            }
        }
        
        // Calculate recall score combining similarity, importance, and recency
        calculateRecallScore(memory, similarity) {
            const daysSinceCreation = (Date.now() - memory.timestamp) / (1000 * 60 * 60 * 24);
            const recencyBoost = Math.exp(-daysSinceCreation / 30); // Decay over 30 days
            
            // Weighted combination
            return (similarity * 0.5) + (memory.importance * 0.3) + (recencyBoost * 0.2);
        }
        
        // Cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Get recent memories
        getRecentMemories(limit = 10, eventFilter = null) {
            let filtered = this.memories;
            
            if (eventFilter) {
                filtered = filtered.filter(m => m.event === eventFilter);
            }
            
            return filtered
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, limit);
        }
        
        // Get high-importance memories
        getImportantMemories(limit = 10, minImportance = 0.6) {
            return this.memories
                .filter(m => m.importance >= minImportance)
                .sort((a, b) => b.importance - a.importance)
                .slice(0, limit);
        }
        
        // Apply time-based decay to importance
        applyDecay(days = 1) {
            const decayMultiplier = Math.pow(this.decayRate, days);
            
            this.memories.forEach(m => {
                m.importance *= decayMultiplier;
            });
            
            // Remove memories below minimum importance
            const before = this.memories.length;
            this.memories = this.memories.filter(m => m.importance >= this.minImportance);
            
            if (this.memories.length < before) {
                console.log(`🧹 Decayed and pruned ${before - this.memories.length} low-importance memories`);
            }
        }
        
        // Prune memories if over limit
        pruneMemories() {
            if (this.memories.length <= this.maxMemories) return;
            
            // Sort by importance * recency score
            this.memories.sort((a, b) => {
                const scoreA = a.importance * Math.exp(-(Date.now() - a.timestamp) / (1000 * 60 * 60 * 24 * 30));
                const scoreB = b.importance * Math.exp(-(Date.now() - b.timestamp) / (1000 * 60 * 60 * 24 * 30));
                return scoreB - scoreA;
            });
            
            // Keep top memories
            const removed = this.memories.length - this.maxMemories;
            this.memories = this.memories.slice(0, this.maxMemories);
            console.log(`🧹 Pruned ${removed} oldest/least important memories`);
        }
        
        // Boost importance of an existing memory
        boostMemory(memoryId, boostAmount = 0.1) {
            const memory = this.memories.find(m => m.id === memoryId);
            if (memory) {
                memory.importance = Math.min(1.0, memory.importance + boostAmount);
                this.scheduleSave();
            }
        }
        
        // Generate insights string for Claude prompts
        async getPromptMemories(nodeLabel, nodePath, limit = 3) {
            if (this.memories.length === 0) return null;
            
            // Create context query from node info
            const query = `${nodeLabel} ${nodePath.join(' ')}`;
            
            // Recall relevant memories
            const relevant = await this.recallMemories(query, limit, 0.35);
            
            if (relevant.length === 0) return null;
            
            const lines = ['Relevant memories from past interactions:'];
            relevant.forEach(m => {
                lines.push(`- ${m.context} (${this.formatTimeAgo(m.timestamp)})`);
            });
            
            return lines.join('\n');
        }
        
        // Format timestamp as "X ago"
        formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
            return `${Math.floor(seconds / 604800)}w ago`;
        }
        
        // Get stats for UI
        getStats() {
            const importantCount = this.memories.filter(m => m.importance >= 0.6).length;
            const avgImportance = this.memories.length > 0
                ? this.memories.reduce((sum, m) => sum + m.importance, 0) / this.memories.length
                : 0;
            
            const eventCounts = {};
            this.memories.forEach(m => {
                eventCounts[m.event] = (eventCounts[m.event] || 0) + 1;
            });
            
            return {
                totalMemories: this.memories.length,
                importantMemories: importantCount,
                avgImportance,
                eventCounts,
                oldestMemory: this.memories.length > 0 
                    ? Math.min(...this.memories.map(m => m.timestamp))
                    : null
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 3000);
        }
        
        // Reset all memories
        async reset() {
            this.memories = [];
            await NeuralDB.delete('semantic-memories');
            console.log('✓ Semantic memories reset');
        }
    }
    
    // Create global semantic memory instance
    const semanticMemory = new SemanticMemory();
    
    // ═══════════════════════════════════════════════════════════════════
    // USER PROFILE - Evolving preferences and behavior patterns
    // ═══════════════════════════════════════════════════════════════════
    class UserProfile {
        constructor() {
            this.loaded = false;
            
            // Depth preferences
            this.depthStats = {
                totalNodes: 0,
                depthCounts: {}, // depth -> count
                avgDepth: 0,
                maxDepthReached: 0,
                preferredDepth: 2 // Default: moderate depth
            };
            
            // Naming style preferences
            this.namingStats = {
                totalLabels: 0,
                wordCounts: [], // Last 100 label word counts
                charCounts: [], // Last 100 label char counts
                avgWords: 2,
                avgChars: 15,
                actionLabelCount: 0,
                nounLabelCount: 0,
                questionCount: 0,
                style: 'balanced' // 'concise', 'descriptive', 'action-oriented', 'balanced'
            };
            
            // Category preferences (which top-level areas user focuses on)
            this.categoryStats = {
                interactions: {}, // categoryLabel -> { views, edits, expansions, lastActive }
                topCategories: [],
                focusAreas: [], // Categories with most activity
                neglectedAreas: [] // Categories rarely touched
            };
            
            // Time patterns
            this.timeStats = {
                hourlyActivity: new Array(24).fill(0), // Activity by hour (0-23)
                dailyActivity: new Array(7).fill(0), // Activity by day (0=Sun, 6=Sat)
                sessions: [], // Last 50 session summaries
                peakHours: [],
                peakDays: [],
                avgSessionLength: 0, // minutes
                totalSessions: 0
            };
            
            // Current session tracking
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
            
            this.maxHistorySize = 100;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('user-profile');
                if (saved) {
                    if (saved.depthStats) this.depthStats = { ...this.depthStats, ...saved.depthStats };
                    if (saved.namingStats) this.namingStats = { ...this.namingStats, ...saved.namingStats };
                    if (saved.categoryStats) this.categoryStats = { ...this.categoryStats, ...saved.categoryStats };
                    if (saved.timeStats) {
                        this.timeStats = { ...this.timeStats, ...saved.timeStats };
                        // Ensure arrays exist
                        if (!Array.isArray(this.timeStats.hourlyActivity)) {
                            this.timeStats.hourlyActivity = new Array(24).fill(0);
                        }
                        if (!Array.isArray(this.timeStats.dailyActivity)) {
                            this.timeStats.dailyActivity = new Array(7).fill(0);
                        }
                    }
                    console.log(`✓ Loaded user profile (${this.depthStats.totalNodes} nodes tracked)`);
                }
                this.loaded = true;
                
                // Start new session
                this.startSession();
            } catch (error) {
                console.error('Failed to load user profile:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('user-profile', {
                    depthStats: this.depthStats,
                    namingStats: this.namingStats,
                    categoryStats: this.categoryStats,
                    timeStats: this.timeStats,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save user profile:', error);
            }
        }
        
        // Start a new session
        startSession() {
            // End previous session if exists
            if (this.currentSession.nodeCount > 0) {
                this.endSession();
            }
            
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
        }
        
        // End current session and record stats
        endSession() {
            const duration = (Date.now() - this.currentSession.startTime) / 60000; // minutes
            
            if (duration > 1 && this.currentSession.nodeCount > 0) { // Only record meaningful sessions
                const session = {
                    timestamp: this.currentSession.startTime,
                    duration: Math.round(duration),
                    nodeCount: this.currentSession.nodeCount,
                    categories: Array.from(this.currentSession.categories),
                    actionCount: this.currentSession.actions.length
                };
                
                this.timeStats.sessions.push(session);
                if (this.timeStats.sessions.length > 50) {
                    this.timeStats.sessions = this.timeStats.sessions.slice(-50);
                }
                
                this.timeStats.totalSessions++;
                
                // Update average session length
                const recentSessions = this.timeStats.sessions.slice(-20);
                this.timeStats.avgSessionLength = Math.round(
                    recentSessions.reduce((sum, s) => sum + s.duration, 0) / recentSessions.length
                );
                
                this.scheduleSave();
            }
        }
        
        // Track node creation
        trackNodeCreated(node, parent, depth, store) {
            const now = new Date();
            
            // Update time stats
            this.timeStats.hourlyActivity[now.getHours()]++;
            this.timeStats.dailyActivity[now.getDay()]++;
            
            // Update depth stats
            this.depthStats.totalNodes++;
            this.depthStats.depthCounts[depth] = (this.depthStats.depthCounts[depth] || 0) + 1;
            this.depthStats.maxDepthReached = Math.max(this.depthStats.maxDepthReached, depth);
            this.updateDepthPreference();
            
            // Update naming stats
            this.trackLabelStyle(node.label);
            
            // Update category stats (find root category)
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'creation');
                this.currentSession.categories.add(rootCategory);
            }
            
            // Update session
            this.currentSession.nodeCount++;
            this.currentSession.actions.push({ type: 'create', label: node.label, timestamp: Date.now() });
            
            this.updatePeakTimes();
            this.scheduleSave();
        }
        
        // Track node selection/viewing
        trackNodeViewed(node, store) {
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'view');
            }
        }
        
        // Track node expansion (showing children)
        trackNodeExpanded(node, store) {
            const rootCategory = this.findRootCategory(node, store);
            if (rootCategory) {
                this.trackCategoryInteraction(rootCategory, 'expansion');
            }
        }
        
        // Track label style
        trackLabelStyle(label) {
            const words = label.trim().split(/\s+/);
            const wordCount = words.length;
            const charCount = label.length;
            
            // Store in rolling window
            this.namingStats.wordCounts.push(wordCount);
            this.namingStats.charCounts.push(charCount);
            
            if (this.namingStats.wordCounts.length > this.maxHistorySize) {
                this.namingStats.wordCounts = this.namingStats.wordCounts.slice(-this.maxHistorySize);
                this.namingStats.charCounts = this.namingStats.charCounts.slice(-this.maxHistorySize);
            }
            
            // Update averages
            this.namingStats.totalLabels++;
            this.namingStats.avgWords = this.namingStats.wordCounts.reduce((a, b) => a + b, 0) / this.namingStats.wordCounts.length;
            this.namingStats.avgChars = this.namingStats.charCounts.reduce((a, b) => a + b, 0) / this.namingStats.charCounts.length;
            
            // Check for action verbs
            const actionVerbs = ['do', 'make', 'create', 'build', 'start', 'finish', 'complete', 'review', 'plan', 'design', 'implement', 'develop', 'write', 'read', 'learn', 'practice', 'track', 'monitor', 'analyze', 'improve', 'fix', 'update', 'add', 'remove', 'check', 'test'];
            const firstWord = words[0]?.toLowerCase();
            
            if (actionVerbs.includes(firstWord)) {
                this.namingStats.actionLabelCount++;
            } else {
                this.namingStats.nounLabelCount++;
            }
            
            if (label.includes('?')) {
                this.namingStats.questionCount++;
            }
            
            // Determine overall style
            this.updateNamingStyle();
        }
        
        // Update naming style classification
        updateNamingStyle() {
            const { avgWords, actionLabelCount, nounLabelCount, totalLabels } = this.namingStats;
            
            if (totalLabels < 10) {
                this.namingStats.style = 'balanced';
                return;
            }
            
            const actionRatio = actionLabelCount / totalLabels;
            
            if (avgWords <= 1.5) {
                this.namingStats.style = 'concise';
            } else if (avgWords >= 3.5) {
                this.namingStats.style = 'descriptive';
            } else if (actionRatio > 0.4) {
                this.namingStats.style = 'action-oriented';
            } else {
                this.namingStats.style = 'balanced';
            }
        }
        
        // Update depth preference
        updateDepthPreference() {
            const counts = this.depthStats.depthCounts;
            const depths = Object.keys(counts).map(Number);
            
            if (depths.length === 0) return;
            
            // Calculate weighted average depth
            let totalWeight = 0;
            let weightedSum = 0;
            
            depths.forEach(depth => {
                const count = counts[depth];
                weightedSum += depth * count;
                totalWeight += count;
            });
            
            this.depthStats.avgDepth = weightedSum / totalWeight;
            
            // Determine preferred depth
            if (this.depthStats.avgDepth <= 1.5) {
                this.depthStats.preferredDepth = 1; // Shallow
            } else if (this.depthStats.avgDepth <= 2.5) {
                this.depthStats.preferredDepth = 2; // Moderate
            } else if (this.depthStats.avgDepth <= 3.5) {
                this.depthStats.preferredDepth = 3; // Deep
            } else {
                this.depthStats.preferredDepth = 4; // Very deep
            }
        }
        
        // Find root category for a node
        findRootCategory(node, store) {
            if (!store || !node) return null;
            
            const path = store.getPath(node.id);
            if (path.length >= 2) {
                return path[1].label; // First child of root is the "category"
            }
            return node.label; // Node itself is a root category
        }
        
        // Track interaction with a category
        trackCategoryInteraction(categoryLabel, type) {
            if (!this.categoryStats.interactions[categoryLabel]) {
                this.categoryStats.interactions[categoryLabel] = {
                    views: 0,
                    edits: 0,
                    expansions: 0,
                    creations: 0,
                    lastActive: Date.now()
                };
            }
            
            const cat = this.categoryStats.interactions[categoryLabel];
            cat.lastActive = Date.now();
            
            switch (type) {
                case 'view': cat.views++; break;
                case 'edit': cat.edits++; break;
                case 'expansion': cat.expansions++; break;
                case 'creation': cat.creations++; break;
            }
            
            this.updateCategoryRankings();
        }
        
        // Update category rankings
        updateCategoryRankings() {
            const interactions = this.categoryStats.interactions;
            const categories = Object.entries(interactions);
            
            if (categories.length === 0) return;
            
            // Score each category
            const scored = categories.map(([label, stats]) => {
                const recencyBoost = Math.exp(-(Date.now() - stats.lastActive) / (1000 * 60 * 60 * 24 * 7)); // 7-day decay
                const activityScore = stats.creations * 3 + stats.expansions * 2 + stats.edits * 1.5 + stats.views * 0.5;
                return {
                    label,
                    score: activityScore * (0.5 + 0.5 * recencyBoost),
                    stats
                };
            });
            
            // Sort by score
            scored.sort((a, b) => b.score - a.score);
            
            // Top categories
            this.categoryStats.topCategories = scored.slice(0, 5).map(s => s.label);
            
            // Focus areas (high activity)
            const avgScore = scored.reduce((sum, s) => sum + s.score, 0) / scored.length;
            this.categoryStats.focusAreas = scored
                .filter(s => s.score > avgScore * 1.5)
                .slice(0, 3)
                .map(s => s.label);
            
            // Neglected areas (low activity, not recently touched)
            const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
            this.categoryStats.neglectedAreas = scored
                .filter(s => s.stats.lastActive < oneWeekAgo && s.score < avgScore * 0.5)
                .slice(0, 3)
                .map(s => s.label);
        }
        
        // Update peak times
        updatePeakTimes() {
            // Find peak hours
            const hourly = this.timeStats.hourlyActivity;
            const maxHourly = Math.max(...hourly);
            if (maxHourly > 0) {
                this.timeStats.peakHours = hourly
                    .map((count, hour) => ({ hour, count }))
                    .filter(h => h.count >= maxHourly * 0.7)
                    .map(h => h.hour);
            }
            
            // Find peak days
            const daily = this.timeStats.dailyActivity;
            const maxDaily = Math.max(...daily);
            if (maxDaily > 0) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                this.timeStats.peakDays = daily
                    .map((count, day) => ({ day: dayNames[day], count }))
                    .filter(d => d.count >= maxDaily * 0.7)
                    .map(d => d.day);
            }
        }
        
        // Generate insights string for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Depth preference
            if (this.depthStats.totalNodes >= 20) {
                const depthDesc = {
                    1: 'shallow, flat hierarchies',
                    2: 'moderate depth (2-3 levels)',
                    3: 'deep hierarchies (3-4 levels)',
                    4: 'very deep, detailed hierarchies'
                };
                insights.push(`Structure preference: ${depthDesc[this.depthStats.preferredDepth] || 'moderate depth'}`);
            }
            
            // Naming style
            if (this.namingStats.totalLabels >= 15) {
                const styleDesc = {
                    'concise': 'concise, 1-2 word labels',
                    'descriptive': 'descriptive, detailed labels (3+ words)',
                    'action-oriented': 'action-oriented labels (verbs like "Plan X", "Review Y")',
                    'balanced': 'balanced label style'
                };
                insights.push(`Naming style: ${styleDesc[this.namingStats.style]}`);
            }
            
            // Focus areas
            if (this.categoryStats.focusAreas.length > 0) {
                insights.push(`Current focus areas: ${this.categoryStats.focusAreas.join(', ')}`);
            }
            
            // Time context
            const now = new Date();
            const currentHour = now.getHours();
            if (this.timeStats.peakHours.includes(currentHour)) {
                insights.push('User is in their peak productivity time');
            }
            
            // Neglected areas (subtle hint)
            if (this.categoryStats.neglectedAreas.length > 0 && Math.random() < 0.3) {
                insights.push(`Areas that might need attention: ${this.categoryStats.neglectedAreas.join(', ')}`);
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI
        getStats() {
            return {
                totalNodes: this.depthStats.totalNodes,
                avgDepth: this.depthStats.avgDepth,
                preferredDepth: this.depthStats.preferredDepth,
                maxDepth: this.depthStats.maxDepthReached,
                namingStyle: this.namingStats.style,
                avgLabelWords: this.namingStats.avgWords,
                totalLabels: this.namingStats.totalLabels,
                topCategories: this.categoryStats.topCategories,
                focusAreas: this.categoryStats.focusAreas,
                neglectedAreas: this.categoryStats.neglectedAreas,
                peakHours: this.timeStats.peakHours,
                peakDays: this.timeStats.peakDays,
                totalSessions: this.timeStats.totalSessions,
                avgSessionLength: this.timeStats.avgSessionLength,
                currentSessionNodes: this.currentSession.nodeCount
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 5000);
        }
        
        // Reset profile
        async reset() {
            this.depthStats = {
                totalNodes: 0,
                depthCounts: {},
                avgDepth: 0,
                maxDepthReached: 0,
                preferredDepth: 2
            };
            this.namingStats = {
                totalLabels: 0,
                wordCounts: [],
                charCounts: [],
                avgWords: 2,
                avgChars: 15,
                actionLabelCount: 0,
                nounLabelCount: 0,
                questionCount: 0,
                style: 'balanced'
            };
            this.categoryStats = {
                interactions: {},
                topCategories: [],
                focusAreas: [],
                neglectedAreas: []
            };
            this.timeStats = {
                hourlyActivity: new Array(24).fill(0),
                dailyActivity: new Array(7).fill(0),
                sessions: [],
                peakHours: [],
                peakDays: [],
                avgSessionLength: 0,
                totalSessions: 0
            };
            this.currentSession = {
                startTime: Date.now(),
                nodeCount: 0,
                categories: new Set(),
                actions: []
            };
            
            await NeuralDB.delete('user-profile');
            console.log('✓ User profile reset');
        }
    }
    
    // Create global user profile instance
    const userProfile = new UserProfile();
    
    // ═══════════════════════════════════════════════════════════════════
    // RELATIONSHIP TYPE CLASSIFIER - Understanding pattern semantics
    // ═══════════════════════════════════════════════════════════════════
    class RelationshipClassifier {
        constructor() {
            this.cache = new Map(); // Cache classifications
            this.typeEmbeddings = null; // Cached embeddings for relationship type exemplars
            this.encoder = null;
            
            // Relationship type definitions with keywords and exemplars
            this.relationshipTypes = {
                decomposition: {
                    description: 'Breaking down into parts/steps',
                    keywords: ['step', 'phase', 'stage', 'part', 'component', 'milestone', 'task', 'subtask', 'section', 'module', 'chapter', 'segment'],
                    parentPatterns: ['goal', 'project', 'plan', 'process', 'system', 'program', 'recipe', 'guide', 'tutorial'],
                    exemplars: [
                        ['Goals', 'Milestones'],
                        ['Project', 'Tasks'],
                        ['Recipe', 'Steps'],
                        ['Process', 'Phases'],
                        ['Book', 'Chapters']
                    ]
                },
                component: {
                    description: 'Parts that make up a whole',
                    keywords: ['include', 'contain', 'consist', 'feature', 'element', 'aspect', 'ingredient', 'material', 'resource'],
                    parentPatterns: ['system', 'product', 'team', 'body', 'machine', 'kit', 'set', 'collection', 'stack'],
                    exemplars: [
                        ['Health', 'Exercise'],
                        ['Computer', 'CPU'],
                        ['Team', 'Designer'],
                        ['Kitchen', 'Oven'],
                        ['Stack', 'React']
                    ]
                },
                sequence: {
                    description: 'Ordered steps or timeline',
                    keywords: ['first', 'then', 'next', 'after', 'before', 'finally', 'step 1', 'step 2', 'day 1', 'week 1', 'phase 1'],
                    parentPatterns: ['workflow', 'routine', 'schedule', 'timeline', 'agenda', 'itinerary', 'procedure'],
                    exemplars: [
                        ['Morning Routine', 'Wake Up'],
                        ['Workflow', 'Step 1'],
                        ['Onboarding', 'Day 1'],
                        ['Sprint', 'Week 1'],
                        ['Pipeline', 'Stage 1']
                    ]
                },
                category: {
                    description: 'Types or classifications',
                    keywords: ['type', 'kind', 'category', 'class', 'genre', 'variety', 'style', 'format', 'mode'],
                    parentPatterns: ['types', 'kinds', 'categories', 'options', 'varieties', 'styles', 'formats'],
                    exemplars: [
                        ['Music', 'Jazz'],
                        ['Animals', 'Mammals'],
                        ['Vehicles', 'Cars'],
                        ['Content', 'Blog Posts'],
                        ['Exercises', 'Cardio']
                    ]
                },
                example: {
                    description: 'Specific instances or examples',
                    keywords: ['example', 'instance', 'case', 'sample', 'illustration', 'e.g.', 'such as', 'like'],
                    parentPatterns: ['examples', 'ideas', 'suggestions', 'options', 'possibilities', 'concepts'],
                    exemplars: [
                        ['Fruits', 'Apple'],
                        ['Countries', 'Japan'],
                        ['Tools', 'Hammer'],
                        ['Languages', 'Python'],
                        ['Hobbies', 'Photography']
                    ]
                },
                attribute: {
                    description: 'Properties or characteristics',
                    keywords: ['color', 'size', 'weight', 'height', 'price', 'cost', 'duration', 'speed', 'quality', 'status', 'priority', 'level'],
                    parentPatterns: ['details', 'specs', 'properties', 'attributes', 'characteristics', 'settings', 'config', 'metadata'],
                    exemplars: [
                        ['Car', 'Color'],
                        ['Task', 'Priority'],
                        ['Product', 'Price'],
                        ['File', 'Size'],
                        ['User', 'Role']
                    ]
                },
                cause_effect: {
                    description: 'Causal relationships',
                    keywords: ['because', 'therefore', 'result', 'outcome', 'consequence', 'impact', 'effect', 'leads to', 'causes'],
                    parentPatterns: ['problem', 'issue', 'risk', 'threat', 'opportunity', 'action', 'decision'],
                    exemplars: [
                        ['Problem', 'Solution'],
                        ['Risk', 'Mitigation'],
                        ['Action', 'Outcome'],
                        ['Cause', 'Effect'],
                        ['Investment', 'Return']
                    ]
                },
                comparison: {
                    description: 'Alternatives or contrasts',
                    keywords: ['vs', 'versus', 'or', 'alternative', 'option', 'pro', 'con', 'advantage', 'disadvantage', 'compare'],
                    parentPatterns: ['options', 'alternatives', 'choices', 'comparison', 'decision', 'tradeoff'],
                    exemplars: [
                        ['Options', 'Option A'],
                        ['Pros and Cons', 'Pros'],
                        ['React vs Vue', 'React'],
                        ['Buy vs Rent', 'Buy'],
                        ['Tradeoffs', 'Speed']
                    ]
                },
                temporal: {
                    description: 'Time-based organization',
                    keywords: ['today', 'tomorrow', 'monday', 'january', 'q1', 'q2', '2024', '2025', 'morning', 'evening', 'daily', 'weekly', 'monthly'],
                    parentPatterns: ['schedule', 'calendar', 'plan', 'roadmap', 'timeline', 'agenda', 'journal'],
                    exemplars: [
                        ['Schedule', 'Monday'],
                        ['2024', 'Q1'],
                        ['Daily', 'Morning'],
                        ['Week', 'Day 1'],
                        ['Roadmap', 'Phase 1']
                    ]
                },
                action: {
                    description: 'Actions or tasks to perform',
                    keywords: ['do', 'make', 'create', 'build', 'write', 'review', 'check', 'update', 'fix', 'implement', 'design', 'test', 'deploy'],
                    parentPatterns: ['tasks', 'todo', 'actions', 'backlog', 'checklist', 'workflow'],
                    exemplars: [
                        ['Tasks', 'Review Code'],
                        ['Todo', 'Buy Groceries'],
                        ['Sprint', 'Implement Feature'],
                        ['Checklist', 'Verify Setup'],
                        ['Actions', 'Send Email']
                    ]
                }
            };
            
            // Weights for scoring
            this.weights = {
                keywordMatch: 0.4,
                parentPatternMatch: 0.3,
                embeddingSimilarity: 0.3
            };
        }
        
        // Set encoder reference
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Classify relationship type (heuristic-first, embedding fallback)
        async classify(parentLabel, childLabel, useEmbeddings = true) {
            const cacheKey = `${parentLabel.toLowerCase()}→${childLabel.toLowerCase()}`;
            
            // Check cache
            if (this.cache.has(cacheKey)) {
                return this.cache.get(cacheKey);
            }
            
            // Fast path: heuristic classification
            const heuristicResult = this.classifyByHeuristics(parentLabel, childLabel);
            
            if (heuristicResult.confidence >= 0.6) {
                this.cache.set(cacheKey, heuristicResult);
                return heuristicResult;
            }
            
            // Slow path: embedding similarity (only if encoder available and enabled)
            if (useEmbeddings && this.encoder) {
                const embeddingResult = await this.classifyByEmbeddings(parentLabel, childLabel);
                
                // Combine heuristic and embedding scores
                const combined = this.combineResults(heuristicResult, embeddingResult);
                this.cache.set(cacheKey, combined);
                return combined;
            }
            
            // Fall back to heuristic result
            this.cache.set(cacheKey, heuristicResult);
            return heuristicResult;
        }
        
        // Fast heuristic classification
        classifyByHeuristics(parentLabel, childLabel) {
            const parentLower = parentLabel.toLowerCase();
            const childLower = childLabel.toLowerCase();
            const scores = {};
            
            for (const [type, config] of Object.entries(this.relationshipTypes)) {
                let score = 0;
                
                // Check child label for keywords
                const keywordMatches = config.keywords.filter(kw => childLower.includes(kw)).length;
                if (keywordMatches > 0) {
                    score += this.weights.keywordMatch * Math.min(keywordMatches / 2, 1);
                }
                
                // Check parent label for patterns
                const parentMatches = config.parentPatterns.filter(p => parentLower.includes(p)).length;
                if (parentMatches > 0) {
                    score += this.weights.parentPatternMatch * Math.min(parentMatches, 1);
                }
                
                // Check for numbered sequences
                if (type === 'sequence' || type === 'temporal') {
                    if (/\b(step|phase|day|week|stage)\s*\d/i.test(childLabel) ||
                        /^\d+[\.\)]\s/.test(childLabel)) {
                        score += 0.3;
                    }
                }
                
                // Check for action verbs at start
                if (type === 'action') {
                    const actionStarters = ['do', 'make', 'create', 'build', 'write', 'review', 'check', 'update', 'fix', 'implement', 'design', 'test', 'deploy', 'add', 'remove', 'send', 'get', 'set', 'run'];
                    const firstWord = childLower.split(/\s+/)[0];
                    if (actionStarters.includes(firstWord)) {
                        score += 0.4;
                    }
                }
                
                scores[type] = score;
            }
            
            // Find best match
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const [bestType, bestScore] = sorted[0];
            const [secondType, secondScore] = sorted[1] || [null, 0];
            
            // Confidence based on margin between top two
            const margin = bestScore - secondScore;
            const confidence = Math.min(bestScore + margin * 0.5, 1);
            
            return {
                type: bestScore > 0.1 ? bestType : 'unknown',
                confidence: bestScore > 0.1 ? confidence : 0.1,
                scores,
                method: 'heuristic'
            };
        }
        
        // Embedding-based classification
        async classifyByEmbeddings(parentLabel, childLabel) {
            try {
                // Build type embeddings if not cached
                if (!this.typeEmbeddings) {
                    await this.buildTypeEmbeddings();
                }
                
                // Get embedding for this parent-child pair
                const pairText = `${parentLabel} contains ${childLabel}`;
                const pairEmbedding = await this.getEmbedding(pairText);
                
                if (!pairEmbedding) {
                    return { type: 'unknown', confidence: 0, method: 'embedding_failed' };
                }
                
                // Compare to each type's exemplar embeddings
                const scores = {};
                
                for (const [type, embeddings] of Object.entries(this.typeEmbeddings)) {
                    // Average similarity to all exemplars of this type
                    let totalSim = 0;
                    for (const exemplarEmb of embeddings) {
                        totalSim += this.cosineSimilarity(pairEmbedding, exemplarEmb);
                    }
                    scores[type] = totalSim / embeddings.length;
                }
                
                // Find best match
                const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
                const [bestType, bestScore] = sorted[0];
                
                return {
                    type: bestType,
                    confidence: Math.max(0, Math.min(bestScore, 1)),
                    scores,
                    method: 'embedding'
                };
            } catch (error) {
                console.error('Embedding classification error:', error);
                return { type: 'unknown', confidence: 0, method: 'embedding_error' };
            }
        }
        
        // Build embeddings for exemplar pairs
        async buildTypeEmbeddings() {
            if (!this.encoder) return;
            
            console.log('🧠 Building relationship type embeddings...');
            this.typeEmbeddings = {};
            
            for (const [type, config] of Object.entries(this.relationshipTypes)) {
                const texts = config.exemplars.map(([parent, child]) => 
                    `${parent} contains ${child}`
                );
                
                try {
                    const embeddings = await this.encoder.embed(texts);
                    const embeddingArray = await embeddings.array();
                    this.typeEmbeddings[type] = embeddingArray;
                    embeddings.dispose();
                } catch (error) {
                    console.error(`Failed to embed ${type} exemplars:`, error);
                    this.typeEmbeddings[type] = [];
                }
            }
            
            console.log('✓ Relationship type embeddings ready');
        }
        
        // Get embedding for a single text
        async getEmbedding(text) {
            if (!this.encoder) return null;
            
            try {
                const embeddings = await this.encoder.embed([text]);
                const embeddingArray = await embeddings.array();
                embeddings.dispose();
                return embeddingArray[0];
            } catch (error) {
                console.error('Embedding error:', error);
                return null;
            }
        }
        
        // Cosine similarity
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Combine heuristic and embedding results
        combineResults(heuristic, embedding) {
            if (embedding.type === 'unknown' || embedding.confidence < 0.3) {
                return heuristic;
            }
            
            // Weight the combination by confidence
            const hWeight = 0.6;
            const eWeight = 0.4;
            
            // If they agree, boost confidence
            if (heuristic.type === embedding.type) {
                return {
                    type: heuristic.type,
                    confidence: Math.min(1, heuristic.confidence * hWeight + embedding.confidence * eWeight + 0.15),
                    method: 'combined_agree'
                };
            }
            
            // If they disagree, use higher confidence
            if (embedding.confidence > heuristic.confidence + 0.2) {
                return {
                    type: embedding.type,
                    confidence: embedding.confidence * 0.8,
                    method: 'combined_embedding_wins'
                };
            }
            
            return {
                type: heuristic.type,
                confidence: heuristic.confidence * 0.9,
                method: 'combined_heuristic_wins'
            };
        }
        
        // Find patterns with same relationship type (for transfer learning)
        async findAnalogousPatterns(parentLabel, childLabel, patternWeights, limit = 5) {
            // Classify this relationship
            const classification = await this.classify(parentLabel, childLabel, false); // Heuristics only for speed
            
            if (classification.type === 'unknown' || classification.confidence < 0.4) {
                return [];
            }
            
            const analogous = [];
            
            // Scan cached classifications for same type
            for (const [key, cachedResult] of this.cache.entries()) {
                if (cachedResult.type === classification.type && 
                    cachedResult.confidence >= 0.5 &&
                    key !== `${parentLabel.toLowerCase()}→${childLabel.toLowerCase()}`) {
                    
                    const [cachedParent, cachedChild] = key.split('→');
                    const patternKey = `${cachedParent}→${cachedChild}`;
                    const weight = patternWeights.get(patternKey);
                    
                    if (weight && weight.weight >= 0.4) {
                        analogous.push({
                            parentLabel: cachedParent,
                            childLabel: cachedChild,
                            relationshipType: cachedResult.type,
                            confidence: cachedResult.confidence,
                            weight: weight.weight
                        });
                    }
                }
            }
            
            // Sort by weight * confidence
            analogous.sort((a, b) => (b.weight * b.confidence) - (a.weight * a.confidence));
            
            return analogous.slice(0, limit);
        }
        
        // Get relationship type description for Claude prompts
        getTypeDescription(type) {
            return this.relationshipTypes[type]?.description || 'General relationship';
        }
        
        // Get stats
        getStats() {
            const typeCounts = {};
            for (const [, result] of this.cache) {
                typeCounts[result.type] = (typeCounts[result.type] || 0) + 1;
            }
            
            return {
                cachedClassifications: this.cache.size,
                typeDistribution: typeCounts,
                hasEmbeddings: !!this.typeEmbeddings
            };
        }
        
        // Clear cache
        clearCache() {
            this.cache.clear();
        }
    }
    
    // Create global classifier instance
    const relationshipClassifier = new RelationshipClassifier();
    
    // ═══════════════════════════════════════════════════════════════════
    // CONCEPT ABSTRACTOR - Learning structural schemas across domains
    // ═══════════════════════════════════════════════════════════════════
    class ConceptAbstractor {
        constructor() {
            this.encoder = null;
            this.loaded = false;
            
            // Structural schemas: abstract templates for hierarchies
            // Schema format: { role -> [typical children roles] }
            this.schemas = new Map();
            
            // Concept clusters: groups of semantically similar labels
            // Maps normalized label -> cluster ID
            this.conceptClusters = new Map();
            
            // Cluster definitions: cluster ID -> { labels, centroid, abstractRole }
            this.clusters = new Map();
            
            // Hierarchy patterns: multi-level structural patterns
            // Maps "role1→role2→role3" -> { examples, confidence }
            this.hierarchyPatterns = new Map();
            
            // Abstract roles (learned categories of concepts)
            this.abstractRoles = {
                plannable: {
                    description: 'Things that can be planned/organized',
                    seeds: ['goal', 'project', 'plan', 'initiative', 'campaign', 'program', 'strategy', 'mission'],
                    typicalChildren: ['milestone', 'phase', 'task', 'step', 'objective', 'target']
                },
                container: {
                    description: 'Things that contain components',
                    seeds: ['system', 'product', 'machine', 'device', 'platform', 'application', 'service', 'kit'],
                    typicalChildren: ['component', 'module', 'part', 'feature', 'element', 'unit']
                },
                process: {
                    description: 'Sequential procedures',
                    seeds: ['workflow', 'process', 'procedure', 'routine', 'pipeline', 'flow', 'cycle'],
                    typicalChildren: ['step', 'stage', 'phase', 'action', 'task']
                },
                category_parent: {
                    description: 'Classification containers',
                    seeds: ['types', 'categories', 'kinds', 'classes', 'genres', 'varieties', 'options'],
                    typicalChildren: ['type', 'category', 'option', 'variant', 'style']
                },
                collection: {
                    description: 'Groups of similar items',
                    seeds: ['list', 'collection', 'set', 'group', 'library', 'inventory', 'portfolio'],
                    typicalChildren: ['item', 'entry', 'element', 'piece', 'asset']
                },
                domain: {
                    description: 'Knowledge/life areas',
                    seeds: ['health', 'finance', 'career', 'education', 'relationships', 'personal', 'work', 'life'],
                    typicalChildren: ['aspect', 'area', 'goal', 'habit', 'practice', 'skill']
                },
                entity: {
                    description: 'Things with attributes',
                    seeds: ['person', 'company', 'product', 'project', 'event', 'place', 'organization'],
                    typicalChildren: ['name', 'description', 'status', 'date', 'owner', 'priority']
                },
                temporal: {
                    description: 'Time-based containers',
                    seeds: ['year', 'quarter', 'month', 'week', 'day', 'schedule', 'calendar', 'timeline'],
                    typicalChildren: ['event', 'task', 'meeting', 'deadline', 'milestone']
                }
            };
            
            // Similarity threshold for clustering
            this.clusterThreshold = 0.65;
            
            // Cache for role assignments
            this.roleCache = new Map();
            
            // Stats
            this.stats = {
                clustersFormed: 0,
                schemasLearned: 0,
                transfersApplied: 0
            };
        }
        
        // Set encoder reference
        setEncoder(encoder) {
            this.encoder = encoder;
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('concept-abstractions');
                if (saved) {
                    if (saved.schemas) {
                        this.schemas = new Map(saved.schemas);
                    }
                    if (saved.conceptClusters) {
                        this.conceptClusters = new Map(saved.conceptClusters);
                    }
                    if (saved.clusters) {
                        this.clusters = new Map(saved.clusters);
                    }
                    if (saved.hierarchyPatterns) {
                        this.hierarchyPatterns = new Map(saved.hierarchyPatterns);
                    }
                    if (saved.stats) {
                        this.stats = saved.stats;
                    }
                    console.log(`✓ Loaded concept abstractions (${this.schemas.size} schemas, ${this.clusters.size} clusters)`);
                }
                this.loaded = true;
            } catch (error) {
                console.error('Failed to load concept abstractions:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('concept-abstractions', {
                    schemas: Array.from(this.schemas.entries()),
                    conceptClusters: Array.from(this.conceptClusters.entries()),
                    clusters: Array.from(this.clusters.entries()),
                    hierarchyPatterns: Array.from(this.hierarchyPatterns.entries()),
                    stats: this.stats,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save concept abstractions:', error);
            }
        }
        
        // Identify the abstract role of a label (using seeds + embeddings)
        async identifyRole(label, useEmbeddings = true) {
            const normalized = label.toLowerCase().trim();
            
            // Check cache
            if (this.roleCache.has(normalized)) {
                return this.roleCache.get(normalized);
            }
            
            // Fast path: check seed words
            for (const [role, config] of Object.entries(this.abstractRoles)) {
                for (const seed of config.seeds) {
                    if (normalized.includes(seed) || seed.includes(normalized)) {
                        const result = { role, confidence: 0.8, method: 'seed' };
                        this.roleCache.set(normalized, result);
                        return result;
                    }
                }
            }
            
            // Check if it matches typical children
            for (const [role, config] of Object.entries(this.abstractRoles)) {
                for (const child of config.typicalChildren) {
                    if (normalized.includes(child) || child.includes(normalized)) {
                        const result = { role: `${role}_child`, confidence: 0.7, method: 'typical_child' };
                        this.roleCache.set(normalized, result);
                        return result;
                    }
                }
            }
            
            // Slow path: embedding similarity (if available)
            if (useEmbeddings && this.encoder) {
                const roleScores = await this.scoreRolesByEmbedding(label);
                if (roleScores && roleScores.bestScore > 0.5) {
                    const result = { role: roleScores.bestRole, confidence: roleScores.bestScore, method: 'embedding' };
                    this.roleCache.set(normalized, result);
                    return result;
                }
            }
            
            // Check existing clusters
            const clusterId = this.conceptClusters.get(normalized);
            if (clusterId) {
                const cluster = this.clusters.get(clusterId);
                if (cluster && cluster.abstractRole) {
                    const result = { role: cluster.abstractRole, confidence: 0.6, method: 'cluster' };
                    this.roleCache.set(normalized, result);
                    return result;
                }
            }
            
            return { role: 'unknown', confidence: 0, method: 'none' };
        }
        
        // Score roles by embedding similarity
        async scoreRolesByEmbedding(label) {
            if (!this.encoder) return null;
            
            try {
                // Get embedding for the label
                const labelEmbedding = await this.getEmbedding(label);
                if (!labelEmbedding) return null;
                
                const scores = {};
                let bestRole = 'unknown';
                let bestScore = 0;
                
                // Compare to seed words of each role
                for (const [role, config] of Object.entries(this.abstractRoles)) {
                    const seedText = config.seeds.slice(0, 4).join(' ');
                    const seedEmbedding = await this.getEmbedding(seedText);
                    
                    if (seedEmbedding) {
                        const similarity = this.cosineSimilarity(labelEmbedding, seedEmbedding);
                        scores[role] = similarity;
                        
                        if (similarity > bestScore) {
                            bestScore = similarity;
                            bestRole = role;
                        }
                    }
                }
                
                return { scores, bestRole, bestScore };
            } catch (error) {
                console.error('Role scoring error:', error);
                return null;
            }
        }
        
        // Learn a structural pattern from parent-child relationship
        async learnPattern(parentLabel, childLabel, depth, relationshipType) {
            const parentRole = await this.identifyRole(parentLabel, false); // Heuristics only for speed
            const childRole = await this.identifyRole(childLabel, false);
            
            // Create or update schema
            if (parentRole.role !== 'unknown' && parentRole.confidence >= 0.5) {
                const schemaKey = parentRole.role;
                
                if (!this.schemas.has(schemaKey)) {
                    this.schemas.set(schemaKey, {
                        childRoles: new Map(),
                        examples: [],
                        relationshipTypes: {}
                    });
                    this.stats.schemasLearned++;
                }
                
                const schema = this.schemas.get(schemaKey);
                
                // Track child role frequency
                const childRoleKey = childRole.role !== 'unknown' ? childRole.role : 'generic';
                const currentCount = schema.childRoles.get(childRoleKey) || 0;
                schema.childRoles.set(childRoleKey, currentCount + 1);
                
                // Track relationship type
                if (relationshipType) {
                    schema.relationshipTypes[relationshipType] = (schema.relationshipTypes[relationshipType] || 0) + 1;
                }
                
                // Store example (limited)
                if (schema.examples.length < 20) {
                    schema.examples.push({
                        parent: parentLabel,
                        child: childLabel,
                        depth,
                        timestamp: Date.now()
                    });
                }
            }
            
            // Learn hierarchy pattern if we have depth info
            if (depth >= 2) {
                await this.learnHierarchyPattern(parentLabel, childLabel, depth);
            }
            
            this.scheduleSave();
        }
        
        // Learn multi-level hierarchy patterns
        async learnHierarchyPattern(parentLabel, childLabel, depth) {
            const parentRole = await this.identifyRole(parentLabel, false);
            const childRole = await this.identifyRole(childLabel, false);
            
            if (parentRole.role === 'unknown' || childRole.role === 'unknown') return;
            
            // Create hierarchy key based on roles
            const hierarchyKey = `${parentRole.role}→${childRole.role}`;
            
            if (!this.hierarchyPatterns.has(hierarchyKey)) {
                this.hierarchyPatterns.set(hierarchyKey, {
                    examples: [],
                    occurrences: 0,
                    avgDepth: depth,
                    confidence: 0.3
                });
            }
            
            const pattern = this.hierarchyPatterns.get(hierarchyKey);
            pattern.occurrences++;
            pattern.avgDepth = (pattern.avgDepth * (pattern.occurrences - 1) + depth) / pattern.occurrences;
            pattern.confidence = Math.min(1.0, 0.3 + pattern.occurrences * 0.1);
            
            if (pattern.examples.length < 10) {
                pattern.examples.push({ parent: parentLabel, child: childLabel });
            }
        }
        
        // Cluster similar concepts together
        async clusterConcept(label, embedding = null) {
            const normalized = label.toLowerCase().trim();
            
            // Skip if already clustered
            if (this.conceptClusters.has(normalized)) {
                return this.conceptClusters.get(normalized);
            }
            
            // Get embedding if not provided
            if (!embedding && this.encoder) {
                embedding = await this.getEmbedding(label);
            }
            
            if (!embedding) return null;
            
            // Find most similar existing cluster
            let bestCluster = null;
            let bestSimilarity = 0;
            
            for (const [clusterId, cluster] of this.clusters) {
                if (cluster.centroid) {
                    const similarity = this.cosineSimilarity(embedding, cluster.centroid);
                    if (similarity > bestSimilarity && similarity >= this.clusterThreshold) {
                        bestSimilarity = similarity;
                        bestCluster = clusterId;
                    }
                }
            }
            
            if (bestCluster) {
                // Add to existing cluster
                const cluster = this.clusters.get(bestCluster);
                cluster.labels.push(normalized);
                
                // Update centroid (running average)
                if (cluster.centroid) {
                    for (let i = 0; i < cluster.centroid.length; i++) {
                        cluster.centroid[i] = (cluster.centroid[i] * (cluster.labels.length - 1) + embedding[i]) / cluster.labels.length;
                    }
                }
                
                this.conceptClusters.set(normalized, bestCluster);
                return bestCluster;
            }
            
            // Create new cluster
            const newClusterId = `cluster_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            const role = await this.identifyRole(label, false);
            
            this.clusters.set(newClusterId, {
                labels: [normalized],
                centroid: embedding,
                abstractRole: role.role !== 'unknown' ? role.role : null,
                createdAt: Date.now()
            });
            
            this.conceptClusters.set(normalized, newClusterId);
            this.stats.clustersFormed++;
            
            return newClusterId;
        }
        
        // Find structurally similar patterns for a new parent
        async findStructuralAnalogs(parentLabel, existingChildren = [], limit = 5) {
            const parentRole = await this.identifyRole(parentLabel, true);
            
            if (parentRole.role === 'unknown' || parentRole.confidence < 0.4) {
                return [];
            }
            
            const analogs = [];
            const existingNormalized = existingChildren.map(c => c.toLowerCase());
            
            // Get schema for this role
            const schema = this.schemas.get(parentRole.role);
            
            if (schema && schema.examples.length > 0) {
                // Find children from examples that might transfer
                const seenChildren = new Set();
                
                for (const example of schema.examples) {
                    const childNormalized = example.child.toLowerCase();
                    
                    // Skip if already exists or already seen
                    if (existingNormalized.includes(childNormalized) || seenChildren.has(childNormalized)) {
                        continue;
                    }
                    
                    seenChildren.add(childNormalized);
                    
                    // Calculate transfer score
                    const childRole = await this.identifyRole(example.child, false);
                    const roleMatch = childRole.role !== 'unknown' ? 0.3 : 0;
                    
                    analogs.push({
                        label: example.child,
                        fromParent: example.parent,
                        schemaRole: parentRole.role,
                        childRole: childRole.role,
                        confidence: (parentRole.confidence * 0.5 + roleMatch + 0.2),
                        source: 'schema'
                    });
                }
            }
            
            // Also check hierarchy patterns
            for (const [key, pattern] of this.hierarchyPatterns) {
                if (key.startsWith(parentRole.role + '→') && pattern.confidence >= 0.4) {
                    for (const example of pattern.examples) {
                        const childNormalized = example.child.toLowerCase();
                        
                        if (!existingNormalized.includes(childNormalized) && 
                            !analogs.some(a => a.label.toLowerCase() === childNormalized)) {
                            analogs.push({
                                label: example.child,
                                fromParent: example.parent,
                                schemaRole: parentRole.role,
                                confidence: pattern.confidence * 0.8,
                                source: 'hierarchy'
                            });
                        }
                    }
                }
            }
            
            // Sort by confidence and limit
            analogs.sort((a, b) => b.confidence - a.confidence);
            
            this.stats.transfersApplied += Math.min(analogs.length, limit);
            
            return analogs.slice(0, limit);
        }
        
        // Get suggestions based on abstract role
        async getSuggestionsByRole(parentLabel, existingChildren = [], limit = 3) {
            const parentRole = await this.identifyRole(parentLabel, false);
            
            if (parentRole.role === 'unknown') {
                return [];
            }
            
            const roleConfig = this.abstractRoles[parentRole.role];
            if (!roleConfig) return [];
            
            const existingNormalized = existingChildren.map(c => c.toLowerCase());
            const suggestions = [];
            
            // Suggest typical children for this role
            for (const typicalChild of roleConfig.typicalChildren) {
                if (!existingNormalized.some(e => e.includes(typicalChild))) {
                    suggestions.push({
                        label: typicalChild.charAt(0).toUpperCase() + typicalChild.slice(1),
                        confidence: parentRole.confidence * 0.6,
                        source: 'role_typical',
                        role: parentRole.role
                    });
                }
                
                if (suggestions.length >= limit) break;
            }
            
            return suggestions;
        }
        
        // Generate insights for Claude prompts
        async getPromptInsights(parentLabel, path = []) {
            const insights = [];
            
            // Identify parent role
            const parentRole = await this.identifyRole(parentLabel, false);
            
            if (parentRole.role !== 'unknown' && parentRole.confidence >= 0.5) {
                const roleConfig = this.abstractRoles[parentRole.role];
                if (roleConfig) {
                    insights.push(`Structural role: "${parentLabel}" is a ${roleConfig.description.toLowerCase()}`);
                    
                    // Get schema info
                    const schema = this.schemas.get(parentRole.role);
                    if (schema && schema.examples.length >= 3) {
                        const exampleParents = [...new Set(schema.examples.map(e => e.parent))].slice(0, 3);
                        insights.push(`Similar structures: ${exampleParents.join(', ')}`);
                    }
                }
            }
            
            // Check for hierarchy patterns along the path
            if (path.length >= 2) {
                const pathRoles = [];
                for (const node of path.slice(-3)) { // Last 3 nodes
                    const role = await this.identifyRole(node, false);
                    if (role.role !== 'unknown') {
                        pathRoles.push(role.role);
                    }
                }
                
                if (pathRoles.length >= 2) {
                    const patternKey = pathRoles.slice(-2).join('→');
                    const pattern = this.hierarchyPatterns.get(patternKey);
                    if (pattern && pattern.confidence >= 0.5) {
                        insights.push(`Hierarchy pattern detected: ${patternKey} (seen ${pattern.occurrences}x)`);
                    }
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get embedding (helper)
        async getEmbedding(text) {
            if (!this.encoder) return null;
            
            try {
                const embeddings = await this.encoder.embed([text]);
                const embeddingArray = await embeddings.array();
                embeddings.dispose();
                return embeddingArray[0];
            } catch (error) {
                return null;
            }
        }
        
        // Cosine similarity (helper)
        cosineSimilarity(a, b) {
            if (!a || !b || a.length !== b.length) return 0;
            
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }
        
        // Get stats for UI
        getStats() {
            return {
                schemas: this.schemas.size,
                clusters: this.clusters.size,
                hierarchyPatterns: this.hierarchyPatterns.size,
                ...this.stats
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 5000);
        }
        
        // Reset
        async reset() {
            this.schemas.clear();
            this.conceptClusters.clear();
            this.clusters.clear();
            this.hierarchyPatterns.clear();
            this.roleCache.clear();
            this.stats = { clustersFormed: 0, schemasLearned: 0, transfersApplied: 0 };
            await NeuralDB.delete('concept-abstractions');
            console.log('✓ Concept abstractions reset');
        }
    }
    
    // Create global concept abstractor instance
    const conceptAbstractor = new ConceptAbstractor();
    
    // ═══════════════════════════════════════════════════════════════════
    // META-LEARNER - Understanding HOW the user thinks
    // ═══════════════════════════════════════════════════════════════════
    class MetaLearner {
        constructor() {
            this.loaded = false;
            
            // Building style: breadth-first vs depth-first
            this.buildingStyle = {
                // Track sequences of node creation depths
                depthSequences: [], // Last 100: [2, 2, 3, 3, 4, 2, 2, 3...] 
                breadthFirstScore: 0.5, // 0 = pure depth-first, 1 = pure breadth-first
                consecutiveSameDepth: 0,
                consecutiveDeeper: 0,
                lastDepth: 0,
                
                // Pattern: does user complete a level before going deeper?
                levelCompletionRate: 0.5
            };
            
            // Exploration patterns: how user navigates
            this.explorationStyle = {
                // Selection sequence: do they jump around or stay local?
                selectionJumps: [], // Distance between consecutive selections
                localityScore: 0.5, // 0 = random jumping, 1 = very local/sequential
                
                // Expansion patterns
                expandBeforeCreate: 0, // Times user expanded existing before creating new
                createBeforeExpand: 0, // Times user created new without expanding first
                
                // Return visits: do they revisit branches?
                branchRevisits: new Map(), // branchId -> visit count
                revisitRate: 0
            };
            
            // Refinement behavior
            this.refinementStyle = {
                editCount: 0,
                createCount: 0,
                editVsCreateRatio: 0.5, // Higher = more editing/refining
                
                // Edit timing: do they edit immediately or come back later?
                immediateEdits: 0, // Edit within 30 seconds of creation
                delayedEdits: 0, // Edit after 30+ seconds
                
                // Description usage
                nodesWithDescription: 0,
                totalNodes: 0,
                descriptionRate: 0
            };
            
            // Decision patterns
            this.decisionStyle = {
                // Suggestion acceptance speed
                acceptanceTimes: [], // Time from suggestion shown to accepted (last 50)
                avgAcceptanceTime: 0,
                quickDecider: false, // < 3 seconds average
                
                // Acceptance selectivity
                suggestionsShown: 0,
                suggestionsAccepted: 0,
                selectivityRate: 0.5, // Lower = accepts more, higher = very selective
                
                // Add All vs individual picks
                addAllCount: 0,
                individualPickCount: 0,
                batchPreference: 0.5 // Higher = prefers Add All
            };
            
            // Session rhythm
            this.sessionRhythm = {
                // Activity bursts vs steady work
                actionTimestamps: [], // Last 200 action timestamps
                burstScore: 0.5, // 0 = very steady, 1 = very bursty
                avgTimeBetweenActions: 0,
                
                // Session patterns
                sessionsAnalyzed: 0,
                avgActionsPerSession: 0,
                avgSessionDuration: 0,
                
                // Momentum: does productivity increase or decrease over session?
                momentumPattern: 'steady' // 'accelerating', 'decelerating', 'steady', 'burst-rest'
            };
            
            // Branch commitment
            this.branchCommitment = {
                // Track depth reached per branch before moving on
                branchDepths: new Map(), // rootChildId -> maxDepth reached
                avgBranchDepth: 0,
                
                // Abandonment patterns
                abandonedBranches: [], // Branches not touched in 7+ days
                abandonmentRate: 0,
                
                // Focus: do they focus on one branch or spread attention?
                focusScore: 0.5, // 0 = very spread out, 1 = deep focus on few branches
                activeBranches: 0,
                
                // Branch switching frequency
                switchesPerSession: 0,
                avgTimeOnBranch: 0
            };
            
            // Cognitive load indicators
            this.cognitivePatterns = {
                // Complexity preference
                avgChildrenPerNode: 0,
                prefersFlatStructure: false, // Many children, shallow depth
                prefersDeepStructure: false, // Few children, deep depth
                
                // Naming complexity
                avgLabelComplexity: 0, // Based on word count, specificity
                
                // Pause patterns (thinking time)
                longPauses: 0, // Pauses > 30 seconds
                shortPauses: 0, // Pauses < 10 seconds
                thinkingRatio: 0.5
            };
            
            // Current tracking state
            this.currentState = {
                sessionStart: Date.now(),
                lastAction: Date.now(),
                lastNodeCreated: null,
                lastNodeSelected: null,
                lastDepth: 0,
                currentBranch: null,
                actionsThisSession: 0,
                suggestionsCurrentlyShown: null,
                suggestionShowTime: null
            };
            
            // Historical insights
            this.insights = {
                lastUpdated: null,
                summary: '',
                strengths: [],
                suggestions: []
            };
        }
        
        // Initialize - load from storage
        async init() {
            if (this.loaded) return;
            
            try {
                const saved = await NeuralDB.load('meta-learner');
                if (saved) {
                    if (saved.buildingStyle) this.buildingStyle = { ...this.buildingStyle, ...saved.buildingStyle };
                    if (saved.explorationStyle) this.explorationStyle = { ...this.explorationStyle, ...saved.explorationStyle };
                    if (saved.refinementStyle) this.refinementStyle = { ...this.refinementStyle, ...saved.refinementStyle };
                    if (saved.decisionStyle) this.decisionStyle = { ...this.decisionStyle, ...saved.decisionStyle };
                    if (saved.sessionRhythm) this.sessionRhythm = { ...this.sessionRhythm, ...saved.sessionRhythm };
                    if (saved.branchCommitment) {
                        this.branchCommitment = { ...this.branchCommitment, ...saved.branchCommitment };
                        if (saved.branchCommitment.branchDepths) {
                            this.branchCommitment.branchDepths = new Map(saved.branchCommitment.branchDepths);
                        }
                    }
                    if (saved.explorationStyle) {
                        this.explorationStyle = { ...this.explorationStyle, ...saved.explorationStyle };
                        if (saved.explorationStyle.branchRevisits) {
                            this.explorationStyle.branchRevisits = new Map(saved.explorationStyle.branchRevisits);
                        }
                    }
                    if (saved.cognitivePatterns) this.cognitivePatterns = { ...this.cognitivePatterns, ...saved.cognitivePatterns };
                    if (saved.insights) this.insights = saved.insights;
                    
                    console.log(`✓ Loaded meta-learner (${this.sessionRhythm.sessionsAnalyzed} sessions analyzed)`);
                }
                this.loaded = true;
                
                // Start new session tracking
                this.startSession();
            } catch (error) {
                console.error('Failed to load meta-learner:', error);
                this.loaded = true;
            }
        }
        
        // Save to storage
        async save() {
            try {
                await NeuralDB.save('meta-learner', {
                    buildingStyle: this.buildingStyle,
                    explorationStyle: {
                        ...this.explorationStyle,
                        branchRevisits: Array.from(this.explorationStyle.branchRevisits.entries())
                    },
                    refinementStyle: this.refinementStyle,
                    decisionStyle: this.decisionStyle,
                    sessionRhythm: this.sessionRhythm,
                    branchCommitment: {
                        ...this.branchCommitment,
                        branchDepths: Array.from(this.branchCommitment.branchDepths.entries())
                    },
                    cognitivePatterns: this.cognitivePatterns,
                    insights: this.insights,
                    savedAt: Date.now()
                });
            } catch (error) {
                console.error('Failed to save meta-learner:', error);
            }
        }
        
        // Start a new session
        startSession() {
            this.currentState = {
                sessionStart: Date.now(),
                lastAction: Date.now(),
                lastNodeCreated: null,
                lastNodeSelected: null,
                lastDepth: 0,
                currentBranch: null,
                actionsThisSession: 0,
                suggestionsCurrentlyShown: null,
                suggestionShowTime: null
            };
        }
        
        // End session and analyze
        endSession() {
            const duration = (Date.now() - this.currentState.sessionStart) / 60000; // minutes
            
            if (duration >= 1 && this.currentState.actionsThisSession >= 3) {
                this.sessionRhythm.sessionsAnalyzed++;
                
                // Update averages
                const n = this.sessionRhythm.sessionsAnalyzed;
                this.sessionRhythm.avgActionsPerSession = 
                    ((n - 1) * this.sessionRhythm.avgActionsPerSession + this.currentState.actionsThisSession) / n;
                this.sessionRhythm.avgSessionDuration = 
                    ((n - 1) * this.sessionRhythm.avgSessionDuration + duration) / n;
                
                // Analyze rhythm patterns
                this.analyzeSessionRhythm();
                
                // Update insights
                this.updateInsights();
                
                this.scheduleSave();
            }
        }
        
        // Track node creation
        trackNodeCreated(node, parent, depth, store) {
            const now = Date.now();
            const timeSinceLastAction = now - this.currentState.lastAction;
            
            // Update action timestamps
            this.sessionRhythm.actionTimestamps.push(now);
            if (this.sessionRhythm.actionTimestamps.length > 200) {
                this.sessionRhythm.actionTimestamps = this.sessionRhythm.actionTimestamps.slice(-200);
            }
            
            // Track building style
            this.trackBuildingStyle(depth);
            
            // Track refinement (creation vs editing)
            this.refinementStyle.createCount++;
            this.refinementStyle.totalNodes++;
            this.refinementStyle.editVsCreateRatio = 
                this.refinementStyle.editCount / (this.refinementStyle.editCount + this.refinementStyle.createCount);
            
            // Track branch commitment
            const rootBranch = this.getRootBranch(node.id, store);
            if (rootBranch) {
                const currentMaxDepth = this.branchCommitment.branchDepths.get(rootBranch) || 0;
                if (depth > currentMaxDepth) {
                    this.branchCommitment.branchDepths.set(rootBranch, depth);
                }
                
                // Track branch switching
                if (this.currentState.currentBranch && this.currentState.currentBranch !== rootBranch) {
                    this.branchCommitment.switchesPerSession++;
                }
                this.currentState.currentBranch = rootBranch;
            }
            
            // Track cognitive patterns (pause analysis)
            if (timeSinceLastAction > 30000) {
                this.cognitivePatterns.longPauses++;
            } else if (timeSinceLastAction < 10000) {
                this.cognitivePatterns.shortPauses++;
            }
            this.cognitivePatterns.thinkingRatio = 
                this.cognitivePatterns.longPauses / 
                Math.max(1, this.cognitivePatterns.longPauses + this.cognitivePatterns.shortPauses);
            
            // Track children count for cognitive complexity
            if (parent.children) {
                const siblingCount = parent.children.length;
                const totalParents = this.refinementStyle.totalNodes - 1;
                if (totalParents > 0) {
                    this.cognitivePatterns.avgChildrenPerNode = 
                        ((totalParents - 1) * this.cognitivePatterns.avgChildrenPerNode + siblingCount) / totalParents;
                }
            }
            
            // Update state
            this.currentState.lastAction = now;
            this.currentState.lastNodeCreated = node.id;
            this.currentState.lastDepth = depth;
            this.currentState.actionsThisSession++;
            
            this.scheduleSave();
        }
        
        // Track building style (breadth-first vs depth-first)
        trackBuildingStyle(depth) {
            // Add to depth sequence
            this.buildingStyle.depthSequences.push(depth);
            if (this.buildingStyle.depthSequences.length > 100) {
                this.buildingStyle.depthSequences = this.buildingStyle.depthSequences.slice(-100);
            }
            
            // Analyze pattern
            const lastDepth = this.buildingStyle.lastDepth;
            
            if (depth === lastDepth) {
                // Same level - breadth-first indicator
                this.buildingStyle.consecutiveSameDepth++;
                this.buildingStyle.consecutiveDeeper = 0;
            } else if (depth > lastDepth) {
                // Going deeper - depth-first indicator
                this.buildingStyle.consecutiveDeeper++;
                this.buildingStyle.consecutiveSameDepth = 0;
            } else {
                // Going shallower - could be either (completing a branch)
                this.buildingStyle.consecutiveSameDepth = 0;
                this.buildingStyle.consecutiveDeeper = 0;
            }
            
            this.buildingStyle.lastDepth = depth;
            
            // Calculate breadth-first score based on sequences
            this.calculateBuildingStyleScore();
        }
        
        // Calculate building style score
        calculateBuildingStyleScore() {
            if (this.buildingStyle.depthSequences.length < 10) return;
            
            const sequences = this.buildingStyle.depthSequences;
            let sameDepthTransitions = 0;
            let deeperTransitions = 0;
            let shallowerTransitions = 0;
            
            for (let i = 1; i < sequences.length; i++) {
                const diff = sequences[i] - sequences[i - 1];
                if (diff === 0) sameDepthTransitions++;
                else if (diff > 0) deeperTransitions++;
                else shallowerTransitions++;
            }
            
            const total = sameDepthTransitions + deeperTransitions + shallowerTransitions;
            
            // Breadth-first: many same-depth transitions
            // Depth-first: many deeper transitions followed by shallower
            this.buildingStyle.breadthFirstScore = sameDepthTransitions / total;
            
            // Level completion rate: ratio of completing a level before going deeper
            this.buildingStyle.levelCompletionRate = 
                (sameDepthTransitions + shallowerTransitions) / total;
        }
        
        // Track node selection
        trackNodeSelected(node, depth, store) {
            const now = Date.now();
            
            // Track exploration locality
            if (this.currentState.lastNodeSelected) {
                // Calculate "distance" between selections (simplified: depth difference)
                const lastDepth = this.currentState.lastDepth;
                const jumpDistance = Math.abs(depth - lastDepth);
                
                this.explorationStyle.selectionJumps.push(jumpDistance);
                if (this.explorationStyle.selectionJumps.length > 50) {
                    this.explorationStyle.selectionJumps = this.explorationStyle.selectionJumps.slice(-50);
                }
                
                // Calculate locality score
                const avgJump = this.explorationStyle.selectionJumps.reduce((a, b) => a + b, 0) / 
                    this.explorationStyle.selectionJumps.length;
                this.explorationStyle.localityScore = Math.max(0, 1 - avgJump / 3); // Normalize
            }
            
            // Track branch revisits
            const rootBranch = this.getRootBranch(node.id, store);
            if (rootBranch) {
                const visits = this.explorationStyle.branchRevisits.get(rootBranch) || 0;
                this.explorationStyle.branchRevisits.set(rootBranch, visits + 1);
                
                // Calculate revisit rate
                const totalVisits = Array.from(this.explorationStyle.branchRevisits.values())
                    .reduce((a, b) => a + b, 0);
                const uniqueBranches = this.explorationStyle.branchRevisits.size;
                this.explorationStyle.revisitRate = uniqueBranches > 0 ? 
                    (totalVisits - uniqueBranches) / totalVisits : 0;
            }
            
            this.currentState.lastNodeSelected = node.id;
            this.currentState.lastDepth = depth;
            this.currentState.lastAction = now;
        }
        
        // Track node editing
        trackNodeEdited(node, editType) {
            const now = Date.now();
            
            this.refinementStyle.editCount++;
            this.refinementStyle.editVsCreateRatio = 
                this.refinementStyle.editCount / (this.refinementStyle.editCount + this.refinementStyle.createCount);
            
            // Check if immediate edit (within 30 seconds of creation)
            if (this.currentState.lastNodeCreated === node.id) {
                const timeSinceCreation = now - this.currentState.lastAction;
                if (timeSinceCreation < 30000) {
                    this.refinementStyle.immediateEdits++;
                } else {
                    this.refinementStyle.delayedEdits++;
                }
            }
            
            // Track description usage
            if (editType === 'description' && node.description) {
                this.refinementStyle.nodesWithDescription++;
                this.refinementStyle.descriptionRate = 
                    this.refinementStyle.nodesWithDescription / Math.max(1, this.refinementStyle.totalNodes);
            }
            
            this.currentState.lastAction = now;
            this.scheduleSave();
        }
        
        // Track suggestions shown
        trackSuggestionsShown(suggestions, parentNode) {
            this.currentState.suggestionsCurrentlyShown = suggestions;
            this.currentState.suggestionShowTime = Date.now();
            this.decisionStyle.suggestionsShown += suggestions.length;
        }
        
        // Track suggestion accepted
        trackSuggestionAccepted(label, wasAddAll = false) {
            const now = Date.now();
            
            this.decisionStyle.suggestionsAccepted++;
            
            // Track acceptance time
            if (this.currentState.suggestionShowTime) {
                const acceptanceTime = now - this.currentState.suggestionShowTime;
                this.decisionStyle.acceptanceTimes.push(acceptanceTime);
                if (this.decisionStyle.acceptanceTimes.length > 50) {
                    this.decisionStyle.acceptanceTimes = this.decisionStyle.acceptanceTimes.slice(-50);
                }
                
                // Calculate average
                this.decisionStyle.avgAcceptanceTime = 
                    this.decisionStyle.acceptanceTimes.reduce((a, b) => a + b, 0) / 
                    this.decisionStyle.acceptanceTimes.length;
                
                this.decisionStyle.quickDecider = this.decisionStyle.avgAcceptanceTime < 3000;
            }
            
            // Track Add All vs individual
            if (wasAddAll) {
                this.decisionStyle.addAllCount++;
            } else {
                this.decisionStyle.individualPickCount++;
            }
            
            const totalDecisions = this.decisionStyle.addAllCount + this.decisionStyle.individualPickCount;
            this.decisionStyle.batchPreference = this.decisionStyle.addAllCount / Math.max(1, totalDecisions);
            
            // Update selectivity
            this.decisionStyle.selectivityRate = 1 - 
                (this.decisionStyle.suggestionsAccepted / Math.max(1, this.decisionStyle.suggestionsShown));
            
            this.scheduleSave();
        }
        
        // Track node expansion
        trackNodeExpanded(node, store) {
            // Track expand before create pattern
            if (this.currentState.lastAction) {
                const timeSinceLastAction = Date.now() - this.currentState.lastAction;
                if (timeSinceLastAction < 5000) {
                    this.explorationStyle.expandBeforeCreate++;
                }
            }
        }
        
        // Analyze session rhythm
        analyzeSessionRhythm() {
            const timestamps = this.sessionRhythm.actionTimestamps;
            if (timestamps.length < 10) return;
            
            // Calculate intervals
            const intervals = [];
            for (let i = 1; i < timestamps.length; i++) {
                intervals.push(timestamps[i] - timestamps[i - 1]);
            }
            
            // Average time between actions
            this.sessionRhythm.avgTimeBetweenActions = 
                intervals.reduce((a, b) => a + b, 0) / intervals.length;
            
            // Burstiness: variance in intervals
            const mean = this.sessionRhythm.avgTimeBetweenActions;
            const variance = intervals.reduce((sum, i) => sum + Math.pow(i - mean, 2), 0) / intervals.length;
            const stdDev = Math.sqrt(variance);
            const coefficientOfVariation = stdDev / mean;
            
            // High CV = bursty, Low CV = steady
            this.sessionRhythm.burstScore = Math.min(1, coefficientOfVariation / 2);
            
            // Analyze momentum (are intervals getting shorter or longer?)
            const firstHalf = intervals.slice(0, Math.floor(intervals.length / 2));
            const secondHalf = intervals.slice(Math.floor(intervals.length / 2));
            
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            
            const ratio = secondAvg / firstAvg;
            
            if (ratio < 0.7) {
                this.sessionRhythm.momentumPattern = 'accelerating';
            } else if (ratio > 1.3) {
                this.sessionRhythm.momentumPattern = 'decelerating';
            } else if (this.sessionRhythm.burstScore > 0.6) {
                this.sessionRhythm.momentumPattern = 'burst-rest';
            } else {
                this.sessionRhythm.momentumPattern = 'steady';
            }
        }
        
        // Get root branch for a node
        getRootBranch(nodeId, store) {
            if (!store) return null;
            
            const path = store.getPath(nodeId);
            if (path.length >= 2) {
                return path[1].id; // First child of root
            }
            return nodeId;
        }
        
        // Update insights based on all patterns
        updateInsights() {
            const strengths = [];
            const suggestions = [];
            
            // Building style insights
            if (this.buildingStyle.breadthFirstScore > 0.6) {
                strengths.push('Systematic breadth-first builder');
            } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                strengths.push('Deep-dive depth-first thinker');
            }
            
            // Exploration insights
            if (this.explorationStyle.localityScore > 0.7) {
                strengths.push('Focused, sequential explorer');
            } else if (this.explorationStyle.localityScore < 0.3) {
                suggestions.push('Consider focusing on one area before jumping');
            }
            
            // Refinement insights
            if (this.refinementStyle.editVsCreateRatio > 0.3) {
                strengths.push('Thoughtful refiner');
            }
            if (this.refinementStyle.descriptionRate > 0.3) {
                strengths.push('Detail-oriented documenter');
            } else if (this.refinementStyle.descriptionRate < 0.1 && this.refinementStyle.totalNodes > 20) {
                suggestions.push('Adding descriptions could help clarify ideas');
            }
            
            // Decision insights
            if (this.decisionStyle.quickDecider) {
                strengths.push('Quick, confident decision maker');
            }
            if (this.decisionStyle.selectivityRate > 0.7) {
                strengths.push('Selective and discerning');
            }
            
            // Session rhythm insights
            if (this.sessionRhythm.momentumPattern === 'accelerating') {
                strengths.push('Builds momentum over sessions');
            } else if (this.sessionRhythm.momentumPattern === 'burst-rest') {
                strengths.push('Works in productive bursts');
            }
            
            // Cognitive pattern insights
            if (this.cognitivePatterns.thinkingRatio > 0.4) {
                strengths.push('Thoughtful, deliberate approach');
            }
            
            this.insights = {
                lastUpdated: Date.now(),
                summary: this.generateSummary(),
                strengths,
                suggestions
            };
        }
        
        // Generate a natural language summary
        generateSummary() {
            const parts = [];
            
            // Building style
            if (this.buildingStyle.breadthFirstScore > 0.6) {
                parts.push('builds systematically across topics');
            } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                parts.push('dives deep into specific areas');
            } else {
                parts.push('balances breadth and depth');
            }
            
            // Rhythm
            if (this.sessionRhythm.momentumPattern === 'accelerating') {
                parts.push('picks up speed as they work');
            } else if (this.sessionRhythm.momentumPattern === 'burst-rest') {
                parts.push('works in focused bursts');
            }
            
            // Decision style
            if (this.decisionStyle.batchPreference > 0.6) {
                parts.push('prefers accepting suggestions in batches');
            } else if (this.decisionStyle.selectivityRate > 0.6) {
                parts.push('carefully selects individual suggestions');
            }
            
            return parts.length > 0 ? 
                `User ${parts.join(', ')}.` : 
                'Still learning user patterns.';
        }
        
        // Get insights for Claude prompts
        getPromptInsights() {
            const insights = [];
            
            // Building style
            if (this.buildingStyle.depthSequences.length >= 20) {
                if (this.buildingStyle.breadthFirstScore > 0.6) {
                    insights.push('User builds breadth-first (suggest siblings before children)');
                } else if (this.buildingStyle.breadthFirstScore < 0.3) {
                    insights.push('User builds depth-first (suggest deeper children)');
                }
            }
            
            // Decision style - helps calibrate suggestion count
            if (this.decisionStyle.suggestionsAccepted > 10) {
                if (this.decisionStyle.selectivityRate > 0.7) {
                    insights.push('User is highly selective (suggest only best matches)');
                } else if (this.decisionStyle.selectivityRate < 0.3) {
                    insights.push('User accepts most suggestions (can include exploratory options)');
                }
            }
            
            // Cognitive style
            if (this.cognitivePatterns.avgChildrenPerNode > 0) {
                if (this.cognitivePatterns.avgChildrenPerNode < 2.5) {
                    insights.push('User prefers focused nodes (suggest fewer, more specific children)');
                } else if (this.cognitivePatterns.avgChildrenPerNode > 4) {
                    insights.push('User likes comprehensive breakdowns (can suggest more children)');
                }
            }
            
            return insights.length > 0 ? insights.join('\n') : null;
        }
        
        // Get stats for UI
        getStats() {
            return {
                buildingStyle: this.buildingStyle.breadthFirstScore > 0.6 ? 'Breadth-first' :
                    this.buildingStyle.breadthFirstScore < 0.3 ? 'Depth-first' : 'Balanced',
                buildingScore: this.buildingStyle.breadthFirstScore,
                localityScore: this.explorationStyle.localityScore,
                refinementRatio: this.refinementStyle.editVsCreateRatio,
                selectivityRate: this.decisionStyle.selectivityRate,
                quickDecider: this.decisionStyle.quickDecider,
                momentumPattern: this.sessionRhythm.momentumPattern,
                burstScore: this.sessionRhythm.burstScore,
                sessionsAnalyzed: this.sessionRhythm.sessionsAnalyzed,
                thinkingRatio: this.cognitivePatterns.thinkingRatio,
                insights: this.insights
            };
        }
        
        // Debounced save
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.save();
            }, 10000); // Save every 10 seconds of inactivity
        }
        
        // Reset
        async reset() {
            this.buildingStyle = {
                depthSequences: [],
                breadthFirstScore: 0.5,
                consecutiveSameDepth: 0,
                consecutiveDeeper: 0,
                lastDepth: 0,
                levelCompletionRate: 0.5
            };
            this.explorationStyle = {
                selectionJumps: [],
                localityScore: 0.5,
                expandBeforeCreate: 0,
                createBeforeExpand: 0,
                branchRevisits: new Map(),
                revisitRate: 0
            };
            this.refinementStyle = {
                editCount: 0,
                createCount: 0,
                editVsCreateRatio: 0.5,
                immediateEdits: 0,
                delayedEdits: 0,
                nodesWithDescription: 0,
                totalNodes: 0,
                descriptionRate: 0
            };
            this.decisionStyle = {
                acceptanceTimes: [],
                avgAcceptanceTime: 0,
                quickDecider: false,
                suggestionsShown: 0,
                suggestionsAccepted: 0,
                selectivityRate: 0.5,
                addAllCount: 0,
                individualPickCount: 0,
                batchPreference: 0.5
            };
            this.sessionRhythm = {
                actionTimestamps: [],
                burstScore: 0.5,
                avgTimeBetweenActions: 0,
                sessionsAnalyzed: 0,
                avgActionsPerSession: 0,
                avgSessionDuration: 0,
                momentumPattern: 'steady'
            };
            this.branchCommitment = {
                branchDepths: new Map(),
                avgBranchDepth: 0,
                abandonedBranches: [],
                abandonmentRate: 0,
                focusScore: 0.5,
                activeBranches: 0,
                switchesPerSession: 0,
                avgTimeOnBranch: 0
            };
            this.cognitivePatterns = {
                avgChildrenPerNode: 0,
                prefersFlatStructure: false,
                prefersDeepStructure: false,
                avgLabelComplexity: 0,
                longPauses: 0,
                shortPauses: 0,
                thinkingRatio: 0.5
            };
            this.insights = {
                lastUpdated: null,
                summary: '',
                strengths: [],
                suggestions: []
            };
            
            await NeuralDB.delete('meta-learner');
            console.log('✓ Meta-learner reset');
        }
    }
    
    // Create global meta-learner instance
    const metaLearner = new MetaLearner();
    
    // ═══════════════════════════════════════════════════════════════════
    // NEURAL NETWORK TRAINING WORKER
    // ═══════════════════════════════════════════════════════════════════
    // Create a worker for training a single model type
    const createModelWorker = (modelType) => {
        const workerCode = `
            // Load TensorFlow.js in worker
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');
            
            // Try to use WebGL backend for GPU acceleration
            async function initBackend() {
                try {
                    await tf.setBackend('webgl');
                    await tf.ready();
                    return tf.getBackend();
                } catch (e) {
                    return 'cpu';
                }
            }
            
            // Default config - will be overridden by main thread
            let CONFIG = {
                embeddingDim: 512,
                hiddenUnits: 128,
                learningRate: 0.001,
                epochs: 15,
                batchSize: 16
            };
            
            function buildCategoryModel(numCategories) {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim],
                    units: CONFIG.hiddenUnits,
                    activation: 'relu',
                    kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: Math.max(32, CONFIG.hiddenUnits / 2), activation: 'relu' }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: numCategories, activation: 'softmax' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate),
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                return model;
            }
            
            function buildConnectionModel() {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim * 2],
                    units: CONFIG.hiddenUnits * 2, // Scale with hiddenUnits
                    activation: 'relu'
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: Math.max(32, CONFIG.hiddenUnits / 2), activation: 'relu' }));
                model.add(tf.layers.dense({ units: 4, activation: 'sigmoid' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                return model;
            }
            
            function buildPredictionModel() {
                const model = tf.sequential();
                model.add(tf.layers.dense({
                    inputShape: [CONFIG.embeddingDim],
                    units: CONFIG.hiddenUnits * 2, // Scale with hiddenUnits
                    activation: 'relu',
                    kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
                }));
                model.add(tf.layers.dropout({ rate: 0.3 }));
                model.add(tf.layers.dense({ units: CONFIG.hiddenUnits * 2, activation: 'relu' }));
                model.add(tf.layers.dropout({ rate: 0.2 }));
                model.add(tf.layers.dense({ units: CONFIG.embeddingDim, activation: 'linear' }));
                model.compile({
                    optimizer: tf.train.adam(CONFIG.learningRate * 0.5),
                    loss: 'meanSquaredError',
                    metrics: ['mae']
                });
                return model;
            }
            
            async function extractWeights(model) {
                const weights = [];
                for (const layer of model.layers) {
                    const layerWeights = layer.getWeights();
                    const layerData = [];
                    for (const w of layerWeights) {
                        layerData.push({
                            shape: w.shape,
                            data: await w.data()
                        });
                    }
                    weights.push(layerData);
                }
                return weights;
            }
            
            self.onmessage = async function(e) {
                const { type, data, modelType, config } = e.data;
                
                // Update config if provided
                if (config) {
                    CONFIG = { ...CONFIG, ...config };
                }
                
                if (type === 'train') {
                    try {
                        // Initialize GPU backend
                        const backend = await initBackend();
                        self.postMessage({ type: 'progress', modelType, progress: 0, message: 'Using ' + backend + ' (epochs=' + CONFIG.epochs + ')' });
                        
                        let model, xs, ys, weights = null;
                        
                        if (modelType === 'category' && data.numCategories > 1 && data.inputs.length > 0) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildCategoryModel(data.numCategories);
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);
                            
                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: CONFIG.batchSize,
                                validationSplit: 0.2,
                                shuffle: true,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({ 
                                            type: 'progress', 
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            accuracy: logs.acc,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });
                            
                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                            
                        } else if (modelType === 'connection' && data.inputs.length > 10) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildConnectionModel();
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);
                            
                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: CONFIG.batchSize,
                                validationSplit: 0.2,
                                shuffle: true,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({ 
                                            type: 'progress', 
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            accuracy: logs.acc,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });
                            
                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                            
                        } else if (modelType === 'prediction' && data.inputs.length > 5) {
                            self.postMessage({ type: 'progress', modelType, progress: 0 });
                            model = buildPredictionModel();
                            xs = tf.tensor2d(data.inputs);
                            ys = tf.tensor2d(data.outputs);
                            
                            await model.fit(xs, ys, {
                                epochs: CONFIG.epochs,
                                batchSize: Math.min(CONFIG.batchSize, data.inputs.length),
                                validationSplit: 0.2,
                                shuffle: true,
                                callbacks: {
                                    onEpochEnd: (epoch, logs) => {
                                        self.postMessage({ 
                                            type: 'progress', 
                                            modelType,
                                            progress: ((epoch + 1) / CONFIG.epochs) * 100,
                                            loss: logs.loss
                                        });
                                    }
                                }
                            });
                            
                            weights = await extractWeights(model);
                            xs.dispose(); ys.dispose(); model.dispose();
                        }
                        
                        self.postMessage({ type: 'complete', modelType, weights });
                        
                    } catch (error) {
                        self.postMessage({ type: 'error', modelType, error: error.message });
                    }
                }
            };
            
            self.postMessage({ type: 'ready' });
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // EMBEDDING WORKER - Offload USE inference to background thread
    // ═══════════════════════════════════════════════════════════════════
    const createEmbeddingWorker = () => {
        const workerCode = `
            // Load TensorFlow.js and Universal Sentence Encoder
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');
            importScripts('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js');
            
            let encoder = null;
            let isReady = false;
            
            // Initialize encoder
            async function init() {
                try {
                    // Try WebGL backend
                    try {
                        await tf.setBackend('webgl');
                        await tf.ready();
                    } catch (e) {
                        console.log('WebGL not available in worker, using CPU');
                    }
                    
                    encoder = await use.load();
                    isReady = true;
                    self.postMessage({ type: 'ready', backend: tf.getBackend() });
                } catch (error) {
                    self.postMessage({ type: 'error', error: error.message });
                }
            }
            
            self.onmessage = async function(e) {
                const { type, id, text, texts } = e.data;
                
                if (type === 'embed' && isReady) {
                    try {
                        const embeddings = await encoder.embed([text]);
                        const vector = (await embeddings.array())[0];
                        embeddings.dispose();
                        self.postMessage({ type: 'embedding', id, vector });
                    } catch (error) {
                        self.postMessage({ type: 'error', id, error: error.message });
                    }
                } else if (type === 'embedBatch' && isReady) {
                    try {
                        const embeddings = await encoder.embed(texts);
                        const vectors = await embeddings.array();
                        embeddings.dispose();
                        self.postMessage({ type: 'embeddings', id, vectors });
                    } catch (error) {
                        self.postMessage({ type: 'error', id, error: error.message });
                    }
                } else if (!isReady) {
                    self.postMessage({ type: 'notReady', id });
                }
            };
            
            // Start initialization
            init();
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        return new Worker(URL.createObjectURL(blob));
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // PERSONAL NEURAL NETWORK - TensorFlow.js Integration
    // ═══════════════════════════════════════════════════════════════════
    class PersonalNeuralNet {
        constructor() {
            this.encoder = null;
            this.embeddingWorker = null;
            this.embeddingWorkerReady = false;
            this.pendingEmbeddingRequests = new Map(); // id -> {resolve, reject}
            this.embeddingRequestId = 0;
            this.categoryModel = null;
            this.connectionModel = null;
            this.predictionModel = null; // New: Predicts likely child nodes
            this.expansionPatterns = new Map(); // Learned parent->children patterns
            this.patternWeights = new Map(); // Weights for parent->child pairs (incremental learning)
            this.embeddings = new Map(); // Cache embeddings for nodes
            this.isReady = false;
            this.isInitializing = false; // Track if initialization is in progress
            this.isTraining = false;
            this.trainingProgress = 0;
            this.categories = []; // Learned categories (top-level nodes)
            this.commonPatterns = []; // Frequently seen expansion patterns
            this.pendingEmbeddings = []; // Queue of texts waiting to be embedded
            this.embeddingDebounceTimer = null;
            this.trainingWorkers = []; // Array for parallel workers
            this.callbacks = {
                onReady: [],
                onTrainingStart: [],
                onTrainingProgress: [],
                onTrainingComplete: [],
                onPrediction: [],
                onSuggestion: [],
                onIncrementalLearn: []
            };
        }
        
        // Initialize the encoder and load any saved models
        async initialize() {
            try {
                console.log('🧠 Initializing Personal Neural Network...');
                
                // Lazy load TensorFlow.js if not already loaded
                if (!TensorFlowLoader.isLoaded()) {
                    try {
                        await TensorFlowLoader.load();
                    } catch (loadError) {
                        console.warn('⚠️ TensorFlow.js could not be loaded:', loadError);
                        this.loadError = 'TensorFlow.js not loaded';
                        return false;
                    }
                }
                
                // Start embedding worker in background
                if (typeof Worker !== 'undefined') {
                    try {
                        this.embeddingWorker = createEmbeddingWorker();
                        this.embeddingWorker.onmessage = (e) => {
                            const { type, id, vector, vectors, backend, error } = e.data;
                            
                            if (type === 'ready') {
                                this.embeddingWorkerReady = true;
                                console.log(`✓ Embedding worker ready (${backend} backend)`);
                            } else if (type === 'embedding') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.resolve(vector);
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            } else if (type === 'embeddings') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.resolve(vectors);
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            } else if (type === 'error' || type === 'notReady') {
                                const pending = this.pendingEmbeddingRequests.get(id);
                                if (pending) {
                                    pending.reject(new Error(error || 'Worker not ready'));
                                    this.pendingEmbeddingRequests.delete(id);
                                }
                            }
                        };
                        this.embeddingWorker.onerror = (err) => {
                            console.warn('Embedding worker error:', err);
                            this.embeddingWorkerReady = false;
                        };
                    } catch (workerError) {
                        console.warn('Could not create embedding worker:', workerError);
                    }
                }
                
                // Load Universal Sentence Encoder on main thread (fallback + sharing with other systems)
                if (typeof use !== 'undefined') {
                    try {
                        this.encoder = await use.load();
                        console.log('✓ Universal Sentence Encoder loaded (main thread)');
                        
                        // Share encoder with semantic memory system
                        semanticMemory.setEncoder(this.encoder);
                        
                        // Share encoder with relationship classifier
                        relationshipClassifier.setEncoder(this.encoder);
                        
                        // Share encoder with concept abstractor
                        conceptAbstractor.setEncoder(this.encoder);
                    } catch (loadError) {
                        // Model fetch blocked (common in preview environments)
                        console.warn('⚠️ Neural network: Model loading blocked (preview environment)');
                        console.warn('   Neural features will work when running locally or hosted');
                        this.loadError = 'Preview environment - run locally for neural features';
                        return false;
                    }
                } else {
                    console.warn('Universal Sentence Encoder not available');
                    this.loadError = 'TensorFlow.js not loaded';
                    return false;
                }
                
                // Try to load saved models
                await this.loadModels();
                
                // Load cached embeddings
                this.loadEmbeddings();
                
                this.isReady = true;
                this.emit('onReady');
                console.log('✓ Personal Neural Network ready');
                return true;
            } catch (error) {
                console.warn('Neural network unavailable:', error.message);
                this.loadError = error.message;
                return false;
            }
        }
        
        // Event system
        on(event, callback) {
            if (this.callbacks[event]) {
                this.callbacks[event].push(callback);
            }
        }
        
        emit(event, data) {
            if (this.callbacks[event]) {
                this.callbacks[event].forEach(cb => cb(data));
            }
        }
        
        // Generate embedding for text (uses worker when available)
        async getEmbedding(text) {
            if (!this.encoder && !this.embeddingWorkerReady) return null;
            
            const cacheKey = text.toLowerCase().trim();
            if (this.embeddings.has(cacheKey)) {
                return this.embeddings.get(cacheKey);
            }
            
            try {
                let vector;
                
                // Use worker if available (non-blocking)
                if (this.embeddingWorkerReady && this.embeddingWorker) {
                    const id = ++this.embeddingRequestId;
                    vector = await new Promise((resolve, reject) => {
                        this.pendingEmbeddingRequests.set(id, { resolve, reject });
                        this.embeddingWorker.postMessage({ type: 'embed', id, text });
                        
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            if (this.pendingEmbeddingRequests.has(id)) {
                                this.pendingEmbeddingRequests.delete(id);
                                reject(new Error('Embedding timeout'));
                            }
                        }, 10000);
                    });
                } else if (this.encoder) {
                    // Fallback to main thread
                    const embeddings = await this.encoder.embed([text]);
                    const embedding = await embeddings.array();
                    vector = embedding[0];
                    embeddings.dispose();
                } else {
                    return null;
                }
                
                this.embeddings.set(cacheKey, vector);
                return vector;
            } catch (error) {
                // If worker fails, try main thread fallback
                if (this.encoder) {
                    try {
                        const embeddings = await this.encoder.embed([text]);
                        const embedding = await embeddings.array();
                        const vector = embedding[0];
                        embeddings.dispose();
                        this.embeddings.set(cacheKey, vector);
                        return vector;
                    } catch (e) {
                        console.error('Embedding fallback error:', e);
                    }
                }
                console.error('Embedding error:', error);
                return null;
            }
        }
        
        // Get embeddings for multiple texts efficiently (uses worker when available)
        async getEmbeddings(texts) {
            if (!this.encoder && !this.embeddingWorkerReady) return null;
            
            // Check cache first
            const uncachedTexts = [];
            const uncachedIndices = [];
            const results = new Array(texts.length);
            
            texts.forEach((text, i) => {
                const cacheKey = text.toLowerCase().trim();
                if (this.embeddings.has(cacheKey)) {
                    results[i] = this.embeddings.get(cacheKey);
                } else {
                    uncachedTexts.push(text);
                    uncachedIndices.push(i);
                }
            });
            
            // If all cached, return immediately
            if (uncachedTexts.length === 0) {
                return results;
            }
            
            try {
                let vectors;
                
                // Use worker if available (non-blocking)
                if (this.embeddingWorkerReady && this.embeddingWorker) {
                    const id = ++this.embeddingRequestId;
                    vectors = await new Promise((resolve, reject) => {
                        this.pendingEmbeddingRequests.set(id, { resolve, reject });
                        this.embeddingWorker.postMessage({ type: 'embedBatch', id, texts: uncachedTexts });
                        
                        // Timeout after 30 seconds for batch
                        setTimeout(() => {
                            if (this.pendingEmbeddingRequests.has(id)) {
                                this.pendingEmbeddingRequests.delete(id);
                                reject(new Error('Batch embedding timeout'));
                            }
                        }, 30000);
                    });
                } else if (this.encoder) {
                    // Fallback to main thread
                    const embeddings = await this.encoder.embed(uncachedTexts);
                    vectors = await embeddings.array();
                    embeddings.dispose();
                } else {
                    return null;
                }
                
                // Cache and fill results
                uncachedTexts.forEach((text, i) => {
                    const cacheKey = text.toLowerCase().trim();
                    this.embeddings.set(cacheKey, vectors[i]);
                    results[uncachedIndices[i]] = vectors[i];
                });
                
                return results;
            } catch (error) {
                // If worker fails, try main thread fallback
                if (this.encoder) {
                    try {
                        const embeddings = await this.encoder.embed(uncachedTexts);
                        const vectors = await embeddings.array();
                        embeddings.dispose();
                        
                        uncachedTexts.forEach((text, i) => {
                            const cacheKey = text.toLowerCase().trim();
                            this.embeddings.set(cacheKey, vectors[i]);
                            results[uncachedIndices[i]] = vectors[i];
                        });
                        
                        return results;
                    } catch (e) {
                        console.error('Batch embedding fallback error:', e);
                    }
                }
                console.error('Batch embedding error:', error);
                return null;
            }
        }
        
        // Build the category prediction model
        buildCategoryModel(numCategories) {
            const model = tf.sequential();
            
            // Input: 512-dim embedding
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: CONFIG.NEURAL_NET.hiddenUnits,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: Math.max(32, CONFIG.NEURAL_NET.hiddenUnits / 2),
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: probability for each category
            model.add(tf.layers.dense({
                units: numCategories,
                activation: 'softmax'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the connection prediction model
        buildConnectionModel() {
            const model = tf.sequential();
            
            // Input: concatenated embeddings of two nodes (512 + 512 = 1024)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim * 2],
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: Math.max(32, CONFIG.NEURAL_NET.hiddenUnits / 2),
                activation: 'relu'
            }));
            
            // Output: connection probability and connection type
            // [shouldConnect, isParentChild, isSibling, isRelated]
            model.add(tf.layers.dense({
                units: 4,
                activation: 'sigmoid'
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // Build the node prediction model - predicts likely child node embeddings
        buildPredictionModel() {
            const model = tf.sequential();
            
            // Input: parent node embedding (512)
            model.add(tf.layers.dense({
                inputShape: [CONFIG.NEURAL_NET.embeddingDim],
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu',
                kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
            }));
            
            model.add(tf.layers.dropout({ rate: 0.3 }));
            
            model.add(tf.layers.dense({
                units: CONFIG.NEURAL_NET.hiddenUnits * 2,
                activation: 'relu'
            }));
            
            model.add(tf.layers.dropout({ rate: 0.2 }));
            
            // Output: predicted "average child" embedding (512)
            // This represents the semantic centroid of expected children
            model.add(tf.layers.dense({
                units: CONFIG.NEURAL_NET.embeddingDim,
                activation: 'linear' // Linear for embedding space
            }));
            
            model.compile({
                optimizer: tf.train.adam(CONFIG.NEURAL_NET.learningRate * 0.5),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            return model;
        }
        
        // Prepare training data from the mind map structure
        async prepareTrainingData(store) {
            const allNodes = [];
            const categoryLabels = [];
            
            // Collect all nodes with their text and category
            const collectNodes = (node, category = null, depth = 0) => {
                if (depth === 0) {
                    // Root node - skip
                } else if (depth === 1) {
                    // This is a category (top-level node)
                    category = node.label;
                    if (!this.categories.includes(category)) {
                        this.categories.push(category);
                    }
                }
                
                if (depth > 0 && category) {
                    const text = node.description 
                        ? `${node.label}. ${node.description}`
                        : node.label;
                    allNodes.push({
                        id: node.id,
                        text: text,
                        label: node.label,
                        category: category,
                        categoryIndex: this.categories.indexOf(category),
                        depth: depth,
                        parentId: null, // Will be set below
                        children: node.children?.map(c => c.id) || []
                    });
                }
                
                if (node.children) {
                    node.children.forEach(child => {
                        collectNodes(child, category || node.label, depth + 1);
                    });
                }
            };
            
            collectNodes(store.data);
            
            // Set parent IDs
            const setParents = (node, parentId = null) => {
                const nodeData = allNodes.find(n => n.id === node.id);
                if (nodeData) {
                    nodeData.parentId = parentId;
                }
                if (node.children) {
                    node.children.forEach(child => setParents(child, node.id));
                }
            };
            setParents(store.data);
            
            if (allNodes.length < CONFIG.NEURAL_NET.minTrainingNodes) {
                console.log(`Need at least ${CONFIG.NEURAL_NET.minTrainingNodes} nodes to train`);
                return null;
            }
            
            // Get embeddings for all node texts
            const texts = allNodes.map(n => n.text);
            const embeddings = await this.getEmbeddings(texts);
            
            if (!embeddings) return null;
            
            // Prepare category training data
            const categoryData = {
                inputs: [],
                outputs: []
            };
            
            allNodes.forEach((node, i) => {
                if (node.categoryIndex >= 0) {
                    categoryData.inputs.push(embeddings[i]);
                    // One-hot encode the category
                    const oneHot = new Array(this.categories.length).fill(0);
                    oneHot[node.categoryIndex] = 1;
                    categoryData.outputs.push(oneHot);
                }
            });
            
            // Prepare connection training data
            const connectionData = {
                inputs: [],
                outputs: []
            };
            
            // Positive examples: actual parent-child and sibling pairs
            allNodes.forEach((node, i) => {
                // Parent-child connections
                node.children.forEach(childId => {
                    const childIndex = allNodes.findIndex(n => n.id === childId);
                    if (childIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[childIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 1, 0, 1]); // connected, parent-child, not sibling, related
                    }
                });
                
                // Sibling connections (same parent)
                const siblings = allNodes.filter(n => 
                    n.parentId === node.parentId && n.id !== node.id
                );
                siblings.slice(0, 3).forEach(sibling => {
                    const siblingIndex = allNodes.findIndex(n => n.id === sibling.id);
                    if (siblingIndex >= 0) {
                        const combined = [...embeddings[i], ...embeddings[siblingIndex]];
                        connectionData.inputs.push(combined);
                        connectionData.outputs.push([1, 0, 1, 1]); // connected, not parent-child, sibling, related
                    }
                });
            });
            
            // Negative examples: random unconnected pairs
            const numNegative = Math.min(connectionData.inputs.length, allNodes.length * 2);
            for (let i = 0; i < numNegative; i++) {
                const idx1 = Math.floor(Math.random() * allNodes.length);
                const idx2 = Math.floor(Math.random() * allNodes.length);
                if (idx1 !== idx2) {
                    const node1 = allNodes[idx1];
                    const node2 = allNodes[idx2];
                    
                    // Check if they're not actually connected
                    const isConnected = node1.children.includes(node2.id) || 
                                       node2.children.includes(node1.id) ||
                                       node1.parentId === node2.parentId;
                    
                    if (!isConnected) {
                        const combined = [...embeddings[idx1], ...embeddings[idx2]];
                        connectionData.inputs.push(combined);
                        // Different categories = probably not related
                        const sameCategory = node1.category === node2.category;
                        connectionData.outputs.push([0, 0, 0, sameCategory ? 0.5 : 0]);
                    }
                }
            }
            
            // Prepare prediction training data (parent -> average child embedding)
            const predictionData = {
                inputs: [],
                outputs: [],
                patterns: [] // Store label patterns for pattern matching
            };
            
            // For each parent with children, create training pair
            allNodes.forEach((node, i) => {
                if (node.children.length > 0) {
                    // Get all child embeddings
                    const childEmbeddings = [];
                    const childLabels = [];
                    
                    node.children.forEach(childId => {
                        const childIndex = allNodes.findIndex(n => n.id === childId);
                        if (childIndex >= 0) {
                            childEmbeddings.push(embeddings[childIndex]);
                            childLabels.push(allNodes[childIndex].label);
                        }
                    });
                    
                    if (childEmbeddings.length > 0) {
                        // Input: parent embedding
                        predictionData.inputs.push(embeddings[i]);
                        
                        // Output: centroid (average) of child embeddings
                        const centroid = new Array(CONFIG.NEURAL_NET.embeddingDim).fill(0);
                        childEmbeddings.forEach(childEmb => {
                            childEmb.forEach((val, j) => {
                                centroid[j] += val / childEmbeddings.length;
                            });
                        });
                        predictionData.outputs.push(centroid);
                        
                        // Store pattern for label-based suggestions
                        predictionData.patterns.push({
                            parentLabel: node.label.toLowerCase(),
                            childLabels: childLabels
                        });
                    }
                }
            });
            
            // Store expansion patterns for quick lookup
            this.expansionPatterns.clear();
            predictionData.patterns.forEach(p => {
                // Normalize parent label for fuzzy matching
                const key = this.normalizeLabel(p.parentLabel);
                if (!this.expansionPatterns.has(key)) {
                    this.expansionPatterns.set(key, []);
                }
                this.expansionPatterns.get(key).push(...p.childLabels);
            });
            
            // Find common patterns across similar parents
            this.learnCommonPatterns(predictionData.patterns);
            
            return { categoryData, connectionData, predictionData, allNodes, embeddings };
        }
        
        // Normalize label for pattern matching
        normalizeLabel(label) {
            return label.toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Learn common expansion patterns
        learnCommonPatterns(patterns) {
            // Group similar child labels across different parents
            const childFrequency = new Map();
            
            patterns.forEach(p => {
                p.childLabels.forEach(label => {
                    const normalized = this.normalizeLabel(label);
                    childFrequency.set(normalized, (childFrequency.get(normalized) || 0) + 1);
                });
            });
            
            // Find commonly used child labels (appear in multiple parent contexts)
            this.commonPatterns = Array.from(childFrequency.entries())
                .filter(([label, count]) => count >= 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([label]) => label);
            
            console.log(`✓ Learned ${this.commonPatterns.length} common expansion patterns`);
        }
        
        // ═══════════════════════════════════════════════════════════════════
        // INCREMENTAL LEARNING - Real-time pattern updates
        // ═══════════════════════════════════════════════════════════════════
        
        // Learn a new parent->child pattern immediately when node is added
        incrementalLearnPattern(parentLabel, childLabel, source = 'user', depth = 1) {
            if (!parentLabel || !childLabel) return;
            
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            // Add to expansion patterns
            if (!this.expansionPatterns.has(normalizedParent)) {
                this.expansionPatterns.set(normalizedParent, []);
            }
            
            const children = this.expansionPatterns.get(normalizedParent);
            if (!children.includes(childLabel)) {
                children.push(childLabel);
            }
            
            // Initialize or update weight
            const currentWeight = this.patternWeights.get(patternKey) || { 
                weight: 0.3, 
                occurrences: 0, 
                accepted: 0,
                sources: [],
                relationshipType: null,
                relationshipConfidence: 0
            };
            
            currentWeight.occurrences++;
            currentWeight.weight = Math.min(1.0, currentWeight.weight + 0.1);
            if (!currentWeight.sources.includes(source)) {
                currentWeight.sources.push(source);
            }
            
            // Classify relationship type (heuristics only for performance)
            if (!currentWeight.relationshipType) {
                const classification = relationshipClassifier.classifyByHeuristics(parentLabel, childLabel);
                if (classification.confidence >= 0.3) {
                    currentWeight.relationshipType = classification.type;
                    currentWeight.relationshipConfidence = classification.confidence;
                }
            }
            
            this.patternWeights.set(patternKey, currentWeight);
            
            // Learn structural pattern for concept abstraction
            conceptAbstractor.learnPattern(
                parentLabel, 
                childLabel, 
                depth, 
                currentWeight.relationshipType
            );
            
            // Update common patterns if this child appears frequently
            const childOccurrences = Array.from(this.patternWeights.entries())
                .filter(([key]) => key.endsWith(`→${normalizedChild}`))
                .length;
            
            if (childOccurrences >= 2 && !this.commonPatterns.includes(normalizedChild)) {
                this.commonPatterns.push(normalizedChild);
                if (this.commonPatterns.length > 25) {
                    this.commonPatterns = this.commonPatterns.slice(-25);
                }
            }
            
            console.log(`📚 Incremental learn: "${parentLabel}" → "${childLabel}" (weight: ${currentWeight.weight.toFixed(2)}, type: ${currentWeight.relationshipType || 'unknown'})`);
            this.emit('onIncrementalLearn', { parentLabel, childLabel, weight: currentWeight.weight });
            
            // Debounced save
            this.scheduleSave();
        }
        
        // Boost pattern weight when user accepts a suggestion
        boostPattern(parentLabel, childLabel, suggestionType = 'ai') {
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            const previousWeight = this.patternWeights.get(patternKey);
            const wasHighConfidence = previousWeight && previousWeight.weight >= 0.7;
            
            const currentWeight = previousWeight || {
                weight: 0.5,
                occurrences: 1,
                accepted: 0,
                sources: []
            };
            
            // Significant boost for accepted suggestions
            currentWeight.accepted++;
            currentWeight.weight = Math.min(1.0, currentWeight.weight + 0.25);
            if (!currentWeight.sources.includes('accepted')) {
                currentWeight.sources.push('accepted');
            }
            
            this.patternWeights.set(patternKey, currentWeight);
            
            console.log(`⬆️ Boosted pattern: "${parentLabel}" → "${childLabel}" (weight: ${currentWeight.weight.toFixed(2)}, accepted: ${currentWeight.accepted}x)`);
            
            // Create memory when pattern reaches high confidence for the first time
            if (!wasHighConfidence && currentWeight.weight >= 0.7 && typeof semanticMemory !== 'undefined') {
                semanticMemory.addMemory(
                    'pattern_emerged',
                    `Strong pattern emerged: "${parentLabel}" → "${childLabel}" (accepted ${currentWeight.accepted}x)`,
                    { parentLabel, childLabel, weight: currentWeight.weight, acceptedCount: currentWeight.accepted }
                );
            }
            
            // Also add to expansion patterns if not present
            if (!this.expansionPatterns.has(normalizedParent)) {
                this.expansionPatterns.set(normalizedParent, []);
            }
            const children = this.expansionPatterns.get(normalizedParent);
            if (!children.includes(childLabel)) {
                children.push(childLabel);
            }
            
            this.scheduleSave();
        }
        
        // Get weight for a pattern (for use in predictions)
        getPatternWeight(parentLabel, childLabel) {
            const normalizedParent = this.normalizeLabel(parentLabel);
            const normalizedChild = this.normalizeLabel(childLabel);
            const patternKey = `${normalizedParent}→${normalizedChild}`;
            
            const weight = this.patternWeights.get(patternKey);
            return weight ? weight.weight : 0.3; // Default weight
        }
        
        // Find patterns with same relationship type for transfer learning
        findAnalogousByType(relationshipType, excludeParent, excludeChildren = [], limit = 3) {
            const analogous = [];
            const normalizedExclude = excludeChildren.map(c => this.normalizeLabel(c));
            
            // Scan all patterns with matching relationship type
            for (const [patternKey, weight] of this.patternWeights) {
                // Must have matching relationship type with decent confidence
                if (weight.relationshipType !== relationshipType || 
                    weight.relationshipConfidence < 0.4 ||
                    weight.weight < 0.4) {
                    continue;
                }
                
                const [parentPart, childPart] = patternKey.split('→');
                
                // Skip if same parent or child already exists
                if (parentPart === excludeParent || normalizedExclude.includes(childPart)) {
                    continue;
                }
                
                // Calculate transfer score based on pattern strength and relationship confidence
                const transferScore = (weight.weight * 0.6 + weight.relationshipConfidence * 0.4) * 0.7; // Discount for being analogous
                
                analogous.push({
                    fromParent: parentPart,
                    childLabel: childPart,
                    relationshipType,
                    transferScore,
                    originalWeight: weight.weight
                });
            }
            
            // Sort by transfer score
            analogous.sort((a, b) => b.transferScore - a.transferScore);
            
            // Return top suggestions (avoid duplicates)
            const seen = new Set();
            const result = [];
            
            for (const item of analogous) {
                if (!seen.has(item.childLabel) && result.length < limit) {
                    seen.add(item.childLabel);
                    result.push(item);
                }
            }
            
            return result;
        }
        
        // Queue embedding for async processing
        queueEmbedding(text) {
            if (!text || this.embeddings.has(text)) return;
            
            if (!this.pendingEmbeddings.includes(text)) {
                this.pendingEmbeddings.push(text);
            }
            
            // Debounce embedding processing
            if (this.embeddingDebounceTimer) {
                clearTimeout(this.embeddingDebounceTimer);
            }
            
            this.embeddingDebounceTimer = setTimeout(() => {
                this.processPendingEmbeddings();
            }, 500); // Process after 500ms of inactivity
        }
        
        // Process queued embeddings in batch
        async processPendingEmbeddings() {
            if (!this.encoder || this.pendingEmbeddings.length === 0) return;
            
            const toProcess = this.pendingEmbeddings.splice(0, 10); // Process up to 10 at a time
            
            try {
                const embeddings = await this.encoder.embed(toProcess);
                const embeddingArrays = await embeddings.array();
                embeddings.dispose();
                
                toProcess.forEach((text, i) => {
                    this.embeddings.set(text, embeddingArrays[i]);
                });
                
                console.log(`📊 Cached ${toProcess.length} new embeddings (total: ${this.embeddings.size})`);
                
                // If more pending, continue processing
                if (this.pendingEmbeddings.length > 0) {
                    this.embeddingDebounceTimer = setTimeout(() => {
                        this.processPendingEmbeddings();
                    }, 100);
                } else {
                    // Save embeddings when done
                    this.saveEmbeddings();
                }
            } catch (error) {
                console.error('Error processing embeddings:', error);
                // Re-queue failed items
                this.pendingEmbeddings.unshift(...toProcess);
            }
        }
        
        // Debounced save to avoid excessive writes
        scheduleSave() {
            if (this.saveDebounceTimer) {
                clearTimeout(this.saveDebounceTimer);
            }
            
            this.saveDebounceTimer = setTimeout(() => {
                this.saveModels();
            }, 2000); // Save after 2 seconds of inactivity
        }
        
        // Get incremental learning stats
        getIncrementalStats() {
            const weights = Array.from(this.patternWeights.values());
            const totalPatterns = weights.length;
            const acceptedPatterns = weights.filter(w => w.accepted > 0).length;
            const avgWeight = weights.length > 0 
                ? weights.reduce((sum, w) => sum + w.weight, 0) / weights.length 
                : 0;
            const highConfidencePatterns = weights.filter(w => w.weight >= 0.7).length;
            
            return {
                totalPatterns,
                acceptedPatterns,
                avgWeight,
                highConfidencePatterns,
                pendingEmbeddings: this.pendingEmbeddings.length
            };
        }
        
        // Restore model weights from worker results
        async restoreModelWeights(model, weights) {
            if (!weights || weights.length === 0) return;
            
            for (let i = 0; i < model.layers.length && i < weights.length; i++) {
                const layerWeights = weights[i];
                if (layerWeights.length > 0) {
                    const tensors = layerWeights.map(w => tf.tensor(Array.from(w.data), w.shape));
                    model.layers[i].setWeights(tensors);
                    tensors.forEach(t => t.dispose());
                }
            }
        }
        
        // Train the models on the user's mind map data (using Web Worker)
        async train(store) {
            if (!this.isReady || this.isTraining) {
                console.log('Neural network not ready or already training');
                return false;
            }
            
            this.isTraining = true;
            this.trainingProgress = 0;
            this.emit('onTrainingStart');
            
            try {
                console.log('🧠 Preparing training data...');
                const data = await this.prepareTrainingData(store);
                
                if (!data) {
                    this.isTraining = false;
                    return false;
                }
                
                const { categoryData, connectionData, predictionData } = data;
                
                // Check if Web Workers are supported
                if (typeof Worker !== 'undefined') {
                    console.log('🧠 Training 3 models in parallel...');
                    
                    return new Promise(async (resolve) => {
                        const results = {
                            categoryWeights: null,
                            connectionWeights: null,
                            predictionWeights: null
                        };
                        
                        const progress = { category: 0, connection: 0, prediction: 0 };
                        const workers = [];
                        let completedCount = 0;
                        let expectedCount = 0;
                        
                        const updateProgress = () => {
                            // Average progress across all active models
                            const avgProgress = (progress.category + progress.connection + progress.prediction) / 3;
                            this.trainingProgress = avgProgress;
                            this.emit('onTrainingProgress', { 
                                phase: 'parallel',
                                progress: avgProgress,
                                details: progress
                            });
                        };
                        
                        const checkComplete = async () => {
                            completedCount++;
                            if (completedCount >= expectedCount) {
                                console.log('🧠 All models trained, restoring...');
                                
                                // Restore models on main thread
                                if (results.categoryWeights && this.categories.length > 1) {
                                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                                    await this.restoreModelWeights(this.categoryModel, results.categoryWeights);
                                    console.log('✓ Category model restored');
                                }
                                
                                if (results.connectionWeights) {
                                    this.connectionModel = this.buildConnectionModel();
                                    await this.restoreModelWeights(this.connectionModel, results.connectionWeights);
                                    console.log('✓ Connection model restored');
                                }
                                
                                if (results.predictionWeights) {
                                    this.predictionModel = this.buildPredictionModel();
                                    await this.restoreModelWeights(this.predictionModel, results.predictionWeights);
                                    console.log('✓ Prediction model restored');
                                }
                                
                                // Cleanup
                                workers.forEach(w => w.terminate());
                                
                                // Save models
                                await this.saveModels();
                                this.saveEmbeddings();
                                
                                this.isTraining = false;
                                this.trainingProgress = 100;
                                this.emit('onTrainingComplete', { categories: this.categories });
                                
                                console.log('✓ Parallel training complete!');
                                resolve(true);
                            }
                        };
                        
                        const createWorkerHandler = (modelType) => {
                            const worker = createModelWorker(modelType);
                            workers.push(worker);
                            
                            worker.onmessage = async (e) => {
                                const { type, modelType: mt, progress: p, weights, error } = e.data;
                                
                                if (type === 'ready') {
                                    // Send training data based on model type
                                    let trainingData;
                                    if (mt === 'category' || modelType === 'category') {
                                        trainingData = { 
                                            inputs: categoryData.inputs, 
                                            outputs: categoryData.outputs,
                                            numCategories: this.categories.length 
                                        };
                                    } else if (mt === 'connection' || modelType === 'connection') {
                                        trainingData = { 
                                            inputs: connectionData.inputs, 
                                            outputs: connectionData.outputs 
                                        };
                                    } else {
                                        trainingData = { 
                                            inputs: predictionData.inputs, 
                                            outputs: predictionData.outputs 
                                        };
                                    }
                                    
                                    worker.postMessage({
                                        type: 'train',
                                        modelType,
                                        data: trainingData,
                                        config: {
                                            epochs: CONFIG.NEURAL_NET.epochs,
                                            batchSize: CONFIG.NEURAL_NET.batchSize,
                                            hiddenUnits: CONFIG.NEURAL_NET.hiddenUnits,
                                            learningRate: CONFIG.NEURAL_NET.learningRate
                                        }
                                    });
                                } else if (type === 'progress') {
                                    progress[modelType] = p;
                                    updateProgress();
                                } else if (type === 'complete') {
                                    if (weights) {
                                        results[modelType + 'Weights'] = weights;
                                    }
                                    await checkComplete();
                                } else if (type === 'error') {
                                    console.error(`Worker ${modelType} error:`, error);
                                    await checkComplete();
                                }
                            };
                            
                            worker.onerror = async (err) => {
                                console.error(`Worker ${modelType} error:`, err);
                                await checkComplete();
                            };
                        };
                        
                        // Spawn workers for models that have enough data
                        if (this.categories.length > 1 && categoryData.inputs.length > 0) {
                            expectedCount++;
                            createWorkerHandler('category');
                        }
                        
                        if (connectionData.inputs.length > 10) {
                            expectedCount++;
                            createWorkerHandler('connection');
                        }
                        
                        if (predictionData.inputs.length > 5) {
                            expectedCount++;
                            createWorkerHandler('prediction');
                        }
                        
                        // If no models to train, resolve immediately
                        if (expectedCount === 0) {
                            this.isTraining = false;
                            resolve(false);
                        }
                    });
                } else {
                    // Fallback to main thread training (old method)
                    console.log('🧠 Training on main thread (Web Workers not supported)...');
                    return this.trainOnMainThread(categoryData, connectionData, predictionData);
                }
                
            } catch (error) {
                console.error('Training error:', error);
                this.isTraining = false;
                return false;
            }
        }
        
        // Fallback: Train on main thread if Web Workers aren't available
        async trainOnMainThread(categoryData, connectionData, predictionData) {
            try {
                // Train category model (0-33%)
                if (this.categories.length > 1 && categoryData.inputs.length > 0) {
                    console.log(`🧠 Training category model (${this.categories.length} categories)...`);
                    
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    
                    const xs = tf.tensor2d(categoryData.inputs);
                    const ys = tf.tensor2d(categoryData.outputs);
                    
                    await this.categoryModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'category',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                                // Yield to UI
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Category model trained');
                }
                
                // Train connection model (33-66%)
                if (connectionData.inputs.length > 10) {
                    console.log(`🧠 Training connection model (${connectionData.inputs.length} pairs)...`);
                    
                    this.connectionModel = this.buildConnectionModel();
                    
                    const xs = tf.tensor2d(connectionData.inputs);
                    const ys = tf.tensor2d(connectionData.outputs);
                    
                    await this.connectionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: CONFIG.NEURAL_NET.batchSize,
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = 33 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 33;
                                this.emit('onTrainingProgress', {
                                    phase: 'connection',
                                    progress: this.trainingProgress,
                                    accuracy: logs.acc,
                                    loss: logs.loss
                                });
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Connection model trained');
                }
                
                // Train prediction model (66-100%)
                if (predictionData.inputs.length > 5) {
                    console.log(`🧠 Training prediction model (${predictionData.inputs.length} parent-child pairs)...`);
                    
                    this.predictionModel = this.buildPredictionModel();
                    
                    const xs = tf.tensor2d(predictionData.inputs);
                    const ys = tf.tensor2d(predictionData.outputs);
                    
                    await this.predictionModel.fit(xs, ys, {
                        epochs: CONFIG.NEURAL_NET.epochs,
                        batchSize: Math.min(CONFIG.NEURAL_NET.batchSize, predictionData.inputs.length),
                        validationSplit: 0.2,
                        shuffle: true,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                this.trainingProgress = 66 + ((epoch + 1) / CONFIG.NEURAL_NET.epochs) * 34;
                                this.emit('onTrainingProgress', {
                                    phase: 'prediction',
                                    progress: this.trainingProgress,
                                    loss: logs.loss
                                });
                                await tf.nextFrame();
                            }
                        }
                    });
                    
                    xs.dispose();
                    ys.dispose();
                    console.log('✓ Prediction model trained');
                }
                
                // Save models
                await this.saveModels();
                this.saveEmbeddings();
                
                this.isTraining = false;
                this.trainingProgress = 100;
                this.emit('onTrainingComplete', { categories: this.categories });
                
                console.log('✓ Training complete!');
                return true;
                
            } catch (error) {
                console.error('Training error:', error);
                this.isTraining = false;
                return false;
            }
        }
        
        // Predict the best category for new text
        async predictCategory(text) {
            if (!this.categoryModel || !this.encoder) return null;
            
            try {
                const embedding = await this.getEmbedding(text);
                if (!embedding) return null;
                
                const input = tf.tensor2d([embedding]);
                const prediction = this.categoryModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                // Get top predictions
                const results = this.categories.map((cat, i) => ({
                    category: cat,
                    confidence: probs[0][i]
                })).sort((a, b) => b.confidence - a.confidence);
                
                this.emit('onPrediction', { type: 'category', results });
                return results;
                
            } catch (error) {
                console.error('Category prediction error:', error);
                return null;
            }
        }
        
        // Find semantically similar nodes to a given text
        async findSimilarNodes(text, store, maxResults = 5) {
            if (!this.encoder) return [];
            
            try {
                const queryEmbedding = await this.getEmbedding(text);
                if (!queryEmbedding) return [];
                
                const allNodes = store.getAllNodes();
                const similarities = [];
                
                for (const node of allNodes) {
                    if (node.id === store.data.id) continue; // Skip root
                    
                    // Try to get cached embedding or compute new one
                    let nodeEmbedding = this.embeddings.get(node.label);
                    
                    if (!nodeEmbedding) {
                        // Check if we have embedding for label + description
                        const fullText = node.description 
                            ? `${node.label}: ${node.description}` 
                            : node.label;
                        nodeEmbedding = this.embeddings.get(fullText);
                    }
                    
                    // If we still don't have embedding, use the label's cached embedding
                    if (!nodeEmbedding) {
                        nodeEmbedding = this.embeddings.get(node.label.toLowerCase());
                    }
                    
                    if (nodeEmbedding) {
                        const similarity = this.cosineSimilarity(queryEmbedding, nodeEmbedding);
                        if (similarity > 0.2) { // Threshold for relevance
                            similarities.push({
                                nodeId: node.id,
                                label: node.label,
                                similarity: similarity
                            });
                        }
                    }
                }
                
                // Sort by similarity and return top results
                return similarities
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, maxResults);
                
            } catch (error) {
                console.error('Find similar nodes error:', error);
                return [];
            }
        }
        
        // Predict connection strength between two nodes
        async predictConnection(text1, text2) {
            if (!this.connectionModel || !this.encoder) return null;
            
            try {
                const [emb1, emb2] = await Promise.all([
                    this.getEmbedding(text1),
                    this.getEmbedding(text2)
                ]);
                
                if (!emb1 || !emb2) return null;
                
                const combined = [...emb1, ...emb2];
                const input = tf.tensor2d([combined]);
                const prediction = this.connectionModel.predict(input);
                const probs = await prediction.array();
                
                input.dispose();
                prediction.dispose();
                
                const result = {
                    shouldConnect: probs[0][0],
                    isParentChild: probs[0][1],
                    isSibling: probs[0][2],
                    isRelated: probs[0][3]
                };
                
                this.emit('onPrediction', { type: 'connection', result });
                return result;
                
            } catch (error) {
                console.error('Connection prediction error:', error);
                return null;
            }
        }
        
        // Find suggested connections for a node
        async suggestConnections(nodeText, store, maxSuggestions = 5) {
            if (!this.connectionModel) return [];
            
            const suggestions = [];
            const nodeEmbedding = await this.getEmbedding(nodeText);
            if (!nodeEmbedding) return [];
            
            // Get all nodes
            const allNodes = [];
            const collectNodes = (node, depth = 0) => {
                if (depth > 0) {
                    allNodes.push({
                        id: node.id,
                        label: node.label,
                        text: node.description ? `${node.label}. ${node.description}` : node.label
                    });
                }
                node.children?.forEach(child => collectNodes(child, depth + 1));
            };
            collectNodes(store.data);
            
            // Check connection with each node
            for (const other of allNodes) {
                const prediction = await this.predictConnection(nodeText, other.text);
                if (prediction && prediction.isRelated > 0.6) {
                    suggestions.push({
                        nodeId: other.id,
                        label: other.label,
                        ...prediction
                    });
                }
            }
            
            // Sort by relatedness and return top suggestions
            return suggestions
                .sort((a, b) => b.isRelated - a.isRelated)
                .slice(0, maxSuggestions);
        }
        
        // Predict likely children for a node using neural network + patterns
        async predictChildren(nodeText, existingChildren = [], maxSuggestions = 5) {
            const suggestions = [];
            
            // Method 1: Pattern-based suggestions with learned weights (fast)
            const normalizedLabel = this.normalizeLabel(nodeText);
            
            // Check for exact and partial pattern matches
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    children.forEach(child => {
                        const normalizedChild = this.normalizeLabel(child);
                        // Skip if already exists
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedChild)) {
                            // Get learned weight for this specific pattern
                            const patternWeight = this.getPatternWeight(pattern, child);
                            
                            const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedChild);
                            if (existing) {
                                existing.confidence += patternWeight * 0.4;
                                existing.sources.push('pattern');
                            } else {
                                suggestions.push({
                                    label: child,
                                    confidence: patternWeight,
                                    sources: ['pattern'],
                                    type: 'learned'
                                });
                            }
                        }
                    });
                }
            }
            
            // Method 2: Common pattern suggestions
            this.commonPatterns.forEach(pattern => {
                if (!existingChildren.some(e => this.normalizeLabel(e) === pattern)) {
                    const existing = suggestions.find(s => this.normalizeLabel(s.label) === pattern);
                    if (existing) {
                        existing.confidence += 0.1;
                        existing.sources.push('common');
                    } else {
                        suggestions.push({
                            label: pattern,
                            confidence: 0.3,
                            sources: ['common'],
                            type: 'common'
                        });
                    }
                }
            });
            
            // Method 2.5: Analogous patterns by relationship type (transfer learning)
            // If we have existing children, analyze what relationship types are established
            // and suggest patterns that follow the same structure from other domains
            if (existingChildren.length > 0 && suggestions.length < maxSuggestions) {
                try {
                    // Classify relationship type of first existing child
                    const sampleChild = existingChildren[0];
                    const classification = relationshipClassifier.classifyByHeuristics(nodeText, sampleChild);
                    
                    if (classification.type !== 'unknown' && classification.confidence >= 0.4) {
                        // Find patterns with same relationship type from other domains
                        const analogous = this.findAnalogousByType(classification.type, normalizedLabel, existingChildren);
                        
                        analogous.forEach(pattern => {
                            const normalizedChild = this.normalizeLabel(pattern.childLabel);
                            if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedChild)) {
                                const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedChild);
                                if (existing) {
                                    existing.confidence += pattern.transferScore * 0.3;
                                    existing.sources.push('analogous');
                                    existing.relationshipType = classification.type;
                                } else {
                                    suggestions.push({
                                        label: pattern.childLabel,
                                        confidence: pattern.transferScore,
                                        sources: ['analogous'],
                                        type: 'transfer',
                                        relationshipType: classification.type,
                                        analogousTo: pattern.fromParent
                                    });
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Analogous pattern error:', error);
                }
            }
            
            // Method 2.75: Concept abstraction - structural schema transfer
            // Find patterns from semantically similar parents (e.g., "Goals" ≈ "Projects")
            if (suggestions.length < maxSuggestions) {
                try {
                    // Get structural analogs based on abstract role
                    const structuralAnalogs = await conceptAbstractor.findStructuralAnalogs(
                        nodeText, 
                        existingChildren, 
                        Math.max(2, maxSuggestions - suggestions.length)
                    );
                    
                    for (const analog of structuralAnalogs) {
                        const normalizedAnalog = this.normalizeLabel(analog.label);
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedAnalog)) {
                            const existing = suggestions.find(s => this.normalizeLabel(s.label) === normalizedAnalog);
                            if (existing) {
                                existing.confidence += analog.confidence * 0.25;
                                existing.sources.push('schema');
                            } else {
                                suggestions.push({
                                    label: analog.label,
                                    confidence: analog.confidence,
                                    sources: ['schema'],
                                    type: 'structural',
                                    schemaRole: analog.schemaRole,
                                    fromParent: analog.fromParent
                                });
                            }
                        }
                    }
                    
                    // Also get role-based suggestions (typical children for this type of parent)
                    const roleSuggestions = await conceptAbstractor.getSuggestionsByRole(
                        nodeText,
                        existingChildren,
                        2
                    );
                    
                    for (const suggestion of roleSuggestions) {
                        const normalizedSugg = this.normalizeLabel(suggestion.label);
                        if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedSugg) &&
                            !suggestions.some(s => this.normalizeLabel(s.label) === normalizedSugg)) {
                            suggestions.push({
                                label: suggestion.label,
                                confidence: suggestion.confidence,
                                sources: ['role'],
                                type: 'role_typical',
                                role: suggestion.role
                            });
                        }
                    }
                } catch (error) {
                    console.error('Concept abstraction error:', error);
                }
            }
            
            // Method 3: Neural network prediction (find similar nodes)
            if (this.predictionModel && this.encoder) {
                try {
                    const parentEmbedding = await this.getEmbedding(nodeText);
                    if (parentEmbedding) {
                        // Predict the "expected child centroid"
                        const input = tf.tensor2d([parentEmbedding]);
                        const prediction = this.predictionModel.predict(input);
                        const predictedCentroid = await prediction.array();
                        
                        input.dispose();
                        prediction.dispose();
                        
                        // Find cached embeddings closest to the predicted centroid
                        const similarities = [];
                        for (const [text, embedding] of this.embeddings) {
                            const similarity = this.cosineSimilarity(predictedCentroid[0], embedding);
                            if (similarity > 0.5) {
                                similarities.push({ text, similarity });
                            }
                        }
                        
                        // Get top similar texts as suggestions
                        similarities
                            .sort((a, b) => b.similarity - a.similarity)
                            .slice(0, 5)
                            .forEach(s => {
                                const normalizedText = this.normalizeLabel(s.text);
                                if (!existingChildren.some(e => this.normalizeLabel(e) === normalizedText)) {
                                    const existing = suggestions.find(sg => this.normalizeLabel(sg.label) === normalizedText);
                                    if (existing) {
                                        existing.confidence += s.similarity * 0.3;
                                        existing.sources.push('neural');
                                    } else {
                                        suggestions.push({
                                            label: s.text.split('.')[0], // Get just the label part
                                            confidence: s.similarity * 0.4,
                                            sources: ['neural'],
                                            type: 'neural'
                                        });
                                    }
                                }
                            });
                    }
                } catch (error) {
                    console.error('Neural prediction error:', error);
                }
            }
            
            // Sort by confidence and return top suggestions
            const results = suggestions
                .sort((a, b) => b.confidence - a.confidence)
                .slice(0, maxSuggestions)
                .map(s => ({
                    ...s,
                    confidence: Math.min(s.confidence, 1.0)
                }));
            
            this.emit('onSuggestion', { type: 'children', results });
            return results;
        }
        
        // Calculate cosine similarity between two vectors
        cosineSimilarity(a, b) {
            if (a.length !== b.length) return 0;
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < a.length; i++) {
                dotProduct += a[i] * b[i];
                normA += a[i] * a[i];
                normB += b[i] * b[i];
            }
            
            const denominator = Math.sqrt(normA) * Math.sqrt(normB);
            return denominator === 0 ? 0 : dotProduct / denominator;
        }
        
        // Get suggestions for a specific node (combines all methods)
        async getSuggestionsForNode(node, store) {
            const suggestions = {
                children: [],
                hasML: false,
                hasPatterns: false
            };
            
            if (!this.isReady) return suggestions;
            
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            const existingChildren = (node.children || []).map(c => c.label);
            
            // Get prediction-based suggestions
            const childSuggestions = await this.predictChildren(nodeText, existingChildren);
            
            if (childSuggestions.length > 0) {
                suggestions.children = childSuggestions;
                suggestions.hasML = childSuggestions.some(s => s.sources.includes('neural'));
                suggestions.hasPatterns = childSuggestions.some(s => 
                    s.sources.includes('pattern') || s.sources.includes('common')
                );
            }
            
            return suggestions;
        }
        
        // Check if a node has strong suggestions (for UI indicator)
        async hasStrongSuggestions(node) {
            if (!this.isReady || this.expansionPatterns.size === 0) return false;
            
            const normalizedLabel = this.normalizeLabel(node.label);
            const existingChildren = (node.children || []).map(c => this.normalizeLabel(c.label));
            
            // Quick check against patterns
            for (const [pattern, children] of this.expansionPatterns) {
                if (normalizedLabel.includes(pattern) || pattern.includes(normalizedLabel)) {
                    // Check if there are un-added children
                    const newChildren = children.filter(c => 
                        !existingChildren.includes(this.normalizeLabel(c))
                    );
                    if (newChildren.length > 0) return true;
                }
            }
            
            return false;
        }
        
        // Generate AI-enhanced child suggestions using Claude
        async generateSmartSuggestions(node, store) {
            const nodeText = node.description 
                ? `${node.label}. ${node.description}`
                : node.label;
            
            // Get our ML predictions first
            const existingChildren = (node.children || []).map(c => c.label);
            const mlSuggestions = await this.predictChildren(nodeText, existingChildren, 2);
            
            // Get path context
            const path = store.getPath(node.id);
            const pathStr = path.map(n => n.label).join(' → ');
            const pathLabels = path.map(n => n.label);
            
            // Get user preference insights
            const preferenceInsights = preferenceTracker.getPromptInsights();
            
            // Get relevant semantic memories
            const memoryInsights = await semanticMemory.getPromptMemories(node.label, pathLabels, 3);
            
            // Get user profile insights
            const profileInsights = userProfile.getPromptInsights();
            
            // Analyze relationship types in existing structure
            let relationshipInsights = null;
            if (existingChildren.length > 0) {
                const typeCount = {};
                for (const child of existingChildren.slice(0, 5)) {
                    const classification = relationshipClassifier.classifyByHeuristics(node.label, child);
                    if (classification.type !== 'unknown' && classification.confidence >= 0.4) {
                        typeCount[classification.type] = (typeCount[classification.type] || 0) + 1;
                    }
                }
                
                const dominantTypes = Object.entries(typeCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2)
                    .map(([type]) => relationshipClassifier.getTypeDescription(type));
                
                if (dominantTypes.length > 0) {
                    relationshipInsights = `Current structure pattern: ${dominantTypes.join(', ')}`;
                }
            }
            
            // Get concept abstraction insights
            const conceptInsights = await conceptAbstractor.getPromptInsights(node.label, pathLabels);
            
            // Get meta-learner insights (how user thinks)
            const metaInsights = metaLearner.getPromptInsights();
            
            // Build semantic context string
            let semanticContext = '';
            if (mlSuggestions.length > 0) {
                semanticContext += `LEARNED PATTERNS suggest:\n${mlSuggestions.map(s => `- ${s.label} (${Math.round(s.confidence * 100)}% confidence)`).join('\n')}\n\n`;
            }
            if (relationshipInsights) semanticContext += `STRUCTURE: ${relationshipInsights}\n`;
            if (conceptInsights) semanticContext += `ABSTRACTION: ${conceptInsights}\n`;
            if (preferenceInsights) semanticContext += `USER PREFERENCES:\n${preferenceInsights}\n`;
            if (metaInsights) semanticContext += `THINKING STYLE:\n${metaInsights}\n`;
            if (memoryInsights) semanticContext += `RELEVANT MEMORIES:\n${memoryInsights}\n`;
            
            try {
                // Use unified Claude API helper (Edge Function when authenticated)
                const result = await callClaudeAPI({
                    type: 'smart-expand',
                    nodeLabel: node.label,
                    nodeDescription: node.description || '',
                    pathContext: pathStr,
                    existingChildren: existingChildren.join(', '),
                    userProfile: profileInsights ? { summary: profileInsights } : null,
                    semanticContext: semanticContext
                });
                
                if (result.success && result.suggestions) {
                    // Enforce max 4 suggestions
                    const suggestions = result.suggestions.slice(0, 4);
                    return {
                        mlSuggestions,
                        aiSuggestions: suggestions,
                        combined: true
                    };
                }
                
                return { mlSuggestions, aiSuggestions: [], combined: false };
                
            } catch (error) {
                console.error('Smart suggestions error:', error);
                return { mlSuggestions, aiSuggestions: [], combined: false };
            }
        }
        
        // Use Claude to enhance predictions with semantic analysis
        async enhanceWithClaude(text, store) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) return null;
            
            try {
                // Get category predictions from our model first
                const categoryPredictions = await this.predictCategory(text);
                
                // Get current structure summary
                const categories = this.categories.join(', ');
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `You are helping categorize content for a personal mind map.

EXISTING CATEGORIES: ${categories}

NEW CONTENT: "${text}"

${categoryPredictions ? `LOCAL MODEL PREDICTIONS (confidence scores):
${categoryPredictions.slice(0, 3).map(p => `- ${p.category}: ${(p.probability * 100).toFixed(1)}%`).join('\n')}` : ''}

Analyze this content and provide:
1. The best matching existing category (or suggest a new one if none fit)
2. Suggested parent node within that category
3. Related concepts that could be sibling nodes
4. A brief reasoning for your categorization

Return as JSON:
{
  "category": "Category Name",
  "confidence": 0.0-1.0,
  "suggestedParent": "Parent Node Name",
  "relatedConcepts": ["concept1", "concept2"],
  "reasoning": "Brief explanation"
}`
                        }]
                    })
                });
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                const text_response = data.content[0].text;
                
                // Parse JSON from response
                const jsonMatch = text_response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    return JSON.parse(jsonMatch[0]);
                }
                
                return null;
                
            } catch (error) {
                console.error('Claude enhancement error:', error);
                return null;
            }
        }
        
        // Save models to IndexedDB (full precision, all models)
        async saveModels() {
            try {
                const modelData = {
                    version: 3, // Bump version for new format
                    savedAt: Date.now(),
                    categories: this.categories,
                    commonPatterns: this.commonPatterns,
                    expansionPatterns: Array.from(this.expansionPatterns.entries()),
                    patternWeights: Array.from(this.patternWeights.entries()) // Incremental learning weights
                };
                
                // Helper to extract weights from a model
                const extractWeights = async (model) => {
                    if (!model) return null;
                    const weights = [];
                    for (const layer of model.layers) {
                        const layerWeights = layer.getWeights();
                        const extracted = [];
                        for (const w of layerWeights) {
                            const data = await w.data();
                            extracted.push({
                                shape: w.shape,
                                data: Array.from(data) // Full precision
                            });
                        }
                        weights.push(extracted);
                    }
                    return weights;
                };
                
                // Save all models with full precision
                modelData.categoryWeights = await extractWeights(this.categoryModel);
                modelData.connectionWeights = await extractWeights(this.connectionModel);
                modelData.predictionWeights = await extractWeights(this.predictionModel);
                
                // Save to IndexedDB
                const success = await NeuralDB.save('neural-models', modelData);
                
                if (success) {
                    const sizeKB = JSON.stringify(modelData).length / 1024;
                    console.log(`✓ Models saved to IndexedDB (${sizeKB.toFixed(1)}KB) - all 3 models with full precision`);
                } else {
                    console.warn('⚠️ Failed to save models to IndexedDB');
                }
                
                // Clean up old localStorage data if present
                try {
                    if (localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY)) {
                        localStorage.removeItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                        console.log('✓ Cleaned up old localStorage model data');
                    }
                } catch (e) {}
                
            } catch (error) {
                console.error('Failed to save models:', error);
            }
        }
        
        // Load models from IndexedDB
        async loadModels() {
            try {
                // Try IndexedDB first
                let modelData = await NeuralDB.load('neural-models');
                
                // Fallback to localStorage for migration
                if (!modelData) {
                    const saved = localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                    if (saved) {
                        console.log('📦 Migrating model data from localStorage to IndexedDB...');
                        modelData = JSON.parse(saved);
                    }
                }
                
                if (!modelData) return false;
                
                this.categories = modelData.categories || [];
                this.commonPatterns = modelData.commonPatterns || [];
                
                // Load expansion patterns
                if (modelData.expansionPatterns) {
                    this.expansionPatterns = new Map(modelData.expansionPatterns);
                    console.log(`✓ Loaded ${this.expansionPatterns.size} expansion patterns`);
                }
                
                // Load pattern weights (incremental learning data)
                if (modelData.patternWeights) {
                    this.patternWeights = new Map(modelData.patternWeights);
                    console.log(`✓ Loaded ${this.patternWeights.size} pattern weights`);
                }
                
                // Helper to restore weights to a model
                const restoreWeights = (model, savedWeights) => {
                    if (!model || !savedWeights) return false;
                    let layerIndex = 0;
                    for (const layer of model.layers) {
                        const layerWeights = savedWeights[layerIndex];
                        if (layerWeights && layerWeights.length > 0) {
                            const tensors = layerWeights.map(w => 
                                tf.tensor(w.data, w.shape)
                            );
                            layer.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                        }
                        layerIndex++;
                    }
                    return true;
                };
                
                // Restore category model
                if (modelData.categoryWeights && this.categories.length > 0) {
                    this.categoryModel = this.buildCategoryModel(this.categories.length);
                    restoreWeights(this.categoryModel, modelData.categoryWeights);
                    console.log('✓ Category model loaded from IndexedDB');
                }
                
                // Restore connection model
                if (modelData.connectionWeights) {
                    this.connectionModel = this.buildConnectionModel();
                    restoreWeights(this.connectionModel, modelData.connectionWeights);
                    console.log('✓ Connection model loaded from IndexedDB');
                }
                
                // Restore prediction model
                if (modelData.predictionWeights) {
                    this.predictionModel = this.buildPredictionModel();
                    restoreWeights(this.predictionModel, modelData.predictionWeights);
                    console.log('✓ Prediction model loaded from IndexedDB');
                }
                
                // If we migrated from localStorage, save to IndexedDB and clean up
                if (!modelData.version) {
                    console.log('📦 Saving migrated data to IndexedDB...');
                    await this.saveModels();
                }
                
                const savedAt = modelData.savedAt ? new Date(modelData.savedAt).toLocaleString() : 'unknown';
                console.log(`✓ Neural network restored (last saved: ${savedAt})`);
                
                return true;
                
            } catch (error) {
                console.error('Failed to load models:', error);
                return false;
            }
        }
        
        // Save embeddings cache to IndexedDB
        async saveEmbeddings() {
            try {
                const data = {};
                this.embeddings.forEach((value, key) => {
                    data[key] = value;
                });
                await NeuralDB.save('embeddings', data);
            } catch (error) {
                console.error('Failed to save embeddings:', error);
            }
        }
        
        // Load embeddings cache from IndexedDB
        async loadEmbeddings() {
            try {
                // Try IndexedDB first
                let data = await NeuralDB.load('embeddings');
                
                // Fallback to localStorage
                if (!data) {
                    const saved = localStorage.getItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
                    if (saved) {
                        data = JSON.parse(saved);
                    }
                }
                
                if (data) {
                    Object.keys(data).forEach(key => {
                        this.embeddings.set(key, data[key]);
                    });
                    console.log(`✓ Loaded ${this.embeddings.size} cached embeddings`);
                }
            } catch (error) {
                console.error('Failed to load embeddings:', error);
            }
        }
        
        // Get model statistics
        getStats() {
            const incrementalStats = this.getIncrementalStats();
            return {
                isReady: this.isReady,
                isTraining: this.isTraining,
                trainingProgress: this.trainingProgress,
                categories: this.categories,
                hasCategoryModel: !!this.categoryModel,
                hasConnectionModel: !!this.connectionModel,
                hasPredictionModel: !!this.predictionModel,
                expansionPatterns: this.expansionPatterns.size,
                commonPatterns: this.commonPatterns.length,
                cachedEmbeddings: this.embeddings.size,
                loadError: this.loadError || null,
                // Incremental learning stats
                patternWeights: this.patternWeights.size,
                highConfidencePatterns: incrementalStats.highConfidencePatterns,
                avgPatternWeight: incrementalStats.avgWeight,
                pendingEmbeddings: incrementalStats.pendingEmbeddings
            };
        }
        
        // Clear all learned data
        async reset() {
            if (this.categoryModel) {
                this.categoryModel.dispose();
                this.categoryModel = null;
            }
            if (this.connectionModel) {
                this.connectionModel.dispose();
                this.connectionModel = null;
            }
            if (this.predictionModel) {
                this.predictionModel.dispose();
                this.predictionModel = null;
            }
            this.categories = [];
            this.commonPatterns = [];
            this.expansionPatterns.clear();
            this.patternWeights.clear(); // Clear incremental learning weights
            this.embeddings.clear();
            this.pendingEmbeddings = [];
            
            // Clear IndexedDB
            await NeuralDB.delete('neural-models');
            await NeuralDB.delete('embeddings');
            
            // Clean up old localStorage entries
            try {
                localStorage.removeItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                localStorage.removeItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
            } catch (e) {}
            
            console.log('✓ Neural network reset (IndexedDB and localStorage cleared)');
        }
    }
    
    // Global neural network instance
    const neuralNet = new PersonalNeuralNet();
    
    // ═══════════════════════════════════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════
    const Utils = {
        // Smoother easing functions for transitions
        easing: {
            smoothStep: t => t * t * (3 - 2 * t),
            smootherStep: t => t * t * t * (t * (t * 6 - 15) + 10),
            outCubic: t => 1 - Math.pow(1 - t, 3),
            outQuart: t => 1 - Math.pow(1 - t, 4)
        },
        
        // Check if theme is dark
        isDarkTheme() {
            const theme = document.documentElement.getAttribute('data-theme') || 'coral';
            return ['obsidian'].includes(theme);
        }
    };
    
    // Get colors based on current theme
    function getThemeColors() {
        const theme = document.documentElement.getAttribute('data-theme') || 'coral';
        return CONFIG.THEME_COLORS[theme] || CONFIG.THEME_COLORS.sandstone;
    }
    
    // Map a color from one palette to another by index
    function remapColor(color, fromPalette, toPalette) {
        const index = fromPalette.findIndex(c => c.toLowerCase() === color.toLowerCase());
        if (index >= 0 && index < toPalette.length) {
            return toPalette[index];
        }
        // If not found in palette, return null to signal we need special handling
        return null;
    }
    
    // Update all node colors for theme change
    function updateNodeColorsForTheme(oldTheme, newTheme) {
        const fromPalette = CONFIG.THEME_COLORS[oldTheme] || CONFIG.THEME_COLORS.coral;
        const toPalette = CONFIG.THEME_COLORS[newTheme] || CONFIG.THEME_COLORS.coral;
        
        if (typeof nodes === 'undefined' || !nodes) return;
        
        // First pass: build a map of old colors to new colors
        // This ensures nodes with the same old color get the same new color
        const colorMap = new Map();
        let unmappedColorIndex = 1; // Start at 1 to skip root color
        
        nodes.forEach((mesh) => {
            const oldColor = mesh.userData.color?.toLowerCase();
            if (!oldColor || colorMap.has(oldColor)) return;
            
            // Try to find exact match in palette
            const mappedColor = remapColor(mesh.userData.color, fromPalette, toPalette);
            if (mappedColor) {
                colorMap.set(oldColor, mappedColor);
            } else {
                // Assign next available color from new palette (skipping root color at index 0)
                colorMap.set(oldColor, toPalette[unmappedColorIndex % toPalette.length]);
                unmappedColorIndex++;
                // Reset to 1 if we've gone through all colors (skip 0 which is root)
                if (unmappedColorIndex >= toPalette.length) unmappedColorIndex = 1;
            }
        });
        
        // Second pass: apply the color mapping
        nodes.forEach((mesh) => {
            let newColor;
            
            // Root node always gets the first color of the new palette
            if (mesh.userData.id === 'mynd') {
                newColor = toPalette[0];
            } else {
                const oldColor = mesh.userData.color?.toLowerCase();
                newColor = colorMap.get(oldColor) || toPalette[1];
            }
            
            // Always update colors when switching themes
            mesh.userData.color = newColor;
            mesh.material.color.set(newColor);
            mesh.material.emissive.set(newColor);
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            // Update connection line color
            if (mesh.userData.connectionLine) {
                mesh.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update stored data
            store.updateNode(mesh.userData.id, { color: newColor });
        });
        
        // Also update label colors if switching between light/dark themes
        const wasLight = !['obsidian'].includes(oldTheme);
        const isLight = !['obsidian'].includes(newTheme);
        if (wasLight !== isLight) {
            updateLabelsForTheme();
        }
    }
    
    // Update color pickers for current theme
    function updateColorPickers() {
        const colors = getThemeColors();
        const colorGrid = document.getElementById('color-grid');
        const infoColorPicker = document.getElementById('info-color-picker');
        
        if (colorGrid) {
            colorGrid.innerHTML = colors.map(color => 
                `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
            ).join('');
        }
        
        if (infoColorPicker) {
            infoColorPicker.innerHTML = colors.slice(0, 12).map(color => 
                `<span style="background:${color}" data-color="${color}"></span>`
            ).join('');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // EVENT BUS
    // ═══════════════════════════════════════════════════════════════════
    class EventBus {
        constructor() { this.listeners = new Map(); }
        on(event, cb) { 
            if (!this.listeners.has(event)) this.listeners.set(event, new Set()); 
            this.listeners.get(event).add(cb); 
            return () => this.off(event, cb); 
        }
        off(event, cb) { this.listeners.get(event)?.delete(cb); }
        emit(event, data) { this.listeners.get(event)?.forEach(cb => cb(data)); }
    }
    const bus = new EventBus();

    // ═══════════════════════════════════════════════════════════════════
    // DATA STORE
    // ═══════════════════════════════════════════════════════════════════
    const defaultData = {
        id: 'mynd',
        label: 'My Mind',
        color: '#A8D5E5',
        description: '',
        children: []
    };

    class Store {
        constructor() {
            this.data = this.load();
            this.selectedNodeId = null;
            this.expandedNodes = new Set();
            this.undoStack = [];
            this.maxUndoSteps = 50;
        }
        
        load() {
            try {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate basic structure
                    if (parsed && parsed.id && parsed.label) {
                        return parsed;
                    }
                    console.warn('Invalid saved data structure, using defaults');
                }
            } catch (e) {
                console.warn('Failed to parse saved data, using defaults:', e.message);
            }
            return JSON.parse(JSON.stringify(defaultData));
        }
        
        save() {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.data));
                bus.emit('data:saved');
                
                // Sync to cloud (debounced)
                if (SupabaseSync.syncEnabled) {
                    SupabaseSync.scheduleSave(this.exportData(), this.data?.label || 'My Mind');
                }
            } catch (e) {
                console.warn('Failed to save data:', e.message);
            }
        }
        
        saveSnapshot(name = 'change') {
            this.undoStack.push({
                data: JSON.parse(JSON.stringify(this.data)),
                expandedNodes: new Set(this.expandedNodes),
                actionName: name
            });
            if (this.undoStack.length > this.maxUndoSteps) this.undoStack.shift();
            bus.emit('undo:changed');
        }
        
        undo() {
            if (this.undoStack.length === 0) return { success: false };
            const snapshot = this.undoStack.pop();
            this.data = snapshot.data;
            this.expandedNodes = snapshot.expandedNodes;
            this.save();
            bus.emit('data:undone', { actionName: snapshot.actionName });
            bus.emit('undo:changed');
            return { success: true, actionName: snapshot.actionName };
        }
        
        canUndo() {
            return this.undoStack.length > 0;
        }
        
        findNode(id, node = this.data) {
            if (node.id === id) return node;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findNode(id, child);
                    if (found) return found;
                }
            }
            return null;
        }
        
        findParent(id, node = this.data, parent = null) {
            if (node.id === id) return parent;
            if (node.children) {
                for (const child of node.children) {
                    const found = this.findParent(id, child, node);
                    if (found !== undefined) return found;
                }
            }
            return undefined;
        }
        
        getPath(id) {
            const path = [];
            const build = (node, target, current = []) => {
                current.push(node);
                if (node.id === target) {
                    path.push(...current);
                    return true;
                }
                if (node.children) {
                    for (const child of node.children) {
                        if (build(child, target, [...current])) return true;
                    }
                }
                return false;
            };
            build(this.data, id);
            return path;
        }
        
        getAllNodes(node = this.data, result = []) {
            result.push(node);
            if (node.children) {
                node.children.forEach(c => this.getAllNodes(c, result));
            }
            return result;
        }
        
        searchNodes(query) {
            const q = query.toLowerCase();
            return this.getAllNodes().filter(n => 
                n.label.toLowerCase().includes(q) || 
                (n.description && n.description.toLowerCase().includes(q))
            );
        }
        
        addNode(parentId, nodeData) {
            const parent = this.findNode(parentId);
            if (!parent) return null;
            
            this.saveSnapshot('Add node');
            if (!parent.children) parent.children = [];
            
            const newNode = {
                id: nodeData.id || `node-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                label: nodeData.label || 'New Node',
                color: nodeData.color || parent.color,
                description: nodeData.description || '',
                source: nodeData.source || 'user',
                createdAt: nodeData.createdAt || new Date().toISOString(),
                children: []
            };
            
            // Include link data if present
            if (nodeData.link) {
                newNode.link = nodeData.link;
                newNode.source = nodeData.source || 'link';
            }
            
            // Include importance if specified
            if (nodeData.importance) {
                newNode.importance = nodeData.importance;
            }
            
            parent.children.push(newNode);
            this.expandedNodes.add(parentId);
            this.save();
            bus.emit('node:added', { parent, node: newNode });
            return newNode;
        }
        
        updateNode(id, updates) {
            const node = this.findNode(id);
            if (!node) return null;
            
            this.saveSnapshot('Edit node');
            Object.assign(node, updates);
            this.save();
            bus.emit('node:updated', { node });
            return node;
        }
        
        deleteNode(id) {
            if (id === this.data.id) return false;
            
            const parent = this.findParent(id);
            if (!parent || !parent.children) return false;
            
            const index = parent.children.findIndex(c => c.id === id);
            if (index === -1) return false;
            
            this.saveSnapshot('Delete node');
            const deleted = parent.children.splice(index, 1)[0];
            this.save();
            bus.emit('node:deleted', { parentId: parent.id, node: deleted });
            return true;
        }
        
        moveNode(nodeId, newParentId) {
            // Can't move root
            if (nodeId === this.data.id) return false;
            // Can't move to itself
            if (nodeId === newParentId) return false;
            
            const node = this.findNode(nodeId);
            const oldParent = this.findParent(nodeId);
            const newParent = this.findNode(newParentId);
            
            if (!node || !oldParent || !newParent) return false;
            
            // Can't move to a descendant
            const isDescendant = (parent, targetId) => {
                if (parent.id === targetId) return true;
                for (const child of (parent.children || [])) {
                    if (isDescendant(child, targetId)) return true;
                }
                return false;
            };
            if (isDescendant(node, newParentId)) return false;
            
            this.saveSnapshot('Move node');
            
            // Remove from old parent
            const index = oldParent.children.findIndex(c => c.id === nodeId);
            if (index === -1) return false;
            oldParent.children.splice(index, 1);
            
            // Add to new parent
            if (!newParent.children) newParent.children = [];
            newParent.children.push(node);
            
            this.save();
            bus.emit('node:moved', { nodeId, oldParentId: oldParent.id, newParentId });
            return true;
        }
        
        reset(rootLabel = 'My Mind') {
            const newData = JSON.parse(JSON.stringify(defaultData));
            newData.label = rootLabel;
            this.data = newData;
            this.expandedNodes.clear();
            this.undoStack = [];
            this.save();
            bus.emit('data:reset');
        }
        
        exportJSON() {
            // Include neural network data in export
            const exportData = {
                version: 2, // Version to identify new format
                map: this.data,
                neural: {
                    modelData: null,
                    embeddings: null
                }
            };
            
            // Get neural network data from localStorage
            try {
                const modelData = localStorage.getItem(CONFIG.NEURAL_NET.STORAGE_KEY);
                const embeddings = localStorage.getItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY);
                
                if (modelData) {
                    exportData.neural.modelData = JSON.parse(modelData);
                }
                if (embeddings) {
                    exportData.neural.embeddings = JSON.parse(embeddings);
                }
            } catch (e) {
                console.warn('Could not export neural data:', e);
            }
            
            return JSON.stringify(exportData, null, 2);
        }
        
        importJSON(json) {
            try {
                const parsed = JSON.parse(json);
                
                // Handle both old format (direct map data) and new format (with neural)
                let mapData;
                let neuralData = null;
                
                if (parsed.version === 2 && parsed.map) {
                    // New format with neural data
                    mapData = parsed.map;
                    neuralData = parsed.neural;
                } else if (parsed.id && parsed.label) {
                    // Old format - just map data
                    mapData = parsed;
                } else {
                    throw new Error('Invalid format');
                }
                
                if (!mapData.id || !mapData.label) throw new Error('Invalid map format');
                
                this.saveSnapshot('Import');
                this.data = mapData;
                this.expandedNodes.clear();
                this.save();
                
                // Restore neural network data if present
                if (neuralData) {
                    try {
                        if (neuralData.modelData) {
                            localStorage.setItem(CONFIG.NEURAL_NET.STORAGE_KEY, JSON.stringify(neuralData.modelData));
                            console.log('✓ Neural model data restored');
                        }
                        if (neuralData.embeddings) {
                            localStorage.setItem(CONFIG.NEURAL_NET.EMBEDDINGS_KEY, JSON.stringify(neuralData.embeddings));
                            console.log('✓ Neural embeddings restored');
                        }
                        
                        // Reload neural network with restored data
                        if (typeof neuralNet !== 'undefined' && neuralNet.isReady) {
                            neuralNet.loadModels();
                            neuralNet.loadEmbeddings();
                        }
                    } catch (e) {
                        console.warn('Could not restore neural data:', e);
                    }
                }
                
                bus.emit('data:imported');
                return true;
            } catch (e) {
                console.error('Import error:', e);
                return false;
            }
        }
        
        // Export just the map data (for cloud sync)
        exportData() {
            return JSON.parse(JSON.stringify(this.data));
        }
        
        // Import just the map data (from cloud sync)
        importData(mapData, skipSync = false) {
            if (!mapData || !mapData.id) {
                console.error('Invalid map data for import');
                return false;
            }
            
            this.saveSnapshot('Cloud sync');
            this.data = mapData;
            this.expandedNodes.clear();
            
            // Save locally but skip cloud sync to avoid loop
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.data));
                bus.emit('data:saved');
            } catch (e) {
                console.warn('Failed to save data:', e.message);
            }
            
            bus.emit('data:imported');
            return true;
        }
    }
    
    const store = new Store();

    // ═══════════════════════════════════════════════════════════════════
    // CONNECTION MANAGER - Batched Connection Updates for Performance
    // ═══════════════════════════════════════════════════════════════════
    const ConnectionManager = {
        pendingUpdates: new Set(),
        
        // Queue a connection for update (called during animation)
        queueUpdate(childMesh) {
            this.pendingUpdates.add(childMesh);
        },
        
        // Process all pending updates in a single batch
        processBatch() {
            if (this.pendingUpdates.size === 0) return;
            
            this.pendingUpdates.forEach(childMesh => {
                const line = childMesh.userData.connectionLine;
                if (!line || !childMesh.userData.parent) return;
                
                const parentMesh = nodes.get(childMesh.userData.parent.id);
                if (!parentMesh) return;
                
                const points = [parentMesh.position.clone(), childMesh.position.clone()];
                line.geometry.setFromPoints(points);
            });
            
            this.pendingUpdates.clear();
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // LABEL SYSTEM - Smart Decluttering with Camera Movement Detection
    // ═══════════════════════════════════════════════════════════════════
    const LabelSystem = {
        lastCameraPosition: null,
        lastCameraTarget: null,
        needsUpdate: true,
        frameCounter: 0,
        
        // Initialize tracking vectors (called after scene init)
        init(camera, controls) {
            this.lastCameraPosition = camera.position.clone();
            this.lastCameraTarget = controls.target.clone();
        },
        
        // Check if camera has moved significantly
        checkCameraMovement(camera, controls) {
            if (!this.lastCameraPosition) return;
            
            const posDiff = camera.position.distanceToSquared(this.lastCameraPosition);
            const targetDiff = controls.target.distanceToSquared(this.lastCameraTarget);
            
            if (posDiff > 0.01 || targetDiff > 0.01) {
                this.lastCameraPosition.copy(camera.position);
                this.lastCameraTarget.copy(controls.target);
                this.needsUpdate = true;
            }
        },
        
        // Mark labels as needing update (call when nodes change)
        markDirty() {
            this.needsUpdate = true;
        },
        
        // Run decluttering - only when needed
        update(camera, nodesMap) {
            this.frameCounter++;
            
            // Only run every N frames unless marked dirty
            if (!this.needsUpdate && this.frameCounter % CONFIG.LABELS.declutterInterval !== 0) {
                return;
            }
            
            this.needsUpdate = false;
            const cfg = CONFIG.LABELS;
            const visibleLabels = [];
            
            nodesMap.forEach(mesh => {
                if (!mesh.visible || !mesh.userData.labelSprite) return;
                
                const sprite = mesh.userData.labelSprite;
                const pos = mesh.position.clone().project(camera);
                
                // Behind camera
                if (pos.z > 1) {
                    sprite.material.opacity = Math.max(0, sprite.material.opacity - cfg.fadeSpeed);
                    return;
                }
                
                const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                
                const dist = camera.position.distanceTo(mesh.position);
                const textLength = (mesh.userData.label || '').length;
                const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
                
                const depth = mesh.userData.depth || 0;
                const isSelected = mesh.userData.selected;
                const isRoot = mesh.userData.level === 0;
                const priority = isSelected ? cfg.selectedPriority : 
                                (isRoot ? cfg.rootPriority : cfg.basePriority - depth * cfg.depthPenalty);
                
                visibleLabels.push({
                    sprite,
                    x: screenX,
                    y: screenY,
                    width: labelWidth,
                    height: labelHeight,
                    priority,
                    baseOpacity: mesh.userData.labelBaseOpacity || 1,
                    shouldShow: true
                });
            });
            
            // Sort by priority (highest first)
            visibleLabels.sort((a, b) => b.priority - a.priority);
            
            // Hide overlapping labels (lower priority ones)
            for (let i = 0; i < visibleLabels.length; i++) {
                if (!visibleLabels[i].shouldShow) continue;
                
                for (let j = i + 1; j < visibleLabels.length; j++) {
                    if (!visibleLabels[j].shouldShow) continue;
                    
                    const a = visibleLabels[i];
                    const b = visibleLabels[j];
                    
                    const overlapX = Math.abs(a.x - b.x) < (a.width + b.width) / 2 + cfg.padding;
                    const overlapY = Math.abs(a.y - b.y) < (a.height + b.height) / 2 + cfg.padding;
                    
                    if (overlapX && overlapY) {
                        visibleLabels[j].shouldShow = false;
                    }
                }
            }
            
            // Apply smooth fade transitions
            visibleLabels.forEach(label => {
                const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
                const currentOpacity = label.sprite.material.opacity;
                label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * cfg.fadeSpeed;
                if (label.sprite.material.opacity < cfg.minOpacity) {
                    label.sprite.material.opacity = 0;
                }
            });
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // UTILITIES
    // ═══════════════════════════════════════════════════════════════════
    function escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    
    function throttle(fn, delay) {
        let lastCall = 0;
        let timeoutId = null;
        return function(...args) {
            const now = Date.now();
            const remaining = delay - (now - lastCall);
            if (remaining <= 0) {
                if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }
                lastCall = now;
                fn.apply(this, args);
            } else if (!timeoutId) {
                timeoutId = setTimeout(() => {
                    lastCall = Date.now();
                    timeoutId = null;
                    fn.apply(this, args);
                }, remaining);
            }
        };
    }
    
    function lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    function easeOutElastic(t) {
        const c4 = (2 * Math.PI) / 3;
        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }

    // ═══════════════════════════════════════════════════════════════════
    // HAPTIC FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const haptic = {
        light: () => navigator.vibrate?.(10),
        medium: () => navigator.vibrate?.(20),
        heavy: () => navigator.vibrate?.([30, 50, 30]),
        success: () => navigator.vibrate?.([10, 50, 10, 50, 10]),
        error: () => navigator.vibrate?.([50, 100, 50])
    };

    // ═══════════════════════════════════════════════════════════════════
    // AUDIO FEEDBACK
    // ═══════════════════════════════════════════════════════════════════
    const audio = {
        ctx: null,
        getCtx() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            return this.ctx;
        },
        play(freq, duration = 0.1, type = 'sine', volume = 0.1) {
            try {
                const ctx = this.getCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.value = volume;
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {}
        },
        pop: () => audio.play(600, 0.08),
        expand: () => audio.play(800, 0.1),
        collapse: () => audio.play(400, 0.1),
        select: () => audio.play(500, 0.05),
        add: () => audio.play(700, 0.08),
        success: () => { audio.play(523, 0.1); setTimeout(() => audio.play(659, 0.1), 100); },
        error: () => audio.play(200, 0.2)
    };

    // ═══════════════════════════════════════════════════════════════════
    // CELEBRATION SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    function createCelebration(x, y, color = '#7c3aed', count = 6) {
        const container = document.body;
        
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.className = 'celebration-particle';
            
            const size = 3 + Math.random() * 4;
            const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
            const velocity = 40 + Math.random() * 60;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity;
            
            particle.style.cssText = `
                left: ${x}px;
                top: ${y}px;
                width: ${size}px;
                height: ${size}px;
                background: ${color};
                opacity: 0.7;
            `;
            
            container.appendChild(particle);
            
            let px = x, py = y, opacity = 0.7;
            const gravity = 100;
            const startTime = performance.now();
            const duration = 400 + Math.random() * 200;
            
            function animate(time) {
                const elapsed = (time - startTime) / 1000;
                const progress = Math.min(elapsed / (duration / 1000), 1);
                
                px += vx * 0.016;
                py += vy * 0.016 + gravity * elapsed * 0.016;
                opacity = 0.7 * (1 - progress);
                
                particle.style.left = px + 'px';
                particle.style.top = py + 'px';
                particle.style.opacity = opacity;
                particle.style.transform = `scale(${1 - progress * 0.3})`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                }
            }
            
            requestAnimationFrame(animate);
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // TOAST NOTIFICATIONS
    // ═══════════════════════════════════════════════════════════════════
    function showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: '✓',
            error: '✕',
            info: 'ℹ'
        };
        
        toast.innerHTML = `<span>${icons[type] || ''}</span> ${escapeHTML(message)}`;
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('exiting');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }
    
    // Custom confirm modal (replaces browser confirm())
    function showConfirm(options = {}) {
        return new Promise((resolve) => {
            const {
                title = 'Confirm',
                message = 'Are you sure?',
                confirmText = 'Confirm',
                cancelText = 'Cancel',
                danger = false
            } = options;
            
            const modal = document.getElementById('confirm-modal');
            const titleEl = document.getElementById('confirm-modal-title');
            const messageEl = document.getElementById('confirm-modal-message');
            const iconEl = document.getElementById('confirm-modal-icon');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');
            
            // Set content
            titleEl.textContent = title;
            messageEl.textContent = message;
            confirmBtn.textContent = confirmText;
            cancelBtn.textContent = cancelText;
            
            // Style icon and confirm button based on danger
            iconEl.className = 'confirm-modal-icon' + (danger ? ' danger' : '');
            confirmBtn.className = 'confirm-btn confirm-btn-confirm' + (danger ? '' : ' primary');
            
            // Show modal
            modal.classList.add('active');
            
            // Focus cancel button (safer default)
            setTimeout(() => cancelBtn.focus(), 50);
            
            // Cleanup function
            const cleanup = () => {
                modal.classList.remove('active');
                confirmBtn.removeEventListener('click', handleConfirm);
                cancelBtn.removeEventListener('click', handleCancel);
                document.removeEventListener('keydown', handleKeydown);
            };
            
            const handleConfirm = () => {
                cleanup();
                resolve(true);
            };
            
            const handleCancel = () => {
                cleanup();
                resolve(false);
            };
            
            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    handleCancel();
                } else if (e.key === 'Enter' && document.activeElement === confirmBtn) {
                    e.preventDefault();
                    handleConfirm();
                }
            };
            
            confirmBtn.addEventListener('click', handleConfirm);
            cancelBtn.addEventListener('click', handleCancel);
            document.addEventListener('keydown', handleKeydown);
        });
    }
    
    // Show AI response in a modal (for respond action)
    function showAIResponse(message, offerToAdd = false, originalQuery = '') {
        // Remove any existing AI response modal
        const existing = document.getElementById('ai-response-modal');
        if (existing) existing.remove();
        
        const modal = document.createElement('div');
        modal.id = 'ai-response-modal';
        modal.innerHTML = `
            <div class="ai-response-backdrop"></div>
            <div class="ai-response-content">
                <div class="ai-response-header">
                    <span class="ai-response-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                        </svg>
                    </span>
                    <span>AI Response</span>
                    <button class="ai-response-close" aria-label="Close">×</button>
                </div>
                <div class="ai-response-body">
                    ${escapeHTML(message).replace(/\n/g, '<br>')}
                </div>
                ${offerToAdd ? `
                <div class="ai-response-actions">
                    <button class="ai-response-btn secondary" data-action="dismiss">Dismiss</button>
                    <button class="ai-response-btn primary" data-action="add">Add to Map</button>
                </div>
                ` : `
                <div class="ai-response-actions">
                    <button class="ai-response-btn primary" data-action="dismiss">Got it</button>
                </div>
                `}
            </div>
        `;
        
        // Add styles if not already present
        if (!document.getElementById('ai-response-styles')) {
            const styles = document.createElement('style');
            styles.id = 'ai-response-styles';
            styles.textContent = `
                #ai-response-modal {
                    position: fixed;
                    inset: 0;
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 20px;
                    animation: fadeIn 0.2s ease;
                }
                .ai-response-backdrop {
                    position: absolute;
                    inset: 0;
                    background: rgba(0,0,0,0.5);
                    backdrop-filter: blur(4px);
                }
                .ai-response-content {
                    position: relative;
                    background: var(--panel-bg, #1a1a2e);
                    border: 1px solid var(--border-color, #333);
                    border-radius: 16px;
                    max-width: 500px;
                    width: 100%;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
                    animation: slideUp 0.3s ease;
                }
                .ai-response-header {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    padding: 16px 20px;
                    border-bottom: 1px solid var(--border-color, #333);
                    font-weight: 600;
                    color: var(--text-primary, #fff);
                }
                .ai-response-icon {
                    font-size: 1.2em;
                }
                .ai-response-close {
                    margin-left: auto;
                    background: none;
                    border: none;
                    color: var(--text-secondary, #888);
                    font-size: 24px;
                    cursor: pointer;
                    padding: 0;
                    line-height: 1;
                    transition: color 0.2s;
                }
                .ai-response-close:hover {
                    color: var(--text-primary, #fff);
                }
                .ai-response-body {
                    padding: 20px;
                    color: var(--text-primary, #fff);
                    line-height: 1.6;
                    overflow-y: auto;
                    font-size: 15px;
                }
                .ai-response-actions {
                    display: flex;
                    gap: 12px;
                    padding: 16px 20px;
                    border-top: 1px solid var(--border-color, #333);
                    justify-content: flex-end;
                }
                .ai-response-btn {
                    padding: 10px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                .ai-response-btn.primary {
                    background: var(--accent-color, #4ECDC4);
                    color: #000;
                    border: none;
                }
                .ai-response-btn.primary:hover {
                    filter: brightness(1.1);
                    transform: translateY(-1px);
                }
                .ai-response-btn.secondary {
                    background: transparent;
                    color: var(--text-secondary, #888);
                    border: 1px solid var(--border-color, #444);
                }
                .ai-response-btn.secondary:hover {
                    background: var(--border-color, #333);
                    color: var(--text-primary, #fff);
                }
                @keyframes slideUp {
                    from { opacity: 0; transform: translateY(20px); }
                    to { opacity: 1; transform: translateY(0); }
                }
            `;
            document.head.appendChild(styles);
        }
        
        document.body.appendChild(modal);
        
        // Handle button clicks
        const closeModal = () => {
            modal.style.animation = 'fadeIn 0.2s ease reverse';
            setTimeout(() => modal.remove(), 200);
        };
        
        modal.querySelector('.ai-response-close').onclick = closeModal;
        modal.querySelector('.ai-response-backdrop').onclick = closeModal;
        
        modal.querySelectorAll('.ai-response-btn').forEach(btn => {
            btn.onclick = async () => {
                if (btn.dataset.action === 'add') {
                    // Create a node with the AI response
                    const label = originalQuery.length > 30 
                        ? originalQuery.substring(0, 30) + '...' 
                        : originalQuery || 'AI Response';
                    
                    const parentId = selectedNode?.userData.id || store.data.id;
                    const newNode = store.addNode(parentId, {
                        label: label.charAt(0).toUpperCase() + label.slice(1),
                        description: message,
                        color: null
                    });
                    
                    if (newNode) {
                        buildScene();
                        setTimeout(() => {
                            const mesh = nodes.get(newNode.id);
                            if (mesh) {
                                selectNode(mesh);
                                focusOnNode(mesh);
                            }
                        }, 100);
                        showToast('Added to map', 'success');
                    }
                }
                closeModal();
            };
        });
        
        // Close on Escape
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }

    // ═══════════════════════════════════════════════════════════════════
    // THEME MANAGER
    // ═══════════════════════════════════════════════════════════════════
    const themeManager = {
        current: 'coral',
        themes: ['sandstone', 'coral', 'ember', 'frost', 'obsidian'],
        
        init() {
            const saved = localStorage.getItem(CONFIG.THEME_KEY);
            if (saved && this.themes.includes(saved)) {
                this.set(saved, true); // Skip color update on init
            } else {
                // Default to sandstone for new users
                this.set('coral', true);
            }
        },
        
        set(theme, skipColorUpdate = false) {
            const oldTheme = this.current;
            this.current = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem(CONFIG.THEME_KEY, theme);
            
            // Update theme picker UI
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.toggle('active', opt.dataset.theme === theme);
            });
            
            // Update node colors when switching themes (different palettes)
            if (!skipColorUpdate && oldTheme !== theme) {
                updateNodeColorsForTheme(oldTheme, theme);
            }
            
            bus.emit('theme:changed', { theme, oldTheme });
        },
        
        toggle() {
            const currentIndex = this.themes.indexOf(this.current);
            const nextIndex = (currentIndex + 1) % this.themes.length;
            this.set(this.themes[nextIndex]);
        }
    };

    // ═══════════════════════════════════════════════════════════════════
    // THREE.JS SCENE
    // ═══════════════════════════════════════════════════════════════════
    let scene, camera, renderer, controls;
    let nodes = new Map();
    let connections = [];
    let selectedNode = null;
    let currentContextId = null;
    let focusMode = false;
    let particleSystem = null;
    let cameraTargetGoal = new THREE.Vector3(0, 0, 0);
    let userInteracting = false;
    
    // Camera arc animation
    let cameraArcAnimation = null;
    let autoCameraEnabled = true;

    function initScene() {
        // Scene
        scene = new THREE.Scene();
        
        // Camera
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const isMobile = window.innerWidth <= 768;
        camera.position.set(0, isMobile ? 18 : 14, isMobile ? 50 : 40);
        
        // Renderer
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Add click handler for node selection
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerup', onPointerUp);
        
        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.12;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 8;
        controls.maxDistance = 500;
        controls.enablePan = true;
        controls.panSpeed = 0.8;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.enableZoom = false; // Disable default zoom, we handle it custom
        
        // Track user interaction with controls
        controls.addEventListener('start', () => { 
            userInteracting = true; 
            // Don't cancel arc animation - let it complete
        });
        controls.addEventListener('end', () => { 
            userInteracting = false;
            cameraTargetGoal.copy(controls.target); // Sync after interaction
        });
        
        // Zoom to pointer - custom zoom behavior
        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Cancel any arc animation
            cameraArcAnimation = null;
            
            // Get mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create a ray from camera through mouse position
            const zoomRaycaster = new THREE.Raycaster();
            zoomRaycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
            
            // Find point on a plane at the target distance
            const targetDistance = camera.position.distanceTo(controls.target);
            const zoomPoint = zoomRaycaster.ray.at(targetDistance, new THREE.Vector3());
            
            // Calculate zoom factor
            const zoomSpeed = 0.001;
            const zoomDelta = event.deltaY * zoomSpeed;
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, currentDistance * (1 + zoomDelta)));
            
            // Move target towards zoom point while zooming in, away while zooming out
            const zoomFactor = 1 - (newDistance / currentDistance);
            const targetShift = new THREE.Vector3().subVectors(zoomPoint, controls.target).multiplyScalar(zoomFactor * 0.5);
            controls.target.add(targetShift);
            cameraTargetGoal.copy(controls.target); // Sync the goal
            
            // Update camera distance
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            
            controls.update();
        }, { passive: false });
        
        // Pinch-to-zoom for mobile
        let initialPinchDistance = null;
        let initialCameraDistance = null;
        
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialCameraDistance = camera.position.distanceTo(controls.target);
            }
        }, { passive: true });
        
        renderer.domElement.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2 && initialPinchDistance !== null) {
                event.preventDefault();
                
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
                
                const pinchRatio = initialPinchDistance / currentPinchDistance;
                const newDistance = Math.max(
                    controls.minDistance, 
                    Math.min(controls.maxDistance, initialCameraDistance * pinchRatio)
                );
                
                // Update camera distance
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                
                controls.update();
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', () => {
            initialPinchDistance = null;
            initialCameraDistance = null;
        }, { passive: true });
        
        // Ambient particles
        createAmbientParticles();
        
        // Lighting - bright for accurate colors
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);
        
        const pointLight2 = new THREE.PointLight(0xffffff, 0.3);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);
        
        // Build initial scene
        currentContextId = store.data.id;
        
        // Initialize label system with camera tracking
        LabelSystem.init(camera, controls);
        
        buildScene();
        
        // Resize handler
        window.addEventListener('resize', throttle(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, 100));
        
        // End session when user leaves
        window.addEventListener('beforeunload', () => {
            userProfile.endSession();
            metaLearner.endSession();
            preferenceTracker.finalizePendingSession();
        });
        
        // Initialize animation controller for performance throttling
        AnimationController.init();
        
        // Start animation loop
        animate();
    }

    function createAmbientParticles() {
        const particleCount = 200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            
            // Subtle purple/blue tints
            colors[i * 3] = 0.5 + Math.random() * 0.3;
            colors[i * 3 + 1] = 0.3 + Math.random() * 0.3;
            colors[i * 3 + 2] = 0.8 + Math.random() * 0.2;
            
            sizes[i] = 0.5 + Math.random() * 1.5;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }

    // Count all descendants of a node
    function countDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        let count = data.children.length;
        data.children.forEach(child => {
            count += countDescendants(child);
        });
        return count;
    }
    
    // Count visible (expanded) descendants
    function countVisibleDescendants(data) {
        if (!data.children || data.children.length === 0) return 0;
        if (!store.expandedNodes.has(data.id)) return 0;
        
        let count = data.children.length;
        data.children.forEach(child => {
            count += countVisibleDescendants(child);
        });
        return count;
    }
    
    // Get max depth of expanded descendants
    function getExpandedDepth(data, currentDepth = 0) {
        if (!data.children || data.children.length === 0) return currentDepth;
        if (!store.expandedNodes.has(data.id)) return currentDepth;
        
        let maxDepth = currentDepth;
        data.children.forEach(child => {
            const childDepth = getExpandedDepth(child, currentDepth + 1);
            if (childDepth > maxDepth) maxDepth = childDepth;
        });
        return maxDepth;
    }

    function calculatePositions(data, parentPos = [0, 0, 0], level = 0, parentAngle = 0, total = 1, index = 0, siblingWeights = null) {
        data.level = level;
        
        // Size based on level - smaller for deeper nodes
        if (level === 0) data.size = CONFIG.NODE_SIZES.root;
        else if (level === 1) data.size = CONFIG.NODE_SIZES.level1;
        else if (level === 2) data.size = CONFIG.NODE_SIZES.level2;
        else data.size = Math.max(0.25, CONFIG.NODE_SIZES.default - (level - 3) * 0.06);
        
        // Check descendants for spacing
        const hasChildren = data.children && data.children.length > 0;
        const childCount = hasChildren ? data.children.length : 0;
        const isExpanded = store.expandedNodes.has(data.id);
        const visibleDescendants = countVisibleDescendants(data);
        const expandedDepth = getExpandedDepth(data);
        
        // Position calculation
        let baseRadius;
        if (level === 0) {
            baseRadius = 0;
        } else if (level === 1) {
            // Level 1: Grow with diminishing returns for depth
            baseRadius = CONFIG.LAYOUT.level1Radius;
            baseRadius += Math.max(0, (total - 4) * 0.6);
            
            // Diminishing returns for descendants - sqrt gives nice falloff
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.sqrt(visibleDescendants) * 0.6;
            }
            // Diminishing returns for depth - log-like falloff
            if (expandedDepth > 1) {
                // depth 2: +0.8, depth 3: +1.27, depth 4: +1.6, depth 5: +1.86
                baseRadius += Math.sqrt(expandedDepth - 1) * 0.8;
            }
        } else if (level === 2) {
            // Level 2: Similar diminishing returns
            baseRadius = CONFIG.LAYOUT.level2Radius;
            baseRadius += Math.max(0, (total - 2) * 0.5);
            
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.sqrt(visibleDescendants) * 0.5;
            }
            if (expandedDepth > 0) {
                baseRadius += Math.sqrt(expandedDepth) * 0.6;
            }
        } else {
            // Level 3+: Scale based on siblings and descendants with diminishing returns
            baseRadius = Math.max(2.5, CONFIG.LAYOUT.level3Radius - (level - 3) * 0.15);
            baseRadius += Math.max(0, (total - 2) * 0.4);
            
            if (isExpanded && visibleDescendants > 0) {
                baseRadius += Math.sqrt(visibleDescendants) * 0.4;
            }
            if (expandedDepth > 0) {
                baseRadius += Math.sqrt(expandedDepth) * 0.5;
            }
        }
        
        if (level === 0) {
            data.position = [0, 0, 0];
            data.basePosition = [0, 0, 0];
            data.expandedPosition = [0, 0, 0];
            data.branchAngle = 0;
        } else if (level === 1) {
            // Spread evenly around center
            const angleStep = (Math.PI * 2) / Math.max(total, 1);
            const startAngle = -Math.PI / 2;
            const angle = startAngle + angleStep * index;
            const verticalOffset = (index % 2 === 0 ? 0.3 : -0.3) + (index % 3 - 1) * 0.2;
            
            data.basePosition = [Math.cos(angle) * baseRadius, verticalOffset, Math.sin(angle) * baseRadius];
            data.expandedPosition = [...data.basePosition];
            data.position = [...data.basePosition];
            data.branchAngle = angle;
        } else {
            // Branch outward from parent - USE PARENT'S BRANCH ANGLE, not just position from origin
            // This ensures children fan out in the direction the branch is going
            const baseSpread = Math.PI * 0.5;
            const siblingSpread = Math.min(total * 0.18, Math.PI * 0.5);
            
            // Extra spread if siblings have many descendants
            let descendantSpread = 0;
            if (siblingWeights) {
                const totalWeight = siblingWeights.reduce((a, b) => a + b, 0);
                if (totalWeight > total) {
                    descendantSpread = Math.min((totalWeight - total) * 0.08, Math.PI * 0.3);
                }
            }
            
            const spreadAngle = Math.min(baseSpread + siblingSpread + descendantSpread, Math.PI * 1.3);
            const halfSpread = spreadAngle / 2;
            
            // Use the parent's branch angle (direction from grandparent to parent)
            // This makes children continue outward in the branch direction
            const outwardAngle = parentAngle;
            
            let childAngle;
            if (total === 1) {
                childAngle = outwardAngle;
            } else if (siblingWeights && siblingWeights.length === total) {
                // Distribute angle proportionally to weight
                const totalWeight = siblingWeights.reduce((a, b) => a + b, 0);
                let weightBefore = 0;
                for (let i = 0; i < index; i++) {
                    weightBefore += siblingWeights[i];
                }
                const myWeight = siblingWeights[index];
                const anglePosition = (weightBefore + myWeight / 2) / totalWeight;
                childAngle = outwardAngle - halfSpread + spreadAngle * anglePosition;
            } else {
                childAngle = outwardAngle - halfSpread + (spreadAngle / (total - 1)) * index;
            }
            
            // Vertical spread scales with siblings
            const verticalSpacing = 0.4 + Math.min(total * 0.05, 0.3);
            const verticalOffset = (index - (total - 1) / 2) * verticalSpacing;
            
            data.basePosition = [
                parentPos[0] + Math.cos(childAngle) * baseRadius,
                parentPos[1] + verticalOffset,
                parentPos[2] + Math.sin(childAngle) * baseRadius
            ];
            data.expandedPosition = [...data.basePosition];
            data.position = [...data.basePosition];
            data.branchAngle = childAngle;
        }
        
        // If node has a custom position (from move mode), use it instead
        if (data.customPosition && level > 0) {
            data.position = [data.customPosition.x, data.customPosition.y, data.customPosition.z];
            data.basePosition = [...data.position];
            data.expandedPosition = [...data.position];
        }
        
        // Recursively process children (using potentially custom position as parent)
        // Calculate weights for children based on their descendants
        if (data.children) {
            const childWeights = data.children.map(child => {
                const descendants = countVisibleDescendants(child);
                return 1 + Math.min(descendants * 0.5, 3); // Weight: 1 base + descendants bonus
            });
            
            data.children.forEach((child, i) => {
                calculatePositions(child, data.position, level + 1, data.branchAngle || 0, data.children.length, i, childWeights);
            });
        }
        
        return data;
    }

    function createNodeMaterial(color) {
        return new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            emissive: new THREE.Color(color),
            emissiveIntensity: 0.3,
            roughness: 0.4,
            metalness: 0.1,
            transparent: true,
            opacity: 1
        });
    }

    function createLabelSprite(text, color, hasLink = false) {
        const labelText = text || 'Untitled';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = CONFIG.LABELS.fontSize;
        const padding = CONFIG.LABELS.spritePadding;
        
        // Add extra width for link icon if needed
        const linkIconSize = hasLink ? 16 : 0;
        const linkPadding = hasLink ? 6 : 0;
        
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        const textWidth = ctx.measureText(labelText).width;
        const width = textWidth + padding * 2 + linkIconSize + linkPadding;
        const height = fontSize + padding * 1.4;
        
        canvas.width = width * 2;
        canvas.height = height * 2;
        ctx.scale(2, 2);
        
        // Background - check for dark themes
        const theme = document.documentElement.getAttribute('data-theme') || 'coral';
        const isDark = ['obsidian'].includes(theme);
        
        ctx.fillStyle = isDark ? 'rgba(18, 18, 26, 0.9)' : 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(1, 1, width - 2, height - 2, 14);
        ctx.fill();
        ctx.stroke();
        
        // Link icon if has link
        if (hasLink) {
            ctx.save();
            ctx.strokeStyle = color || '#6366f1';
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            
            const iconX = padding + 2;
            const iconY = height / 2;
            const iconSize = 10;
            
            // Draw link icon (two interlocking chain links)
            ctx.beginPath();
            ctx.moveTo(iconX + 3, iconY - 2);
            ctx.lineTo(iconX + 6, iconY - 5);
            ctx.arc(iconX + 8, iconY - 3, 3, -Math.PI * 0.75, Math.PI * 0.25);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(iconX + 9, iconY + 2);
            ctx.lineTo(iconX + 6, iconY + 5);
            ctx.arc(iconX + 4, iconY + 3, 3, Math.PI * 0.25, -Math.PI * 0.75, true);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Text
        ctx.fillStyle = isDark ? '#ffffff' : '#1f2937';
        ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Calculate text position accounting for link icon on left
        const leftOffset = hasLink ? (linkIconSize + linkPadding) : 0;
        const textX = padding + leftOffset + (textWidth / 2);
        
        ctx.fillText(labelText, textX, height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: true,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        const aspect = width / height;
        sprite.userData.aspect = aspect;
        sprite.userData.labelWidth = width;
        const spriteHeight = 0.5;
        sprite.scale.set(spriteHeight * aspect, spriteHeight, 1);
        
        return sprite;
    }
    
    // Create context badge sprite (separate from label) - pulsing light
    function createContextBadge() {
        const canvas = document.createElement('canvas');
        const size = 64;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const centerX = size / 2;
        const centerY = size / 2;
        
        // Tight, defined light with minimal glow
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.4, 'rgba(230, 85, 70, 1)');
        gradient.addColorStop(0.7, 'rgba(200, 55, 45, 0.95)');
        gradient.addColorStop(0.85, 'rgba(180, 45, 40, 0.5)');
        gradient.addColorStop(1, 'rgba(160, 40, 35, 0)');
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.userData.isContextBadge = true;
        sprite.userData.pulsePhase = Math.random() * Math.PI * 2;
        sprite.userData.baseScale = 0.28;
        sprite.scale.set(0.28, 0.28, 1);
        
        return sprite;
    }
    
    // Remove context badge from a node
    function removeContextIndicator(mesh) {
        if (mesh.userData.contextBadge) {
            const badge = mesh.userData.contextBadge;
            mesh.remove(badge);
            badge.material.map?.dispose();
            badge.material.dispose();
            mesh.userData.contextBadge = null;
            mesh.userData.needsContext = false;
        }
    }

    function createNodeMesh(data, parent = null) {
        // Geometry
        const geometry = new THREE.SphereGeometry(data.size, 32, 32);
        const material = createNodeMaterial(data.color);
        const mesh = new THREE.Mesh(geometry, material);
        
        // Position
        const isExpanded = store.expandedNodes.has(data.id);
        const startPos = isExpanded && data.expandedPosition ? data.expandedPosition : data.position;
        mesh.position.set(...startPos);
        
        // User data
        mesh.userData = { ...data, parent };
        mesh.userData.isExpanded = isExpanded;
        mesh.userData.baseSize = 1; // Store base scale for importance adjustment
        mesh.userData.importance = data.importance || 1;
        
        // Apply importance scale
        const importanceScale = data.importance || 1;
        mesh.scale.set(importanceScale, importanceScale, importanceScale);
        
        mesh.userData.spring = {
            velocity: new THREE.Vector3(),
            target: new THREE.Vector3(...startPos),
            scaleVelocity: 0,
            scaleTarget: importanceScale,
            floatOffset: Math.random() * Math.PI * 2,
            floatSpeed: 0.15 + Math.random() * 0.1
        };
        
        // Outline
        const outlineGeometry = new THREE.SphereGeometry(data.size * 1.03, 32, 32);
        const outlineMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color(data.color).multiplyScalar(0.3),
            side: THREE.BackSide,
            transparent: true,
            opacity: 1
        });
        const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
        outline.position.copy(mesh.position);
        outline.scale.set(importanceScale, importanceScale, importanceScale);
        scene.add(outline);
        mesh.userData.outlineMesh = outline;
        
        // Label - with link indicator if this node has a link
        const hasLink = !!data.link;
        const label = createLabelSprite(data.label, data.color, hasLink);
        const labelOffset = data.level === 0 ? -data.size - 0.6 : -data.size - 0.35;
        label.position.set(0, labelOffset, 0);
        label.visible = true;  // All labels visible by default
        mesh.add(label);
        mesh.userData.labelSprite = label;
        
        // Context badge (separate sprite to the right of label) for nodes without descriptions
        const needsContext = data.level > 0 && (!data.description || data.description.trim() === '');
        mesh.userData.needsContext = needsContext;
        if (needsContext) {
            const badge = createContextBadge();
            // Position to the right of the label
            const labelWidth = label.scale.x;
            badge.position.set(labelWidth / 2 + 0.16, labelOffset, 0);
            mesh.add(badge);
            mesh.userData.contextBadge = badge;
        }
        
        // Store link data if present
        if (data.link) {
            mesh.userData.link = data.link;
        }
        
        scene.add(mesh);
        
        // Visibility for collapsed nodes
        const parentIsExpanded = parent && store.expandedNodes.has(parent.id);
        if (data.level >= 2 && !parentIsExpanded) {
            mesh.visible = false;
            outline.visible = false;
            label.visible = false;
            if (mesh.userData.contextBadge) {
                mesh.userData.contextBadge.visible = false;
            }
            mesh.userData.collapsed = true;
        }
        
        // Connection to parent
        if (parent) {
            const connection = createConnection(parent, data, mesh);
            if (connection) {
                mesh.userData.connectionLine = connection;
                if (data.level >= 2 && !parentIsExpanded) {
                    connection.visible = false;
                }
            }
        }
        
        nodes.set(data.id, mesh);
        
        // Create children
        if (data.children) {
            data.children.forEach(child => createNodeMesh(child, data));
        }
        
        return mesh;
    }

    function createConnection(parentData, childData, childMesh) {
        const parentMesh = nodes.get(parentData.id);
        if (!parentMesh) return null;
        
        // Straight line from parent to child
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        const material = new THREE.LineBasicMaterial({
            color: new THREE.Color(childData.color).multiplyScalar(0.6),
            transparent: true,
            opacity: 0.6,
            linewidth: 2
        });
        
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        connections.push(line);
        
        return line;
    }

    function updateConnection(childMesh, parentMesh) {
        const line = childMesh.userData.connectionLine;
        if (!line) return;
        
        // Straight line update
        const points = [
            parentMesh.position.clone(),
            childMesh.position.clone()
        ];
        line.geometry.setFromPoints(points);
    }

    function buildScene() {
        // Clear existing
        nodes.forEach(mesh => {
            scene.remove(mesh);
            if (mesh.userData.outlineMesh) {
                scene.remove(mesh.userData.outlineMesh);
                mesh.userData.outlineMesh.geometry.dispose();
                mesh.userData.outlineMesh.material.dispose();
            }
            if (mesh.userData.labelSprite) {
                mesh.userData.labelSprite.material.map?.dispose();
                mesh.userData.labelSprite.material.dispose();
            }
            mesh.geometry.dispose();
            mesh.material.dispose();
        });
        
        connections.forEach(conn => {
            scene.remove(conn);
            conn.geometry.dispose();
            conn.material.dispose();
        });
        
        nodes.clear();
        connections.length = 0;
        selectedNode = null;
        
        // Get context node
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) {
            currentContextId = store.data.id;
            return buildScene();
        }
        
        // Calculate positions and create meshes
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        createNodeMesh(processedData);
        
        // Restore expanded state
        store.expandedNodes.forEach(nodeId => {
            const mesh = nodes.get(nodeId);
            if (mesh && mesh.userData.children?.length > 0) {
                expandNode(mesh, false);
            }
        });
        
        updateDepthIndicator();
        
        // Mark labels for declutter recalculation
        LabelSystem.markDirty();
    }
    
    // Smoothly update node positions without rebuilding scene
    function updateNodePositions() {
        const contextNode = store.findNode(currentContextId);
        if (!contextNode) return;
        
        // Recalculate positions
        const processedData = calculatePositions(JSON.parse(JSON.stringify(contextNode)));
        
        // Update spring targets for existing visible nodes
        function updatePositionsRecursive(data) {
            const mesh = nodes.get(data.id);
            if (mesh && mesh.visible) {
                const newPos = new THREE.Vector3(data.position[0], data.position[1], data.position[2]);
                mesh.userData.spring.target.copy(newPos);
                mesh.userData.basePosition = [...data.position];
            }
            
            if (data.children) {
                data.children.forEach(child => updatePositionsRecursive(child));
            }
        }
        
        updatePositionsRecursive(processedData);
    }

    function updateLabelsForTheme() {
        // Just update label sprite textures without rebuilding the scene
        nodes.forEach(mesh => {
            if (mesh.userData.labelSprite) {
                const oldSprite = mesh.userData.labelSprite;
                const newSprite = createLabelSprite(mesh.userData.label, mesh.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                
                // Labels are children of mesh, not scene
                mesh.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                
                mesh.add(newSprite);
                mesh.userData.labelSprite = newSprite;
            }
        });
    }
    
    // Update a single node's label
    function updateNodeLabel(mesh, newLabel) {
        if (!mesh) return;
        mesh.userData.label = newLabel;
        
        if (mesh.userData.labelSprite) {
            const oldSprite = mesh.userData.labelSprite;
            const newSprite = createLabelSprite(newLabel, mesh.userData.color);
            newSprite.position.copy(oldSprite.position);
            newSprite.scale.copy(oldSprite.scale);
            newSprite.visible = oldSprite.visible;
            
            mesh.remove(oldSprite);
            oldSprite.material.map?.dispose();
            oldSprite.material.dispose();
            
            mesh.add(newSprite);
            mesh.userData.labelSprite = newSprite;
        }
    }

    function expandNode(mesh, animate = true) {
        if (!mesh.userData.children?.length) return;
        if (mesh.userData.isExpanded) return;
        
        // Track expansion in user profile
        const nodeData = store.findNode(mesh.userData.id);
        if (nodeData) {
            userProfile.trackNodeExpanded(nodeData, store);
        }
        
        mesh.userData.isExpanded = true;
        store.expandedNodes.add(mesh.userData.id);
        
        // Store old positions of all visible nodes before rebuild
        const oldPositions = new Map();
        nodes.forEach((m, id) => {
            if (m.visible) {
                oldPositions.set(id, m.position.clone());
            }
        });
        
        // Rebuild scene to recalculate positions with proper spacing
        buildScene();
        
        // Re-get the mesh after rebuild
        const newMesh = nodes.get(mesh.userData.id);
        if (newMesh && animate) {
            // Restore old positions for existing nodes so they animate smoothly
            oldPositions.forEach((oldPos, id) => {
                const m = nodes.get(id);
                if (m && m.visible) {
                    m.position.copy(oldPos);
                    if (m.userData.outlineMesh) {
                        m.userData.outlineMesh.position.copy(oldPos);
                    }
                }
            });
            
            // Start children from parent position for animation
            newMesh.userData.children?.forEach((childData) => {
                const childMesh = nodes.get(childData.id);
                if (childMesh) {
                    const parentPos = newMesh.position.clone();
                    childMesh.position.copy(parentPos);
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.position.copy(parentPos);
                    const importance = childMesh.userData.importance || 1;
                    childMesh.scale.set(0.5 * importance, 0.5 * importance, 0.5 * importance);
                    childMesh.material.opacity = 0.3;
                }
            });
        }
        
        if (animate) {
            audio.expand();
            haptic.light();
        }
    }
    
    function expandAllDescendants(mesh, animate = true, isFirst = true) {
        if (!mesh.userData.children?.length) return;
        
        // First expand this node's direct children
        if (!mesh.userData.isExpanded) {
            expandNode(mesh, animate && isFirst);
        }
        
        // Then recursively expand all descendants with staggered delay
        mesh.userData.children.forEach((childData, i) => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.userData.children?.length > 0) {
                setTimeout(() => {
                    expandAllDescendants(childMesh, animate, false);
                }, animate ? 80 * (i + 1) : 0);
            }
        });
        
        if (animate && isFirst) {
            showToast('Expanded all descendants', 'info');
        }
    }

    function collapseNode(mesh, animate = true, depth = 0) {
        if (!mesh.userData.children?.length) return 0;
        if (!mesh.userData.isExpanded) return 0;
        
        mesh.userData.isExpanded = false;
        store.expandedNodes.delete(mesh.userData.id);
        
        const parentPos = mesh.position.clone();
        const childCount = mesh.userData.children.length;
        const staggerDelay = CONFIG.TIMING.collapseStagger;
        const hideDelay = CONFIG.TIMING.collapseHideDelay;
        
        // First recursively collapse all grandchildren and get max delay
        let maxNestedDelay = 0;
        mesh.userData.children.forEach((childData) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            if (childMesh.userData.isExpanded) {
                const nestedDelay = collapseNode(childMesh, animate, depth + 1);
                maxNestedDelay = Math.max(maxNestedDelay, nestedDelay);
            }
        });
        
        // Wait for nested collapses to finish, then collapse this level
        const baseDelay = maxNestedDelay;
        const thisLevelDuration = childCount * staggerDelay + hideDelay;
        
        mesh.userData.children.forEach((childData, index) => {
            const childMesh = nodes.get(childData.id);
            if (!childMesh) return;
            
            childMesh.userData.collapsed = true;
            childMesh.userData.collapseId = Date.now(); // Track this collapse operation
            const thisCollapseId = childMesh.userData.collapseId;
            
            const itemDelay = baseDelay + index * staggerDelay;
            
            if (animate) {
                setTimeout(() => {
                    // Only proceed if this collapse wasn't cancelled by an expand
                    if (childMesh.userData.collapseId !== thisCollapseId) return;
                    
                    // Hide connection line and label immediately
                    if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;
                    if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                    if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = false;
                    
                    // Animate back to parent position
                    childMesh.userData.spring.target.copy(parentPos);
                    childMesh.userData.spring.scaleTarget = 0.1;
                }, itemDelay);
                
                // Hide node after animation completes
                setTimeout(() => {
                    // Only hide if this collapse wasn't cancelled
                    if (childMesh.userData.collapseId !== thisCollapseId) return;
                    if (!childMesh.userData.collapsed) return;
                    
                    childMesh.visible = false;
                    if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                }, itemDelay + hideDelay);
            } else {
                childMesh.visible = false;
                if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = false;
                if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = false;
                if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = false;
                if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = false;
            }
        });
        
        if (animate && depth === 0) {
            audio.collapse();
            haptic.light();
            
            // Smoothly update positions after collapse animation (don't rebuild)
            const totalDuration = baseDelay + thisLevelDuration + 100;
            setTimeout(() => updateNodePositions(), totalDuration);
        }
        
        // Return total time for this level and nested
        return baseDelay + thisLevelDuration;
    }

    function toggleExpand(mesh) {
        if (mesh.userData.isExpanded) {
            collapseNode(mesh);
        } else {
            expandNode(mesh);
        }
    }

    function selectNode(mesh, isDoubleClick = false) {
        const nodeId = mesh.userData.id;
        const wasAlreadySelected = selectedNode === mesh;
        
        // Deselect previous
        if (selectedNode && selectedNode !== mesh) {
            selectedNode.userData.selected = false;
        }
        
        // Check for link node double-click - open URL
        if (isDoubleClick && mesh.userData.link?.url) {
            window.open(mesh.userData.link.url, '_blank');
            showToast('Opening link...', 'info');
            // Still select the node but don't expand
            selectedNode = mesh;
            mesh.userData.selected = true;
            store.selectedNodeId = mesh.userData.id;
            audio.select();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Expand/collapse logic:
        // - Single click on collapsed node: expand direct children only
        // - Single click on expanded node: just select (no collapse)
        // - Second click on already-selected expanded node: collapse
        // - Double click: expand all layers of children
        if (mesh.userData.children?.length > 0) {
            if (isDoubleClick) {
                // Double click: expand all descendants
                expandAllDescendants(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else if (!mesh.userData.isExpanded) {
                // Single click on collapsed: expand direct children only
                expandNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            } else if (wasAlreadySelected) {
                // Second click on already-selected expanded node: collapse
                collapseNode(mesh);
                mesh = nodes.get(nodeId) || mesh;
            }
            // Otherwise: just select the expanded node (don't collapse)
        }
        
        selectedNode = mesh;
        mesh.userData.selected = true;
        store.selectedNodeId = mesh.userData.id;
        
        // Skip camera animation if auto-camera is disabled
        if (!autoCameraEnabled) {
            audio.select();
            haptic.light();
            bus.emit('node:selected', { data: mesh.userData });
            return;
        }
        
        // Start smooth camera animation - horizontal arc rotation
        // Use spring target position (final position) rather than current animated position
        const nodePos = mesh.userData.spring?.target?.clone() || mesh.position.clone();
        
        // Check if node has children - zoom out more if it does
        const nodeData = store.findNode(mesh.userData.id);
        const hasChildren = nodeData?.children?.length > 0;
        const childCount = nodeData?.children?.length || 0;
        
        // Get current camera spherical coordinates relative to current target
        const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
        const currentRadius = currentOffset.length();
        const currentTheta = Math.atan2(currentOffset.x, currentOffset.z); // horizontal angle
        const currentPhi = Math.acos(Math.max(-1, Math.min(1, currentOffset.y / currentRadius))); // vertical angle
        
        // Calculate target angle - where the node is
        const nodeAngle = Math.atan2(nodePos.x, nodePos.z);
        const nodeDist2D = Math.sqrt(nodePos.x * nodePos.x + nodePos.z * nodePos.z);
        
        // End target - look directly at the selected node (centered)
        const endTarget = nodePos.clone();
        cameraTargetGoal.copy(endTarget);
        
        // Calculate end camera angle - offset so root node appears to the RIGHT of selected node
        // Subtract angle offset so we're viewing from an angle, not straight through the root
        const endTheta = nodeDist2D > 0.5 ? nodeAngle - Math.PI * 0.35 : currentTheta;
        
        // Zoom out more if node has children - scale based on child count
        const isMobile = window.innerWidth <= 768;
        const baseRadius = isMobile ? 22 : 18;
        const childZoomBonus = hasChildren ? Math.min(childCount * 4, 20) : 0; // up to 20 extra for many children
        const endRadius = Math.max(baseRadius + childZoomBonus, nodeDist2D + 14 + childZoomBonus);
        const endPhi = Math.PI * 0.35; // consistent downward viewing angle
        
        // Calculate shortest angle difference for arc boost
        let angleDiff = endTheta - currentTheta;
        if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        // Arc boost - how much to zoom out at midpoint (more for bigger rotations)
        const arcBoost = Math.abs(angleDiff) > 0.5 ? 3 : 1;
        
        cameraArcAnimation = {
            startTime: performance.now(),
            duration: 800, // Faster, smoother
            startTarget: controls.target.clone(),
            endTarget: endTarget,
            startTheta: currentTheta,
            endTheta: endTheta,
            startPhi: currentPhi,
            endPhi: endPhi,
            startRadius: currentRadius,
            endRadius: endRadius,
            arcBoost: arcBoost,
            useSpherical: true,
            startCameraPos: camera.position.clone()
        };
        
        audio.select();
        haptic.light();
        
        bus.emit('node:selected', { data: mesh.userData });
    }

    function deselectNode() {
        if (selectedNode) {
            selectedNode.userData.selected = false;
            selectedNode = null;
            store.selectedNodeId = null;
        }
        bus.emit('node:deselected');
    }

    function diveIntoNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node || !node.children?.length) return;
        
        currentContextId = nodeId;
        buildScene();
        
        // Camera animation
        const mesh = nodes.get(nodeId);
        if (mesh) {
            const targetPos = new THREE.Vector3(0, 8, 25);
            const startPos = camera.position.clone();
            const duration = 800;
            const startTime = Date.now();
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = easeOutCubic(progress);
                
                camera.position.lerpVectors(startPos, targetPos, ease);
                controls.target.set(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            animateCamera();
        }
        
        audio.expand();
        haptic.medium();
        showToast(`Diving into "${node.label}"`, 'info');
    }

    function surfaceUp() {
        const currentNode = store.findNode(currentContextId);
        if (!currentNode || currentContextId === store.data.id) return;
        
        const parent = store.findParent(currentContextId);
        if (!parent) {
            currentContextId = store.data.id;
        } else {
            currentContextId = parent.id;
        }
        
        buildScene();
        audio.collapse();
        haptic.medium();
    }

    function updateDepthIndicator() {
        const indicator = document.getElementById('depth-indicator');
        const pathEl = document.getElementById('depth-path');
        
        if (currentContextId === store.data.id) {
            indicator.classList.remove('active');
            return;
        }
        
        const path = store.getPath(currentContextId);
        if (path.length === 0) {
            indicator.classList.remove('active');
            return;
        }
        
        pathEl.innerHTML = path.map((n, i) => {
            const isLast = i === path.length - 1;
            return `<span class="depth-item ${isLast ? 'current' : ''}">${escapeHTML(n.label)}</span>` +
                   (isLast ? '' : '<span style="margin: 0 4px;">›</span>');
        }).join('');
        
        indicator.classList.add('active');
    }

    function resetCamera() {
        const isMobile = window.innerWidth <= 768;
        const targetPos = new THREE.Vector3(0, isMobile ? 12 : 8, isMobile ? 35 : 25);
        const startPos = camera.position.clone();
        const duration = 600;
        const startTime = Date.now();
        
        // Reset camera target goal to origin
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function zoomToFitMap(extraZoom = 0) {
        // Calculate bounds of all visible nodes
        let maxDist = 0;
        nodes.forEach(mesh => {
            if (mesh.visible) {
                const dist = mesh.position.length();
                maxDist = Math.max(maxDist, dist);
            }
        });
        
        const isMobile = window.innerWidth <= 768;
        // Zoom out enough to see all nodes plus some padding - more on mobile
        const targetDist = Math.max(maxDist * (isMobile ? 3 : 2.5) + extraZoom, isMobile ? 50 : 30);
        const targetPos = new THREE.Vector3(0, targetDist * 0.4, targetDist);
        const startPos = camera.position.clone();
        const duration = isMobile ? 1500 : 800; // Slower on mobile
        const startTime = Date.now();
        
        cameraTargetGoal.set(0, 0, 0);
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            camera.position.lerpVectors(startPos, targetPos, ease);
            controls.target.lerp(new THREE.Vector3(0, 0, 0), ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }
    
    // Focus camera on a specific node without full selection animation
    function focusOnNode(mesh) {
        if (!mesh) return;
        
        const nodePos = mesh.userData.spring?.target?.clone() || mesh.position.clone();
        
        // Smoothly move camera target to node
        cameraTargetGoal.copy(nodePos);
        
        // Calculate ideal camera position - maintain current viewing angle but center on node
        const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
        const currentRadius = currentOffset.length();
        
        // Animate camera to look at node
        const startTarget = controls.target.clone();
        const startPos = camera.position.clone();
        const endTarget = nodePos.clone();
        const endPos = nodePos.clone().add(currentOffset.normalize().multiplyScalar(Math.min(currentRadius, 30)));
        
        const duration = 400;
        const startTime = Date.now();
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const ease = easeOutCubic(progress);
            
            controls.target.lerpVectors(startTarget, endTarget, ease);
            camera.position.lerpVectors(startPos, endPos, ease);
            
            if (progress < 1) requestAnimationFrame(animate);
        }
        animate();
    }

    function expandAll() {
        const isMobile = window.innerWidth <= 768;
        
        // Start zooming out immediately on mobile
        if (isMobile) {
            zoomToFitMap(25);
        }
        
        // Get all nodes that need expanding, sorted by level (shallowest first)
        const toExpand = [];
        nodes.forEach(mesh => {
            if (mesh.userData.children?.length && !mesh.userData.isExpanded) {
                toExpand.push(mesh);
            }
        });
        
        if (toExpand.length === 0) {
            showToast('All nodes already expanded', 'info');
            // Still zoom out to show entire map
            if (!isMobile) zoomToFitMap(15);
            return;
        }
        
        // Sort by level (shallowest first)
        toExpand.sort((a, b) => (a.userData.level || 0) - (b.userData.level || 0));
        
        // Slower stagger on mobile to reduce lag
        const staggerTime = isMobile ? 150 : 60;
        
        // Expand with staggered animation
        toExpand.forEach((mesh, index) => {
            setTimeout(() => {
                if (!mesh.userData.isExpanded) {
                    expandNode(mesh, true);
                }
            }, index * staggerTime);
        });
        
        // Zoom out again at the end for desktop or if auto camera is enabled
        if (!isMobile && autoCameraEnabled) {
            const totalDuration = toExpand.length * staggerTime;
            setTimeout(() => {
                zoomToFitMap(15);
            }, Math.min(totalDuration + 200, 1500));
        }
        
        showToast('Expanding all nodes...', 'success');
    }

    function collapseAll() {
        const isMobile = window.innerWidth <= 768;
        
        // Get all expanded nodes, sorted by level (deepest first for proper collapse order)
        // Skip root node (level 0) - keep level 1 nodes visible but collapse their children
        const toCollapse = [];
        nodes.forEach(mesh => {
            // Only collapse nodes that are expanded AND have level >= 1 (not the root)
            if (mesh.userData.isExpanded && (mesh.userData.level || 0) >= 1) {
                toCollapse.push(mesh);
            }
        });
        
        if (toCollapse.length === 0) {
            showToast('Already collapsed', 'info');
            return;
        }
        
        // Sort by level descending (deepest first)
        toCollapse.sort((a, b) => (b.userData.level || 0) - (a.userData.level || 0));
        
        // Slower stagger on mobile
        const staggerTime = isMobile ? 100 : 50;
        
        // Collapse with staggered animation
        toCollapse.forEach((mesh, index) => {
            setTimeout(() => {
                if (mesh.userData.isExpanded) {
                    collapseNode(mesh, true);
                }
            }, index * staggerTime);
        });
        
        // Zoom to fit after collapse (only if auto camera is enabled)
        if (autoCameraEnabled) {
            const totalDuration = toCollapse.length * staggerTime;
            setTimeout(() => {
                zoomToFitMap(0);
            }, Math.min(totalDuration + 500, 2000));
        }
        
        showToast('Collapsing nodes...', 'success');
    }

    // Label decluttering - hide labels that overlap with others
    function declutterLabels() {
        const visibleLabels = [];
        const padding = 12; // pixels of padding between labels
        
        // Collect all visible labels with their screen positions
        nodes.forEach(mesh => {
            if (!mesh.visible || !mesh.userData.labelSprite) return;
            
            const sprite = mesh.userData.labelSprite;
            const pos = mesh.position.clone();
            pos.project(camera);
            
            // Skip if behind camera
            if (pos.z > 1) {
                sprite.material.opacity = 0;
                return;
            }
            
            // Convert to screen coordinates
            const screenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            
            // Get approximate label size in screen pixels based on text length
            const dist = camera.position.distanceTo(mesh.position);
            const textLength = (mesh.userData.label || '').length;
            const cfg = CONFIG.LABELS;
            const labelWidth = Math.max(cfg.minWidth, textLength * cfg.charWidth) * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            const labelHeight = 24 * (cfg.scaleFactor / Math.max(dist, cfg.minDistance));
            
            // Priority: selected nodes > root > by depth (shallower = higher priority)
            const depth = mesh.userData.depth || 0;
            const isSelected = mesh.userData.selected;
            const isRoot = mesh.userData.id === 'root';
            const priority = isSelected ? cfg.selectedPriority : (isRoot ? cfg.rootPriority : cfg.basePriority - depth * cfg.depthPenalty);
            
            visibleLabels.push({
                sprite,
                mesh,
                x: screenX,
                y: screenY,
                width: labelWidth,
                height: labelHeight,
                priority,
                baseOpacity: mesh.userData.labelBaseOpacity || 1,
                shouldShow: true
            });
        });
        
        // Sort by priority (higher priority labels get shown first)
        visibleLabels.sort((a, b) => b.priority - a.priority);
        
        // Check for overlaps and hide lower priority labels
        for (let i = 0; i < visibleLabels.length; i++) {
            if (!visibleLabels[i].shouldShow) continue;
            
            const labelA = visibleLabels[i];
            
            for (let j = i + 1; j < visibleLabels.length; j++) {
                if (!visibleLabels[j].shouldShow) continue;
                
                const labelB = visibleLabels[j];
                
                // Check for rectangle overlap
                const overlapX = Math.abs(labelA.x - labelB.x) < (labelA.width + labelB.width) / 2 + padding;
                const overlapY = Math.abs(labelA.y - labelB.y) < (labelA.height + labelB.height) / 2 + padding;
                
                if (overlapX && overlapY) {
                    // Hide the lower priority label (labelB since array is sorted)
                    visibleLabels[j].shouldShow = false;
                }
            }
        }
        
        // Apply visibility with smooth fade
        visibleLabels.forEach(label => {
            const targetOpacity = label.shouldShow ? label.baseOpacity : 0;
            const currentOpacity = label.sprite.material.opacity;
            // Smooth transition
            label.sprite.material.opacity = currentOpacity + (targetOpacity - currentOpacity) * 0.12;
            // Clamp very small values to 0
            if (label.sprite.material.opacity < 0.03) {
                label.sprite.material.opacity = 0;
            }
        });
    }

    // Animation loop - modularized and optimized
    function animate() {
        requestAnimationFrame(animate);
        
        // Check if we should render this frame (throttling)
        const currentTime = performance.now();
        if (!AnimationController.shouldRenderFrame(currentTime)) {
            return;
        }
        
        const time = Date.now() * 0.001;
        const cfg = CONFIG.ANIMATION;
        
        // Animate particles (skip when idle)
        if (particleSystem && !AnimationController.isIdle) {
            particleSystem.rotation.y = time * CONFIG.PARTICLES.rotationSpeed;
            particleSystem.rotation.x = Math.sin(time * 0.01) * 0.1;
        }
        
        // Track animating nodes for idle detection
        let animatingCount = 0;
        
        // Spring physics for nodes
        nodes.forEach(mesh => {
            if (!mesh.visible) return;
            
            const spring = mesh.userData.spring;
            if (!spring) return;
            
            // Check if node is still animating (position or scale)
            const posDiff = mesh.position.distanceTo(spring.target);
            const scaleDiff = Math.abs(mesh.scale.x - spring.scaleTarget);
            const isAnimating = posDiff > cfg.animatingThreshold || scaleDiff > cfg.animatingThreshold;
            
            if (isAnimating) animatingCount++;
            
            // Adaptive lerp - slower for longer distances (smoother repositioning)
            const lerpFactor = posDiff > 3 ? cfg.springLerpSlow : 
                              (posDiff > 1.5 ? cfg.springLerpMedium : cfg.springLerpBase);
            
            // Smooth position lerp
            if (posDiff > cfg.positionThreshold) {
                mesh.position.lerp(spring.target, lerpFactor);
            } else if (posDiff > 0) {
                mesh.position.copy(spring.target);
            }
            
            // Outline follows
            if (mesh.userData.outlineMesh) {
                mesh.userData.outlineMesh.position.copy(mesh.position);
            }
            
            // Smooth scale lerp
            const currentScale = mesh.scale.x;
            if (scaleDiff > cfg.scaleThreshold) {
                const newScale = currentScale + (spring.scaleTarget - currentScale) * cfg.scaleLerp;
                mesh.scale.set(newScale, newScale, newScale);
            } else {
                mesh.scale.set(spring.scaleTarget, spring.scaleTarget, spring.scaleTarget);
            }
            
            if (mesh.userData.outlineMesh) {
                const s = mesh.scale.x * 1.03;
                mesh.userData.outlineMesh.scale.set(s, s, s);
            }
            
            // Opacity for new nodes
            if (mesh.material.opacity < 1) {
                mesh.material.opacity = Math.min(1, mesh.material.opacity + 0.1);
            }
            
            // Queue connection updates for batch processing
            if (isAnimating && mesh.userData.connectionLine && mesh.userData.parent) {
                ConnectionManager.queueUpdate(mesh);
            }
            
            // Label visibility and scale (less frequent updates)
            if (mesh.userData.labelSprite) {
                const dist = camera.position.distanceTo(mesh.position);
                
                // Base scale calculation (less frequent)
                if (!mesh.userData.lastLabelUpdate || time - mesh.userData.lastLabelUpdate > CONFIG.TIMING.labelUpdateInterval / 1000) {
                    mesh.userData.lastLabelUpdate = time;
                    mesh.userData.labelBaseScale = 0.6 * Math.max(0.5, Math.min(1.2, dist / 15));
                    mesh.userData.labelBaseOpacity = Math.max(0.7, Math.min(1, 35 / dist));
                }
                
                const labelScale = mesh.userData.labelBaseScale || 0.6;
                const aspect = mesh.userData.labelSprite.userData.aspect || 
                    (mesh.userData.labelSprite.scale.x / mesh.userData.labelSprite.scale.y);
                mesh.userData.labelSprite.scale.set(labelScale * aspect, labelScale, 1);
                
                // Update context badge position and animation
                if (mesh.userData.contextBadge) {
                    const badge = mesh.userData.contextBadge;
                    const labelWidth = labelScale * aspect;
                    
                    // Position badge to the right of the label
                    badge.position.x = labelWidth / 2 + 0.16;
                    
                    // Pulse animation for the badge - scale and opacity
                    const pulsePhase = time * 2.5 + badge.userData.pulsePhase;
                    const scalePulse = 1 + Math.sin(pulsePhase) * 0.08;
                    const opacityPulse = 0.85 + Math.sin(pulsePhase) * 0.15;
                    
                    const baseScale = badge.userData.baseScale || 0.28;
                    let badgeScale = baseScale * scalePulse;
                    
                    // Hover effect
                    if (mesh.userData.badgeHovered) {
                        badgeScale *= 1.4;
                        badge.material.opacity = 1;
                    } else {
                        badge.material.opacity = opacityPulse;
                    }
                    
                    badge.scale.set(badgeScale, badgeScale, 1);
                }
            }
            
            // Selection glow
            if (mesh.userData.selected) {
                mesh.material.emissiveIntensity = 0.4 + Math.sin(time * 4) * 0.2;
            } else {
                mesh.material.emissiveIntensity = 0.5;
            }
        });
        
        // Batch process all connection updates
        ConnectionManager.processBatch();
        
        // Smart label decluttering - checks camera movement and runs only when needed
        LabelSystem.checkCameraMovement(camera, controls);
        LabelSystem.update(camera, nodes);
        
        // Smooth camera animation (runs even during interaction if animation is active)
        if (cameraArcAnimation) {
            const elapsed = performance.now() - cameraArcAnimation.startTime;
            const progress = Math.min(elapsed / cameraArcAnimation.duration, 1);
            
            // Use smootherStep for silkier transitions
            const ease = Utils.easing.smootherStep(progress);
            
            // Lerp target position
            controls.target.lerpVectors(
                cameraArcAnimation.startTarget,
                cameraArcAnimation.endTarget,
                ease
            );
            
            if (cameraArcAnimation.useSpherical) {
                // Spherical interpolation for smooth horizontal rotation
                let startTheta = cameraArcAnimation.startTheta;
                let endTheta = cameraArcAnimation.endTheta;
                
                // Take shortest path around the circle
                let deltaTheta = endTheta - startTheta;
                if (deltaTheta > Math.PI) deltaTheta -= Math.PI * 2;
                if (deltaTheta < -Math.PI) deltaTheta += Math.PI * 2;
                
                const currentTheta = startTheta + deltaTheta * ease;
                
                // Vertical angle - keep relatively constant, slight interpolation
                const currentPhi = cameraArcAnimation.startPhi + 
                    (cameraArcAnimation.endPhi - cameraArcAnimation.startPhi) * ease;
                
                // Radius with arc boost - zoom out in middle, back in at end
                const arcProgress = Math.sin(progress * Math.PI); // peaks at 0.5
                const baseRadius = cameraArcAnimation.startRadius + 
                    (cameraArcAnimation.endRadius - cameraArcAnimation.startRadius) * ease;
                const currentRadius = baseRadius + arcProgress * cameraArcAnimation.arcBoost;
                
                // Convert spherical back to cartesian, relative to current target
                const newOffset = new THREE.Vector3(
                    Math.sin(currentTheta) * Math.sin(currentPhi) * currentRadius,
                    Math.cos(currentPhi) * currentRadius,
                    Math.cos(currentTheta) * Math.sin(currentPhi) * currentRadius
                );
                
                camera.position.copy(controls.target).add(newOffset);
            } else if (cameraArcAnimation.endCameraPos) {
                // Fallback linear interpolation
                camera.position.lerpVectors(
                    cameraArcAnimation.startCameraPos,
                    cameraArcAnimation.endCameraPos,
                    ease
                );
            }
            
            cameraTargetGoal.copy(controls.target);
            
            // Clear animation when done
            if (progress >= 1) {
                cameraArcAnimation = null;
            }
        } else if (!userInteracting) {
            // Normal slow follow when no arc animation and not interacting
            const targetDiff = new THREE.Vector3().subVectors(cameraTargetGoal, controls.target);
            const step = targetDiff.multiplyScalar(CONFIG.ANIMATION.cameraFollowSpeed);
            controls.target.add(step);
            camera.position.add(step);
        }
        
        // Update animation controller with count of animating nodes
        AnimationController.setAnimatingCount(animatingCount);
        
        controls.update();
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════════════════════
    // UI INTERACTIONS
    // ═══════════════════════════════════════════════════════════════════
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let moveMode = false;
    let draggedNode = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    let dragOffset = new THREE.Vector3();
    let childOffsets = new Map(); // Store offsets for children when dragging expanded node
    let pointerDownTime = 0;
    let pointerDownPos = { x: 0, y: 0 };
    let clickedOnEmpty = false;
    let lastClickTime = 0;
    let lastClickedNodeId = null;

    // Get all visible descendants of a node
    function getVisibleDescendants(mesh, descendants = []) {
        if (!mesh.userData.children) return descendants;
        mesh.userData.children.forEach(childData => {
            const childMesh = nodes.get(childData.id);
            if (childMesh && childMesh.visible) {
                descendants.push(childMesh);
                getVisibleDescendants(childMesh, descendants);
            }
        });
        return descendants;
    }

    function onPointerDown(event) {
        if (event.target.closest('#info-panel, #side-panel, #top-controls, #quick-capture, #spotlight-overlay, #modal-overlay, #menu-dropdown, #theme-picker, #depth-indicator, #radial-menu, #voice-indicator, #voice-backdrop, #api-key-modal')) {
            return;
        }
        
        pointerDownTime = Date.now();
        pointerDownPos = { x: event.clientX, y: event.clientY };
        clickedOnEmpty = false;
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const meshes = Array.from(nodes.values()).filter(m => m.visible);
        const intersects = raycaster.intersectObjects(meshes, true); // Include children (labels)
        
        if (intersects.length > 0) {
            // Get the intersected object - might be the label sprite or badge, not the mesh
            let mesh = intersects[0].object;
            let clickedOnContextBadge = false;
            
            // If we hit a sprite, get the parent mesh
            if (mesh.isSprite && mesh.parent && mesh.parent.userData?.id) {
                // Check if this is the context badge
                if (mesh.userData?.isContextBadge) {
                    clickedOnContextBadge = true;
                }
                mesh = mesh.parent;
            }
            
            // Make sure we have a valid node mesh with userData
            if (!mesh.userData?.id) {
                clickedOnEmpty = true;
                lastClickedNodeId = null;
                return;
            }
            
            // Move mode - start dragging immediately, don't select (which might collapse)
            if (moveMode) {
                draggedNode = mesh;
                controls.enabled = false;
                renderer.domElement.style.cursor = 'grabbing';
                
                // Set up drag plane facing camera
                const cameraDir = new THREE.Vector3();
                camera.getWorldDirection(cameraDir);
                dragPlane.setFromNormalAndCoplanarPoint(cameraDir.negate(), mesh.position);
                
                // Calculate offset
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragOffset.subVectors(mesh.position, intersectPoint);
                
                // Store offsets for all visible descendants so they move with parent
                childOffsets.clear();
                const descendants = getVisibleDescendants(mesh);
                descendants.forEach(childMesh => {
                    const offset = childMesh.position.clone().sub(mesh.position);
                    childOffsets.set(childMesh.userData.id, offset);
                });
            } else {
                // Check for double-click on same node
                const now = Date.now();
                const isDoubleClick = (now - lastClickTime < 350) && (lastClickedNodeId === mesh.userData.id);
                
                lastClickTime = now;
                lastClickedNodeId = mesh.userData.id;
                
                selectNode(mesh, isDoubleClick);
                
                // If context badge was clicked, expand panel and open the question popover
                if (clickedOnContextBadge && mesh.userData.contextBadge) {
                    setTimeout(() => {
                        // Expand the info panel first so the button is visible
                        const infoPanel = document.getElementById('info-panel');
                        if (!infoPanel.classList.contains('expanded')) {
                            infoPanel.classList.add('expanded');
                        }
                        // Then click the context question button
                        setTimeout(() => {
                            document.getElementById('context-question-btn').click();
                        }, 100);
                    }, 100);
                }
            }
        } else {
            // Clicked on empty space - track for potential deselect on pointer up
            clickedOnEmpty = true;
            lastClickedNodeId = null;
        }
    }
    
    function onPointerMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Hover detection for labels with context badges
        if (!moveMode && !draggedNode) {
            raycaster.setFromCamera(mouse, camera);
            const meshes = Array.from(nodes.values()).filter(m => m.visible);
            const intersects = raycaster.intersectObjects(meshes, true);
            
            // Clear previous hover states
            nodes.forEach(mesh => {
                if (mesh.userData.badgeHovered) {
                    mesh.userData.badgeHovered = false;
                }
            });
            
            if (intersects.length > 0) {
                let hitObject = intersects[0].object;
                let parentMesh = null;
                
                // Check if we hit a context badge sprite
                if (hitObject.isSprite && hitObject.userData?.isContextBadge && hitObject.parent && hitObject.parent.userData?.id) {
                    parentMesh = hitObject.parent;
                    parentMesh.userData.badgeHovered = true;
                    renderer.domElement.style.cursor = 'pointer';
                } else if (hitObject.isSprite && hitObject.parent && hitObject.parent.userData?.id) {
                    // Hit the label - check if node has a context badge
                    parentMesh = hitObject.parent;
                }
                
                if (!parentMesh?.userData.badgeHovered) {
                    renderer.domElement.style.cursor = moveMode ? 'grab' : 'default';
                }
            } else {
                renderer.domElement.style.cursor = moveMode ? 'grab' : 'default';
            }
        }
        
        // Dragging logic
        if (!draggedNode || !moveMode) return;
        
        raycaster.setFromCamera(mouse, camera);
        const intersectPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(dragPlane, intersectPoint);
        
        if (intersectPoint) {
            const newPos = intersectPoint.add(dragOffset);
            draggedNode.userData.spring.target.copy(newPos);
            draggedNode.userData.basePosition = [newPos.x, newPos.y, newPos.z];
            
            // Move all children with the parent
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh && childMesh.visible) {
                    const childNewPos = newPos.clone().add(offset);
                    childMesh.userData.spring.target.copy(childNewPos);
                    childMesh.userData.basePosition = [childNewPos.x, childNewPos.y, childNewPos.z];
                    
                    // Update child's connection line
                    if (childMesh.userData.connectionLine && childMesh.userData.parent) {
                        const parentMesh = nodes.get(childMesh.userData.parent.id);
                        if (parentMesh) {
                            updateConnection(childMesh, parentMesh);
                        }
                    }
                }
            });
            
            // Update connection line for dragged node
            if (draggedNode.userData.connectionLine && draggedNode.userData.parent) {
                const parentMesh = nodes.get(draggedNode.userData.parent.id);
                if (parentMesh) {
                    updateConnection(draggedNode, parentMesh);
                }
            }
        }
    }
    
    function onPointerUp(event) {
        if (draggedNode && moveMode) {
            // Save final positions to store
            const nodeData = store.findNode(draggedNode.userData.id);
            if (nodeData) {
                const pos = draggedNode.userData.spring.target;
                nodeData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
            }
            
            // Save child positions too
            childOffsets.forEach((offset, childId) => {
                const childMesh = nodes.get(childId);
                if (childMesh) {
                    const childData = store.findNode(childId);
                    if (childData) {
                        const pos = childMesh.userData.spring.target;
                        childData.customPosition = { x: pos.x, y: pos.y, z: pos.z };
                    }
                }
            });
            
            store.save();
            childOffsets.clear();
            draggedNode = null;
            controls.enabled = true;
            renderer.domElement.style.cursor = 'grab';
        }
        
        // Only deselect on single click (not drag) on empty space
        if (clickedOnEmpty) {
            const timeDiff = Date.now() - pointerDownTime;
            const dx = event.clientX - pointerDownPos.x;
            const dy = event.clientY - pointerDownPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Single click = short time and minimal movement
            if (timeDiff < 300 && distance < 10) {
                deselectNode();
            }
            clickedOnEmpty = false;
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // KEYBOARD SHORTCUTS
    // ═══════════════════════════════════════════════════════════════════
    document.addEventListener('keydown', (e) => {
        // Cmd/Ctrl + K for spotlight
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            toggleSpotlight();
            return;
        }
        
        // Ignore if in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch (e.key) {
            case 'Tab':
                e.preventDefault();
                if (selectedNode) {
                    openModal('add', selectedNode.userData.id);
                } else if (currentContextId) {
                    openModal('add', currentContextId);
                }
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedNode && selectedNode.userData.parent) {
                    openModal('add', selectedNode.userData.parent.id);
                }
                break;
                
            case ' ':
                e.preventDefault();
                if (selectedNode) {
                    toggleExpand(selectedNode);
                }
                break;
                
            case 'Escape':
                if (voiceAI.isRecording || voiceAI.isProcessing) {
                    voiceAI.stop();
                }
                closeSpotlight();
                closeModal();
                deselectNode();
                break;
                
            case 'Backspace':
            case 'Delete':
                if (selectedNode && selectedNode.userData.id !== store.data.id) {
                    const nodeLabel = selectedNode.userData.label;
                    const hasChildren = selectedNode.userData.children?.length > 0;
                    showConfirm({
                        title: 'Delete Node',
                        message: hasChildren 
                            ? `Delete "${nodeLabel}" and all its children?`
                            : `Delete "${nodeLabel}"?`,
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        danger: true
                    }).then(confirmed => {
                        if (confirmed) {
                            store.deleteNode(selectedNode.userData.id);
                            buildScene();
                            showToast('Node deleted', 'success');
                        }
                    });
                }
                break;
                
            case 'e':
                if (selectedNode) {
                    openModal('edit', selectedNode.userData.id);
                }
                break;
                
            case 'd':
                if (selectedNode && selectedNode.userData.children?.length) {
                    diveIntoNode(selectedNode.userData.id);
                }
                break;
                
            case 'u':
                surfaceUp();
                break;
                
            case '?':
                showKeyboardHints();
                break;
                
            case 'z':
                if (e.metaKey || e.ctrlKey) {
                    e.preventDefault();
                    const result = store.undo();
                    if (result.success) {
                        buildScene();
                        showToast(`Undid: ${result.actionName}`, 'info');
                    }
                }
                break;
        }
    });

    function showKeyboardHints() {
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 3000);
    }

    // ═══════════════════════════════════════════════════════════════════
    // SPOTLIGHT SEARCH
    // ═══════════════════════════════════════════════════════════════════
    const spotlightOverlay = document.getElementById('spotlight-overlay');
    const spotlightInput = document.getElementById('spotlight-input');
    const spotlightNodesList = document.getElementById('spotlight-nodes-list');
    let spotlightOpen = false;

    function toggleSpotlight() {
        spotlightOpen = !spotlightOpen;
        if (spotlightOpen) {
            spotlightOverlay.classList.add('active');
            spotlightInput.value = '';
            spotlightInput.focus();
            updateSpotlightResults('');
        } else {
            spotlightOverlay.classList.remove('active');
        }
    }

    function closeSpotlight() {
        spotlightOpen = false;
        spotlightOverlay.classList.remove('active');
    }

    spotlightOverlay.addEventListener('click', (e) => {
        if (e.target === spotlightOverlay) closeSpotlight();
    });

    spotlightInput.addEventListener('input', (e) => {
        updateSpotlightResults(e.target.value);
    });

    spotlightInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeSpotlight();
        } else if (e.key === 'Enter') {
            const selected = document.querySelector('.spotlight-item.selected');
            if (selected) {
                selected.click();
            } else if (spotlightInput.value.trim()) {
                // Create new node with input text
                const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
                store.addNode(parentId, { label: spotlightInput.value.trim() });
                buildScene();
                closeSpotlight();
                showToast(`Created "${spotlightInput.value.trim()}"`, 'success');
            }
        }
    });

    function updateSpotlightResults(query) {
        const results = query ? store.searchNodes(query) : store.getAllNodes().slice(0, 8);
        
        spotlightNodesList.innerHTML = results.map(node => `
            <div class="spotlight-item" data-id="${node.id}">
                <div class="spotlight-item-icon" style="background: ${node.color};"></div>
                <div class="spotlight-item-content">
                    <div class="spotlight-item-title">${escapeHTML(node.label)}</div>
                    <div class="spotlight-item-subtitle">${node.children?.length || 0} children</div>
                </div>
            </div>
        `).join('');
        
        // Add click handlers
        spotlightNodesList.querySelectorAll('.spotlight-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                const mesh = nodes.get(id);
                if (mesh) {
                    selectNode(mesh);
                    
                    // Pan camera to node
                    const targetPos = mesh.position.clone();
                    controls.target.lerp(targetPos, 0.5);
                }
                closeSpotlight();
            });
        });
    }

    // Quick actions in spotlight
    document.querySelectorAll('.spotlight-item[data-action]').forEach(item => {
        item.addEventListener('click', () => {
            const action = item.dataset.action;
            switch (action) {
                case 'new-node':
                    openModal('add', selectedNode?.userData.id || currentContextId);
                    break;
                case 'brainstorm':
                    if (selectedNode) {
                        brainstormNode(selectedNode.userData.id);
                    }
                    break;
            }
            closeSpotlight();
        });
    });

    // ═══════════════════════════════════════════════════════════════════
    // MODAL SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const modalOverlay = document.getElementById('modal-overlay');
    const modalTitle = document.getElementById('modal-title');
    const inputName = document.getElementById('input-name');
    const inputDesc = document.getElementById('input-desc');
    const colorGrid = document.getElementById('color-grid');
    let modalMode = 'add';
    let modalParentId = null;
    let modalEditId = null;
    let selectedColor = getThemeColors()[0];

    // Create color swatches
    colorGrid.innerHTML = getThemeColors().map(color => 
        `<div class="color-swatch" data-color="${color}" style="background: ${color};"></div>`
    ).join('');

    colorGrid.addEventListener('click', (e) => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            selectedColor = swatch.dataset.color;
            colorGrid.querySelectorAll('.color-swatch').forEach(s => 
                s.classList.toggle('selected', s.dataset.color === selectedColor)
            );
        }
    });

    function openModal(mode, targetId) {
        modalMode = mode;
        modalOverlay.classList.add('active');
        
        if (mode === 'add') {
            modalParentId = targetId;
            modalEditId = null;
            modalTitle.textContent = 'Add New Node';
            document.getElementById('modal-submit').textContent = 'Create';
            inputName.value = '';
            inputDesc.value = '';
            
            const parent = store.findNode(targetId);
            selectedColor = parent?.color || getThemeColors()[0];
        } else {
            modalEditId = targetId;
            modalParentId = null;
            modalTitle.textContent = 'Edit Node';
            document.getElementById('modal-submit').textContent = 'Save';
            
            const node = store.findNode(targetId);
            if (node) {
                inputName.value = node.label;
                inputDesc.value = node.description || '';
                selectedColor = node.color;
            }
        }
        
        colorGrid.querySelectorAll('.color-swatch').forEach(s => 
            s.classList.toggle('selected', s.dataset.color === selectedColor)
        );
        
        inputName.focus();
    }

    function closeModal() {
        modalOverlay.classList.remove('active');
        modalParentId = null;
        modalEditId = null;
    }

    function submitModal() {
        const name = inputName.value.trim();
        if (!name) {
            showToast('Please enter a name', 'error');
            return;
        }
        
        if (modalMode === 'add' && modalParentId) {
            const newNode = store.addNode(modalParentId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            if (newNode) {
                buildScene();
                
                // Celebration!
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, selectedColor, 6);
                    selectNode(mesh);
                }
                
                audio.success();
                haptic.success();
                showToast(`Created "${name}"`, 'success');
            }
        } else if (modalMode === 'edit' && modalEditId) {
            store.updateNode(modalEditId, {
                label: name,
                color: selectedColor,
                description: inputDesc.value.trim()
            });
            
            buildScene();
            showToast(`Updated "${name}"`, 'success');
        }
        
        closeModal();
    }

    document.getElementById('modal-cancel').addEventListener('click', closeModal);
    document.getElementById('modal-submit').addEventListener('click', submitModal);
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) closeModal();
    });
    
    // Enter key to submit modal
    inputName.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitModal();
        }
    });
    inputDesc.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            submitModal();
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // AI BRAINSTORM
    // ═══════════════════════════════════════════════════════════════════
    async function brainstormNode(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                showToast('API key required for AI features', 'error');
                return;
            }
        }
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 300,
                    messages: [{
                        role: 'user',
                        content: `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${node.label}"${description ? `\n- Description: "${description}"` : ''}
- Path to root: ${context}
- Existing children: ${siblings || 'none yet'}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of strings with the node labels. Make them concise but meaningful.
Example: ["Daily Habits", "Weekly Reviews", "Long-term Vision"]`
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            const ideas = JSON.parse(text);
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    store.addNode(nodeId, { label: idea, color: node.color });
                });
                
                // Mark node as expanded BEFORE building scene so children are visible
                store.expandedNodes.add(nodeId);
                
                buildScene();
                
                // Get the mesh and ensure it's marked as expanded
                const mesh = nodes.get(nodeId);
                if (mesh) {
                    mesh.userData.isExpanded = true;
                    
                    // Make sure all children are visible
                    mesh.userData.children?.forEach(childData => {
                        const childMesh = nodes.get(childData.id);
                        if (childMesh) {
                            childMesh.visible = true;
                            if (childMesh.userData.outlineMesh) childMesh.userData.outlineMesh.visible = true;
                            if (childMesh.userData.labelSprite) childMesh.userData.labelSprite.visible = true;
                            if (childMesh.userData.contextBadge) childMesh.userData.contextBadge.visible = true;
                            if (childMesh.userData.connectionLine) childMesh.userData.connectionLine.visible = true;
                            childMesh.userData.collapsed = false;
                        }
                    });
                    
                    // Celebration
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, node.color, 8);
                }
                
                audio.success();
                haptic.success();
                showToast(`Added ${ideas.length} new ideas!`, 'success');
            }
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast('Failed to generate ideas. Check your API key.', 'error');
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // INFO PANEL
    // ═══════════════════════════════════════════════════════════════════
    const infoPanel = document.getElementById('info-panel');
    const infoTitle = document.getElementById('info-title');
    const infoColor = document.getElementById('info-color');
    const infoColorPicker = document.getElementById('info-color-picker');
    const infoChildren = document.getElementById('info-children');
    
    // Populate color picker
    infoColorPicker.innerHTML = getThemeColors().slice(0, 12).map(color => 
        `<span style="background:${color}" data-color="${color}"></span>`
    ).join('');
    
    // Toggle color picker
    infoColor.addEventListener('click', (e) => {
        if (e.target === infoColor || e.target === infoColorPicker) {
            infoColorPicker.classList.toggle('active');
        }
    });
    
    // Select color from picker
    infoColorPicker.addEventListener('click', (e) => {
        const colorEl = e.target.closest('[data-color]');
        if (colorEl && selectedNode) {
            const newColor = colorEl.dataset.color;
            store.updateNode(selectedNode.userData.id, { color: newColor });
            selectedNode.userData.color = newColor;
            selectedNode.material.color.set(newColor);
            selectedNode.material.emissive.set(newColor);
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.material.color.set(new THREE.Color(newColor).multiplyScalar(0.3));
            }
            if (selectedNode.userData.connectionLine) {
                selectedNode.userData.connectionLine.material.color.set(new THREE.Color(newColor).multiplyScalar(0.6));
            }
            // Update label with new color
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(selectedNode.userData.label, newColor);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            infoColor.style.background = newColor;
            infoColorPicker.classList.remove('active');
            showToast('Color updated', 'success');
        }
    });
    
    // Inline title editing
    infoTitle.addEventListener('change', () => {
        if (selectedNode && infoTitle.value.trim()) {
            store.updateNode(selectedNode.userData.id, { label: infoTitle.value.trim() });
            selectedNode.userData.label = infoTitle.value.trim();
            // Update label sprite
            if (selectedNode.userData.labelSprite) {
                const oldSprite = selectedNode.userData.labelSprite;
                const newSprite = createLabelSprite(infoTitle.value.trim(), selectedNode.userData.color);
                newSprite.position.copy(oldSprite.position);
                newSprite.scale.copy(oldSprite.scale);
                newSprite.visible = oldSprite.visible;
                selectedNode.remove(oldSprite);
                oldSprite.material.map?.dispose();
                oldSprite.material.dispose();
                selectedNode.add(newSprite);
                selectedNode.userData.labelSprite = newSprite;
            }
            showToast('Name updated', 'success');
        }
    });
    
    // Enter key to save and blur info title
    infoTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            infoTitle.blur();
        }
    });
    
    // Importance slider
    const infoImportance = document.getElementById('info-importance');
    infoImportance.addEventListener('input', () => {
        if (selectedNode) {
            const scale = parseFloat(infoImportance.value);
            selectedNode.userData.importance = scale;
            store.updateNode(selectedNode.userData.id, { importance: scale });
            
            // Update node size
            const baseSize = selectedNode.userData.baseSize || 1;
            const newSize = baseSize * scale;
            selectedNode.scale.set(newSize, newSize, newSize);
            if (selectedNode.userData.outlineMesh) {
                selectedNode.userData.outlineMesh.scale.set(newSize * 1.03, newSize * 1.03, newSize * 1.03);
            }
            
            // Update spring scale target
            selectedNode.userData.spring.scaleTarget = newSize;
        }
    });
    
    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.info-color')) {
            infoColorPicker.classList.remove('active');
        }
    });

    bus.on('node:selected', ({ data }) => {
        // Track node view in user profile
        userProfile.trackNodeViewed(data, store);
        
        // Track in meta-learner (exploration patterns)
        const path = store.getPath(data.id);
        const depth = path.length - 1;
        metaLearner.trackNodeSelected(data, depth, store);
        
        infoTitle.value = data.label || 'Untitled';
        infoColor.style.background = data.color || '#888888';
        infoChildren.textContent = `${data.children?.length || 0} children`;
        infoColorPicker.classList.remove('active');
        
        // Set importance slider
        infoImportance.value = data.importance || 1;
        
        // Show source badge (AI, Link, etc.)
        const sourceEl = document.getElementById('info-source');
        const source = data.source || data.link?.source;
        if (source === 'ai' || source === 'brainstorm' || source === 'smart-expand') {
            sourceEl.textContent = 'AI';
            sourceEl.className = 'ai';
        } else if (source === 'link' || data.link) {
            sourceEl.textContent = '🔗 Link';
            sourceEl.className = 'link';
        } else {
            sourceEl.textContent = '';
            sourceEl.className = '';
        }
        
        // Populate expanded section
        // Description
        document.getElementById('info-description').value = data.description || '';
        
        // Show/hide context question button based on description (skip root node)
        document.getElementById('context-question-popover').classList.remove('active');
        
        if (data.level > 0 && (!data.description || data.description.trim() === '')) {
            document.getElementById('context-question-btn').classList.remove('hidden');
        } else {
            document.getElementById('context-question-btn').classList.add('hidden');
        }
        
        // Path breadcrumbs
        const pathSection = document.getElementById('info-path-section');
        const pathContainer = document.getElementById('info-path');
        // path already declared above for meta-learner
        
        if (path.length > 1) {
            pathSection.style.display = 'block';
            pathContainer.innerHTML = path.map((node, index) => {
                const isLast = index === path.length - 1;
                const separator = !isLast ? '<span class="info-path-separator">›</span>' : '';
                return `
                    <div class="info-path-item ${isLast ? 'info-path-current' : ''}" data-node-id="${node.id}">
                        <span class="info-path-color" style="background: ${node.color || '#888888'}"></span>
                        <span class="info-path-name">${node.label || 'Untitled'}</span>
                    </div>
                    ${separator}
                `;
            }).join('');
            
            // Add click handlers
            pathContainer.querySelectorAll('.info-path-item:not(.info-path-current)').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const nodeMesh = nodes.get(nodeId);
                    if (nodeMesh) {
                        selectNode(nodeMesh);
                        focusOnNode(nodeMesh);
                    }
                });
            });
        } else {
            pathSection.style.display = 'none';
        }
        
        // Show/hide link info (collapsed view)
        const linkSection = document.getElementById('info-link');
        const addLinkSection = document.getElementById('info-add-link-section');
        
        if (data.link?.url) {
            linkSection.style.display = 'block';
            document.getElementById('info-link-url').href = data.link.url;
            document.getElementById('info-link-favicon').src = data.link.favicon || '';
            document.getElementById('info-link-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
        } else {
            linkSection.style.display = 'none';
        }
        
        // Show add link section for all non-root nodes
        addLinkSection.style.display = data.id !== 'mynd' ? 'block' : 'none';
        document.getElementById('info-add-link-input').value = '';
        
        // Link info (expanded view)
        const linkExpandedSection = document.getElementById('info-link-section');
        if (data.link?.url) {
            linkExpandedSection.style.display = 'block';
            
            // Thumbnail
            const thumbnail = document.getElementById('info-link-thumbnail');
            if (data.link.image) {
                thumbnail.src = data.link.image;
                thumbnail.style.display = 'block';
            } else {
                thumbnail.style.display = 'none';
            }
            
            // URL and domain
            document.getElementById('info-link-full-url').href = data.link.url;
            document.getElementById('info-link-favicon-small').src = data.link.favicon || '';
            document.getElementById('info-link-full-domain').textContent = data.link.domain || new URL(data.link.url).hostname;
            
            // Meta info
            const meta = [];
            if (data.link.type) meta.push(data.link.type);
            if (data.link.author) meta.push(`by ${data.link.author}`);
            if (data.link.addedAt) {
                const date = new Date(data.link.addedAt);
                meta.push(`added ${date.toLocaleDateString()}`);
            }
            document.getElementById('info-link-meta').textContent = meta.join(' • ');
        } else {
            linkExpandedSection.style.display = 'none';
        }
        
        // Transcript section
        const transcriptSection = document.getElementById('info-transcript-section');
        if (data.link?.transcript) {
            transcriptSection.style.display = 'block';
            
            const transcript = data.link.transcript;
            const charCount = transcript.length;
            document.getElementById('info-transcript-chars').textContent = `${Math.round(charCount / 100) / 10}k chars`;
            
            // Show preview (first 300 chars)
            document.getElementById('info-transcript-preview').textContent = 
                transcript.substring(0, 300) + (transcript.length > 300 ? '...' : '');
            
            // Full transcript
            document.getElementById('info-transcript-text').textContent = transcript;
            
            // Reset toggle state
            document.getElementById('info-transcript-full').style.display = 'none';
            document.getElementById('info-transcript-toggle').textContent = 'Show full transcript';
        } else {
            transcriptSection.style.display = 'none';
        }
        
        // Node metadata
        // Created date
        const createdSection = document.getElementById('info-created-section');
        if (data.createdAt) {
            createdSection.style.display = 'flex';
            const date = new Date(data.createdAt);
            document.getElementById('info-created').textContent = date.toLocaleDateString();
        } else {
            createdSection.style.display = 'none';
        }
        
        // Added by
        const addedByValue = document.getElementById('info-added-by');
        if (data.source === 'brainstorm') {
            addedByValue.textContent = 'AI Brainstorm';
        } else if (data.source === 'smart-expand') {
            addedByValue.textContent = 'Smart Expand';
        } else if (data.source === 'link' || data.link) {
            addedByValue.textContent = '🔗 Link Import';
        } else if (data.source === 'onboarding') {
            addedByValue.textContent = '📋 Onboarding';
        } else {
            addedByValue.textContent = 'You';
        }
        
        // Show/hide dive button
        document.getElementById('action-dive').style.display = 
            data.children?.length ? 'flex' : 'none';
        
        // Show/hide delete button (can't delete root in current context)
        document.getElementById('action-delete').style.display = 
            data.id !== currentContextId ? 'flex' : 'none';
        
        // Show/hide organize button
        // Show if: (1) 2+ link children from same domain, OR (2) 6+ children total
        const organizeBtn = document.getElementById('action-organize');
        if (data.children && data.children.length >= 2) {
            // Count links by domain
            const domainCounts = {};
            let linkCount = 0;
            data.children.forEach(child => {
                if (child.link?.domain || child.link?.url) {
                    linkCount++;
                    let domain = child.link.domain;
                    if (!domain && child.link.url) {
                        try {
                            domain = new URL(child.link.url).hostname;
                        } catch (e) {}
                    }
                    if (domain) {
                        domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                        domainCounts[domain] = (domainCounts[domain] || 0) + 1;
                    }
                }
            });
            
            // Show if any domain has 2+ items OR if node has 6+ children
            const hasMultipleSameDomain = Object.values(domainCounts).some(count => count >= 2);
            const hasManyChildren = data.children.length >= 6;
            
            organizeBtn.style.display = (hasMultipleSameDomain || hasManyChildren) ? 'flex' : 'none';
        } else {
            organizeBtn.style.display = 'none';
        }
        
        // Hide quick capture, show info panel
        document.getElementById('quick-capture').style.display = 'none';
        infoPanel.classList.add('active');
        
        // Don't auto-expand - user can expand manually if needed
        // The context question button is visible in the collapsed view
        
        // Move toolbar up on mobile when info panel is visible
        if (window.innerWidth <= 768) {
            document.getElementById('side-panel').classList.add('info-visible');
            document.getElementById('toolbar-toggle').classList.add('info-visible');
        }
    });

    bus.on('node:deselected', () => {
        infoPanel.classList.remove('active');
        infoPanel.classList.remove('expanded');
        infoColorPicker.classList.remove('active');
        // Show quick capture again
        document.getElementById('quick-capture').style.display = 'block';
        
        // Move toolbar back down on mobile
        document.getElementById('side-panel').classList.remove('info-visible');
        document.getElementById('toolbar-toggle').classList.remove('info-visible');
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // INCREMENTAL LEARNING - Learn from every node addition
    // ═══════════════════════════════════════════════════════════════════
    bus.on('node:added', ({ parent, node }) => {
        if (!neuralNet.isReady) return;
        
        // Calculate depth first (needed for multiple systems)
        const path = store.getPath(node.id);
        const depth = path.length - 1; // Depth is path length minus 1 (root is depth 0)
        
        // Learn the parent->child pattern
        neuralNet.incrementalLearnPattern(parent.label, node.label, node.source || 'user', depth);
        
        // Queue embedding for new node
        const nodeText = node.description 
            ? `${node.label}. ${node.description}`
            : node.label;
        neuralNet.queueEmbedding(nodeText);
        
        // Track in user profile
        userProfile.trackNodeCreated(node, parent, depth, store);
        
        // Track in meta-learner (how user thinks)
        metaLearner.trackNodeCreated(node, parent, depth, store);
        
        // Store semantic memory for significant events
        const source = node.source || 'user';
        if (source === 'user') {
            semanticMemory.addMemory(
                'node_created_manual',
                `User created "${node.label}" under "${parent.label}"`,
                { parentLabel: parent.label, childLabel: node.label }
            );
        } else if (source === 'smart-expand') {
            // Memory already created when suggestion was accepted
        } else if (source === 'brainstorm') {
            semanticMemory.addMemory(
                'brainstorm_completed',
                `AI brainstormed "${node.label}" under "${parent.label}"`,
                { parentLabel: parent.label, childLabel: node.label, source: 'brainstorm' }
            );
        }
        
        // Update UI stats
        NeuralUI.updateStatus();
    });
    
    // Info panel expand toggle
    document.getElementById('info-expand-toggle').addEventListener('click', () => {
        infoPanel.classList.toggle('expanded');
    });
    
    // Description save on blur
    document.getElementById('info-description').addEventListener('blur', (e) => {
        if (selectedNode) {
            const nodeData = store.findNode(selectedNode.userData.id);
            if (nodeData) {
                const newDescription = e.target.value.trim();
                const wasEmpty = !nodeData.description;
                nodeData.description = newDescription;
                selectedNode.userData.description = newDescription;
                store.save();
                
                // Track edit in meta-learner
                if (newDescription && wasEmpty) {
                    metaLearner.trackNodeEdited(nodeData, 'description');
                }
                
                // Remove context badge if description was added
                if (newDescription && selectedNode.userData.contextBadge) {
                    removeContextIndicator(selectedNode);
                    document.getElementById('context-question-btn').classList.add('hidden');
                }
            }
        }
    });
    
    // Transcript toggle
    document.getElementById('info-transcript-toggle').addEventListener('click', () => {
        const fullSection = document.getElementById('info-transcript-full');
        const toggleBtn = document.getElementById('info-transcript-toggle');
        
        if (fullSection.style.display === 'none') {
            fullSection.style.display = 'block';
            toggleBtn.textContent = 'Hide full transcript';
        } else {
            fullSection.style.display = 'none';
            toggleBtn.textContent = 'Show full transcript';
        }
    });

    document.getElementById('info-close').addEventListener('click', deselectNode);

    document.getElementById('action-dive').addEventListener('click', () => {
        if (selectedNode) diveIntoNode(selectedNode.userData.id);
    });

    document.getElementById('action-add').addEventListener('click', () => {
        if (selectedNode) openModal('add', selectedNode.userData.id);
    });

    document.getElementById('action-brainstorm').addEventListener('click', () => {
        if (selectedNode) brainstormNodeEnhanced(selectedNode.userData.id);
    });

    document.getElementById('action-delete').addEventListener('click', async () => {
        if (selectedNode && selectedNode.userData.id !== store.data.id) {
            const nodeLabel = selectedNode.userData.label;
            const hasChildren = selectedNode.userData.children?.length > 0;
            
            const confirmed = await showConfirm({
                title: 'Delete Node',
                message: hasChildren 
                    ? `Delete "${nodeLabel}" and all its children?`
                    : `Delete "${nodeLabel}"?`,
                confirmText: 'Delete',
                cancelText: 'Cancel',
                danger: true
            });
            
            if (confirmed) {
                store.deleteNode(selectedNode.userData.id);
                deselectNode();
                buildScene();
                showToast('Node deleted', 'success');
            }
        }
    });
    
    // Add link to node - creates a child node with the link
    document.getElementById('info-add-link-btn').addEventListener('click', () => {
        const input = document.getElementById('info-add-link-input');
        const url = input.value.trim();
        
        if (!url) {
            showToast('Please enter a URL', 'info');
            input.focus();
            return;
        }
        
        // Validate and normalize URL
        let normalizedUrl = url;
        if (!url.match(/^https?:\/\//i)) {
            normalizedUrl = 'https://' + url;
        }
        
        try {
            new URL(normalizedUrl);
        } catch {
            showToast('Invalid URL format', 'error');
            return;
        }
        
        if (!selectedNode) return;
        
        const parentId = selectedNode.userData.id;
        
        // Clear input
        input.value = '';
        
        // Use LinkCapture to add as child node
        LinkCapture.addLinkAsChild(normalizedUrl, parentId);
    });
    
    // Handle Enter key in add-link input
    document.getElementById('info-add-link-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('info-add-link-btn').click();
        }
    });
    
    // Organize button - groups children by domain/platform OR uses AI for regular nodes
    document.getElementById('action-organize').addEventListener('click', async () => {
        if (!selectedNode) return;
        
        const nodeId = selectedNode.userData.id;
        const nodeData = store.findNode(nodeId);
        if (!nodeData || !nodeData.children || nodeData.children.length < 2) return;
        
        // First, try domain-based grouping for links
        const domainGroups = {};
        let regularNodes = [];
        
        nodeData.children.forEach(child => {
            if (child.link?.domain || child.link?.url) {
                let domain = child.link.domain;
                if (!domain && child.link.url) {
                    try {
                        domain = new URL(child.link.url).hostname;
                    } catch (e) {}
                }
                if (domain) {
                    domain = domain.replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '').toLowerCase();
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            } else {
                regularNodes.push(child);
            }
        });
        
        let totalMoved = 0;
        let foldersCreated = 0;
        
        // Handle link grouping by domain
        for (const [domain, items] of Object.entries(domainGroups)) {
            if (items.length >= 2) {
                const folderName = LinkManager.getDomainFolderName(domain);
                
                const existingFolder = nodeData.children.find(c => 
                    c.label.toLowerCase() === folderName.toLowerCase() && !c.link
                );
                
                let folderId;
                if (existingFolder) {
                    folderId = existingFolder.id;
                } else {
                    const folder = store.addNode(nodeId, {
                        label: folderName,
                        description: `Collection of ${folderName} content`,
                        color: nodeData.color,
                        source: 'smart-organize'
                    });
                    folderId = folder.id;
                    foldersCreated++;
                }
                
                for (const item of items) {
                    if (store.moveNode(item.id, folderId)) {
                        totalMoved++;
                    }
                }
            }
        }
        
        // If we have many regular nodes, use AI to organize (Edge Function or local API)
        if (regularNodes.length >= 5) {
            showToast('AI analyzing nodes...', 'info');
            
            try {
                const childrenList = regularNodes.map(c => `- ${c.label}${c.description ? ': ' + c.description.substring(0, 50) : ''}`).join('\n');
                
                const result = await callClaudeAPI({
                    type: 'organize',
                    nodeLabel: nodeData.label,
                    childrenList: childrenList
                });
                
                if (result.success && result.suggestions?.categories) {
                    // Collect all moves first, then execute
                    const movesToMake = [];
                    
                    for (const category of result.suggestions.categories) {
                        if (category.items && category.items.length >= 2) {
                            // Create category folder
                            const folder = store.addNode(nodeId, {
                                label: category.name,
                                description: category.description || '',
                                color: nodeData.color,
                                source: 'ai-organize'
                            });
                            foldersCreated++;
                            
                            // Find matching items to move
                            for (const itemLabel of category.items) {
                                // Extract just the label part (before any colon or description)
                                const cleanLabel = itemLabel.split(':')[0].trim().toLowerCase();
                                
                                const freshParent = store.findNode(nodeId);
                                const matchingChild = freshParent?.children?.find(c => 
                                    c.label.toLowerCase() === cleanLabel && 
                                    c.source !== 'ai-organize' && // Don't match folders we created
                                    c.source !== 'smart-organize'
                                );
                                if (matchingChild) {
                                    movesToMake.push({ childId: matchingChild.id, folderId: folder.id });
                                }
                            }
                        }
                    }
                    
                    // Execute all moves
                    for (const move of movesToMake) {
                        if (store.moveNode(move.childId, move.folderId)) {
                            totalMoved++;
                        }
                    }
                }
            } catch (error) {
                console.error('AI organize error:', error);
            }
        }
        
        if (totalMoved > 0) {
            // Collapse the parent first to reset layout
            const parentMesh = nodes.get(nodeId);
            if (parentMesh && parentMesh.userData.isExpanded) {
                collapseNode(parentMesh);
            }
            
            buildScene();
            
            // Re-expand after a brief delay to get fresh layout
            setTimeout(() => {
                const mesh = nodes.get(nodeId);
                if (mesh) {
                    expandNode(mesh);
                    selectNode(mesh);
                }
            }, 150);
            
            showToast(`📁 Created ${foldersCreated} folders, organized ${totalMoved} items`, 'success');
        } else {
            showToast('No clear groupings found', 'info');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // QUICK CAPTURE
    // ═══════════════════════════════════════════════════════════════════
    const quickInput = document.getElementById('quick-input');

    quickInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && quickInput.value.trim()) {
            const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
            const newNode = store.addNode(parentId, { label: quickInput.value.trim() });
            
            if (newNode) {
                buildScene();
                
                const mesh = nodes.get(newNode.id);
                if (mesh) {
                    const screenPos = mesh.position.clone().project(camera);
                    const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                    createCelebration(x, y, newNode.color, 6);
                    selectNode(mesh);
                }
                
                audio.pop();
                haptic.light();
                showToast(`Added "${newNode.label}"`, 'success');
            }
            
            quickInput.value = '';
        }
    });

    document.getElementById('quick-add').addEventListener('click', () => {
        if (quickInput.value.trim()) {
            quickInput.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // ROTATING PROMPTS
    // ═══════════════════════════════════════════════════════════════════
    const rotatingPrompts = [
        "What's on your mind?",
        "Any ideas worth remembering?",
        "Something on your to-do list?",
        "A goal you're working toward?",
        "Something new you're learning?",
        "A project on your mind?",
        "Something you're grateful for?",
        "A problem you're solving?",
        "Anyone you need to follow up with?",
        "A habit you want to build?",
        "Something exciting coming up?",
        "A skill you want to develop?"
    ];
    
    let currentPromptIndex = 0;
    let promptRotationInterval = null;
    
    function rotatePrompt() {
        // Only rotate if input is empty and not focused
        if (quickInput.value === '' && document.activeElement !== quickInput) {
            // Fade out
            quickInput.style.transition = 'opacity 0.3s ease';
            quickInput.style.opacity = '0';
            
            setTimeout(() => {
                currentPromptIndex = (currentPromptIndex + 1) % rotatingPrompts.length;
                quickInput.placeholder = rotatingPrompts[currentPromptIndex];
                // Fade in
                quickInput.style.opacity = '1';
            }, 300);
        }
    }
    
    // Start rotating prompts every 12 seconds
    function startPromptRotation() {
        if (!promptRotationInterval) {
            promptRotationInterval = setInterval(rotatePrompt, 12000);
        }
    }
    
    function stopPromptRotation() {
        if (promptRotationInterval) {
            clearInterval(promptRotationInterval);
            promptRotationInterval = null;
        }
    }
    
    // Stop rotation when input is focused, resume when blurred
    quickInput.addEventListener('focus', () => {
        stopPromptRotation();
        quickInput.style.opacity = '1';
    });
    
    quickInput.addEventListener('blur', () => {
        if (quickInput.value === '') {
            startPromptRotation();
        }
    });
    
    // Start rotation on load
    startPromptRotation();

    // ═══════════════════════════════════════════════════════════════════
    // CONTEXT QUESTION SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const contextQuestionBtn = document.getElementById('context-question-btn');
    const contextQuestionPopover = document.getElementById('context-question-popover');
    const contextQuestionText = document.getElementById('context-question-text');
    const contextQuestionInput = document.getElementById('context-question-input');
    const contextQuestionSubmit = document.getElementById('context-question-submit');
    
    // Question templates based on common node types/keywords
    const questionTemplates = {
        // Goals & aspirations
        goal: ["What's your target timeline for this?", "What would achieving this mean to you?", "What's your first step toward this?"],
        dream: ["Why does this matter to you?", "What inspired this dream?", "How will you know when you've achieved it?"],
        want: ["What's driving this desire?", "How would having this change things?", "What's stopping you from getting this now?"],
        
        // Projects & work
        project: ["What's the current status?", "What's the main challenge right now?", "Who else is involved in this?"],
        work: ["What's your role in this?", "What's the deadline or timeline?", "What outcome are you aiming for?"],
        business: ["What problem does this solve?", "Who is your target audience?", "What's your next milestone?"],
        
        // Learning & skills
        learn: ["Why do you want to learn this?", "How are you planning to learn it?", "What level do you want to reach?"],
        skill: ["How proficient are you currently?", "How will you practice this?", "Why is this skill important to you?"],
        course: ["What do you hope to gain from this?", "How much time can you dedicate weekly?", "When do you plan to complete it?"],
        
        // People & relationships
        person: ["How do you know this person?", "What do you need to follow up on?", "When should you reach out?"],
        meet: ["What's the purpose of this meeting?", "What do you want to accomplish?", "Who needs to be there?"],
        call: ["What topics need to be discussed?", "When is this scheduled?", "What's the expected outcome?"],
        
        // Health & wellness
        health: ["What specific improvement are you targeting?", "How will you track progress?", "What triggered this focus?"],
        fitness: ["What's your specific goal?", "How often will you work on this?", "What's your current baseline?"],
        habit: ["What triggers this habit?", "How will you stay consistent?", "What's your streak goal?"],
        
        // Ideas & creativity
        idea: ["What problem does this solve?", "What inspired this idea?", "What's the first step to explore it?"],
        create: ["What's your vision for this?", "What resources do you need?", "Who might be interested in this?"],
        
        // Tasks & todos
        todo: ["When does this need to be done?", "How long will it take?", "Is anyone else involved?"],
        task: ["What's the priority level?", "What's blocking this?", "What does 'done' look like?"],
        buy: ["What's your budget for this?", "When do you need it by?", "Have you researched options?"],
        
        // General fallbacks
        default: [
            "What's most important about this to you?",
            "How does this connect to your other goals?",
            "What would success look like here?",
            "What's your next action on this?",
            "Why did you add this to your mind map?"
        ]
    };
    
    function generateContextQuestion(label) {
        const lowerLabel = label.toLowerCase();
        
        // Check for keyword matches
        for (const [keyword, questions] of Object.entries(questionTemplates)) {
            if (keyword !== 'default' && lowerLabel.includes(keyword)) {
                return questions[Math.floor(Math.random() * questions.length)];
            }
        }
        
        // Check for common patterns
        if (lowerLabel.match(/^(finish|complete|do|make|build|start|begin)/)) {
            return questionTemplates.task[Math.floor(Math.random() * questionTemplates.task.length)];
        }
        if (lowerLabel.match(/^(read|watch|listen|study)/)) {
            return questionTemplates.learn[Math.floor(Math.random() * questionTemplates.learn.length)];
        }
        if (lowerLabel.match(/^(talk|email|text|contact|reach)/)) {
            return questionTemplates.person[Math.floor(Math.random() * questionTemplates.person.length)];
        }
        
        // Default questions
        return questionTemplates.default[Math.floor(Math.random() * questionTemplates.default.length)];
    }
    
    function expandAnswer(label, question, answer) {
        // Generate an expanded description based on the question type and answer
        const lowerQuestion = question.toLowerCase();
        const trimmedAnswer = answer.trim();
        
        // Expansion templates based on question patterns
        if (lowerQuestion.includes('timeline') || lowerQuestion.includes('when') || lowerQuestion.includes('deadline')) {
            return `Timeline: ${trimmedAnswer}. This is a time-bound goal that requires focused attention and planning to achieve within the set timeframe.`;
        }
        if (lowerQuestion.includes('why') || lowerQuestion.includes('what') && lowerQuestion.includes('mean')) {
            return `This matters because ${trimmedAnswer.toLowerCase()}. Understanding this motivation helps maintain focus and commitment.`;
        }
        if (lowerQuestion.includes('first step') || lowerQuestion.includes('next action') || lowerQuestion.includes('next step')) {
            return `Next action: ${trimmedAnswer}. Taking this first step will create momentum and clarity for the path forward.`;
        }
        if (lowerQuestion.includes('status') || lowerQuestion.includes('current')) {
            return `Current status: ${trimmedAnswer}. Tracking this progress helps identify what's working and what needs adjustment.`;
        }
        if (lowerQuestion.includes('challenge') || lowerQuestion.includes('blocking') || lowerQuestion.includes('stopping')) {
            return `Main challenge: ${trimmedAnswer}. Identifying this obstacle is the first step to overcoming it.`;
        }
        if (lowerQuestion.includes('who') || lowerQuestion.includes('involved')) {
            return `Key people: ${trimmedAnswer}. Collaboration and accountability with others can accelerate progress.`;
        }
        if (lowerQuestion.includes('goal') || lowerQuestion.includes('target') || lowerQuestion.includes('outcome')) {
            return `Goal: ${trimmedAnswer}. Having a clear target makes it easier to measure progress and stay motivated.`;
        }
        if (lowerQuestion.includes('how') && (lowerQuestion.includes('plan') || lowerQuestion.includes('track') || lowerQuestion.includes('practice'))) {
            return `Approach: ${trimmedAnswer}. Having a systematic method increases the likelihood of success.`;
        }
        if (lowerQuestion.includes('priority') || lowerQuestion.includes('important')) {
            return `Priority: ${trimmedAnswer}. Understanding the importance helps with decision-making and time allocation.`;
        }
        if (lowerQuestion.includes('inspired') || lowerQuestion.includes('triggered')) {
            return `Origin: ${trimmedAnswer}. Remembering what sparked this can reignite motivation when needed.`;
        }
        if (lowerQuestion.includes('budget') || lowerQuestion.includes('cost') || lowerQuestion.includes('resource')) {
            return `Resources needed: ${trimmedAnswer}. Planning for requirements helps avoid obstacles later.`;
        }
        if (lowerQuestion.includes('success') || lowerQuestion.includes('done') || lowerQuestion.includes('achieve')) {
            return `Success looks like: ${trimmedAnswer}. Having a clear vision of the end state guides all actions toward it.`;
        }
        
        // Default expansion
        return `${trimmedAnswer}. This context helps clarify the purpose and direction for "${label}".`;
    }
    
    // Show question popover when button clicked
    contextQuestionBtn.addEventListener('click', () => {
        if (!selectedNode) return;
        
        const label = selectedNode.userData.label || 'this item';
        const question = generateContextQuestion(label);
        
        contextQuestionText.textContent = question;
        contextQuestionInput.value = '';
        contextQuestionPopover.classList.add('active');
        
        // Focus input after animation
        setTimeout(() => contextQuestionInput.focus(), 200);
    });
    
    // Handle answer submission
    function submitContextAnswer() {
        if (!selectedNode || !contextQuestionInput.value.trim()) return;
        
        const label = selectedNode.userData.label;
        const question = contextQuestionText.textContent;
        const answer = contextQuestionInput.value.trim();
        
        // Expand the answer into a full description
        const expandedDescription = expandAnswer(label, question, answer);
        
        // Update the node
        const descriptionEl = document.getElementById('info-description');
        descriptionEl.value = expandedDescription;
        
        // Save to store
        store.updateNode(selectedNode.userData.id, { description: expandedDescription });
        selectedNode.userData.description = expandedDescription;
        
        // Remove context indicator from node
        removeContextIndicator(selectedNode);
        
        // Update neural network with new context
        if (window.NeuralUI && NeuralUI.neuralNet) {
            NeuralUI.neuralNet.addEmbedding(selectedNode.userData.id, `${label} ${expandedDescription}`);
        }
        
        // Hide popover and question button
        contextQuestionPopover.classList.remove('active');
        contextQuestionBtn.classList.add('hidden');
        
        // Feedback
        showToast('Description added', 'success');
        audio.pop();
    }
    
    contextQuestionSubmit.addEventListener('click', submitContextAnswer);
    
    contextQuestionInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitContextAnswer();
        }
        if (e.key === 'Escape') {
            contextQuestionPopover.classList.remove('active');
        }
    });
    
    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
        if (contextQuestionPopover.classList.contains('active') && 
            !e.target.closest('.context-question-popover') && 
            !e.target.closest('.context-question-btn')) {
            contextQuestionPopover.classList.remove('active');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // SIDE PANEL BUTTONS
    // ═══════════════════════════════════════════════════════════════════
    document.getElementById('btn-home').addEventListener('click', resetCamera);
    document.getElementById('btn-expand').addEventListener('click', expandAll);
    document.getElementById('btn-collapse').addEventListener('click', collapseAll);
    
    document.getElementById('btn-add').addEventListener('click', () => {
        const parentId = selectedNode?.userData.id || currentContextId || store.data.id;
        openModal('add', parentId);
    });
    
    // Link button - opens link modal
    document.getElementById('btn-link').addEventListener('click', () => {
        LinkManager.open();
    });
    
    // Move mode toggle
    const moveBtnEl = document.getElementById('btn-move');
    
    moveBtnEl.addEventListener('click', () => {
        moveMode = !moveMode;
        moveBtnEl.classList.toggle('active', moveMode);
        if (moveMode) {
            showToast('Move mode: Drag nodes to reposition', 'info');
            renderer.domElement.style.cursor = 'grab';
        } else {
            showToast('Move mode disabled', 'info');
            renderer.domElement.style.cursor = 'default';
        }
    });
    
    // Auto camera toggle
    const autoCamBtn = document.getElementById('btn-autocam');
    autoCamBtn.addEventListener('click', () => {
        autoCameraEnabled = !autoCameraEnabled;
        autoCamBtn.classList.toggle('active', autoCameraEnabled);
        showToast(autoCameraEnabled ? 'Auto camera enabled' : 'Auto camera disabled', 'info');
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // AI CHAT MANAGER - Conversational AI Interface
    // ═══════════════════════════════════════════════════════════════════
    const chatManager = {
        isOpen: false,
        isProcessing: false,
        conversation: [], // {role: 'user'|'assistant', content: string, actions?: array, timestamp: number}
        maxHistory: 20, // Keep last 20 messages for context
        
        init() {
            this.panel = document.getElementById('ai-chat-panel');
            this.messagesContainer = document.getElementById('chat-messages');
            this.input = document.getElementById('chat-input');
            this.sendBtn = document.getElementById('chat-send-btn');
            this.voiceBtn = document.getElementById('chat-voice-btn');
            this.toggleBtn = document.getElementById('chat-toggle-btn');
            this.slideToggle = document.getElementById('chat-slide-toggle');
            this.clearBtn = document.getElementById('chat-clear');
            this.suggestionsContainer = document.getElementById('chat-suggestions');
            
            this.setupEventListeners();
            this.loadConversation();
            
            console.log('Chat Manager initialized');
        },
        
        setupEventListeners() {
            // Toggle chat - both buttons toggle
            this.toggleBtn.addEventListener('click', () => this.toggle());
            this.slideToggle.addEventListener('click', () => this.toggle());
            
            // Clear conversation
            this.clearBtn.addEventListener('click', async () => {
                const confirmed = await showConfirm({
                    title: 'Clear Chat',
                    message: 'Clear all conversation history?',
                    confirmText: 'Clear',
                    cancelText: 'Cancel',
                    danger: true
                });
                if (confirmed) {
                    this.clearConversation();
                }
            });
            
            // Send message
            this.sendBtn.addEventListener('click', () => this.sendMessage());
            
            // Input handling
            this.input.addEventListener('input', () => {
                this.autoResize();
                this.sendBtn.disabled = !this.input.value.trim();
            });
            
            this.input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
            
            // Voice input
            this.voiceBtn.addEventListener('click', () => this.startVoiceInput());
            
            // Example buttons
            document.querySelectorAll('.chat-example-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
            
            // Keyboard shortcut to open chat (Ctrl/Cmd + /)
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === '/') {
                    e.preventDefault();
                    this.toggle();
                }
            });
        },
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        open() {
            this.isOpen = true;
            this.panel.classList.add('open');
            document.body.classList.add('chat-open');
            this.toggleBtn.classList.add('hidden');
            setTimeout(() => this.input.focus(), 350);
        },
        
        close() {
            this.isOpen = false;
            this.panel.classList.remove('open');
            document.body.classList.remove('chat-open');
            this.toggleBtn.classList.remove('hidden');
        },
        
        autoResize() {
            this.input.style.height = 'auto';
            this.input.style.height = Math.min(this.input.scrollHeight, 120) + 'px';
        },
        
        async sendMessage() {
            const content = this.input.value.trim();
            if (!content || this.isProcessing) return;
            
            // Clear input
            this.input.value = '';
            this.input.style.height = 'auto';
            this.sendBtn.disabled = true;
            
            // Hide welcome if shown
            const welcome = this.messagesContainer.querySelector('.chat-welcome');
            if (welcome) welcome.style.display = 'none';
            
            // Add user message
            this.addMessage('user', content);
            
            // Show typing indicator
            this.showTyping();
            
            // Process with AI
            this.isProcessing = true;
            try {
                const response = await this.callAI(content);
                this.hideTyping();
                
                if (response) {
                    // Debug log
                    console.log('AI Response:', response);
                    console.log('Actions to execute:', response.actions);
                    
                    // Execute any actions
                    let actionResults = [];
                    if (response.actions && response.actions.length > 0) {
                        console.log(`Executing ${response.actions.length} actions...`);
                        showToast(`Executing ${response.actions.length} action${response.actions.length > 1 ? 's' : ''}...`, 'info');
                        actionResults = await this.executeActions(response.actions);
                        console.log('Action results:', actionResults);
                        
                        // Show success/failure summary
                        const successCount = actionResults.filter(r => r.success).length;
                        const failCount = actionResults.length - successCount;
                        if (failCount > 0) {
                            showToast(`${successCount} succeeded, ${failCount} failed`, failCount === actionResults.length ? 'error' : 'info');
                        } else if (successCount > 0) {
                            showToast(`${successCount} action${successCount > 1 ? 's' : ''} completed`, 'success');
                        }
                    }
                    
                    // Add assistant message
                    this.addMessage('assistant', response.message, actionResults, response.suggestions);
                    
                    // Show quick suggestions if provided
                    if (response.suggestions && response.suggestions.length > 0) {
                        this.showSuggestions(response.suggestions);
                    } else {
                        this.hideSuggestions();
                    }
                }
            } catch (error) {
                this.hideTyping();
                this.addMessage('assistant', `Sorry, I encountered an error: ${error.message}. Please try again.`);
            } finally {
                this.isProcessing = false;
            }
        },
        
        addMessage(role, content, actionResults = [], suggestions = []) {
            const message = {
                role,
                content,
                actions: actionResults,
                timestamp: Date.now()
            };
            
            this.conversation.push(message);
            
            // Trim conversation history
            if (this.conversation.length > this.maxHistory) {
                this.conversation = this.conversation.slice(-this.maxHistory);
            }
            
            // Save conversation
            this.saveConversation();
            
            // Render message
            this.renderMessage(message);
            
            // Scroll to bottom
            this.scrollToBottom();
        },
        
        renderMessage(message) {
            const div = document.createElement('div');
            div.className = `chat-message ${message.role}`;
            
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            let actionsHTML = '';
            if (message.actions && message.actions.length > 0) {
                actionsHTML = `
                    <div class="chat-actions-indicator">
                        ${message.actions.map(a => `
                            <div class="chat-action-item ${a.success ? 'success' : 'error'}">
                                <span class="chat-action-icon">${a.success ? '✓' : '✗'}</span>
                                <span>${a.description}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            div.innerHTML = `
                <div class="chat-bubble">
                    ${this.formatMessage(message.content)}
                    ${actionsHTML}
                </div>
                <div class="chat-message-time">${time}</div>
            `;
            
            this.messagesContainer.appendChild(div);
        },
        
        formatMessage(content) {
            // Basic markdown-like formatting
            return escapeHTML(content)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code>$1</code>')
                .replace(/\n/g, '<br>');
        },
        
        showTyping() {
            const typing = document.createElement('div');
            typing.className = 'chat-message assistant';
            typing.id = 'chat-typing';
            typing.innerHTML = `
                <div class="chat-typing">
                    <div class="chat-typing-dot"></div>
                    <div class="chat-typing-dot"></div>
                    <div class="chat-typing-dot"></div>
                </div>
            `;
            this.messagesContainer.appendChild(typing);
            this.scrollToBottom();
        },
        
        hideTyping() {
            const typing = document.getElementById('chat-typing');
            if (typing) typing.remove();
        },
        
        showSuggestions(suggestions) {
            this.suggestionsContainer.innerHTML = suggestions.map(s => 
                `<button class="chat-suggestion-btn">${escapeHTML(s)}</button>`
            ).join('');
            this.suggestionsContainer.style.display = 'flex';
            
            // Add click handlers
            this.suggestionsContainer.querySelectorAll('.chat-suggestion-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
        },
        
        hideSuggestions() {
            this.suggestionsContainer.style.display = 'none';
        },
        
        scrollToBottom() {
            setTimeout(() => {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }, 50);
        },
        
        async callAI(userMessage) {
            // Build context
            const allNodes = store.getAllNodes();
            const selectedNodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
            
            // Build complete tree structure from store.data recursively
            const buildFullTree = (node, depth = 0) => {
                if (!node) return '';
                const indent = '  '.repeat(depth);
                const childCount = node.children?.length || 0;
                const desc = node.description ? ` - "${node.description.substring(0, 50)}${node.description.length > 50 ? '...' : ''}"` : '';
                let line = `${indent}- ${node.label} [id:${node.id}]${childCount > 0 ? ` (${childCount} children)` : ''}${desc}`;
                
                if (node.children && node.children.length > 0) {
                    const childLines = node.children.map(child => buildFullTree(child, depth + 1));
                    line += '\n' + childLines.join('\n');
                }
                return line;
            };
            
            const treeStructure = buildFullTree(store.data);
            const totalNodes = allNodes.length;
            
            // Build conversation history for Claude
            const historyForClaude = this.conversation.slice(-10).map(m => ({
                role: m.role,
                content: m.content
            }));
            
            // Gather neural context from all intelligence systems
            let neuralContext = '';
            
            // 1. Neural network predictions (category & similar nodes)
            if (neuralNet.isReady) {
                try {
                    const [categoryPredictions, similarNodes] = await Promise.all([
                        neuralNet.predictCategory(userMessage),
                        neuralNet.findSimilarNodes(userMessage, store, 5)
                    ]);
                    
                    if (categoryPredictions && categoryPredictions.length > 0) {
                        const topPreds = categoryPredictions.filter(p => p.confidence > 0.2).slice(0, 3);
                        if (topPreds.length > 0) {
                            neuralContext += `Category predictions: ${topPreds.map(p => `${p.category} (${Math.round(p.confidence * 100)}%)`).join(', ')}\n`;
                        }
                    }
                    
                    if (similarNodes && similarNodes.length > 0) {
                        const topSimilar = similarNodes.filter(s => s.similarity > 0.25).slice(0, 5);
                        if (topSimilar.length > 0) {
                            neuralContext += `Semantically similar existing nodes:\n`;
                            topSimilar.forEach(s => {
                                const node = store.findNode(s.nodeId);
                                if (node) {
                                    const parent = store.findParent(s.nodeId);
                                    neuralContext += `  - "${node.label}"${parent ? ` (under ${parent.label})` : ''} [${Math.round(s.similarity * 100)}% match]\n`;
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.warn('Neural net context error:', e);
                }
            }
            
            // 2. User profile insights (behavior patterns, preferences)
            if (userProfile.loaded) {
                try {
                    const profileInsights = userProfile.getPromptInsights();
                    if (profileInsights) {
                        neuralContext += `\nUser behavior patterns:\n${profileInsights}\n`;
                    }
                    
                    // Add focus areas and neglected areas
                    if (userProfile.categoryStats?.focusAreas?.length > 0) {
                        neuralContext += `Current focus areas: ${userProfile.categoryStats.focusAreas.join(', ')}\n`;
                    }
                    if (userProfile.categoryStats?.neglectedAreas?.length > 0) {
                        neuralContext += `Areas that may need attention: ${userProfile.categoryStats.neglectedAreas.join(', ')}\n`;
                    }
                } catch (e) {
                    console.warn('User profile context error:', e);
                }
            }
            
            // 3. Preference tracker (what user accepts/rejects)
            try {
                const prefInsights = preferenceTracker.getPromptInsights();
                if (prefInsights) {
                    neuralContext += `\nSuggestion preferences:\n${prefInsights}\n`;
                }
            } catch (e) {
                console.warn('Preference tracker context error:', e);
            }
            
            // 4. Semantic memories (past interactions)
            try {
                const selectedLabel = selectedNodeData?.label || '';
                const pathLabels = [];
                if (selectedNodeData) {
                    let current = selectedNodeData;
                    while (current) {
                        pathLabels.unshift(current.label);
                        current = store.findParent(current.id);
                    }
                }
                
                const memoryInsights = await semanticMemory.getPromptMemories(
                    selectedLabel || userMessage, 
                    pathLabels.length > 0 ? pathLabels : [userMessage], 
                    3
                );
                if (memoryInsights) {
                    neuralContext += `\n${memoryInsights}\n`;
                }
            } catch (e) {
                console.warn('Semantic memory context error:', e);
            }
            
            // 5. Concept abstractor (structural patterns)
            if (selectedNodeData) {
                try {
                    const pathLabels = [];
                    let current = selectedNodeData;
                    while (current) {
                        pathLabels.unshift(current.label);
                        current = store.findParent(current.id);
                    }
                    
                    const conceptInsights = await conceptAbstractor.getPromptInsights(
                        selectedNodeData.label, 
                        pathLabels
                    );
                    if (conceptInsights) {
                        neuralContext += `\nStructural insights:\n${conceptInsights}\n`;
                    }
                } catch (e) {
                    console.warn('Concept abstractor context error:', e);
                }
            }
            
            // 6. Quick stats summary
            try {
                const stats = {
                    patterns: neuralNet.isReady ? neuralNet.getStats().totalPatterns : 0,
                    memories: semanticMemory.getStats().totalMemories,
                    acceptedSuggestions: preferenceTracker.getStats().totalAccepted
                };
                if (stats.patterns > 0 || stats.memories > 0) {
                    neuralContext += `\nLearning stats: ${stats.patterns} patterns learned, ${stats.memories} memories, ${stats.acceptedSuggestions} accepted suggestions\n`;
                }
            } catch (e) {
                // Stats not critical
            }
            
            const systemPrompt = `You are the AI assistant for MYND, a 3D mind mapping app. You help users build, organize, and explore their mind maps through natural conversation.

CURRENT CONTEXT:
- Total nodes in map: ${totalNodes}
- Selected node: ${selectedNodeData ? `"${selectedNodeData.label}" [id:${selectedNodeData.id}]${selectedNodeData.children?.length ? ` with ${selectedNodeData.children.length} children` : ''}` : 'None'}

COMPLETE MAP STRUCTURE:
${treeStructure || '(empty map)'}
${neuralContext ? `
NEURAL INTELLIGENCE CONTEXT:
${neuralContext}` : ''}

YOUR CAPABILITIES:
1. **Full Map Visibility**: You can see the ENTIRE map structure above
2. **Neural Insights**: Use the neural context above to understand user patterns, find similar nodes, and make personalized suggestions
3. **Actions**: Create, edit, delete, move, focus on nodes when user wants
4. **Proactive**: Suggest improvements, identify duplicates, offer to help organize based on learned patterns
5. **Real-time info**: You can search the web for current information

RESPONSE FORMAT (always JSON):
{
  "message": "Your conversational response to the user",
  "actions": [
    // Optional - only if user wants to modify the map
    {"action": "add", "label": "Node Name", "description": "...", "color": null, "parentId": "selected|root|node-id"},
    {"action": "edit", "targetId": "node-id", "label": "new name", "color": "#hex"},
    {"action": "delete", "targetId": "node-id"},
    {"action": "move", "targetId": "node-id", "parentId": "new-parent-id"},
    {"action": "focus", "targetId": "node-id"},
    {"action": "expand", "targetId": "node-id"},
    {"action": "collapse", "targetId": "node-id"}
  ],
  "suggestions": ["Quick reply 1", "Quick reply 2"] // Optional quick reply suggestions
}

GUIDELINES:
- Reference the neural context to personalize responses (e.g., if user prefers concise labels, suggest short names)
- Use similar nodes to avoid creating duplicates
- Reference learned patterns and memories when relevant
- You have FULL visibility of the map - reference specific nodes by name when helpful
- Be conversational and helpful, not robotic
- When asked about the map, give specific answers based on what you see
- Proactively notice issues like duplicates, unorganized sections, or missing areas
- Only include actions when the user wants to modify the map
- Use web search for current events, prices, news, etc.
- Keep responses concise but helpful

COLORS: Red #EF4444, Orange #EF8354, Yellow #F7B731, Green #26DE81, Teal #4ECDC4, Blue #45B7D1, Purple #9B5DE5, Pink #FF6B9D

CRITICAL: Respond with ONLY a valid JSON object. No markdown, no code blocks, no explanation before or after. Just the raw JSON starting with { and ending with }.`;

            // Build messages array
            const messages = [
                { role: 'user', content: systemPrompt },
                { role: 'assistant', content: '{"message": "I understand. I\'m ready to help with your mind map.", "actions": [], "suggestions": []}' },
                ...historyForClaude,
                { role: 'user', content: userMessage }
            ];
            
            // Get auth session
            let session = null;
            if (typeof supabase !== 'undefined') {
                const { data } = await supabase.auth.getSession();
                session = data?.session;
            }
            
            let responseText;
            
            if (session?.access_token) {
                // Use Edge Function
                const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({
                        type: 'chat',
                        messages: messages,
                        maxTokens: 4096,
                        webSearch: true
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Failed to get response');
                }
                
                const data = await response.json();
                responseText = data.response;
            } else {
                // Direct API call
                const apiKey = localStorage.getItem(CONFIG.API_KEY);
                if (!apiKey) {
                    throw new Error('Please sign in or add an API key in Settings');
                }
                
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey.trim(),
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 4096,
                        tools: [{
                            type: 'web_search_20250305',
                            name: 'web_search',
                            max_uses: 3
                        }],
                        messages: messages
                    })
                });
                
                if (!response.ok) {
                    throw new Error('API request failed');
                }
                
                const data = await response.json();
                // Extract text from response
                if (Array.isArray(data.content)) {
                    const textBlock = data.content.find(b => b.type === 'text');
                    responseText = textBlock?.text || '';
                } else {
                    responseText = data.content?.[0]?.text || '';
                }
            }
            
            // Parse JSON response - handle markdown code blocks and text before JSON
            try {
                // Remove markdown code block markers if present
                let cleanedResponse = responseText
                    .replace(/```json\s*/gi, '')
                    .replace(/```\s*/g, '')
                    .trim();
                
                // Try to find JSON starting with {"message" (our expected format)
                const jsonStartIndex = cleanedResponse.indexOf('{"message"');
                if (jsonStartIndex !== -1) {
                    // Extract from {"message" to the end and find the matching closing brace
                    const jsonPart = cleanedResponse.substring(jsonStartIndex);
                    
                    // Find the matching closing brace by counting braces
                    let braceCount = 0;
                    let endIndex = -1;
                    for (let i = 0; i < jsonPart.length; i++) {
                        if (jsonPart[i] === '{') braceCount++;
                        if (jsonPart[i] === '}') braceCount--;
                        if (braceCount === 0) {
                            endIndex = i + 1;
                            break;
                        }
                    }
                    
                    if (endIndex > 0) {
                        const jsonString = jsonPart.substring(0, endIndex);
                        const parsed = JSON.parse(jsonString);
                        
                        if (parsed && typeof parsed.message === 'string') {
                            console.log('Parsed AI response:', parsed);
                            return {
                                message: parsed.message,
                                actions: Array.isArray(parsed.actions) ? parsed.actions : [],
                                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : []
                            };
                        }
                    }
                }
                
                // Fallback: try generic JSON extraction
                const jsonMatch = cleanedResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    if (parsed && typeof parsed.message === 'string') {
                        return {
                            message: parsed.message,
                            actions: Array.isArray(parsed.actions) ? parsed.actions : [],
                            suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : []
                        };
                    }
                }
            } catch (e) {
                console.error('Failed to parse AI response:', e, responseText);
            }
            
            // Fallback - try to extract just the message if JSON parsing failed
            return { message: responseText.substring(0, 500), actions: [], suggestions: [] };
        },
        
        async executeActions(actions) {
            const results = [];
            const createdNodes = [];
            
            console.log('executeActions called with:', actions);
            
            for (const action of actions) {
                try {
                    let result = { action: action.action, success: false, description: '' };
                    console.log('Processing action:', action);
                    
                    // Resolve IDs
                    const resolveId = (id) => {
                        if (!id) return null;
                        if (id === 'selected') return selectedNode?.userData.id;
                        if (id === 'root') return store.data.id;
                        if (id.startsWith('PREV_')) {
                            const idx = parseInt(id.split('_')[1]);
                            return createdNodes[idx]?.id;
                        }
                        // Try to find by ID or label
                        if (store.findNode(id)) return id;
                        const allNodes = store.getAllNodes();
                        const match = allNodes.find(n => n.label.toLowerCase() === id.toLowerCase());
                        return match?.id;
                    };
                    
                    if (action.action === 'add') {
                        const parentId = resolveId(action.parentId) || selectedNode?.userData.id || store.data.id;
                        const newNode = store.addNode(parentId, {
                            label: action.label,
                            description: action.description || '',
                            color: action.color || null
                        });
                        if (newNode) {
                            createdNodes.push(newNode);
                            result.success = true;
                            result.description = `Added "${action.label}"`;
                        }
                    } else if (action.action === 'edit') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            const updates = {};
                            if (action.label) updates.label = action.label;
                            if (action.description) updates.description = action.description;
                            if (action.color) updates.color = action.color;
                            store.updateNode(targetId, updates);
                            result.success = true;
                            result.description = `Updated node`;
                            
                            // Update mesh
                            const mesh = nodes.get(targetId);
                            if (mesh && action.color) {
                                mesh.material.color.set(action.color);
                                mesh.material.emissive.set(action.color);
                            }
                            if (mesh && action.label) {
                                updateNodeLabel(mesh, action.label);
                            }
                        }
                    } else if (action.action === 'delete') {
                        const targetId = resolveId(action.targetId);
                        console.log('Delete action - raw targetId:', action.targetId, '- resolved:', targetId);
                        if (!targetId) {
                            result.description = `Could not find node "${action.targetId}"`;
                        } else if (targetId === store.data.id) {
                            result.description = `Cannot delete root node`;
                        } else {
                            const node = store.findNode(targetId);
                            if (store.deleteNode(targetId)) {
                                result.success = true;
                                result.description = `Deleted "${node?.label}"`;
                            } else {
                                result.description = `Failed to delete node`;
                            }
                        }
                    } else if (action.action === 'move') {
                        const targetId = resolveId(action.targetId);
                        const parentId = resolveId(action.parentId);
                        console.log('Move action - target:', action.targetId, '->', targetId, 'parent:', action.parentId, '->', parentId);
                        if (!targetId) {
                            result.description = `Could not find node to move "${action.targetId}"`;
                        } else if (!parentId) {
                            result.description = `Could not find target parent "${action.parentId}"`;
                        } else {
                            const moved = store.moveNode(targetId, parentId);
                            if (moved) {
                                result.success = true;
                                result.description = `Moved node`;
                            } else {
                                result.description = `Move operation failed`;
                            }
                        }
                    } else if (action.action === 'focus') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            // Expand path to node
                            let current = targetId;
                            while (current && current !== store.data.id) {
                                const parent = store.findParent(current);
                                if (parent) store.expandedNodes.add(parent.id);
                                current = parent?.id;
                            }
                            buildScene();
                            setTimeout(() => {
                                const mesh = nodes.get(targetId);
                                if (mesh) {
                                    selectNode(mesh);
                                    focusOnNode(mesh);
                                }
                            }, 100);
                            result.success = true;
                            result.description = `Focused on node`;
                        }
                    } else if (action.action === 'expand') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            store.expandedNodes.add(targetId);
                            result.success = true;
                            result.description = `Expanded node`;
                        }
                    } else if (action.action === 'collapse') {
                        const targetId = resolveId(action.targetId);
                        if (targetId) {
                            store.expandedNodes.delete(targetId);
                            result.success = true;
                            result.description = `Collapsed node`;
                        }
                    }
                    
                    results.push(result);
                } catch (e) {
                    results.push({ action: action.action, success: false, description: `Error: ${e.message}` });
                }
            }
            
            // Rebuild scene if any structural changes
            if (results.some(r => r.success && ['add', 'delete', 'move', 'expand', 'collapse'].includes(r.action))) {
                buildScene();
            }
            
            return results;
        },
        
        // Audio feedback for voice recording
        playVoiceSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                
                if (type === 'start') {
                    // Ascending tone for start
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'stop') {
                    // Descending tone for stop
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                } else if (type === 'error') {
                    // Low tone for error
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                }
            } catch (e) {
                // Audio not available, fail silently
                console.warn('Audio feedback not available:', e);
            }
        },
        
        startVoiceInput() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                showToast('Voice input not supported in this browser', 'error');
                return;
            }
            
            // Get overlay elements
            const overlay = document.getElementById('chat-voice-overlay');
            const status = document.getElementById('chat-voice-status');
            const cancelBtn = document.getElementById('chat-voice-cancel');
            const container = this.input.closest('.chat-input-container');
            
            const recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            // Store recognition instance for cancel
            this.activeRecognition = recognition;
            
            // Play start sound and show visual feedback
            this.playVoiceSound('start');
            this.voiceBtn.classList.add('recording');
            overlay.classList.add('active');
            if (container) container.classList.add('recording');
            status.textContent = 'Listening...';
            status.className = 'chat-voice-status recording';
            
            // Cancel button handler
            const handleCancel = () => {
                recognition.abort();
                this.cleanupVoiceUI();
            };
            cancelBtn.addEventListener('click', handleCancel, { once: true });
            
            recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                this.input.value = transcript;
                this.sendBtn.disabled = !transcript.trim();
                
                // Update status to show we're getting input
                if (transcript.trim()) {
                    status.textContent = 'Heard: ' + transcript.substring(0, 30) + (transcript.length > 30 ? '...' : '');
                }
            };
            
            recognition.onend = () => {
                // Play stop sound
                this.playVoiceSound('stop');
                
                // Update status briefly before hiding
                if (this.input.value.trim()) {
                    status.textContent = 'Processing...';
                    status.className = 'chat-voice-status processing';
                    
                    // Small delay to show processing state
                    setTimeout(() => {
                        this.cleanupVoiceUI();
                        this.sendMessage();
                    }, 200);
                } else {
                    this.cleanupVoiceUI();
                }
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                
                const errorMessages = {
                    'no-speech': 'No speech detected',
                    'audio-capture': 'No microphone found',
                    'not-allowed': 'Microphone access denied',
                    'network': 'Network error',
                    'aborted': null,
                    'service-not-allowed': 'Speech service not available'
                };
                
                const message = errorMessages[event.error];
                
                if (event.error !== 'aborted') {
                    this.playVoiceSound('error');
                }
                
                if (message) {
                    status.textContent = message;
                    status.className = 'chat-voice-status';
                    setTimeout(() => {
                        this.cleanupVoiceUI();
                        if (event.error !== 'no-speech') {
                            showToast(message, 'error', 3000);
                        }
                    }, 1000);
                } else {
                    this.cleanupVoiceUI();
                }
            };
            
            try {
                recognition.start();
            } catch (e) {
                this.playVoiceSound('error');
                this.cleanupVoiceUI();
                showToast('Could not start voice recognition', 'error');
                console.error('Recognition start error:', e);
            }
        },
        
        cleanupVoiceUI() {
            this.voiceBtn.classList.remove('recording', 'processing');
            const overlay = document.getElementById('chat-voice-overlay');
            if (overlay) overlay.classList.remove('active');
            const container = this.input?.closest('.chat-input-container');
            if (container) container.classList.remove('recording');
            this.activeRecognition = null;
        },
        
        saveConversation() {
            try {
                localStorage.setItem('mynd-chat-history', JSON.stringify(this.conversation));
            } catch (e) {
                console.warn('Failed to save chat history:', e);
            }
        },
        
        loadConversation() {
            try {
                const saved = localStorage.getItem('mynd-chat-history');
                if (saved) {
                    this.conversation = JSON.parse(saved);
                    // Render existing messages
                    const welcome = this.messagesContainer.querySelector('.chat-welcome');
                    if (this.conversation.length > 0 && welcome) {
                        welcome.style.display = 'none';
                    }
                    this.conversation.forEach(m => this.renderMessage(m));
                    this.scrollToBottom();
                }
            } catch (e) {
                console.warn('Failed to load chat history:', e);
            }
        },
        
        clearConversation() {
            this.conversation = [];
            localStorage.removeItem('mynd-chat-history');
            this.messagesContainer.innerHTML = `
                <div class="chat-welcome">
                    <div class="chat-welcome-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
                        </svg>
                    </div>
                    <div class="chat-welcome-title">Hi, I'm your MYND assistant</div>
                    <div class="chat-welcome-text">
                        I can help you build and organize your mind map. Try asking me to:
                    </div>
                    <div class="chat-welcome-examples">
                        <button class="chat-example-btn">Help me brainstorm ideas for my goals</button>
                        <button class="chat-example-btn">What should I add to my fitness plan?</button>
                        <button class="chat-example-btn">Organize my project nodes</button>
                        <button class="chat-example-btn">What's the latest news on AI?</button>
                    </div>
                </div>
            `;
            // Re-attach example button handlers
            this.messagesContainer.querySelectorAll('.chat-example-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.input.value = btn.textContent;
                    this.sendBtn.disabled = false;
                    this.sendMessage();
                });
            });
            this.hideSuggestions();
            showToast('Conversation cleared', 'success');
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // VOICE AI SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    const voiceAI = {
        recognition: null,
        isRecording: false,
        isProcessing: false,
        apiKey: localStorage.getItem(CONFIG.API_KEY) || '',
        
        init() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Speech recognition not supported');
                return false;
            }
            
            this.recognition = new SpeechRecognition();
            this.recognition.continuous = false;
            this.recognition.interimResults = true;
            this.recognition.lang = 'en-US';
            
            this.recognition.onstart = () => {
                console.log('Voice recognition started');
            };
            
            this.recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                document.getElementById('voice-transcript').textContent = transcript || 'Listening...';
            };
            
            this.recognition.onend = () => {
                if (this.isRecording) {
                    const transcript = document.getElementById('voice-transcript').textContent;
                    if (transcript && transcript !== 'Listening...' && transcript !== 'Say something...') {
                        this.processWithAI(transcript);
                    } else {
                        this.stop();
                    }
                }
            };
            
            this.recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showToast('Microphone access denied', 'error');
                }
                this.stop();
            };
            
            return true;
        },
        
        async start() {
            console.log('Voice start called');
            
            // Check if user is authenticated OR has API key
            let isAuthenticated = false;
            if (typeof supabase !== 'undefined') {
                const { data } = await supabase.auth.getSession();
                isAuthenticated = !!data?.session;
            }
            
            if (!isAuthenticated && !this.apiKey) {
                // Not authenticated and no API key - prompt to sign in
                showToast('Sign in or add API key in Settings for AI features', 'info');
                this.showSettings();
                return;
            }
            
            // Show UI immediately - even if voice isn't supported, text input will work
            this.isRecording = true;
            this.updateUI('recording');
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            // Try to initialize speech recognition
            if (!this.recognition && !this.init()) {
                // Voice not supported, but text input still works
                console.warn('Voice not supported, text input available');
                document.getElementById('voice-status').textContent = 'Voice not supported - use text';
                document.getElementById('voice-transcript').textContent = 'Click "Type" to enter your request';
                // Don't stop - let user switch to text mode
                return;
            }
            
            try {
                this.recognition.start();
                haptic.medium();
            } catch (e) {
                console.error('Failed to start recognition:', e);
                // Don't hide UI - let user switch to text mode
                document.getElementById('voice-status').textContent = 'Voice unavailable - use text';
                document.getElementById('voice-transcript').textContent = 'Click "Type" to enter your request';
            }
        },
        
        // Start only the recording part (called from mode toggle)
        startRecording() {
            if (!this.recognition && !this.init()) {
                showToast('Voice not supported in this browser', 'error');
                return;
            }
            
            this.isRecording = true;
            document.getElementById('voice-transcript').textContent = 'Say something...';
            
            try {
                this.recognition.start();
            } catch (e) {
                console.error('Failed to start recognition:', e);
            }
        },
        
        stop() {
            this.isRecording = false;
            this.isProcessing = false;
            if (this.recognition) {
                try { this.recognition.stop(); } catch (e) {}
            }
            this.updateUI('idle');
        },
        
        updateUI(state) {
            const voiceBtn = document.getElementById('btn-voice');
            const indicator = document.getElementById('voice-indicator');
            const backdrop = document.getElementById('voice-backdrop');
            const icon = document.getElementById('voice-icon');
            const micIcon = document.getElementById('voice-icon-mic');
            const brainIcon = document.getElementById('voice-icon-brain');
            const status = document.getElementById('voice-status');
            
            voiceBtn.classList.remove('recording', 'processing', 'active');
            indicator.classList.remove('active');
            backdrop.classList.remove('active');
            icon.classList.remove('recording', 'processing');
            
            if (state === 'recording') {
                voiceBtn.classList.add('recording');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('recording');
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                status.textContent = 'Listening...';
            } else if (state === 'processing') {
                voiceBtn.classList.add('processing');
                indicator.classList.add('active');
                backdrop.classList.add('active');
                icon.classList.add('processing');
                micIcon.style.display = 'none';
                brainIcon.style.display = 'block';
                status.textContent = 'Thinking...';
            } else {
                micIcon.style.display = 'block';
                brainIcon.style.display = 'none';
                
                // Reset to speak mode
                document.getElementById('voice-mode-speak').classList.add('active');
                document.getElementById('voice-mode-type').classList.remove('active');
                document.getElementById('voice-icon').style.display = 'block';
                document.getElementById('voice-status').style.display = 'block';
                document.getElementById('voice-transcript').style.display = 'block';
                document.getElementById('voice-text-wrapper').style.display = 'none';
                document.getElementById('voice-text-input').value = '';
                document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
            }
        },
        
        async processWithAI(transcript) {
            console.log('processWithAI called with:', transcript);
            this.isRecording = false;
            this.isProcessing = true;
            this.updateUI('processing');
            
            // Check if user is authenticated with Supabase
            let session = null;
            if (typeof supabase !== 'undefined') {
                const { data } = await supabase.auth.getSession();
                session = data?.session;
            }
            
            // Refresh API key from localStorage (in case it was updated)
            this.apiKey = localStorage.getItem(CONFIG.API_KEY) || '';
            
            // Check for authentication or API key
            if (!session?.access_token && !this.apiKey) {
                console.error('No auth or API key!');
                showToast('Sign in or add API key in Settings for AI features', 'error');
                this.stop();
                return;
            }
            
            console.log('Auth or API key exists, proceeding with AI request...');
            
            // Fix common speech recognition errors
            let cleanedTranscript = transcript.trim()
                .replace(/\bnote\b/gi, 'node')
                .replace(/\bnotes\b/gi, 'nodes')
                .replace(/\bknow\b/gi, 'node')
                .replace(/\bno\b(?=\s+called)/gi, 'node')
                .replace(/\bmode\b(?=\s+called)/gi, 'node')
                .replace(/\badd a no\b/gi, 'add a node')
                .replace(/\bnew no\b/gi, 'new node')
                .replace(/\bcreate a no\b/gi, 'create a node');
            
            console.log('Original transcript:', transcript);
            console.log('Cleaned transcript:', cleanedTranscript);
            
            try {
                // ═══════════════════════════════════════════════════════════
                // GATHER NEURAL NETWORK CONTEXT (if available)
                // ═══════════════════════════════════════════════════════════
                let neuralContext = '';
                
                if (neuralNet.isReady || userProfile.loaded) {
                    try {
                        const allNodes = store.getAllNodes();
                        
                        // Run queries in parallel for speed
                        const [categoryPredictions, similarNodes, connectionPrediction] = await Promise.all([
                            neuralNet.isReady ? neuralNet.predictCategory(cleanedTranscript) : null,
                            neuralNet.isReady ? neuralNet.findSimilarNodes(cleanedTranscript, store, 5) : [],
                            neuralNet.isReady && selectedNode ? 
                                neuralNet.predictConnection(cleanedTranscript, selectedNode.userData.label) : null
                        ]);
                        
                        const stats = neuralNet.isReady ? neuralNet.getStats() : { totalPatterns: 0 };
                        
                        neuralContext += `\n═══ NEURAL INTELLIGENCE (learned from this user's patterns) ═══\n`;
                        
                        // 1. CATEGORY PREDICTIONS
                        if (categoryPredictions && categoryPredictions.length > 0) {
                            const topPredictions = categoryPredictions
                                .filter(p => p.confidence > 0.15)
                                .slice(0, 3);
                            
                            if (topPredictions.length > 0) {
                                neuralContext += `\n📁 CATEGORY PREDICTIONS:\n`;
                                for (const pred of topPredictions) {
                                    const matchingNode = allNodes.find(n => 
                                        n.label.toLowerCase() === pred.category.toLowerCase() ||
                                        n.label.toLowerCase().includes(pred.category.toLowerCase())
                                    );
                                    if (matchingNode) {
                                        neuralContext += `   • ${pred.category}: ${Math.round(pred.confidence * 100)}% confident → use parentId: "${matchingNode.id}"\n`;
                                    } else {
                                        neuralContext += `   • ${pred.category}: ${Math.round(pred.confidence * 100)}% confident (no matching node in tree)\n`;
                                    }
                                }
                            }
                        }
                        
                        // 2. SIMILAR NODES (semantic matches)
                        if (similarNodes && similarNodes.length > 0) {
                            const topSimilar = similarNodes
                                .filter(s => s.similarity > 0.25)
                                .slice(0, 5);
                            
                            if (topSimilar.length > 0) {
                                neuralContext += `\n🔗 SIMILAR EXISTING NODES:\n`;
                                for (const s of topSimilar) {
                                    const node = store.findNode(s.nodeId);
                                    const parent = store.findParent(s.nodeId);
                                    if (node) {
                                        neuralContext += `   • "${node.label}" under "${parent?.label || 'root'}" (${Math.round(s.similarity * 100)}% similar) → sibling parentId: "${parent?.id || store.data.id}"\n`;
                                    }
                                }
                            }
                        }
                        
                        // 3. CONNECTION PREDICTION (relationship to selected node)
                        if (connectionPrediction && selectedNode) {
                            neuralContext += `\n🔀 RELATIONSHIP TO SELECTED NODE "${selectedNode.userData.label}":\n`;
                            if (connectionPrediction.isParentChild > 0.5) {
                                neuralContext += `   • Should be CHILD of selected (${Math.round(connectionPrediction.isParentChild * 100)}% confident)\n`;
                            }
                            if (connectionPrediction.isSibling > 0.5) {
                                const parent = store.findParent(selectedNode.userData.id);
                                neuralContext += `   • Should be SIBLING (${Math.round(connectionPrediction.isSibling * 100)}% confident) → use parentId: "${parent?.id || store.data.id}"\n`;
                            }
                            if (connectionPrediction.shouldConnect < 0.3) {
                                neuralContext += `   • NOT related to selected node - find better parent from categories above\n`;
                            }
                        }
                        
                        // 4. EXPANSION PATTERNS (typical children for parent types)
                        if (neuralNet.expansionPatterns && neuralNet.expansionPatterns.size > 0) {
                            // Find patterns relevant to this input
                            const relevantPatterns = [];
                            for (const [parentLabel, children] of neuralNet.expansionPatterns) {
                                if (cleanedTranscript.toLowerCase().includes(parentLabel.toLowerCase()) ||
                                    parentLabel.toLowerCase().includes(cleanedTranscript.toLowerCase().split(' ')[0])) {
                                    relevantPatterns.push({ parent: parentLabel, children: children.slice(0, 5) });
                                }
                            }
                            if (relevantPatterns.length > 0) {
                                neuralContext += `\n📊 LEARNED EXPANSION PATTERNS:\n`;
                                for (const p of relevantPatterns.slice(0, 2)) {
                                    neuralContext += `   • Under "${p.parent}", user typically adds: ${p.children.join(', ')}\n`;
                                }
                            }
                        }
                        
                        // 5. COLOR PREFERENCES (from user profile and pattern analysis)
                        const colorPrefs = analyzeColorPreferences(store, allNodes);
                        if (colorPrefs.categoryColors.size > 0) {
                            neuralContext += `\n🎨 USER'S COLOR PREFERENCES:\n`;
                            for (const [category, color] of Array.from(colorPrefs.categoryColors).slice(0, 5)) {
                                neuralContext += `   • ${category} nodes: ${color}\n`;
                            }
                            if (colorPrefs.mostUsedColor) {
                                neuralContext += `   • Most used color overall: ${colorPrefs.mostUsedColor}\n`;
                            }
                        }
                        
                        // 6. NAMING STYLE (analyze user's labeling patterns)
                        const namingStyle = analyzeNamingStyle(allNodes);
                        if (namingStyle) {
                            neuralContext += `\n✏️ USER'S NAMING STYLE:\n`;
                            neuralContext += `   • Average label length: ${namingStyle.avgLength} words\n`;
                            neuralContext += `   • Style: ${namingStyle.style}\n`;
                            if (namingStyle.commonPrefixes.length > 0) {
                                neuralContext += `   • Common prefixes: ${namingStyle.commonPrefixes.join(', ')}\n`;
                            }
                        }
                        
                        // 7. MISSING SIBLINGS (gaps in structure)
                        const missingSiblings = findMissingSiblings(store, cleanedTranscript, allNodes);
                        if (missingSiblings.length > 0) {
                            neuralContext += `\n🧩 POTENTIAL GAPS (common patterns not in tree):\n`;
                            for (const gap of missingSiblings.slice(0, 3)) {
                                neuralContext += `   • "${gap.parent}" is missing typical child: "${gap.suggestion}"\n`;
                            }
                        }
                        
                        // 8. HIERARCHY DEPTH PREFERENCE
                        const depthStats = analyzeHierarchyDepth(store.data);
                        neuralContext += `\n📐 STRUCTURE PREFERENCES:\n`;
                        neuralContext += `   • Average depth: ${depthStats.avgDepth.toFixed(1)} levels\n`;
                        neuralContext += `   • Max depth: ${depthStats.maxDepth} levels\n`;
                        neuralContext += `   • Preference: ${depthStats.avgDepth < 2.5 ? 'FLAT structure' : depthStats.avgDepth > 4 ? 'DEEP nesting' : 'MODERATE nesting'}\n`;
                        
                        // 9. NODE IMPORTANCE (most interacted branches)
                        if (userProfile.categoryStats?.interactions) {
                            const topCategories = Object.entries(userProfile.categoryStats.interactions)
                                .map(([cat, data]) => [cat, data.views + data.edits * 2 + data.expansions])
                                .sort((a, b) => b[1] - a[1])
                                .slice(0, 3);
                            if (topCategories.length > 0) {
                                neuralContext += `\n⭐ MOST ACTIVE BRANCHES:\n`;
                                for (const [cat, score] of topCategories) {
                                    neuralContext += `   • "${cat}" (engagement score: ${Math.round(score)})\n`;
                                }
                            }
                        }
                        
                        // 10. TIME CONTEXT (when user typically works on what)
                        const currentHour = new Date().getHours();
                        if (userProfile.timeStats?.hourlyActivity) {
                            const hourlyActivity = userProfile.timeStats.hourlyActivity;
                            const peakHour = hourlyActivity.indexOf(Math.max(...hourlyActivity));
                            const isActiveTime = hourlyActivity[currentHour] > (Math.max(...hourlyActivity) * 0.5);
                            neuralContext += `\n🕐 TIME CONTEXT:\n`;
                            neuralContext += `   • Current hour: ${currentHour}:00 (${isActiveTime ? 'typically active' : 'less active'} time)\n`;
                            neuralContext += `   • Peak activity hour: ${peakHour}:00\n`;
                        }
                        
                        // 11. SESSION CONTEXT (what user has been working on this session)
                        if (userProfile.currentSession?.categories?.size > 0) {
                            const sessionCategories = Array.from(userProfile.currentSession.categories);
                            neuralContext += `\n📍 THIS SESSION:\n`;
                            neuralContext += `   • Working on: ${sessionCategories.join(', ')}\n`;
                            neuralContext += `   • Nodes created this session: ${userProfile.currentSession.nodeCount}\n`;
                        }
                        
                        // Summary guidance
                        neuralContext += `\n═══ PLACEMENT GUIDANCE ═══\n`;
                        neuralContext += `Use the node IDs from predictions above. Prioritize:\n`;
                        neuralContext += `1. High-confidence category matches (>50%)\n`;
                        neuralContext += `2. Similar node siblings (>60% similarity)\n`;
                        neuralContext += `3. Connection predictions for relationship to selected\n`;
                        neuralContext += `4. Match user's color and naming style\n`;
                        
                    } catch (neuralError) {
                        console.warn('Could not get neural context:', neuralError);
                    }
                }
                
                // Helper functions for neural analysis
                function analyzeColorPreferences(store, allNodes) {
                    const categoryColors = new Map();
                    const colorCounts = new Map();
                    
                    // Analyze top-level nodes and their colors
                    if (store.data.children) {
                        for (const child of store.data.children) {
                            if (child.color) {
                                categoryColors.set(child.label, child.color);
                            }
                        }
                    }
                    
                    // Count all colors
                    for (const node of allNodes) {
                        if (node.color) {
                            colorCounts.set(node.color, (colorCounts.get(node.color) || 0) + 1);
                        }
                    }
                    
                    // Find most used color
                    let mostUsedColor = null;
                    let maxCount = 0;
                    for (const [color, count] of colorCounts) {
                        if (count > maxCount) {
                            maxCount = count;
                            mostUsedColor = color;
                        }
                    }
                    
                    return { categoryColors, mostUsedColor };
                }
                
                function analyzeNamingStyle(allNodes) {
                    if (allNodes.length < 5) return null;
                    
                    const labels = allNodes.map(n => n.label);
                    const wordCounts = labels.map(l => l.split(/\s+/).length);
                    const avgLength = wordCounts.reduce((a, b) => a + b, 0) / wordCounts.length;
                    
                    // Detect common prefixes
                    const prefixes = new Map();
                    for (const label of labels) {
                        const firstWord = label.split(/\s+/)[0];
                        if (firstWord.length > 2) {
                            prefixes.set(firstWord, (prefixes.get(firstWord) || 0) + 1);
                        }
                    }
                    const commonPrefixes = Array.from(prefixes.entries())
                        .filter(([_, count]) => count >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([prefix]) => prefix);
                    
                    // Determine style
                    let style = 'Mixed';
                    const allCaps = labels.filter(l => l === l.toUpperCase()).length;
                    const allLower = labels.filter(l => l === l.toLowerCase()).length;
                    const titleCase = labels.filter(l => /^[A-Z][a-z]/.test(l)).length;
                    
                    if (avgLength <= 2) style = 'Concise (1-2 words)';
                    else if (avgLength <= 4) style = 'Moderate (2-4 words)';
                    else style = 'Descriptive (4+ words)';
                    
                    if (titleCase > labels.length * 0.7) style += ', Title Case';
                    
                    return { avgLength: Math.round(avgLength * 10) / 10, style, commonPrefixes };
                }
                
                function findMissingSiblings(store, input, allNodes) {
                    const suggestions = [];
                    
                    // Common patterns
                    const commonPatterns = {
                        'fitness': ['Cardio', 'Strength', 'Flexibility', 'Nutrition'],
                        'health': ['Exercise', 'Diet', 'Sleep', 'Mental Health'],
                        'work': ['Projects', 'Meetings', 'Goals', 'Tasks'],
                        'projects': ['Planning', 'Execution', 'Review'],
                        'goals': ['Short-term', 'Long-term', 'Daily'],
                        'learning': ['Books', 'Courses', 'Practice'],
                        'finance': ['Income', 'Expenses', 'Savings', 'Investments'],
                        'personal': ['Health', 'Relationships', 'Hobbies', 'Growth']
                    };
                    
                    for (const node of allNodes) {
                        const key = node.label.toLowerCase();
                        if (commonPatterns[key]) {
                            const existingChildren = (node.children || []).map(c => c.label.toLowerCase());
                            for (const expected of commonPatterns[key]) {
                                if (!existingChildren.some(e => e.includes(expected.toLowerCase()))) {
                                    suggestions.push({ parent: node.label, suggestion: expected });
                                }
                            }
                        }
                    }
                    
                    return suggestions;
                }
                
                function analyzeHierarchyDepth(root, depth = 0, depths = []) {
                    depths.push(depth);
                    if (root.children) {
                        for (const child of root.children) {
                            analyzeHierarchyDepth(child, depth + 1, depths);
                        }
                    }
                    
                    const maxDepth = Math.max(...depths);
                    const avgDepth = depths.reduce((a, b) => a + b, 0) / depths.length;
                    
                    return { maxDepth, avgDepth };
                }
                
                // Build context about current mind map with proper parent tracking
                const buildNodeList = (node, parentId = null, list = []) => {
                    list.push({
                        id: node.id,
                        label: node.label,
                        parentId: parentId,
                        hasChildren: node.children && node.children.length > 0
                    });
                    if (node.children) {
                        node.children.forEach(child => buildNodeList(child, node.id, list));
                    }
                    return list;
                };
                const nodeContext = buildNodeList(store.data).slice(0, 60);
                
                const selectedNodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
                const currentContext = selectedNodeData 
                    ? `"${selectedNodeData.label}" (id: ${selectedNodeData.id})${selectedNodeData.description ? ' - ' + selectedNodeData.description.substring(0, 50) : ''}`
                    : 'None (will default to root)';
                
                // Build tree structure string for better visualization
                const buildTreeString = (nodes, parentId = null, depth = 0) => {
                    const children = nodes.filter(n => n.parentId === parentId);
                    return children.map(n => {
                        const indent = '  '.repeat(depth);
                        const childStr = buildTreeString(nodes, n.id, depth + 1);
                        return `${indent}- ${n.label} (${n.id})${childStr ? '\n' + childStr : ''}`;
                    }).join('\n');
                };
                const treeStructure = buildTreeString(nodeContext);
                
                const prompt = `You are the intelligent AI assistant for MYND, a 3D mind mapping app. The user is building a personal knowledge/goal map.

USER INPUT: "${cleanedTranscript}"

SELECTED NODE: ${currentContext || 'None selected'}
${neuralContext}
CURRENT MAP STRUCTURE (with node IDs):
${treeStructure || '(empty map)'}

AVAILABLE ACTIONS:
1. "add" - Create new node(s)
2. "edit" - Modify existing node (label, description, color)
3. "delete" - Remove a node
4. "move" - Move node to different parent
5. "focus" - Navigate to a node
6. "expand" - Expand a collapsed node
7. "collapse" - Collapse an expanded node
8. "respond" - Just answer a question WITHOUT creating a node (use for factual queries, current info, etc.)

RESPONSE FORMAT (JSON only):
{
  "actions": [
    {
      "action": "add|edit|delete|move|focus|expand|collapse|respond",
      "label": "Node name (for add)",
      "description": "2-3 sentences (for add/edit)",
      "color": "#HEX or null (for add/edit)",
      "parentId": "node-id, 'selected', 'root', or 'PREV_N' (for add/move)",
      "targetId": "node-id to act on (for edit/delete/move/focus/expand/collapse)",
      "message": "Response text to show user (for respond action)",
      "offerToAdd": true/false (for respond - offer to create a node with this info)
    }
  ]
}

AVAILABLE COLORS:
- Red: #EF4444
- Orange: #EF8354
- Yellow: #F7B731
- Green: #26DE81
- Teal: #4ECDC4
- Blue: #45B7D1
- Purple: #9B5DE5
- Pink: #FF6B9D
- Lavender: #A29BFE

**USING NEURAL INTELLIGENCE:**
The NEURAL INTELLIGENCE section above contains learned patterns from THIS SPECIFIC USER. Use it to make smart decisions:

📁 CATEGORY PREDICTIONS: Place nodes under the suggested category with highest confidence. Use the provided parentId directly.

🔗 SIMILAR NODES: If input is similar to existing nodes, place as sibling (same parent) or child of that branch.

🔀 RELATIONSHIP TO SELECTED: Use this to decide if new content should be:
   - CHILD of selected node (isParentChild > 50%)
   - SIBLING of selected (isSibling > 50%) 
   - SOMEWHERE ELSE (shouldConnect < 30%)

📊 EXPANSION PATTERNS: Follow the user's established patterns for child nodes.

🎨 COLOR PREFERENCES: Match colors to categories. If user always uses green for Health, use green for health-related nodes.

✏️ NAMING STYLE: Match the user's labeling style:
   - If "Concise (1-2 words)", use short labels like "Budget" not "Personal Budget Management"
   - If "Descriptive (4+ words)", use fuller labels
   - Follow any common prefixes the user uses

🧩 POTENTIAL GAPS: If a gap is mentioned that matches user input, fill it!

📐 STRUCTURE PREFERENCES: 
   - FLAT preference: Add to existing categories, don't create deep nesting
   - DEEP preference: OK to create sub-sub-categories

⭐ MOST ACTIVE BRANCHES: Prefer placing in user's most-used areas when relevant.

🕐 TIME CONTEXT: Consider what the user typically works on at this time.

📍 SESSION CONTEXT: Prefer branches the user is currently working on this session.

=== EXAMPLES ===

**ADDING NODES:**

User: "add a node called Morning Routine"
{"actions":[{"action":"add","label":"Morning Routine","description":"A structured sequence of activities to start each day with intention, energy, and clarity.","color":null,"parentId":"selected"}]}

User: "create three nodes for my workout: cardio, strength, flexibility"
{"actions":[{"action":"add","label":"Cardio","description":"Cardiovascular exercises to improve heart health and endurance.","color":"#EF4444","parentId":"selected"},{"action":"add","label":"Strength","description":"Resistance training to build muscle and increase metabolism.","color":"#EF8354","parentId":"selected"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work to prevent injury and improve range of motion.","color":"#4ECDC4","parentId":"selected"}]}

User: "what is machine learning" (tree has "AI (node-ai123)")
{"actions":[{"action":"add","label":"Machine Learning","description":"A subset of artificial intelligence where systems learn and improve from experience without being explicitly programmed. Uses algorithms to find patterns in data and make predictions or decisions.","color":null,"parentId":"node-ai123"}]}

User: "add project alpha under work with subitems planning and execution"
{"actions":[{"action":"add","label":"Project Alpha","description":"A major initiative requiring structured planning and careful execution.","color":"#9B5DE5","parentId":"work"},{"action":"add","label":"Planning","description":"Initial phase covering requirements, timeline, and resource allocation.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Execution","description":"Implementation phase where planned tasks are carried out.","color":null,"parentId":"PREV_0"}]}

User: "remind me to call mom"
{"actions":[{"action":"add","label":"Call Mom","description":"Remember to check in with mom. Consider scheduling a regular time for these calls.","color":"#FF6B9D","parentId":"selected"}]}

User: "I want to learn Spanish this year"
{"actions":[{"action":"add","label":"Learn Spanish","description":"Goal to achieve conversational Spanish fluency. Consider apps like Duolingo, classes, or conversation partners.","color":"#F7B731","parentId":"root"}]}

**NEURAL-GUIDED PLACEMENT (using all intelligence):**

User: "meditation benefits"
Neural: Category=Health(72%), Similar="Mindfulness" under Health, Color=Health uses #4ECDC4
{"actions":[{"action":"add","label":"Meditation Benefits","description":"Regular meditation practice offers reduced stress, improved focus, better emotional regulation, and enhanced overall wellbeing.","color":"#4ECDC4","parentId":"node-health123"}]}

User: "need to fix that bug"
Neural: Category=Work(68%), Active branch=Work, Session focus=Work, Naming=Concise
{"actions":[{"action":"add","label":"Bug Fix","description":"Technical issue requiring investigation and resolution.","color":null,"parentId":"node-work123"}]}

User: "random thought about saving money"
Neural: Similar="Budget" under Finance (65%), Gap="Finance missing Savings"
{"actions":[{"action":"add","label":"Savings","description":"Ideas and strategies for building financial reserves and reducing unnecessary spending.","color":"#26DE81","parentId":"node-finance456"}]}

User: "I should start running more"
Neural: Category=Fitness(80%), Expansion pattern="Under Fitness: Cardio, Strength, Nutrition", Similar="Cardio"(70%)
{"actions":[{"action":"add","label":"Running","description":"Cardiovascular exercise through running to improve endurance and overall health.","color":null,"parentId":"node-cardio789"}]}

User: "productivity hack I learned"
Neural: Relationship to selected=SIBLING(65%), Time=Morning(work time), Active=Personal Development
{"actions":[{"action":"add","label":"Productivity Hack","description":"Useful technique for getting more done with less effort and better focus.","color":null,"parentId":"node-personaldev123"}]}

**VAGUE INPUT HANDLING (neural is crucial here):**

User: "hmm just thinking about stuff"
Neural: Session focus=Work, Recent edits=Project X, Time=Afternoon
{"actions":[{"action":"add","label":"Project Thoughts","description":"General reflections and ideas related to current work focus.","color":null,"parentId":"node-work123"}]}

User: "something to remember"
Neural: Active branch=Tasks, Category=Personal(45%)
{"actions":[{"action":"add","label":"Quick Note","description":"Important thought or reminder to capture for later review.","color":"#F7B731","parentId":"selected"}]}

User: "that thing I saw online"
Neural: Similar="Bookmarks"(55%), Category=Resources(40%)
{"actions":[{"action":"add","label":"Web Discovery","description":"Interesting content found online worth saving for reference.","color":null,"parentId":"node-resources123"}]}

**EDITING NODES:**

User: "make the fitness node green"
{"actions":[{"action":"edit","targetId":"node-fitness123","color":"#26DE81"}]}

User: "change Morning Routine to green"
{"actions":[{"action":"edit","targetId":"node-morning456","color":"#26DE81"}]}

User: "rename meditation to mindfulness practice"
{"actions":[{"action":"edit","targetId":"node-meditation789","label":"Mindfulness Practice"}]}

User: "update the description of Project Alpha to say it's due next month"
{"actions":[{"action":"edit","targetId":"node-alpha123","description":"A major initiative due next month requiring structured planning and execution."}]}

User: "make work node orange and rename it to Career"
{"actions":[{"action":"edit","targetId":"node-work123","label":"Career","color":"#EF8354"}]}

User: "change the color of all my health nodes to teal" (health has id node-health1)
{"actions":[{"action":"edit","targetId":"node-health1","color":"#4ECDC4"}]}

User: "mark reading as purple"
{"actions":[{"action":"edit","targetId":"node-reading123","color":"#9B5DE5"}]}

User: "set the selected node to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

**DELETING NODES:**

User: "delete the meditation node"
{"actions":[{"action":"delete","targetId":"node-meditation789"}]}

User: "remove Project Beta"
{"actions":[{"action":"delete","targetId":"node-beta456"}]}

User: "get rid of the selected node"
{"actions":[{"action":"delete","targetId":"selected"}]}

**MOVING NODES:**

User: "move meditation under health"
{"actions":[{"action":"move","targetId":"node-meditation789","parentId":"node-health123"}]}

User: "put the reading node under personal development"
{"actions":[{"action":"move","targetId":"node-reading456","parentId":"node-personal789"}]}

User: "move project alpha to the root"
{"actions":[{"action":"move","targetId":"node-alpha123","parentId":"root"}]}

**NAVIGATION:**

User: "go to the fitness node"
{"actions":[{"action":"focus","targetId":"node-fitness123"}]}

User: "show me my goals"
{"actions":[{"action":"focus","targetId":"node-goals456"}]}

User: "take me to work"
{"actions":[{"action":"focus","targetId":"node-work789"}]}

User: "find the meditation node"
{"actions":[{"action":"focus","targetId":"node-meditation123"}]}

**EXPAND/COLLAPSE:**

User: "expand the work node"
{"actions":[{"action":"expand","targetId":"node-work123"}]}

User: "collapse personal"
{"actions":[{"action":"collapse","targetId":"node-personal456"}]}

User: "open up my goals"
{"actions":[{"action":"expand","targetId":"node-goals789"}]}

User: "close the projects section"
{"actions":[{"action":"collapse","targetId":"node-projects123"}]}

**COMPLEX MULTI-ACTION:**

User: "create a new category called side projects with two items: app idea and blog"
{"actions":[{"action":"add","label":"Side Projects","description":"Personal projects pursued outside of main work for learning and creativity.","color":"#9B5DE5","parentId":"root"},{"action":"add","label":"App Idea","description":"Concept for a mobile or web application to develop.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Blog","description":"Personal blog for sharing thoughts, tutorials, or experiences.","color":null,"parentId":"PREV_0"}]}

User: "move reading to hobbies and make it blue"
{"actions":[{"action":"move","targetId":"node-reading123","parentId":"node-hobbies456"},{"action":"edit","targetId":"node-reading123","color":"#45B7D1"}]}

User: "delete the old project and add a new one called Project Phoenix"
{"actions":[{"action":"delete","targetId":"node-oldproject123"},{"action":"add","label":"Project Phoenix","description":"New initiative rising from lessons learned in previous projects.","color":"#EF8354","parentId":"selected"}]}

**CONVERSATIONAL/QUESTION INPUTS:**

User: "I'm feeling stressed about deadlines"
{"actions":[{"action":"add","label":"Deadline Stress","description":"Feeling overwhelmed by upcoming deadlines. Consider breaking tasks into smaller chunks, prioritizing ruthlessly, and scheduling breaks.","color":"#EF4444","parentId":"selected"}]}

User: "how do I stay motivated"
{"actions":[{"action":"add","label":"Staying Motivated","description":"Key strategies include: setting clear goals, tracking progress visibly, celebrating small wins, finding accountability partners, and connecting tasks to larger purpose.","color":"#F7B731","parentId":"selected"}]}

User: "what should I focus on today"
{"actions":[{"action":"add","label":"Today's Focus","description":"Review your most important tasks, identify the one with highest impact, and protect time to work on it without interruption.","color":"#26DE81","parentId":"selected"}]}

**PARENTID RULES:**
1. Use actual node IDs from the tree (like "node-abc123")
2. Use "selected" when user says "here", "this node", or no specific location
3. Use "root" for new top-level categories
4. Use "PREV_0", "PREV_1" etc. to reference nodes created earlier in same response
5. Search the tree for relevant parents - put fitness content under fitness nodes, work under work, etc.

**MORE COLOR EXAMPLES (various phrasings):**

User: "turn fitness green"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81"}]}

User: "I want the work node to be orange"
{"actions":[{"action":"edit","targetId":"work","color":"#EF8354"}]}

User: "can you change health to teal please"
{"actions":[{"action":"edit","targetId":"health","color":"#4ECDC4"}]}

User: "make my goals yellow"
{"actions":[{"action":"edit","targetId":"goals","color":"#F7B731"}]}

User: "set color of meditation to purple"
{"actions":[{"action":"edit","targetId":"meditation","color":"#9B5DE5"}]}

User: "color the selected node pink"
{"actions":[{"action":"edit","targetId":"selected","color":"#FF6B9D"}]}

User: "change this to blue"
{"actions":[{"action":"edit","targetId":"selected","color":"#45B7D1"}]}

User: "red for the deadline task"
{"actions":[{"action":"edit","targetId":"deadline","color":"#EF4444"}]}

User: "make morning routine lavender colored"
{"actions":[{"action":"edit","targetId":"morning routine","color":"#A29BFE"}]}

**MORE NATURAL LANGUAGE VARIATIONS:**

User: "add exercise"
{"actions":[{"action":"add","label":"Exercise","description":"Physical activity for health, fitness, and mental wellbeing. Consider cardio, strength training, and flexibility work.","color":null,"parentId":"selected"}]}

User: "new node: weekly review"
{"actions":[{"action":"add","label":"Weekly Review","description":"A dedicated time each week to reflect on progress, plan ahead, and realign with goals.","color":null,"parentId":"selected"}]}

User: "brainstorm: marketing ideas"
{"actions":[{"action":"add","label":"Marketing Ideas","description":"Creative concepts and strategies for promoting products, services, or brand awareness.","color":"#9B5DE5","parentId":"selected"}]}

User: "quick thought - need to buy groceries"
{"actions":[{"action":"add","label":"Buy Groceries","description":"Shopping reminder. Consider making a list and checking pantry before going.","color":null,"parentId":"selected"}]}

User: "jot down: call the dentist"
{"actions":[{"action":"add","label":"Call Dentist","description":"Schedule a dental appointment for routine checkup or specific concern.","color":null,"parentId":"selected"}]}

**RENAMING EXAMPLES:**

User: "rename fitness to health and wellness"
{"actions":[{"action":"edit","targetId":"fitness","label":"Health & Wellness"}]}

User: "change the name of project alpha to project omega"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Omega"}]}

User: "call the meditation node mindfulness instead"
{"actions":[{"action":"edit","targetId":"meditation","label":"Mindfulness"}]}

User: "update work label to career development"
{"actions":[{"action":"edit","targetId":"work","label":"Career Development"}]}

**DESCRIPTION UPDATES:**

User: "add a description to fitness: my workout plan for 2024"
{"actions":[{"action":"edit","targetId":"fitness","description":"My comprehensive workout plan for 2024 focusing on consistency and progressive improvement."}]}

User: "update the description of goals to mention Q1 targets"
{"actions":[{"action":"edit","targetId":"goals","description":"Key objectives and Q1 targets for personal and professional growth."}]}

**COMBINED EDIT EXAMPLES:**

User: "rename work to career and make it blue"
{"actions":[{"action":"edit","targetId":"work","label":"Career","color":"#45B7D1"}]}

User: "change fitness to green and add description about daily exercise"
{"actions":[{"action":"edit","targetId":"fitness","color":"#26DE81","description":"Daily exercise routine for physical health, mental clarity, and sustained energy."}]}

User: "update project alpha: rename to project beta, make it purple, and add description about the new scope"
{"actions":[{"action":"edit","targetId":"project alpha","label":"Project Beta","color":"#9B5DE5","description":"Revised project with expanded scope and updated timeline."}]}

**HIERARCHICAL CREATION:**

User: "create a fitness category with subcategories for cardio, strength, and flexibility"
{"actions":[{"action":"add","label":"Fitness","description":"Physical training and exercise for health and performance.","color":"#26DE81","parentId":"root"},{"action":"add","label":"Cardio","description":"Cardiovascular exercises for heart health and endurance.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Strength","description":"Resistance training for muscle building and metabolism.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Flexibility","description":"Stretching and mobility work for injury prevention.","color":null,"parentId":"PREV_0"}]}

User: "add a books section under personal with three books: atomic habits, deep work, and thinking fast and slow"
{"actions":[{"action":"add","label":"Books","description":"Reading list and book notes for personal development.","color":"#9B5DE5","parentId":"personal"},{"action":"add","label":"Atomic Habits","description":"James Clear's guide to building good habits and breaking bad ones through small changes.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Deep Work","description":"Cal Newport's framework for focused, distraction-free productivity.","color":null,"parentId":"PREV_0"},{"action":"add","label":"Thinking Fast and Slow","description":"Daniel Kahneman's exploration of the two systems that drive how we think.","color":null,"parentId":"PREV_0"}]}

**QUESTION-BASED INPUTS:**

User: "what are the benefits of meditation"
{"actions":[{"action":"add","label":"Benefits of Meditation","description":"Meditation offers numerous benefits including reduced stress and anxiety, improved focus and concentration, better emotional regulation, enhanced self-awareness, and improved sleep quality. Regular practice can also lower blood pressure and boost immune function.","color":"#A29BFE","parentId":"selected"}]}

User: "explain compound interest"
{"actions":[{"action":"add","label":"Compound Interest","description":"Compound interest is interest calculated on both the initial principal and accumulated interest from previous periods. It's often called 'interest on interest' and is a powerful force for growing wealth over time. The formula is A = P(1 + r/n)^(nt).","color":"#F7B731","parentId":"selected"}]}

User: "how do I start a morning routine"
{"actions":[{"action":"add","label":"Starting a Morning Routine","description":"Begin by waking at a consistent time. Start simple with 2-3 activities like hydration, movement, and intention-setting. Prepare the night before and protect this time from distractions. Gradually add elements as habits solidify.","color":"#4ECDC4","parentId":"selected"}]}

**VOICE-STYLE INFORMAL INPUTS:**

User: "uh add something about like project deadlines I guess"
{"actions":[{"action":"add","label":"Project Deadlines","description":"Tracking and managing upcoming project deadlines to ensure timely delivery.","color":"#EF4444","parentId":"selected"}]}

User: "hmm let me think... yeah add productivity tips"
{"actions":[{"action":"add","label":"Productivity Tips","description":"Strategies and techniques for getting more done with less stress and better focus.","color":"#F7B731","parentId":"selected"}]}

User: "so basically I want to track my water intake"
{"actions":[{"action":"add","label":"Water Intake Tracking","description":"Monitor daily hydration to ensure adequate water consumption for health and energy.","color":"#45B7D1","parentId":"selected"}]}

**RESPOND ACTION (answer without creating nodes):**

User: "what's the weather today"
{"actions":[{"action":"respond","message":"Based on current conditions, it's 72°F and sunny in your area. Would you like me to add a weather tracking node to your map?","offerToAdd":false}]}

User: "what time is it in Tokyo"
{"actions":[{"action":"respond","message":"It's currently 3:45 AM in Tokyo (JST, UTC+9).","offerToAdd":false}]}

User: "what's Tesla stock price"
{"actions":[{"action":"respond","message":"Tesla (TSLA) is currently trading at $248.50, up 2.3% today. The stock has risen 15% this month following strong delivery numbers.","offerToAdd":true}]}

User: "how many calories in an avocado"
{"actions":[{"action":"respond","message":"A medium avocado contains about 240 calories, with 22g of healthy fats, 12g of carbs, and 3g of protein. It's also rich in potassium, vitamin K, and fiber.","offerToAdd":false}]}

User: "what's happening with bitcoin"
{"actions":[{"action":"respond","message":"Bitcoin is currently at $67,450, up 4% in the last 24 hours. Recent ETF inflows and halving anticipation are driving momentum.","offerToAdd":true}]}

User: "who won the super bowl"
{"actions":[{"action":"respond","message":"The Kansas City Chiefs won Super Bowl LVIII in February 2024, defeating the San Francisco 49ers 25-22 in overtime.","offerToAdd":false}]}

User: "summarize the latest AI news"
{"actions":[{"action":"respond","message":"Key AI developments this week: OpenAI announced GPT-5 training, Google released Gemini 2.0, and the EU AI Act enforcement began. Anthropic also launched new Claude features for enterprise.","offerToAdd":true}]}

**WHEN TO USE RESPOND vs ADD:**

User: "what is meditation" (general question - RESPOND)
{"actions":[{"action":"respond","message":"Meditation is a practice of focused attention and awareness, often involving breathing techniques or mindfulness. It reduces stress, improves focus, and promotes emotional wellbeing. Want me to add this to your map?","offerToAdd":true}]}

User: "add info about meditation" (explicit request - ADD)
{"actions":[{"action":"add","label":"Meditation","description":"A practice of focused attention and awareness to reduce stress, improve concentration, and promote emotional wellbeing.","color":"#A29BFE","parentId":"selected"}]}

User: "tell me about compound interest" (informational - RESPOND)
{"actions":[{"action":"respond","message":"Compound interest is interest calculated on both the initial principal and accumulated interest. The formula is A = P(1 + r/n)^(nt). It's powerful for long-term investing - $10,000 at 7% for 30 years becomes $76,123.","offerToAdd":true}]}

User: "I need to learn about compound interest" (intent to capture - ADD)
{"actions":[{"action":"add","label":"Compound Interest","description":"Interest calculated on both principal and accumulated interest. Key wealth-building concept: A = P(1 + r/n)^(nt). Small regular investments grow exponentially over time.","color":"#26DE81","parentId":"selected"}]}

**CRITICAL RULES:**
1. Always respond with valid JSON only - no extra text
2. Always include meaningful descriptions for new nodes
3. Match node IDs from the tree structure above, not labels
4. For colors, use the exact hex codes provided
5. When user mentions a node by name, find its ID in the tree
6. "selected" as targetId means the currently selected node
7. Be helpful and interpret user intent, don't be overly literal
8. For ambiguous color names, use closest match (e.g., "blue" = #45B7D1, "red" = #EF4444)
9. When editing, only include fields that are being changed
10. Use "respond" for: factual questions, current events, prices, time queries, "what is X" questions
11. Use "add" for: "add", "create", "track", "remember", "I want to learn", "capture this", or when user clearly wants to save info
12. When unsure, use "respond" with "offerToAdd": true so user can choose

**WEB SEARCH CAPABILITY:**
You have access to real-time web search. For questions about:
- Current stock prices, crypto prices, market data
- Latest news and current events  
- Weather, time zones, live information
- Recent developments, announcements
- Anything that requires up-to-date information
Use your web search to get accurate, current data before responding.

Respond with JSON only:`;

                let content;
                
                // Use Edge Function if authenticated, otherwise direct API
                if (session?.access_token) {
                    console.log('Using Edge Function for voice AI with web search...');
                    const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${session.access_token}`
                        },
                        body: JSON.stringify({
                            type: 'voice',
                            prompt: prompt,
                            maxTokens: 1024,
                            webSearch: true // Enable web search
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || 'Edge function request failed');
                    }
                    
                    const data = await response.json();
                    content = data.response;
                } else {
                    // Fall back to direct API call with web search
                    console.log('Using direct API for voice AI with web search...');
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': this.apiKey.trim(),
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 1024,
                            tools: [{
                                type: 'web_search_20250305',
                                name: 'web_search',
                                max_uses: 3
                            }],
                            messages: [{
                                role: 'user',
                                content: prompt
                            }]
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error('API Error:', response.status, errorData);
                        
                        if (response.status === 401) {
                            throw new Error('Invalid API key. Check your key in Settings.');
                        } else if (response.status === 429) {
                            throw new Error('Rate limit exceeded. Please wait a moment and try again.');
                        } else if (response.status === 400) {
                            throw new Error('Bad request. The voice input may be too long.');
                        } else if (response.status === 500 || response.status === 503) {
                            throw new Error('AI service temporarily unavailable. Try again shortly.');
                        } else if (errorData.error?.message) {
                            throw new Error(errorData.error.message);
                        } else {
                            throw new Error(`Connection error (${response.status}). Check your internet.`);
                        }
                    }
                    
                    const data = await response.json();
                    
                    // Handle potential tool use - extract final text response
                    if (data.content && Array.isArray(data.content)) {
                        // Find the text response (may be after tool_use blocks)
                        const textBlock = data.content.find(block => block.type === 'text');
                        if (textBlock) {
                            content = textBlock.text;
                        } else {
                            throw new Error('No text response from AI');
                        }
                    } else if (data.content?.[0]?.text) {
                        content = data.content[0].text;
                    } else {
                        throw new Error('Empty response from AI. Try speaking more clearly.');
                    }
                }
                
                console.log('AI response:', content);
                
                // Parse the JSON response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('Could not understand that. Try a clearer command like "add node called Work"');
                }
                
                let result;
                try {
                    result = JSON.parse(jsonMatch[0]);
                } catch (parseError) {
                    throw new Error('AI response was unclear. Try rephrasing your command.');
                }
                
                console.log('Parsed result:', result);
                
                // Handle new multi-action format
                const actions = result.actions || [result]; // Support both old and new format
                const createdNodes = []; // Track created nodes for PREV_N references
                
                // Helper function to resolve targetId to actual node ID
                const resolveTargetId = (targetId) => {
                    if (!targetId) return null;
                    if (targetId === 'selected') {
                        return selectedNode?.userData.id || null;
                    }
                    // Try to find by ID first
                    const byId = store.findNode(targetId);
                    if (byId) return targetId;
                    
                    // Search by label (case-insensitive)
                    const allNodes = store.getAllNodes();
                    const searchTerm = targetId.toLowerCase();
                    
                    // Exact match first
                    let match = allNodes.find(n => n.label.toLowerCase() === searchTerm);
                    // Partial match
                    if (!match) {
                        match = allNodes.find(n => 
                            n.label.toLowerCase().includes(searchTerm) ||
                            searchTerm.includes(n.label.toLowerCase())
                        );
                    }
                    return match?.id || null;
                };
                
                for (const action of actions) {
                    // Resolve targetId for all actions that use it
                    const resolvedTargetId = resolveTargetId(action.targetId);
                    
                    // Handle respond action - just show message, no node creation
                    if (action.action === 'respond') {
                        // Show the response message
                        const message = action.message || 'No response provided';
                        
                        // Create a styled response toast/modal
                        showAIResponse(message, action.offerToAdd, cleanedTranscript);
                        continue;
                    }
                    
                    if (action.action === 'delete') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to delete', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (targetNode && targetNode.id !== store.data.id) {
                            const label = targetNode.label;
                            if (store.deleteNode(resolvedTargetId)) {
                                showToast(`Deleted "${label}"`, 'success');
                            }
                        }
                    } else if (action.action === 'edit') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to edit', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (targetNode) {
                            const updates = {};
                            if (action.label) updates.label = action.label;
                            if (action.description) updates.description = action.description;
                            if (action.color && action.color !== 'null') updates.color = action.color;
                            store.updateNode(resolvedTargetId, updates);
                            
                            // Update the mesh visually
                            const mesh = nodes.get(resolvedTargetId);
                            if (mesh && action.color) {
                                mesh.material.color.set(action.color);
                                mesh.material.emissive.set(action.color);
                                if (mesh.userData.outlineMesh) {
                                    mesh.userData.outlineMesh.material.color.set(action.color);
                                }
                            }
                            if (mesh && action.label) {
                                // Update label sprite
                                updateNodeLabel(mesh, action.label);
                            }
                            
                            showToast(`Updated "${targetNode.label}"`, 'success');
                        }
                    } else if (action.action === 'move') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to move', 'error');
                            continue;
                        }
                        const targetNode = store.findNode(resolvedTargetId);
                        if (!targetNode || targetNode.id === store.data.id) {
                            showToast('Cannot move root node', 'error');
                            continue;
                        }
                        
                        // Resolve new parent
                        let newParentId = store.data.id;
                        if (action.parentId === 'root') {
                            newParentId = store.data.id;
                        } else if (action.parentId === 'selected' && selectedNode) {
                            newParentId = selectedNode.userData.id;
                        } else if (action.parentId) {
                            const resolved = resolveTargetId(action.parentId);
                            if (resolved) newParentId = resolved;
                        }
                        
                        // Move the node
                        if (store.moveNode && typeof store.moveNode === 'function') {
                            store.moveNode(resolvedTargetId, newParentId);
                        } else {
                            // Manual move if moveNode doesn't exist
                            const parent = store.findParent(resolvedTargetId);
                            if (parent) {
                                parent.children = parent.children.filter(c => c.id !== resolvedTargetId);
                            }
                            const newParent = store.findNode(newParentId);
                            if (newParent) {
                                newParent.children = newParent.children || [];
                                newParent.children.push(targetNode);
                            }
                            store.save();
                        }
                        showToast(`Moved "${targetNode.label}"`, 'success');
                        
                    } else if (action.action === 'focus') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node', 'error');
                            continue;
                        }
                        const mesh = nodes.get(resolvedTargetId);
                        if (mesh) {
                            // Expand parent chain first
                            let current = resolvedTargetId;
                            while (current && current !== store.data.id) {
                                const parent = store.findParent(current);
                                if (parent) {
                                    store.expandedNodes.add(parent.id);
                                }
                                current = parent?.id;
                            }
                            buildScene();
                            
                            // Then focus after rebuild
                            setTimeout(() => {
                                const updatedMesh = nodes.get(resolvedTargetId);
                                if (updatedMesh) {
                                    selectNode(updatedMesh);
                                    focusOnNode(updatedMesh);
                                    showToast(`Focused on "${store.findNode(resolvedTargetId)?.label}"`, 'success');
                                }
                            }, 100);
                        }
                        continue; // Skip buildScene at end since we handle it here
                        
                    } else if (action.action === 'expand') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to expand', 'error');
                            continue;
                        }
                        store.expandedNodes.add(resolvedTargetId);
                        const targetNode = store.findNode(resolvedTargetId);
                        showToast(`Expanded "${targetNode?.label}"`, 'success');
                        
                    } else if (action.action === 'collapse') {
                        if (!resolvedTargetId) {
                            showToast('Could not find node to collapse', 'error');
                            continue;
                        }
                        store.expandedNodes.delete(resolvedTargetId);
                        const targetNode = store.findNode(resolvedTargetId);
                        showToast(`Collapsed "${targetNode?.label}"`, 'success');
                        
                    } else if (action.action === 'add' || !action.action) {
                        // Resolve parentId (including PREV_N references)
                        let parentId = store.data.id; // Default to root
                        
                        console.log('Resolving parentId:', action.parentId);
                        
                        if (action.parentId === 'selected' && selectedNode) {
                            parentId = selectedNode.userData.id;
                            console.log('Using selected node:', parentId);
                        } else if (action.parentId === 'root') {
                            parentId = store.data.id;
                            console.log('Using root');
                        } else if (action.parentId && action.parentId.startsWith('PREV_')) {
                            const prevIndex = parseInt(action.parentId.replace('PREV_', ''));
                            if (createdNodes[prevIndex]) {
                                parentId = createdNodes[prevIndex].id;
                                console.log('Using PREV_' + prevIndex + ':', parentId);
                            }
                        } else if (action.parentId && action.parentId !== 'selected') {
                            // Try to find by ID first
                            const byId = store.findNode(action.parentId);
                            if (byId) {
                                parentId = action.parentId;
                                console.log('Found by ID:', parentId);
                            } else {
                                // Search by label (case-insensitive, partial match)
                                const allNodes = store.getAllNodes();
                                const searchTerm = action.parentId.toLowerCase();
                                
                                // Try exact match first
                                let byLabel = allNodes.find(n => 
                                    n.label.toLowerCase() === searchTerm
                                );
                                
                                // Try partial match if no exact match
                                if (!byLabel) {
                                    byLabel = allNodes.find(n => 
                                        n.label.toLowerCase().includes(searchTerm) ||
                                        searchTerm.includes(n.label.toLowerCase())
                                    );
                                }
                                
                                if (byLabel) {
                                    parentId = byLabel.id;
                                    console.log('Found by label "' + action.parentId + '":', byLabel.label, parentId);
                                } else {
                                    console.log('Could not find parent "' + action.parentId + '", using selected or root');
                                    parentId = selectedNode?.userData.id || store.data.id;
                                }
                            }
                        } else if (selectedNode) {
                            parentId = selectedNode.userData.id;
                            console.log('Defaulting to selected node:', parentId);
                        }
                        
                        // Final validation - make sure parent exists
                        const parentNode = store.findNode(parentId);
                        if (!parentNode) {
                            console.warn('Parent not found, falling back to root');
                            parentId = store.data.id;
                        }
                        
                        console.log('Final parentId:', parentId, 'Parent label:', store.findNode(parentId)?.label);
                        
                        const nodeData = { 
                            label: action.label,
                            source: 'ai-voice'
                        };
                        
                        // Add description if provided
                        if (action.description) {
                            nodeData.description = action.description;
                        }
                        
                        // Add color if provided
                        if (action.color && action.color !== 'null' && action.color !== null) {
                            nodeData.color = action.color;
                        }
                        
                        const newNode = store.addNode(parentId, nodeData);
                        if (newNode) {
                            createdNodes.push(newNode);
                            console.log(`Created node: "${action.label}" (${newNode.id}) under "${store.findNode(parentId)?.label}"`);
                            
                            // Make sure parent chain is expanded
                            let current = parentId;
                            while (current && current !== store.data.id) {
                                store.expandedNodes.add(current);
                                const parent = store.findParent(current);
                                current = parent?.id;
                            }
                        } else {
                            console.error('Failed to create node:', action.label);
                        }
                    }
                }
                
                // Rebuild scene after all actions
                buildScene();
                
                // Focus on last created node and show celebration
                if (createdNodes.length > 0) {
                    const lastNode = createdNodes[createdNodes.length - 1];
                    
                    // Small delay to let physics settle, then focus
                    setTimeout(() => {
                        const mesh = nodes.get(lastNode.id);
                        if (mesh) {
                            selectNode(mesh);
                            focusOnNode(mesh);
                            const screenPos = mesh.position.clone().project(camera);
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
                            createCelebration(x, y, lastNode.color, 12);
                        }
                    }, 300);
                    
                    if (createdNodes.length === 1) {
                        showToast(`Added "${lastNode.label}"`, 'success');
                    } else {
                        showToast(`Added ${createdNodes.length} nodes`, 'success');
                    }
                    haptic.success();
                }
                
            } catch (error) {
                console.error('AI processing error:', error);
                showToast(error.message || 'Failed to process', 'error');
                haptic.error();
            } finally {
                this.stop();
            }
        },
        
        showSettings() {
            showApiKeyModal();
        },
        
        hideSettings() {
            hideApiKeyModal();
        },
        
        saveApiKey() {
            saveApiKeyFromModal();
        }
    };
    
    // Voice button click handler
    document.getElementById('btn-voice').addEventListener('click', () => {
        if (voiceAI.isRecording || voiceAI.isProcessing) {
            voiceAI.stop();
        } else {
            voiceAI.start();
        }
    });
    
    // Settings is now accessible via menu (gear icon removed from sidebar)
    
    // Standalone API key modal function with optional callback
    let apiKeyModalCallback = null;
    
    function showApiKeyModal(callback) {
        apiKeyModalCallback = callback || null;
        const modal = document.getElementById('api-key-modal');
        const input = document.getElementById('api-key-input');
        const status = document.getElementById('api-key-status');
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        
        if (apiKey) {
            input.value = apiKey;
            status.textContent = '✓ API key configured';
            status.classList.add('configured');
        } else {
            input.value = '';
            status.textContent = 'Enter your Anthropic API key for AI features';
            status.classList.remove('configured');
        }
        
        // Update neural network stats
        const neuralStats = document.getElementById('neural-stats-settings');
        if (neuralStats && neuralNet) {
            const stats = neuralNet.getStats();
            let statsText = 'The neural network learns from your mind map to suggest related nodes.';
            if (stats.isReady) {
                statsText = `Neural network trained with ${stats.cachedEmbeddings} embeddings, ${stats.expansionPatterns} patterns.`;
            }
            neuralStats.textContent = statsText;
        }
        
        modal.classList.add('active');
        input.focus();
    }
    
    function hideApiKeyModal() {
        document.getElementById('api-key-modal').classList.remove('active');
        apiKeyModalCallback = null;
    }
    
    function saveApiKeyFromModal() {
        const input = document.getElementById('api-key-input');
        const key = input.value.trim();
        
        if (key) {
            voiceAI.apiKey = key;
            localStorage.setItem(CONFIG.API_KEY, key);
            showToast('API key saved', 'success');
            
            document.getElementById('api-key-modal').classList.remove('active');
            
            // Call callback if provided (for onboarding flow)
            if (apiKeyModalCallback) {
                const cb = apiKeyModalCallback;
                apiKeyModalCallback = null;
                cb();
            }
        } else {
            showToast('Please enter an API key', 'error');
        }
    }
    
    // Voice indicator event handlers
    document.getElementById('voice-cancel').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-backdrop').addEventListener('click', () => voiceAI.stop());
    document.getElementById('voice-indicator').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) voiceAI.stop();
    });
    
    // Voice mode toggle (speak vs type)
    let voiceInputMode = 'speak'; // 'speak' or 'type'
    
    // Prevent clicks on toggle from closing modal
    document.querySelector('.voice-mode-toggle').addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    document.getElementById('voice-mode-speak').addEventListener('click', (e) => {
        e.stopPropagation();
        voiceInputMode = 'speak';
        document.getElementById('voice-mode-speak').classList.add('active');
        document.getElementById('voice-mode-type').classList.remove('active');
        
        // Show voice UI, hide text UI
        document.getElementById('voice-icon').style.display = 'block';
        document.getElementById('voice-status').style.display = 'block';
        document.getElementById('voice-transcript').style.display = 'block';
        document.getElementById('voice-text-wrapper').style.display = 'none';
        document.getElementById('voice-hint').textContent = 'Tap anywhere or press Escape to cancel';
        
        // Start voice recognition if not already processing
        if (!voiceAI.isProcessing) {
            voiceAI.startRecording();
        }
    });
    
    document.getElementById('voice-mode-type').addEventListener('click', (e) => {
        e.stopPropagation();
        console.log('Type mode clicked');
        voiceInputMode = 'type';
        document.getElementById('voice-mode-type').classList.add('active');
        document.getElementById('voice-mode-speak').classList.remove('active');
        
        // Hide voice UI, show text UI
        document.getElementById('voice-icon').style.display = 'none';
        document.getElementById('voice-status').textContent = 'Type your request';
        document.getElementById('voice-status').style.display = 'block';
        document.getElementById('voice-transcript').style.display = 'none';
        
        const textWrapper = document.getElementById('voice-text-wrapper');
        textWrapper.style.display = 'block';
        console.log('Text wrapper display:', textWrapper.style.display);
        
        document.getElementById('voice-hint').textContent = 'Press Enter or click Send to submit';
        
        // Stop voice recognition
        if (voiceAI.recognition) {
            try { voiceAI.recognition.stop(); } catch (e) {}
        }
        voiceAI.isRecording = false;
        
        // Focus text input
        setTimeout(() => {
            document.getElementById('voice-text-input').focus();
        }, 100);
    });
    
    // Voice text input submit
    document.getElementById('voice-text-submit').addEventListener('click', (e) => {
        e.stopPropagation();
        const textInput = document.getElementById('voice-text-input');
        const text = textInput.value.trim();
        console.log('Submit clicked, text:', text);
        if (text) {
            console.log('Processing with AI:', text);
            voiceAI.processWithAI(text);
            textInput.value = '';
        } else {
            showToast('Please enter a request', 'info');
        }
    });
    
    // Prevent clicks in text area from closing modal
    document.getElementById('voice-text-input').addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    document.getElementById('voice-text-wrapper').addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    // Enter key in text input
    document.getElementById('voice-text-input').addEventListener('keydown', (e) => {
        e.stopPropagation();
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            console.log('Enter pressed in text input');
            document.getElementById('voice-text-submit').click();
        }
    });
    
    // API key modal handlers
    document.getElementById('api-key-save').addEventListener('click', () => saveApiKeyFromModal());
    document.getElementById('api-key-cancel').addEventListener('click', () => hideApiKeyModal());
    document.getElementById('api-key-modal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) hideApiKeyModal();
    });

    // ═══════════════════════════════════════════════════════════════════
    // AUTH MODAL HANDLERS
    // ═══════════════════════════════════════════════════════════════════
    const authModal = document.getElementById('auth-modal');
    const authForm = document.getElementById('auth-form');
    const authError = document.getElementById('auth-error');
    let authMode = 'signin'; // 'signin' or 'signup'
    
    function showAuthModal() {
        authModal.classList.add('active');
        authError.classList.remove('active');
        document.getElementById('auth-email').value = '';
        document.getElementById('auth-password').value = '';
    }
    
    function hideAuthModal() {
        authModal.classList.remove('active');
    }
    
    function showAuthError(message) {
        authError.textContent = message;
        authError.classList.add('active');
    }
    
    function updateAuthUI(user) {
        const avatar = document.getElementById('user-avatar');
        const syncIndicator = document.getElementById('sync-indicator');
        
        if (!avatar || !syncIndicator) {
            console.warn('Auth UI elements not found');
            return;
        }
        
        console.log('Updating auth UI for user:', user?.email || 'logged out');
        
        if (user) {
            // Show user initial
            const initial = user.email?.charAt(0).toUpperCase() || 'U';
            avatar.innerHTML = `<span style="line-height: 1;">${initial}</span>`;
            avatar.title = user.email;
            
            // Update sync indicator
            syncIndicator.classList.add('synced');
            syncIndicator.title = 'Synced to cloud';
        } else {
            // Show default icon
            avatar.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                    <circle cx="12" cy="7" r="4"/>
                </svg>
            `;
            avatar.title = 'Sign in';
            
            syncIndicator.classList.remove('synced');
            syncIndicator.title = 'Offline mode';
        }
    }
    
    function toggleAuthMode() {
        authMode = authMode === 'signin' ? 'signup' : 'signin';
        
        document.getElementById('auth-title').textContent = 
            authMode === 'signin' ? 'Sign in to MYND' : 'Create your account';
        document.getElementById('auth-submit').textContent = 
            authMode === 'signin' ? 'Sign In' : 'Sign Up';
        document.getElementById('auth-toggle-text').textContent = 
            authMode === 'signin' ? "Don't have an account?" : 'Already have an account?';
        document.getElementById('auth-toggle-link').textContent = 
            authMode === 'signin' ? 'Sign up' : 'Sign in';
        document.getElementById('auth-forgot').style.display = 
            authMode === 'signin' ? 'block' : 'none';
        
        authError.classList.remove('active');
    }
    
    // User account dropdown management
    const userDropdown = {
        element: document.getElementById('user-dropdown'),
        isOpen: false,
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        async open() {
            this.isOpen = true;
            this.element.classList.add('open');
            await this.refresh();
            
            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', this.handleOutsideClick);
            }, 10);
        },
        
        close() {
            this.isOpen = false;
            this.element.classList.remove('open');
            document.removeEventListener('click', this.handleOutsideClick);
        },
        
        handleOutsideClick: function(e) {
            if (!e.target.closest('#user-account-wrapper')) {
                userDropdown.close();
            }
        },
        
        async refresh() {
            const loggedIn = SupabaseAuth.isLoggedIn();
            
            document.getElementById('user-dropdown-loggedin').style.display = loggedIn ? 'block' : 'none';
            document.getElementById('user-dropdown-loggedout').style.display = loggedIn ? 'none' : 'block';
            
            if (loggedIn) {
                // Update email
                document.getElementById('user-dropdown-email').textContent = SupabaseAuth.getUserEmail();
                
                // Update sync status
                this.updateSyncStatus();
                
                // Load maps
                await this.loadMaps();
            }
        },
        
        updateSyncStatus() {
            const syncDot = document.querySelector('.user-dropdown-sync-dot');
            const syncStatus = document.getElementById('user-sync-status');
            
            if (SupabaseSync.lastSyncTime) {
                const ago = this.formatTimeAgo(SupabaseSync.lastSyncTime);
                syncStatus.textContent = `Synced ${ago}`;
                syncDot.className = 'user-dropdown-sync-dot synced';
            } else if (SupabaseSync.isSyncing) {
                syncStatus.textContent = 'Syncing...';
                syncDot.className = 'user-dropdown-sync-dot syncing';
            } else {
                syncStatus.textContent = 'Connected';
                syncDot.className = 'user-dropdown-sync-dot synced';
            }
        },
        
        formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        },
        
        async loadMaps() {
            const listEl = document.getElementById('user-maps-list');
            const maps = await SupabaseSync.loadUserMaps();
            
            if (maps.length === 0) {
                listEl.innerHTML = '<div class="user-maps-empty">No saved maps yet</div>';
                return;
            }
            
            listEl.innerHTML = maps.slice(0, 8).map(map => `
                <div class="user-map-item ${map.id === SupabaseSync.currentMapId ? 'active' : ''}" data-map-id="${map.id}">
                    <div class="user-map-icon"></div>
                    <div class="user-map-info">
                        <div class="user-map-name">${escapeHTML(map.name)}</div>
                        <div class="user-map-date">${this.formatTimeAgo(new Date(map.updated_at).getTime())}</div>
                    </div>
                    <div class="user-map-actions">
                        <button class="user-map-action rename" title="Rename" data-map-id="${map.id}">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                            </svg>
                        </button>
                        <button class="user-map-action delete" title="Delete" data-map-id="${map.id}">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `).join('');
            
            // Add click handlers
            listEl.querySelectorAll('.user-map-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    if (e.target.closest('.user-map-action')) return;
                    
                    const mapId = item.dataset.mapId;
                    if (mapId === SupabaseSync.currentMapId) return;
                    
                    await this.switchToMap(mapId);
                });
            });
            
            // Rename handlers
            listEl.querySelectorAll('.user-map-action.rename').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const mapId = btn.dataset.mapId;
                    const mapItem = btn.closest('.user-map-item');
                    const currentName = mapItem.querySelector('.user-map-name').textContent;
                    
                    const newName = prompt('Rename map:', currentName);
                    if (newName && newName !== currentName) {
                        await SupabaseSync.renameMap(mapId, newName);
                        await this.loadMaps();
                        
                        // Update store if current map
                        if (mapId === SupabaseSync.currentMapId) {
                            store.data.label = newName;
                            store.save();
                            updateNodeLabel(nodes.get(store.data.id), newName);
                        }
                    }
                });
            });
            
            // Delete handlers
            listEl.querySelectorAll('.user-map-action.delete').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const mapId = btn.dataset.mapId;
                    const mapItem = btn.closest('.user-map-item');
                    const mapName = mapItem.querySelector('.user-map-name').textContent;
                    
                    const confirmed = await showConfirm({
                        title: 'Delete Map',
                        message: `Delete "${mapName}"? This cannot be undone.`,
                        confirmText: 'Delete',
                        cancelText: 'Cancel',
                        danger: true
                    });
                    
                    if (confirmed) {
                        await SupabaseSync.deleteMap(mapId);
                        await this.loadMaps();
                        
                        // If deleted current map, create new
                        if (mapId === SupabaseSync.currentMapId) {
                            await this.createNewMap();
                        }
                    }
                });
            });
        },
        
        async switchToMap(mapId) {
            this.close();
            showToast('Loading map...', 'info');
            
            const mapData = await SupabaseSync.loadMap(mapId);
            if (mapData && mapData.data) {
                store.data = mapData.data;
                store.expandedNodes = new Set([store.data.id]);
                store.save();
                buildScene();
                resetCamera();
                showToast(`Loaded "${mapData.name}"`, 'success');
            } else {
                showToast('Failed to load map', 'error');
            }
        },
        
        async createNewMap() {
            const name = prompt('Name for new map:', 'New Mind Map');
            if (!name) return;
            
            this.close();
            
            // Reset store
            store.reset(name);
            
            // Clear current map ID so a new one is created
            SupabaseSync.currentMapId = null;
            SupabaseSync.unsubscribeFromRealtime();
            
            // Save to create new map
            const saved = await SupabaseSync.saveMap(store.data, name);
            if (saved) {
                SupabaseSync.currentMapId = saved.id;
                await SupabaseSync.subscribeToRealtime(saved.id);
            }
            
            buildScene();
            resetCamera();
            showToast(`Created "${name}"`, 'success');
        }
    };
    
    // User account button click
    document.getElementById('user-account-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        userDropdown.toggle();
    });
    
    // Sign out button
    document.getElementById('user-dropdown-signout').addEventListener('click', async () => {
        userDropdown.close();
        await SupabaseAuth.signOut();
        showToast('Signed out', 'info');
    });
    
    // Sign in button (in dropdown)
    document.getElementById('user-dropdown-signin').addEventListener('click', () => {
        userDropdown.close();
        showAuthModal();
    });
    
    // New map action
    document.getElementById('user-action-new').addEventListener('click', () => {
        userDropdown.createNewMap();
    });
    
    // Export actions
    const handleExport = () => {
        userDropdown.close();
        const data = store.export();
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${store.data.label || 'mindmap'}.json`;
        a.click();
        URL.revokeObjectURL(url);
        showToast('Map exported', 'success');
    };
    document.getElementById('user-action-export').addEventListener('click', handleExport);
    document.getElementById('user-action-export-offline').addEventListener('click', handleExport);
    
    // Import actions
    const handleImport = () => {
        userDropdown.close();
        document.getElementById('file-input').click();
    };
    document.getElementById('user-action-import').addEventListener('click', handleImport);
    document.getElementById('user-action-import-offline').addEventListener('click', handleImport);
    
    // Auth modal close
    document.getElementById('auth-close').addEventListener('click', hideAuthModal);
    authModal.addEventListener('click', (e) => {
        if (e.target === authModal) hideAuthModal();
    });
    
    // Google sign in
    document.getElementById('auth-google').addEventListener('click', async () => {
        await SupabaseAuth.signInWithGoogle();
    });
    
    // Email form submit
    authForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const email = document.getElementById('auth-email').value;
        const password = document.getElementById('auth-password').value;
        
        if (authMode === 'signin') {
            const { error } = await SupabaseAuth.signInWithEmail(email, password);
            if (error) {
                showAuthError(error.message);
            } else {
                hideAuthModal();
            }
        } else {
            const { error } = await SupabaseAuth.signUpWithEmail(email, password);
            if (error) {
                showAuthError(error.message);
            }
            // Don't hide modal - user needs to verify email
        }
    });
    
    // Toggle between sign in and sign up
    document.getElementById('auth-toggle-link').addEventListener('click', toggleAuthMode);
    
    // Forgot password
    document.getElementById('auth-forgot').addEventListener('click', async () => {
        const email = document.getElementById('auth-email').value;
        if (!email) {
            showAuthError('Enter your email address first');
            return;
        }
        await SupabaseAuth.resetPassword(email);
    });
    
    // Skip auth (continue offline)
    document.getElementById('auth-skip').addEventListener('click', () => {
        hideAuthModal();
        showToast('Using offline mode', 'info');
    });
    
    // Listen for auth state changes
    SupabaseAuth.onAuthChange(async (user, previousUser, event) => {
        updateAuthUI(user);
        
        // Refresh dropdown if it's open
        if (typeof userDropdown !== 'undefined' && userDropdown.isOpen) {
            userDropdown.refresh();
        }
        
        if (user && !previousUser) {
            // User just logged in
            hideAuthModal();
            showToast(`Welcome, ${user.email}!`, 'success');
            
            // Initialize sync
            await SupabaseSync.init();
            
            // Check for existing cloud data
            const maps = await SupabaseSync.loadUserMaps();
            if (maps.length > 0) {
                // Ask user if they want to load cloud data
                if (confirm(`Found ${maps.length} mind map(s) in the cloud. Load your most recent map?`)) {
                    const latestMap = maps[0];
                    const mapData = await SupabaseSync.loadMap(latestMap.id);
                    if (mapData?.data) {
                        store.importData(mapData.data);
                        showToast(`Loaded "${latestMap.name}"`, 'success');
                    }
                }
            } else {
                // No cloud data - sync current local data
                await SupabaseSync.performFullSync(store, neuralNet, metaLearner, conceptAbstractor);
            }
        } else if (!user && previousUser) {
            // User logged out
            SupabaseSync.syncEnabled = false;
            SupabaseSync.currentMapId = null;
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // TOP CONTROLS
    // ═══════════════════════════════════════════════════════════════════
    const themePicker = document.getElementById('theme-picker');
    
    document.getElementById('theme-btn').addEventListener('click', () => {
        themePicker.classList.toggle('active');
        document.getElementById('menu-dropdown').classList.remove('active');
    });
    
    document.querySelectorAll('.theme-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const oldTheme = document.documentElement.getAttribute('data-theme') || 'coral';
            const newTheme = opt.dataset.theme;
            themeManager.set(newTheme);
            themePicker.classList.remove('active');
            // Remap node colors to new theme palette FIRST
            updateNodeColorsForTheme(oldTheme, newTheme);
            // Update label sprites with new colors
            updateLabelsForTheme();
            // Update color pickers for theme
            updateColorPickers();
        });
    });

    const menuDropdown = document.getElementById('menu-dropdown');
    
    document.getElementById('menu-btn').addEventListener('click', () => {
        menuDropdown.classList.toggle('active');
        themePicker.classList.remove('active');
    });
    
    document.getElementById('menu-search').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        toggleSpotlight();
    });
    
    document.getElementById('menu-new').addEventListener('click', () => {
        if (confirm('Start a new map? This will clear your current map.')) {
            store.reset();
            currentContextId = store.data.id;
            
            // Reset onboarding state and show questionnaire
            currentQuestion = 0;
            questionAnswers = [];
            mapName = 'My Mind';
            localStorage.removeItem(CONFIG.ONBOARDING_KEY);
            
            // Re-create onboarding overlay if it was removed
            if (!document.getElementById('onboarding-overlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'onboarding-overlay';
                overlay.innerHTML = `
                    <div class="onboarding-content" id="onboarding-welcome">
                        <div class="onboarding-logo">M</div>
                        <h1 class="onboarding-title">Create New Map</h1>
                        <p class="onboarding-subtitle">Your thoughts, beautifully organized in 3D space.</p>
                        <div class="onboarding-input-wrapper">
                            <input type="text" id="onboarding-name" placeholder="What should we call your mind map?" value="My Mind">
                        </div>
                        <div class="onboarding-choices">
                            <div class="onboarding-choice ai" id="onboarding-ai">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5A2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5a2.5 2.5 0 0 0 2.5 2.5a2.5 2.5 0 0 0 2.5-2.5a2.5 2.5 0 0 0-2.5-2.5z"/></svg>
                                </div>
                                <div class="onboarding-choice-title">AI-Assisted Setup</div>
                                <div class="onboarding-choice-desc">Answer a few questions and let AI build your personalized mind map</div>
                            </div>
                            <div class="onboarding-choice scratch" id="onboarding-scratch">
                                <div class="onboarding-choice-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                                </div>
                                <div class="onboarding-choice-title">Start from Scratch</div>
                                <div class="onboarding-choice-desc">Begin with a simple template and build your own structure</div>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-questionnaire" id="onboarding-questionnaire">
                        <div class="question-header">
                            <div class="question-logo">M</div>
                            <div class="question-progress">
                                <div class="question-step">Question <span id="question-current">1</span> of 6</div>
                                <div class="question-progress-bar">
                                    <div class="question-progress-fill" id="question-progress-fill" style="width: 16.67%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="question-text" id="question-text"></div>
                        <textarea class="question-input" id="question-input" placeholder="Type your answer here..."></textarea>
                        <div class="question-actions">
                            <span class="question-skip" id="question-skip-btn">Skip this question</span>
                            <div class="question-nav">
                                <button class="question-btn secondary" id="question-back" style="display: none;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                                    Back
                                </button>
                                <button class="question-btn primary" id="question-next">
                                    Next
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="onboarding-processing" id="onboarding-processing">
                        <div class="processing-spinner"></div>
                        <div class="processing-title">Building your mind map...</div>
                        <div class="processing-subtitle">Analyzing your responses to create a personalized starting point</div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Re-attach event listeners to the NEW overlay specifically
                overlay.querySelector('.onboarding-choice.ai').addEventListener('click', () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    
                    // Check for API key first
                    const apiKey = localStorage.getItem(CONFIG.API_KEY);
                    if (!apiKey) {
                        showApiKeyModal(() => {
                            showQuestionnaire();
                        });
                    } else {
                        showQuestionnaire();
                    }
                });
                
                overlay.querySelector('.onboarding-choice.scratch').addEventListener('click', () => {
                    mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                    createBasicMapStructure();
                });
                
                overlay.querySelector('#onboarding-name').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        mapName = overlay.querySelector('#onboarding-name').value.trim() || 'My Mind';
                        
                        // Check for API key first
                        const apiKey = localStorage.getItem(CONFIG.API_KEY);
                        if (!apiKey) {
                            showApiKeyModal(() => {
                                showQuestionnaire();
                            });
                        } else {
                            showQuestionnaire();
                        }
                    }
                });
                
                document.getElementById('question-next').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-back').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
                    if (currentQuestion > 0) {
                        currentQuestion--;
                        updateQuestionUI();
                    }
                });
                
                document.getElementById('question-skip-btn').addEventListener('click', () => {
                    questionAnswers[currentQuestion] = '';
                    if (currentQuestion < onboardingQuestions.length - 1) {
                        currentQuestion++;
                        updateQuestionUI();
                    } else {
                        processOnboardingAnswers();
                    }
                });
                
                document.getElementById('question-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('question-next').click();
                    }
                });
            }
            
            document.getElementById('onboarding-overlay').style.display = 'flex';
            document.getElementById('onboarding-overlay').classList.remove('fade-out');
        }
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-save').addEventListener('click', () => {
        const json = store.exportJSON();
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `mynd-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        // Check if neural data was included
        const hasNeural = json.includes('"neural"');
        showToast(hasNeural ? 'Map + neural data saved!' : 'Map saved!', 'success');
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-load').addEventListener('click', () => {
        document.getElementById('file-input').click();
        menuDropdown.classList.remove('active');
    });
    
    document.getElementById('menu-shortcuts').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        const hints = document.getElementById('keyboard-hints');
        hints.classList.add('visible');
        setTimeout(() => hints.classList.remove('visible'), 5000);
    });
    
    document.getElementById('menu-settings').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        showApiKeyModal();
    });
    
    document.getElementById('menu-voice-settings').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        voiceAI.showSettings();
    });
    
    document.getElementById('menu-help').addEventListener('click', () => {
        menuDropdown.classList.remove('active');
        showToast('MYND: 3D Mind Mapping\n\nClick nodes to expand/collapse\nDouble-click to expand all\nDrag to rotate view\nUse sidebar for actions', 'info', 5000);
    });
    
    document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const content = event.target.result;
                if (store.importJSON(content)) {
                    currentContextId = store.data.id;
                    buildScene();
                    
                    // Check if neural data was included
                    const hasNeural = content.includes('"neural"') && content.includes('"modelData"');
                    if (hasNeural) {
                        showToast('Map + neural data loaded!', 'success');
                        // Update neural UI if it's initialized
                        if (typeof NeuralUI !== 'undefined') {
                            NeuralUI.updateStatus();
                        }
                    } else {
                        showToast('Map loaded!', 'success');
                    }
                } else {
                    showToast('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);
        }
        e.target.value = '';
    });

    // Undo button
    const undoBtn = document.getElementById('undo-btn');
    
    undoBtn.addEventListener('click', () => {
        const result = store.undo();
        if (result.success) {
            buildScene();
            showToast(`Undid: ${result.actionName}`, 'info');
        }
    });
    
    bus.on('undo:changed', () => {
        undoBtn.disabled = !store.canUndo();
    });

    // Depth back button
    document.getElementById('depth-back').addEventListener('click', surfaceUp);

    // Close dropdowns on outside click
    document.addEventListener('click', (e) => {
        if (!e.target.closest('#theme-btn, #theme-picker')) {
            themePicker.classList.remove('active');
        }
        if (!e.target.closest('#menu-btn, #menu-dropdown')) {
            menuDropdown.classList.remove('active');
        }
    });

    // ═══════════════════════════════════════════════════════════════════
    // ONBOARDING
    // ═══════════════════════════════════════════════════════════════════
    const onboardingQuestions = [
        "What's one goal you want to make real progress on in the next 30 days?",
        "What's your ultimate dream career or life achievement?",
        "What's something you've been meaning to get around to but keep putting off?",
        "Is there a skill you're currently learning or want to develop?",
        "What area of your life feels cluttered, overwhelming, or in need of better organization?",
        "What do you do to recharge or find joy outside of work and responsibilities?"
    ];
    
    let currentQuestion = 0;
    let questionAnswers = [];
    let mapName = 'My Mind';
    
    function checkOnboarding() {
        const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
        const overlay = document.getElementById('onboarding-overlay');
        if (onboarded) {
            // Already onboarded - hide overlay
            overlay.style.display = 'none';
        } else {
            // Show onboarding
            overlay.style.display = 'flex';
        }
    }
    
    function updateQuestionUI() {
        document.getElementById('question-current').textContent = currentQuestion + 1;
        document.getElementById('question-progress-fill').style.width = `${((currentQuestion + 1) / onboardingQuestions.length) * 100}%`;
        document.getElementById('question-text').textContent = onboardingQuestions[currentQuestion];
        document.getElementById('question-input').value = questionAnswers[currentQuestion] || '';
        document.getElementById('question-input').placeholder = 'Type your answer here...';
        document.getElementById('question-back').style.display = currentQuestion > 0 ? 'flex' : 'none';
        
        const nextBtn = document.getElementById('question-next');
        if (currentQuestion === onboardingQuestions.length - 1) {
            nextBtn.innerHTML = 'Finish <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
        } else {
            nextBtn.innerHTML = 'Next <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>';
        }
        
        // Focus input
        setTimeout(() => document.getElementById('question-input').focus(), 100);
    }
    
    function showQuestionnaire() {
        document.getElementById('onboarding-welcome').style.display = 'none';
        document.getElementById('onboarding-questionnaire').classList.add('active');
        updateQuestionUI();
    }
    
    function showProcessing() {
        document.getElementById('onboarding-questionnaire').classList.remove('active');
        document.getElementById('onboarding-processing').classList.add('active');
    }
    
    async function processOnboardingAnswers() {
        showProcessing();
        
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        
        // If no API key, create basic structure without AI
        if (!apiKey) {
            createBasicMapStructure();
            return;
        }
        
        try {
            const answersContext = onboardingQuestions.map((q, i) => 
                `Q${i+1}: ${q}\nA${i+1}: ${questionAnswers[i] || '(skipped)'}`
            ).join('\n\n');
            
            console.log('🚀 Calling AI with answers:', answersContext);
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4000,
                    temperature: 0,
                    system: `You create mind map structures as JSON. You ALWAYS include nested children. You NEVER create flat structures. Every node at level 1 MUST have children, and those children MUST have their own children. You ALWAYS create EXACTLY 4 top-level nodes.`,
                    messages: [{
                        role: 'user',
                        content: `Based on these answers, create a mind map with EXACTLY this structure:
- EXACTLY 4 main categories (Level 1) - no more, no less
- Each category has 2-3 topics (Level 2)
- Each topic has 2-3 actions (Level 3)

User's answers:
${answersContext}

Return this EXACT JSON structure (with your own labels based on answers):

{"nodes":[{"label":"Goals","color":"#60a5fa","children":[{"label":"Short Term","children":[{"label":"Action 1"},{"label":"Action 2"}]},{"label":"Long Term","children":[{"label":"Action 1"},{"label":"Action 2"}]}]},{"label":"Growth","color":"#2dd4bf","children":[{"label":"Skills","children":[{"label":"Step 1"},{"label":"Step 2"}]},{"label":"Learning","children":[{"label":"Resource 1"},{"label":"Resource 2"}]}]},{"label":"Projects","color":"#c084fc","children":[{"label":"Current","children":[{"label":"Task 1"},{"label":"Task 2"}]},{"label":"Planned","children":[{"label":"Idea 1"},{"label":"Idea 2"}]}]},{"label":"Wellness","color":"#4ade80","children":[{"label":"Physical","children":[{"label":"Habit 1"},{"label":"Habit 2"}]},{"label":"Mental","children":[{"label":"Practice 1"},{"label":"Practice 2"}]}]}]}

Replace placeholder labels with real content from user's answers. MUST have exactly 4 top-level nodes. JSON only.`
                    }]
                })
            });
            
            if (!response.ok) {
                const errData = await response.json().catch(() => ({}));
                console.error('❌ API error:', response.status, errData);
                throw new Error('API request failed');
            }
            
            const data = await response.json();
            const content = data.content?.[0]?.text || '';
            console.log('📝 AI response:', content);
            
            // Find JSON in response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            
            if (jsonMatch) {
                try {
                    const structure = JSON.parse(jsonMatch[0]);
                    console.log('✅ Parsed structure:', structure);
                    console.log('📊 Top level nodes:', structure.nodes?.length);
                    
                    // Validate structure has nested children
                    if (structure.nodes?.[0]?.children?.[0]?.children) {
                        console.log('✅ Structure has 3 levels - using AI result');
                        createMapFromStructure(structure);
                    } else {
                        console.error('❌ Structure missing nested children, using fallback');
                        createBasicMapStructure();
                    }
                } catch (parseError) {
                    console.error('❌ JSON parse error:', parseError);
                    createBasicMapStructure();
                }
            } else {
                console.error('❌ No JSON found in response');
                createBasicMapStructure();
            }
        } catch (error) {
            console.error('Onboarding AI error:', error);
            createBasicMapStructure();
        }
    }
    
    function createMapFromStructure(structure) {
        // Update root label and clear any existing children
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear existing children
        
        // Get colors from current theme
        const themeColors = getThemeColors();
        
        console.log('🏗️ Creating map from structure, nodes:', structure.nodes?.length);
        
        // Add nodes from AI structure (3 levels deep)
        if (structure.nodes && Array.isArray(structure.nodes)) {
            // Limit to max 4 top-level nodes
            const topNodes = structure.nodes.slice(0, 4);
            
            topNodes.forEach((category, categoryIndex) => {
                // Use theme colors for top-level categories - start from index 1 (skip root color)
                const categoryColor = themeColors[(categoryIndex % 4) + 1];
                console.log('📁 Adding category:', category.label, 'color:', categoryColor);
                
                const categoryNode = store.addNode(store.data.id, {
                    label: category.label,
                    color: categoryColor,
                    source: 'onboarding'
                });
                
                if (!categoryNode) {
                    console.error('Failed to create category node');
                    return;
                }
                
                // Layer 2: Children of category - INHERIT parent color
                if (category.children && Array.isArray(category.children)) {
                    category.children.forEach((child) => {
                        console.log('  📄 Adding child:', child.label, 'inheriting color:', categoryColor);
                        
                        const childNode = store.addNode(categoryNode.id, {
                            label: child.label,
                            color: categoryColor,  // Inherit parent color
                            source: 'onboarding'
                        });
                        
                        if (!childNode) {
                            console.error('Failed to create child node');
                            return;
                        }
                        
                        // Layer 3: Grandchildren - INHERIT parent color
                        if (child.children && Array.isArray(child.children)) {
                            child.children.forEach((grandchild) => {
                                console.log('    📌 Adding grandchild:', grandchild.label, 'inheriting color:', categoryColor);
                                store.addNode(childNode.id, {
                                    label: grandchild.label,
                                    color: categoryColor,  // Inherit from top-level parent
                                    source: 'onboarding'
                                });
                            });
                        }
                    });
                }
            });
        }
        
        store.save();
        buildScene();
        completeOnboarding();
        
        // Auto-train neural network on newly created map
        if (neuralNet.isReady) {
            console.log('🧠 Auto-training neural network on new map...');
            setTimeout(() => {
                neuralNet.train(store).then(() => {
                    console.log('✓ Neural network trained on initial map');
                });
            }, 3000); // Delay to let the scene fully build
        }
    }
    
    function createBasicMapStructure() {
        console.log('📝 Creating basic structure from scratch');
        // Create basic structure without AI
        store.updateNode(store.data.id, { label: mapName });
        store.data.children = []; // Clear any existing children
        
        // Use colors from current theme palette
        const colors = getThemeColors();
        
        // Add default categories for starting from scratch
        // Using distinct colors that don't match root (orange)
        const categories = [
            { label: 'Goals', color: colors[4] },      // Blue
            { label: 'Ideas', color: colors[3] },      // Yellow
            { label: 'To Do', color: colors[7] },      // Purple
            { label: 'Wants', color: colors[2] }       // Teal
        ];
        
        categories.forEach(cat => {
            store.addNode(store.data.id, cat);
        });
        
        store.save();
        buildScene();
        completeOnboarding();
    }

    // AI-Assisted Setup choice - use class selector for clarity
    const aiChoiceBtn = document.querySelector('#onboarding-overlay .onboarding-choice.ai');
    if (aiChoiceBtn) {
        aiChoiceBtn.addEventListener('click', () => {
            console.log('AI Assist clicked');
            mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
            
            // Check for API key first
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey) {
                // Show API key modal first
                showApiKeyModal(() => {
                    // After API key is saved, show questionnaire
                    showQuestionnaire();
                });
            } else {
                showQuestionnaire();
            }
        });
    } else {
        console.error('Could not find AI choice button');
    }
    
    // Start from Scratch choice - use class selector for clarity
    const scratchChoiceBtn = document.querySelector('#onboarding-overlay .onboarding-choice.scratch');
    if (scratchChoiceBtn) {
        scratchChoiceBtn.addEventListener('click', () => {
            console.log('Start from Scratch clicked');
            mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
            createBasicMapStructure();
        });
    } else {
        console.error('Could not find Scratch choice button');
    }
    
    const onboardingNameInput = document.querySelector('#onboarding-overlay #onboarding-name');
    if (onboardingNameInput) {
        onboardingNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                mapName = document.getElementById('onboarding-name').value.trim() || 'My Mind';
                
                // Check for API key first
                const apiKey = localStorage.getItem(CONFIG.API_KEY);
                if (!apiKey) {
                    showApiKeyModal(() => {
                        showQuestionnaire();
                    });
                } else {
                    showQuestionnaire();
                }
            }
        });
    }
    
    document.getElementById('question-next').addEventListener('click', () => {
        // Save current answer
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            // All questions answered
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-back').addEventListener('click', () => {
        questionAnswers[currentQuestion] = document.getElementById('question-input').value.trim();
        if (currentQuestion > 0) {
            currentQuestion--;
            updateQuestionUI();
        }
    });
    
    document.getElementById('question-skip-btn').addEventListener('click', () => {
        questionAnswers[currentQuestion] = '';
        if (currentQuestion < onboardingQuestions.length - 1) {
            currentQuestion++;
            updateQuestionUI();
        } else {
            processOnboardingAnswers();
        }
    });
    
    document.getElementById('question-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            document.getElementById('question-next').click();
        }
    });

    function completeOnboarding() {
        localStorage.setItem(CONFIG.ONBOARDING_KEY, 'true');
        const overlay = document.getElementById('onboarding-overlay');
        overlay.classList.add('fade-out');
        setTimeout(() => overlay.remove(), 800);
    }

    // ═══════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    async function init() {
        try {
            // Check onboarding first - hide overlay immediately if already completed
            const onboarded = localStorage.getItem(CONFIG.ONBOARDING_KEY);
            if (onboarded) {
                document.getElementById('onboarding-overlay').style.display = 'none';
            }
            
            // Initialize Supabase (if configured)
            initSupabase();
            const initialUser = await SupabaseAuth.init();
            
            themeManager.init();
            chatManager.init();
            initScene();
            
            // Update auth UI after scene is initialized (DOM ready)
            setTimeout(() => {
                updateAuthUI(initialUser);
                
                // If user is logged in, initialize sync
                if (initialUser) {
                    SupabaseSync.init().then(async () => {
                        // Check for cloud data
                        const maps = await SupabaseSync.loadUserMaps();
                        if (maps.length > 0) {
                            console.log(`Found ${maps.length} cloud map(s)`);
                        }
                    });
                }
            }, 100);
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                setTimeout(() => document.getElementById('loading').remove(), 500);
            }, 500);
            
            // Show keyboard hints briefly
            setTimeout(() => {
                if (window.innerWidth > 768) {
showKeyboardHints();
                }
            }, 2000);
            
            console.log('✨ MYND initialized successfully');
            
        } catch (error) {
            console.error('Initialization failed:', error);
            const loading = document.getElementById('loading');
            if (loading) {
                loading.innerHTML = `
                    <div class="loading-content">
                        <div class="loading-logo" style="background: #f87171;">!</div>
                        <div class="loading-text" style="color: #f87171;">Failed to load</div>
                        <p style="margin-top: 16px; color: var(--text-muted); font-size: 13px;">${error.message}</p>
                    </div>
                `;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // NEURAL NETWORK UI INTEGRATION
    // ═══════════════════════════════════════════════════════════════════
    
    const NeuralUI = {
        panel: null,
        isOpen: false,
        suggestionsForNodeId: null, // Track which node suggestions are for
        
        init() {
            this.panel = document.getElementById('neural-panel');
            this.bindEvents();
            this.initNeuralNetwork();
        },
        
        bindEvents() {
            // Toggle panel
            document.getElementById('btn-neural')?.addEventListener('click', () => {
                this.toggle();
            });
            
            // Close button
            document.getElementById('neural-close')?.addEventListener('click', () => {
                this.close();
            });
            
            // Train button (now in settings modal)
            document.getElementById('neural-train-settings-btn')?.addEventListener('click', () => {
                this.trainNetwork();
            });
            
            // Suggest connections button
            document.getElementById('neural-suggest-btn')?.addEventListener('click', () => {
                this.suggestConnections();
            });
            
            // Reset button (now in settings modal)
            document.getElementById('neural-reset-settings-btn')?.addEventListener('click', () => {
                this.resetNetwork();
            });
            
            // Smart suggest button
            document.getElementById('neural-smart-suggest-btn')?.addEventListener('click', () => {
                this.smartExpand();
            });
            
            // Close when clicking outside
            document.addEventListener('click', (e) => {
                if (this.isOpen && 
                    !this.panel.contains(e.target) && 
                    !e.target.closest('#btn-neural')) {
                    this.close();
                }
            });
        },
        
        async initNeuralNetwork() {
            // Initialize preference tracker, semantic memory, and user profile first (don't need TensorFlow)
            await preferenceTracker.init();
            await semanticMemory.init();
            await userProfile.init();
            await conceptAbstractor.init();
            await metaLearner.init();
            
            // DON'T initialize neural network here - defer until first AI feature use
            // This saves ~10MB download and several seconds on mobile
            console.log('✓ Preference systems ready (TensorFlow deferred)');
        },
        
        async ensureNeuralNetReady() {
            // Lazy initialize neural network when first needed
            if (neuralNet.isReady) return true;
            if (neuralNet.isInitializing) {
                // Wait for ongoing initialization
                return new Promise(resolve => {
                    const check = setInterval(() => {
                        if (neuralNet.isReady || neuralNet.loadError) {
                            clearInterval(check);
                            resolve(neuralNet.isReady);
                        }
                    }, 100);
                });
            }
            
            neuralNet.isInitializing = true;
            console.log('🧠 First AI feature used - loading TensorFlow...');
            
            const success = await neuralNet.initialize();
            neuralNet.isInitializing = false;
            
            if (success) {
                document.getElementById('neural-train-settings-btn').disabled = false;
                this.updateStatus();
                
                // Set up event listeners
                this.setupNeuralEventListeners();
            }
            
            return success;
        },
        
        setupNeuralEventListeners() {
            neuralNet.on('onTrainingStart', () => {
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = true;
                    trainBtn.innerHTML = `
                        <svg class="spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2"/>
                        </svg>
                        Training...
                    `;
                }
                document.getElementById('neural-progress').style.display = 'block';
            });
            
            neuralNet.on('onTrainingProgress', (data) => {
                document.getElementById('neural-progress-bar').style.width = `${data.progress}%`;
                document.getElementById('neural-status-text').textContent = 
                    `Training ${data.phase} (${Math.round(data.progress)}%)`;
                document.getElementById('neural-status-text').className = 'neural-status-value training';
            });
            
            neuralNet.on('onTrainingComplete', (data) => {
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = false;
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    `;
                }
                document.getElementById('neural-progress').style.display = 'none';
                document.getElementById('neural-suggest-btn').disabled = false;
                this.updateStatus();
                showToast('Neural network trained successfully!', 'success');
            });
            
            // Auto-train on first load if no model exists but enough nodes do
            const stats = neuralNet.getStats();
            if (!stats.hasCategoryModel && !stats.hasPredictionModel) {
                // Count nodes
                let nodeCount = 0;
                const countNodes = (node) => {
                    nodeCount++;
                    node.children?.forEach(countNodes);
                };
                countNodes(store.data);
                
                if (nodeCount >= CONFIG.NEURAL_NET.minTrainingNodes) {
                    console.log('🧠 Auto-training on first load...');
                    setTimeout(() => {
                        neuralNet.train(store);
                    }, 2000); // Delay to let UI settle
                }
            }
        },
        
        toggle() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        },
        
        open() {
            this.panel.classList.add('active');
            this.isOpen = true;
            document.getElementById('btn-neural').classList.add('active');
            this.updateStatus();
            
            // Check if we should clear suggestions
            const currentNodeId = selectedNode?.userData?.id;
            if (this.suggestionsForNodeId && this.suggestionsForNodeId !== currentNodeId) {
                // Different node selected or no node - clear suggestions
                this.clearSuggestions();
            }
        },
        
        close() {
            this.panel.classList.remove('active');
            this.isOpen = false;
            document.getElementById('btn-neural').classList.remove('active');
            
            // If no node is selected, clear suggestions for next open
            if (!selectedNode) {
                this.clearSuggestions();
            }
        },
        
        clearSuggestions() {
            this.suggestionsForNodeId = null;
            document.getElementById('neural-suggestions').style.display = 'none';
            document.getElementById('neural-suggestions-list').innerHTML = '';
            document.getElementById('neural-suggestions-for').textContent = '';
        },
        
        updateStatus() {
            const stats = neuralNet.getStats();
            
            // Update status text
            const statusText = document.getElementById('neural-status-text');
            if (stats.isTraining) {
                statusText.textContent = 'Training...';
                statusText.className = 'neural-status-value training';
            } else if (stats.isReady) {
                statusText.textContent = stats.hasPredictionModel ? 'Trained' : 'Ready';
                statusText.className = 'neural-status-value ready';
            } else {
                statusText.textContent = 'Not Ready';
                statusText.className = 'neural-status-value';
            }
            
            // Update counts
            document.getElementById('neural-category-count').textContent = stats.categories.length;
            document.getElementById('neural-pattern-count').textContent = stats.expansionPatterns;
            document.getElementById('neural-embedding-count').textContent = stats.cachedEmbeddings;
            
            // Update preference stats
            const prefStats = preferenceTracker.getStats();
            document.getElementById('pref-accepted-count').textContent = prefStats.totalAccepted;
            document.getElementById('pref-ignored-count').textContent = prefStats.totalIgnored;
            
            if (prefStats.overallAcceptanceRate !== null) {
                const rate = Math.round(prefStats.overallAcceptanceRate * 100);
                const rateEl = document.getElementById('pref-acceptance-rate');
                rateEl.textContent = `${rate}%`;
                rateEl.style.color = rate >= 50 ? '#22c55e' : rate >= 30 ? '#f59e0b' : '#ef4444';
            } else {
                document.getElementById('pref-acceptance-rate').textContent = '—';
            }
            
            // Show style preference if we have enough data
            const style = prefStats.stylePreferences;
            const styleRow = document.getElementById('pref-style-row');
            const styleEl = document.getElementById('pref-style');
            if (prefStats.totalAccepted + prefStats.totalIgnored >= 15) {
                styleRow.style.display = 'flex';
                let styleText = [];
                if (style.prefersActionLabels > 0.3) styleText.push('Action-oriented');
                if (style.prefersShortLabels > 0.3) styleText.push('Concise');
                if (style.prefersDescriptive > 0.3) styleText.push('Descriptive');
                if (style.prefersActionLabels < -0.3) styleText.push('Noun-based');
                styleEl.textContent = styleText.length > 0 ? styleText.join(', ') : 'Balanced';
            } else {
                styleRow.style.display = 'none';
            }
            
            // Update incremental learning stats
            document.getElementById('incr-pattern-weights').textContent = stats.patternWeights || 0;
            document.getElementById('incr-high-confidence').textContent = stats.highConfidencePatterns || 0;
            
            if (stats.avgPatternWeight > 0) {
                const avgEl = document.getElementById('incr-avg-weight');
                avgEl.textContent = `${Math.round(stats.avgPatternWeight * 100)}%`;
                avgEl.style.color = stats.avgPatternWeight >= 0.6 ? '#22c55e' : stats.avgPatternWeight >= 0.4 ? '#f59e0b' : 'var(--text-secondary)';
            } else {
                document.getElementById('incr-avg-weight').textContent = '—';
            }
            
            // Show pending embeddings if any
            const pendingRow = document.getElementById('incr-pending-row');
            if (stats.pendingEmbeddings > 0) {
                pendingRow.style.display = 'flex';
                document.getElementById('incr-pending').textContent = stats.pendingEmbeddings;
            } else {
                pendingRow.style.display = 'none';
            }
            
            // Update semantic memory stats
            const memStats = semanticMemory.getStats();
            document.getElementById('mem-total-count').textContent = memStats.totalMemories;
            document.getElementById('mem-important-count').textContent = memStats.importantMemories;
            
            if (memStats.avgImportance > 0) {
                const avgMemEl = document.getElementById('mem-avg-importance');
                avgMemEl.textContent = `${Math.round(memStats.avgImportance * 100)}%`;
                avgMemEl.style.color = memStats.avgImportance >= 0.6 ? '#22c55e' : memStats.avgImportance >= 0.4 ? '#f59e0b' : 'var(--text-secondary)';
            } else {
                document.getElementById('mem-avg-importance').textContent = '—';
            }
            
            // Update user profile stats
            const profileStats = userProfile.getStats();
            document.getElementById('profile-nodes-count').textContent = profileStats.totalNodes;
            
            // Preferred depth
            const depthLabels = { 1: 'Shallow', 2: 'Moderate', 3: 'Deep', 4: 'Very Deep' };
            document.getElementById('profile-depth').textContent = 
                profileStats.totalNodes >= 10 ? depthLabels[profileStats.preferredDepth] || 'Moderate' : '—';
            
            // Naming style
            const styleLabels = {
                'concise': 'Concise',
                'descriptive': 'Descriptive',
                'action-oriented': 'Action-oriented',
                'balanced': 'Balanced'
            };
            document.getElementById('profile-naming-style').textContent = 
                profileStats.totalLabels >= 10 ? styleLabels[profileStats.namingStyle] || 'Balanced' : '—';
            
            // Focus areas
            const focusRow = document.getElementById('profile-focus-row');
            if (profileStats.focusAreas && profileStats.focusAreas.length > 0) {
                focusRow.style.display = 'flex';
                document.getElementById('profile-focus').textContent = profileStats.focusAreas.slice(0, 2).join(', ');
            } else {
                focusRow.style.display = 'none';
            }
            
            // Peak hours
            const peakRow = document.getElementById('profile-peak-row');
            if (profileStats.peakHours && profileStats.peakHours.length > 0) {
                peakRow.style.display = 'flex';
                const peakStr = profileStats.peakHours.slice(0, 3).map(h => {
                    const hour12 = h % 12 || 12;
                    const ampm = h < 12 ? 'am' : 'pm';
                    return `${hour12}${ampm}`;
                }).join(', ');
                document.getElementById('profile-peak-hours').textContent = peakStr;
            } else {
                peakRow.style.display = 'none';
            }
            
            // Update relationship type stats
            const relStats = relationshipClassifier.getStats();
            document.getElementById('rel-classified-count').textContent = relStats.cachedClassifications;
            
            // Find dominant type
            const dominantRow = document.getElementById('rel-dominant-row');
            const typeDist = relStats.typeDistribution;
            const sortedTypes = Object.entries(typeDist).sort((a, b) => b[1] - a[1]);
            
            if (sortedTypes.length > 0 && sortedTypes[0][1] >= 3) {
                dominantRow.style.display = 'flex';
                const typeLabels = {
                    decomposition: 'Decomposition',
                    component: 'Components',
                    sequence: 'Sequence',
                    category: 'Categories',
                    example: 'Examples',
                    attribute: 'Attributes',
                    cause_effect: 'Cause/Effect',
                    comparison: 'Comparison',
                    temporal: 'Temporal',
                    action: 'Actions'
                };
                document.getElementById('rel-dominant-type').textContent = typeLabels[sortedTypes[0][0]] || sortedTypes[0][0];
            } else {
                dominantRow.style.display = 'none';
            }
            
            // Count transfer-ready patterns (high confidence, typed)
            const transferRow = document.getElementById('rel-transfer-row');
            let transferReady = 0;
            for (const [, weight] of neuralNet.patternWeights) {
                if (weight.relationshipType && weight.relationshipConfidence >= 0.5 && weight.weight >= 0.5) {
                    transferReady++;
                }
            }
            
            if (transferReady >= 3) {
                transferRow.style.display = 'flex';
                document.getElementById('rel-transfer-count').textContent = transferReady;
            } else {
                transferRow.style.display = 'none';
            }
            
            // Update concept abstraction stats
            const conceptStats = conceptAbstractor.getStats();
            document.getElementById('concept-schemas').textContent = conceptStats.schemas;
            document.getElementById('concept-clusters').textContent = conceptStats.clusters;
            
            // Show hierarchy patterns if any
            const hierarchyRow = document.getElementById('concept-hierarchy-row');
            if (conceptStats.hierarchyPatterns > 0) {
                hierarchyRow.style.display = 'flex';
                document.getElementById('concept-hierarchies').textContent = conceptStats.hierarchyPatterns;
            } else {
                hierarchyRow.style.display = 'none';
            }
            
            // Show transfers applied if any
            const transfersRow = document.getElementById('concept-transfers-row');
            if (conceptStats.transfersApplied > 0) {
                transfersRow.style.display = 'flex';
                document.getElementById('concept-transfers').textContent = conceptStats.transfersApplied;
            } else {
                transfersRow.style.display = 'none';
            }
            
            // Update meta-learner stats
            const metaStats = metaLearner.getStats();
            
            // Building style
            const buildingStyleEl = document.getElementById('meta-building-style');
            if (metaStats.sessionsAnalyzed >= 2 || metaStats.buildingScore !== 0.5) {
                buildingStyleEl.textContent = metaStats.buildingStyle;
                buildingStyleEl.style.color = metaStats.buildingStyle === 'Breadth-first' ? '#3b82f6' :
                    metaStats.buildingStyle === 'Depth-first' ? '#8b5cf6' : 'var(--text-primary)';
            }
            
            // Decision speed
            const decisionSpeedEl = document.getElementById('meta-decision-speed');
            if (metaStats.sessionsAnalyzed >= 1) {
                decisionSpeedEl.textContent = metaStats.quickDecider ? 'Quick' : 'Deliberate';
                decisionSpeedEl.style.color = metaStats.quickDecider ? '#22c55e' : '#f59e0b';
            }
            
            // Work rhythm (show after 2+ sessions)
            const rhythmRow = document.getElementById('meta-rhythm-row');
            if (metaStats.sessionsAnalyzed >= 2) {
                rhythmRow.style.display = 'flex';
                const rhythmEl = document.getElementById('meta-rhythm');
                const rhythmLabels = {
                    'accelerating': 'Builds Momentum',
                    'decelerating': 'Front-loaded',
                    'burst-rest': 'Burst Worker',
                    'steady': 'Steady Pace'
                };
                rhythmEl.textContent = rhythmLabels[metaStats.momentumPattern] || metaStats.momentumPattern;
            }
            
            // Selectivity (show after some suggestions)
            const selectivityRow = document.getElementById('meta-selectivity-row');
            if (metaStats.selectivityRate !== 0.5) {
                selectivityRow.style.display = 'flex';
                const selectivityEl = document.getElementById('meta-selectivity');
                if (metaStats.selectivityRate > 0.7) {
                    selectivityEl.textContent = 'Very Selective';
                    selectivityEl.style.color = '#8b5cf6';
                } else if (metaStats.selectivityRate > 0.4) {
                    selectivityEl.textContent = 'Balanced';
                    selectivityEl.style.color = 'var(--text-primary)';
                } else {
                    selectivityEl.textContent = 'Open-minded';
                    selectivityEl.style.color = '#22c55e';
                }
            }
            
            // Sessions analyzed
            const sessionsRow = document.getElementById('meta-sessions-row');
            if (metaStats.sessionsAnalyzed > 0) {
                sessionsRow.style.display = 'flex';
                document.getElementById('meta-sessions').textContent = metaStats.sessionsAnalyzed;
            }
            
            // Show strengths if available
            const insightsSection = document.getElementById('meta-insights-section');
            const strengthsEl = document.getElementById('meta-strengths');
            if (metaStats.insights && metaStats.insights.strengths && metaStats.insights.strengths.length > 0) {
                insightsSection.style.display = 'block';
                strengthsEl.innerHTML = metaStats.insights.strengths.map(s => 
                    `<span style="background: rgba(139, 92, 246, 0.2); color: #a78bfa; padding: 2px 8px; border-radius: 4px; font-size: 10px;">${s}</span>`
                ).join('');
            } else {
                insightsSection.style.display = 'none';
            }
            
            // Update categories list
            const categoriesSection = document.getElementById('neural-categories');
            const categoryList = document.getElementById('neural-category-list');
            
            if (stats.categories.length > 0) {
                categoriesSection.style.display = 'block';
                categoryList.innerHTML = stats.categories.map(cat => 
                    `<span class="neural-category-tag">${cat}</span>`
                ).join('');
            } else {
                categoriesSection.style.display = 'none';
            }
            
            // Enable/disable buttons based on model availability
            document.getElementById('neural-suggest-btn').disabled = !stats.hasCategoryModel;
            // Enable smart expand if neural net is ready (will fall back to AI if no prediction model)
            document.getElementById('neural-smart-suggest-btn').disabled = !neuralNet.isReady;
        },
        
        async trainNetwork() {
            if (neuralNet.isTraining) return;
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            showToast('Starting neural network training...', 'info');
            const success = await neuralNet.train(store);
            
            if (!success) {
                showToast('Need more nodes to train (minimum 5)', 'error');
                const trainBtn = document.getElementById('neural-train-settings-btn');
                if (trainBtn) {
                    trainBtn.disabled = false;
                    trainBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:6px;">
                            <path d="M12 2v4m0 12v4m-8-10H2m20 0h-2m-3.5-6.5L17 7m-10 0l-1.5-1.5M17 17l1.5 1.5M7 17l-1.5 1.5"/>
                        </svg>
                        Train on My Map
                    `;
                }
                document.getElementById('neural-progress').style.display = 'none';
            }
        },
        
        async suggestConnections() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            const nodeText = nodeData.description 
                ? `${nodeData.label}. ${nodeData.description}`
                : nodeData.label;
            
            showToast('Analyzing connections...', 'info');
            
            // Get suggestions from neural network
            const suggestions = await neuralNet.suggestConnections(nodeText, store);
            
            // Also get Claude enhancement if API key available
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            let claudeSuggestion = null;
            if (apiKey) {
                claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
            }
            
            this.displaySuggestions(suggestions, claudeSuggestion);
        },
        
        displaySuggestions(neuralSuggestions, claudeSuggestion) {
            const suggestionsSection = document.getElementById('neural-suggestions');
            const suggestionsList = document.getElementById('neural-suggestions-list');
            
            // Get current node info for tracking
            const nodeData = selectedNode ? store.findNode(selectedNode.userData.id) : null;
            
            if (neuralSuggestions.length === 0 && !claudeSuggestion) {
                suggestionsSection.style.display = 'none';
                showToast('No strong connections found', 'info');
                return;
            }
            
            suggestionsSection.style.display = 'block';
            
            // Track which node these suggestions are for
            if (nodeData) {
                this.suggestionsForNodeId = nodeData.id;
                document.getElementById('neural-suggestions-for').textContent = `for "${nodeData.label}"`;
            }
            
            let html = '';
            
            // Neural network suggestions - these navigate to related nodes
            if (neuralSuggestions.length > 0) {
                html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">Related nodes in your map:</div>`;
                neuralSuggestions.forEach(s => {
                    html += `
                        <div class="neural-suggestion" data-node-id="${s.nodeId}">
                            <span class="neural-suggestion-text">${s.label}</span>
                            <span class="neural-suggestion-score">${Math.round(s.isRelated * 100)}%</span>
                        </div>
                    `;
                });
            }
            
            // Claude suggestion - this can move the node
            if (claudeSuggestion) {
                const suggestedParent = claudeSuggestion.suggestedParent || claudeSuggestion.category;
                html += `
                    <div style="font-size: 11px; color: var(--text-tertiary); margin: ${neuralSuggestions.length > 0 ? '12px' : '0'} 0 8px 0;">AI reorganization suggestion:</div>
                    <div class="neural-suggestion claude-suggestion" data-suggested-parent="${suggestedParent}" style="border-left: 3px solid var(--accent); cursor: pointer;">
                        <div>
                            <div class="neural-suggestion-text" style="font-weight: 600;">
                                Move to "${suggestedParent}"
                            </div>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 4px;">
                                ${claudeSuggestion.reasoning || 'Click to reorganize'}
                            </div>
                        </div>
                        <span class="neural-suggestion-score">${Math.round((claudeSuggestion.confidence || 0.8) * 100)}%</span>
                    </div>
                `;
                
                // Show related concepts
                if (claudeSuggestion.relatedConcepts?.length > 0) {
                    html += `
                        <div style="margin-top: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 4px;">Related concepts to add:</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${claudeSuggestion.relatedConcepts.join(', ')}
                            </div>
                        </div>
                    `;
                }
            }
            
            suggestionsList.innerHTML = html;
            
            // Scroll panel to show suggestions
            setTimeout(() => {
                suggestionsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
            
            // Add click handlers to navigate to related nodes
            suggestionsList.querySelectorAll('.neural-suggestion[data-node-id]').forEach(el => {
                el.addEventListener('click', () => {
                    const nodeId = el.dataset.nodeId;
                    const mesh = nodes.get(nodeId);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                        this.close();
                    }
                });
            });
            
            // Add click handler for Claude's reorganization suggestion
            const claudeSuggestionEl = suggestionsList.querySelector('.claude-suggestion[data-suggested-parent]');
            if (claudeSuggestionEl && selectedNode) {
                claudeSuggestionEl.addEventListener('click', () => {
                    const suggestedParent = claudeSuggestionEl.dataset.suggestedParent;
                    const nodeToMove = selectedNode.userData.id;
                    const nodeData = store.findNode(nodeToMove);
                    
                    if (!nodeData || nodeToMove === 'mynd') {
                        showToast("Can't move root node", 'error');
                        return;
                    }
                    
                    // Find the suggested parent node
                    const findNodeByLabel = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNodeByLabel(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const newParent = findNodeByLabel(store.data, suggestedParent);
                    
                    if (!newParent) {
                        showToast(`Couldn't find "${suggestedParent}"`, 'error');
                        return;
                    }
                    
                    if (newParent.id === nodeToMove) {
                        showToast("Can't move node into itself", 'error');
                        return;
                    }
                    
                    // Confirm the move
                    if (confirm(`Move "${nodeData.label}" under "${newParent.label}"?`)) {
                        // Use store.moveNode
                        if (store.moveNode(nodeToMove, newParent.id)) {
                            // Update color to match new parent
                            nodeData.color = newParent.color;
                            store.save();
                            buildScene();
                            
                            // Focus on the moved node in its new location
                            setTimeout(() => {
                                const movedMesh = nodes.get(nodeToMove);
                                if (movedMesh) {
                                    selectNode(movedMesh);
                                    focusOnNode(movedMesh);
                                }
                            }, 100);
                            
                            this.close();
                            showToast(`Moved to "${newParent.label}"`, 'success');
                        } else {
                            showToast('Failed to move node', 'error');
                        }
                    }
                });
            }
        },
        
        async resetNetwork() {
            if (confirm('Reset neural network? This will clear all learned patterns.')) {
                await neuralNet.reset();
                
                // Ask about preference history separately
                if (confirm('Also reset preference learning history?')) {
                    await preferenceTracker.reset();
                }
                
                // Ask about semantic memories separately
                if (confirm('Also reset semantic memories?')) {
                    await semanticMemory.reset();
                }
                
                // Ask about user profile separately
                if (confirm('Also reset user profile (depth, naming, time patterns)?')) {
                    await userProfile.reset();
                }
                
                // Ask about concept abstractions separately
                if (confirm('Also reset concept abstractions (schemas, clusters)?')) {
                    await conceptAbstractor.reset();
                }
                
                // Ask about meta-learner separately
                if (confirm('Also reset thinking patterns (building style, decisions, rhythm)?')) {
                    await metaLearner.reset();
                }
                
                this.updateStatus();
                document.getElementById('neural-suggestions').style.display = 'none';
                document.getElementById('neural-suggest-btn').disabled = true;
                document.getElementById('neural-smart-suggest-btn').disabled = true;
                showToast('Neural network reset', 'info');
            }
        },
        
        async smartExpand() {
            if (!selectedNode) {
                showToast('Select a node first', 'info');
                return;
            }
            
            const nodeData = store.findNode(selectedNode.userData.id);
            if (!nodeData) return;
            
            // Ensure TensorFlow is loaded
            const ready = await this.ensureNeuralNetReady();
            if (!ready) {
                showToast('Failed to load AI engine', 'error');
                return;
            }
            
            showToast('Generating smart suggestions...', 'info');
            
            try {
                // Get AI-enhanced suggestions
                const result = await neuralNet.generateSmartSuggestions(nodeData, store);
                
                if (!result) {
                    showToast('Failed to generate suggestions', 'error');
                    return;
                }
                
                // Display suggestions in the panel
                const suggestionsSection = document.getElementById('neural-suggestions');
                const suggestionsList = document.getElementById('neural-suggestions-list');
                
                let html = '';
                
                // Show ML-based suggestions first
                if (result.mlSuggestions && result.mlSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin-bottom: 8px;">From learned patterns:</div>`;
                    result.mlSuggestions.forEach(s => {
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ml">
                                <span class="neural-suggestion-text">${s.label}</span>
                                <span class="neural-suggestion-score">${Math.round(s.confidence * 100)}%</span>
                            </div>
                        `;
                    });
                }
                
                // Show AI suggestions
                if (result.aiSuggestions && result.aiSuggestions.length > 0) {
                    html += `<div style="font-size: 11px; color: var(--text-tertiary); margin: 12px 0 8px 0;">AI recommendations:</div>`;
                    result.aiSuggestions.forEach(s => {
                        // Escape the reasoning for use in data attribute
                        const escapedReasoning = (s.reasoning || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        html += `
                            <div class="neural-suggestion" data-label="${s.label}" data-type="ai" data-description="${escapedReasoning}" style="border-left: 3px solid var(--accent);">
                                <div>
                                    <span class="neural-suggestion-text">${s.label}</span>
                                    ${s.reasoning ? `<div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${s.reasoning}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });
                }
                
                // Add "Add All" button if we have suggestions
                if (result.mlSuggestions?.length > 0 || result.aiSuggestions?.length > 0) {
                    html += `
                        <button class="neural-btn primary" id="neural-add-all-btn" style="margin-top: 12px;">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Add All Suggestions
                        </button>
                    `;
                }
                
                suggestionsList.innerHTML = html;
                suggestionsSection.style.display = 'block';
                
                // Track which node these suggestions are for
                this.suggestionsForNodeId = nodeData.id;
                
                // Show which node the suggestions are for
                document.getElementById('neural-suggestions-for').textContent = `for "${nodeData.label}"`;
                
                // Scroll panel to show suggestions
                setTimeout(() => {
                    suggestionsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
                
                // Store parentId on container for click handlers to use
                const currentParentId = selectedNode.userData.id;
                suggestionsList.dataset.parentId = currentParentId;
                
                // Start preference tracking session
                const allSuggestions = [
                    ...(result.mlSuggestions || []).map(s => ({ label: s.label, type: 'ml', confidence: s.confidence })),
                    ...(result.aiSuggestions || []).map(s => ({ label: s.label, type: 'ai' }))
                ];
                if (allSuggestions.length > 0) {
                    preferenceTracker.startSession(currentParentId, nodeData.label, allSuggestions);
                    metaLearner.trackSuggestionsShown(allSuggestions, nodeData);
                }
                
                // Add click handlers for individual suggestions
                suggestionsList.querySelectorAll('.neural-suggestion[data-label]').forEach(el => {
                    el.addEventListener('click', () => {
                        if (el.classList.contains('added')) return; // Already added
                        
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        const suggestionType = el.dataset.type; // 'ml' or 'ai'
                        const parentId = suggestionsList.dataset.parentId; // Get from container, not selectedNode
                        const parentNode = store.findNode(parentId);
                        
                        store.addNode(parentId, { 
                            label, 
                            description,
                            color: parentNode?.color,
                            source: 'smart-expand'
                        });
                        
                        // Track preference and boost pattern weight
                        preferenceTracker.recordAccept(label, suggestionType);
                        metaLearner.trackSuggestionAccepted(label, false); // false = not Add All
                        if (parentNode) {
                            neuralNet.boostPattern(parentNode.label, label, suggestionType);
                            
                            // Store semantic memory
                            semanticMemory.addMemory(
                                'suggestion_accepted',
                                `User accepted ${suggestionType} suggestion "${label}" under "${parentNode.label}"`,
                                { parentLabel: parentNode.label, childLabel: label, suggestionType }
                            );
                        }
                        
                        buildScene();
                        
                        // Re-select the parent node to keep panel active
                        const newParentMesh = nodes.get(parentId);
                        if (newParentMesh) {
                            // Update selectedNode reference without triggering full selection animation
                            selectedNode = newParentMesh;
                            
                            // Expand the parent node if collapsed
                            if (!newParentMesh.userData.isExpanded) {
                                expandNode(newParentMesh);
                            }
                        }
                        
                        // Mark as added instead of removing
                        el.classList.add('added');
                        el.style.opacity = '0.5';
                        el.style.pointerEvents = 'none';
                        
                        // Add checkmark
                        const score = el.querySelector('.neural-suggestion-score');
                        if (score) {
                            score.textContent = '✓';
                            score.style.background = '#22c55e';
                            score.style.color = 'white';
                        } else {
                            // For AI suggestions without score element, add a checkmark
                            const textEl = el.querySelector('.neural-suggestion-text');
                            if (textEl && !textEl.textContent.includes('✓')) {
                                textEl.textContent = '✓ ' + textEl.textContent;
                            }
                        }
                        
                        // Update "Add All" button to show remaining count
                        const remaining = suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').length;
                        const addAllBtn = document.getElementById('neural-add-all-btn');
                        if (addAllBtn) {
                            if (remaining === 0) {
                                addAllBtn.style.display = 'none';
                            } else {
                                addAllBtn.innerHTML = `
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px">
                                        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                                    </svg>
                                    Add Remaining (${remaining})
                                `;
                            }
                        }
                        
                        showToast(`Added "${label}"`, 'success');
                        audio.add();
                    });
                });
                
                // Add click handler for "Add All" button
                document.getElementById('neural-add-all-btn')?.addEventListener('click', () => {
                    const parentId = suggestionsList.dataset.parentId; // Get from container
                    const parentNode = store.findNode(parentId);
                    let added = 0;
                    
                    // Only add suggestions that haven't been added yet
                    suggestionsList.querySelectorAll('.neural-suggestion:not(.added)').forEach(el => {
                        const label = el.dataset.label;
                        const description = el.dataset.description || '';
                        const suggestionType = el.dataset.type || 'ai';
                        if (label) {
                            store.addNode(parentId, { 
                                label, 
                                description,
                                color: parentNode?.color,
                                source: 'smart-expand'
                            });
                            added++;
                            
                            // Track preference and boost pattern weight
                            preferenceTracker.recordAccept(label, suggestionType);
                            metaLearner.trackSuggestionAccepted(label, true); // true = Add All
                            if (parentNode) {
                                neuralNet.boostPattern(parentNode.label, label, suggestionType);
                                
                                // Store semantic memory
                                semanticMemory.addMemory(
                                    'suggestion_accepted',
                                    `User accepted ${suggestionType} suggestion "${label}" under "${parentNode.label}"`,
                                    { parentLabel: parentNode.label, childLabel: label, suggestionType }
                                );
                            }
                            
                            // Mark as added
                            el.classList.add('added');
                            el.style.opacity = '0.5';
                            el.style.pointerEvents = 'none';
                            const score = el.querySelector('.neural-suggestion-score');
                            if (score) {
                                score.textContent = '✓';
                                score.style.background = '#22c55e';
                                score.style.color = 'white';
                            }
                        }
                    });
                    
                    if (added === 0) {
                        showToast('All suggestions already added', 'info');
                        return;
                    }
                    
                    buildScene();
                    
                    // Expand the parent
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                    
                    // Hide the button
                    document.getElementById('neural-add-all-btn').style.display = 'none';
                    showToast(`Added ${added} nodes`, 'success');
                    audio.success();
                    
                    // Close the panel to reveal new nodes
                    setTimeout(() => {
                        NeuralPanel.close();
                    }, 300);
                });
                
            } catch (error) {
                console.error('Smart expand error:', error);
                showToast('Failed to generate suggestions', 'error');
            }
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // CLAUDE API HELPER - Uses Edge Function when authenticated
    // ═══════════════════════════════════════════════════════════════════
    
    async function callClaudeAPI(requestBody) {
        // Check if user is authenticated with Supabase
        let session = null;
        if (typeof supabase !== 'undefined') {
            const { data } = await supabase.auth.getSession();
            session = data?.session;
        }
        
        if (session?.access_token) {
            // Use Edge Function (secure, no API key exposed)
            try {
                const response = await fetch(CONFIG.EDGE_FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Edge function request failed');
                }
                
                const data = await response.json();
                return { success: true, suggestions: data.suggestions };
            } catch (error) {
                console.error('Edge function error:', error);
                // Fall back to direct API if edge function fails
                console.log('Falling back to direct API call...');
            }
        }
        
        // Fall back to direct API call (requires local API key)
        const apiKey = localStorage.getItem(CONFIG.API_KEY);
        if (!apiKey) {
            const key = prompt('Enter your Anthropic API key for AI features:\n\n(Sign in with Google to use AI features without an API key)');
            if (key) {
                localStorage.setItem(CONFIG.API_KEY, key);
            } else {
                throw new Error('API key required for AI features');
            }
        }
        
        // Build prompt based on request type
        let aiPrompt, maxTokens;
        
        if (requestBody.type === 'brainstorm') {
            maxTokens = 600;
            aiPrompt = `You are the AI core of MYND, helping a user expand their mental landscape. MYND visually represents a user's internal world—thoughts, goals, desires, and memories—as an explorable 3D mind map.

Your role is to be an insightful, nonjudgmental guide who helps users discover connections and possibilities they might not see on their own.

CONTEXT:
- Current node: "${requestBody.nodeLabel}"${requestBody.nodeDescription ? `\n- Description: "${requestBody.nodeDescription}"` : ''}
- Path to root: ${requestBody.pathContext}
- Existing children: ${requestBody.existingChildren || 'none yet'}${requestBody.neuralContext || ''}

Generate 3-4 thoughtful child nodes that would meaningfully expand this area of their mind map. Consider:
- What natural next steps or subcategories would help organize their thinking?
- What aspects might they not have considered yet?
- What would help them achieve clarity or take action?

Return ONLY a JSON array of objects with "label" and "description" properties. Make labels concise but meaningful. Descriptions should be 1-2 sentences explaining the purpose or context of that node.
Example: [{"label": "Daily Habits", "description": "Small, repeatable actions that compound over time into significant results."}, {"label": "Weekly Reviews", "description": "Regular reflection sessions to assess progress and adjust course."}]`;
        } else if (requestBody.type === 'smart-expand') {
            maxTokens = 800;
            aiPrompt = `You are the AI core of MYND, a 3D mind mapping tool that learns from user behavior. You're helping expand a node with intelligent suggestions.

CONTEXT:
- Current node: "${requestBody.nodeLabel}"${requestBody.nodeDescription ? `\n- Description: "${requestBody.nodeDescription}"` : ''}
- Path to root: ${requestBody.pathContext}
- Existing children: ${requestBody.existingChildren || 'none yet'}
${requestBody.userProfile ? `\nUSER PROFILE:\n${JSON.stringify(requestBody.userProfile, null, 2)}` : ''}
${requestBody.semanticContext ? `\nSEMANTIC CONTEXT:\n${requestBody.semanticContext}` : ''}

Generate 3-5 suggestions for child nodes. For each suggestion, consider:
1. The user's demonstrated patterns and preferences
2. Natural subcategories or next steps
3. Connections to other areas of their mind map
4. Actionable items that would help them progress

Return ONLY a JSON array of objects with "label", "description", and "reasoning" properties.
- label: Concise node name (2-5 words)
- description: 1-2 sentence explanation of the node's purpose
- reasoning: Brief explanation of why this suggestion fits the user's patterns

Example: [{"label": "Morning Routine", "description": "A sequence of activities to start each day with intention and energy.", "reasoning": "User has shown interest in habits and productivity optimization."}]`;
        } else if (requestBody.type === 'organize') {
            maxTokens = 800;
            aiPrompt = `You are organizing a mind map. The parent node is "${requestBody.nodeLabel}".

Here are the child nodes that need organizing:
${requestBody.childrenList}

Group these into 2-4 logical categories. Each category should have at least 2 items.

Respond with JSON only:
{
  "categories": [
    {
      "name": "Category Name",
      "description": "Brief description of this category",
      "items": ["Life Hacks", "Mental Models"]
    }
  ]
}

IMPORTANT: In the "items" array, use ONLY the exact node label (the part before the colon). Do not include descriptions.`;
        } else {
            throw new Error('Invalid request type');
        }
        
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': localStorage.getItem(CONFIG.API_KEY),
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
                model: 'claude-sonnet-4-20250514',
                max_tokens: maxTokens,
                messages: [{ role: 'user', content: aiPrompt }]
            })
        });
        
        if (!response.ok) {
            throw new Error('API request failed');
        }
        
        const data = await response.json();
        const text = data.content[0].text;
        
        // Parse JSON response
        let suggestions;
        try {
            suggestions = JSON.parse(text);
        } catch (e) {
            const jsonMatch = text.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                suggestions = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('Failed to parse response');
            }
        }
        
        return { success: true, suggestions };
    }

    // ═══════════════════════════════════════════════════════════════════
    // ENHANCED BRAINSTORM WITH NEURAL NETWORK
    // ═══════════════════════════════════════════════════════════════════
    
    async function brainstormNodeEnhanced(nodeId) {
        const node = store.findNode(nodeId);
        if (!node) return;
        
        showToast('Brainstorming ideas...', 'info');
        
        try {
            // Get context
            const path = store.getPath(nodeId);
            const context = path.map(n => n.label).join(' → ');
            const siblings = node.children?.map(c => c.label).join(', ') || 'none';
            const description = node.description?.trim() || '';
            
            // Get neural network predictions if available
            let neuralContext = '';
            if (neuralNet.isReady && neuralNet.categories.length > 0) {
                const nodeText = description ? `${node.label}. ${description}` : node.label;
                const predictions = await neuralNet.predictCategory(nodeText);
                
                if (predictions && predictions.length > 0) {
                    const topPredictions = predictions.slice(0, 3)
                        .filter(p => p.probability > 0.1)
                        .map(p => `${p.category} (${Math.round(p.probability * 100)}%)`);
                    
                    if (topPredictions.length > 0) {
                        neuralContext = `\n\nNEURAL NETWORK ANALYSIS:
The user's personalized neural network suggests this content relates to: ${topPredictions.join(', ')}
Consider these learned patterns when generating suggestions.`;
                    }
                }
            }
            
            // Use the unified Claude API helper
            const result = await callClaudeAPI({
                type: 'brainstorm',
                nodeLabel: node.label,
                nodeDescription: description,
                pathContext: context,
                existingChildren: siblings,
                neuralContext: neuralContext
            });
            
            if (!result.success || !result.suggestions) {
                throw new Error('No suggestions returned');
            }
            
            const ideas = result.suggestions;
            
            if (Array.isArray(ideas)) {
                ideas.forEach(idea => {
                    // Handle both old format (string) and new format (object with label/description)
                    const label = typeof idea === 'string' ? idea : idea.label;
                    const desc = typeof idea === 'string' ? '' : (idea.description || '');
                    store.addNode(nodeId, { 
                        label, 
                        description: desc,
                        color: node.color, 
                        source: 'brainstorm' 
                    });
                });
                
                buildScene();
                
                // Focus on the parent node
                const parentMesh = nodes.get(nodeId);
                if (parentMesh) {
                    selectNode(parentMesh);
                    
                    // Expand if collapsed
                    if (!parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
                
                showToast(`Added ${ideas.length} ideas`, 'success');
                audio.ai();
                
                // Update embeddings for new nodes in background
                if (neuralNet.isReady) {
                    ideas.forEach(async (idea) => {
                        const label = typeof idea === 'string' ? idea : idea.label;
                        const desc = typeof idea === 'string' ? '' : (idea.description || '');
                        const nodeText = desc ? `${label}. ${desc}` : label;
                        await neuralNet.getEmbedding(nodeText);
                    });
                    neuralNet.saveEmbeddings();
                }
            }
            
        } catch (error) {
            console.error('Brainstorm error:', error);
            showToast(error.message || 'Failed to generate ideas', 'error');
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SMART NODE PLACEMENT - Uses neural network for intelligent categorization
    // ═══════════════════════════════════════════════════════════════════
    
    async function smartAddNode(label, description = '') {
        if (!neuralNet.isReady || neuralNet.categories.length === 0) {
            // Fall back to adding under root or selected node
            const parentId = selectedNode?.userData.id || 'mynd';
            const parentNode = store.findNode(parentId);
            const newNode = store.addNode(parentId, { 
                label, 
                description,
                color: parentNode?.color 
            });
            buildScene();
            return newNode;
        }
        
        const nodeText = description ? `${label}. ${description}` : label;
        
        // Get predictions
        const predictions = await neuralNet.predictCategory(nodeText);
        
        if (predictions && predictions.length > 0 && predictions[0].probability > 0.5) {
            // High confidence - place under predicted category
            const categoryLabel = predictions[0].category;
            
            // Find the category node
            const categoryNode = store.data.children?.find(c => c.label === categoryLabel);
            
            if (categoryNode) {
                // Get Claude suggestion for specific parent within category
                const claudeSuggestion = await neuralNet.enhanceWithClaude(nodeText, store);
                
                let parentId = categoryNode.id;
                
                // Try to find more specific parent if Claude suggests one
                if (claudeSuggestion?.suggestedParent) {
                    const findNode = (node, label) => {
                        if (node.label.toLowerCase() === label.toLowerCase()) return node;
                        for (const child of (node.children || [])) {
                            const found = findNode(child, label);
                            if (found) return found;
                        }
                        return null;
                    };
                    
                    const specificParent = findNode(categoryNode, claudeSuggestion.suggestedParent);
                    if (specificParent) {
                        parentId = specificParent.id;
                    }
                }
                
                const parentNode = store.findNode(parentId);
                const newNode = store.addNode(parentId, { 
                    label, 
                    description,
                    color: parentNode?.color 
                });
                
                buildScene();
                
                // Focus on the new node
                setTimeout(() => {
                    const mesh = nodes.get(newNode.id);
                    if (mesh) {
                        selectNode(mesh);
                        focusOnNode(mesh);
                    }
                }, 100);
                
                showToast(`Added to ${categoryLabel}`, 'success');
                return newNode;
            }
        }
        
        // Low confidence or no prediction - ask user or add to root
        const parentId = selectedNode?.userData.id || 'mynd';
        const parentNode = store.findNode(parentId);
        const newNode = store.addNode(parentId, { 
            label, 
            description,
            color: parentNode?.color 
        });
        
        buildScene();
        return newNode;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // AUTO-TRAIN ON SIGNIFICANT CHANGES
    // ═══════════════════════════════════════════════════════════════════
    
    let nodeCountAtLastTrain = 0;
    const AUTO_TRAIN_THRESHOLD = 10; // Train when 10 new nodes added
    
    bus.on('data:saved', () => {
        if (!neuralNet.isReady || neuralNet.isTraining) return;
        
        // Count total nodes
        let nodeCount = 0;
        const countNodes = (node) => {
            nodeCount++;
            node.children?.forEach(countNodes);
        };
        countNodes(store.data);
        
        // Auto-train if significant new nodes
        if (nodeCount - nodeCountAtLastTrain >= AUTO_TRAIN_THRESHOLD) {
            console.log('🧠 Auto-training neural network (new nodes detected)');
            neuralNet.train(store).then(() => {
                nodeCountAtLastTrain = nodeCount;
            });
        }
    });

    // Start the app
    init();
    
    // ═══════════════════════════════════════════════════════════════════
    // LINK MANAGER - Add links from URLs
    // ═══════════════════════════════════════════════════════════════════
    const LinkManager = {
        modal: null,
        currentLink: null,
        selectedCategory: null,
        pasteToast: null,
        
        init() {
            this.modal = document.getElementById('link-modal');
            this.createPasteToast();
            this.bindEvents();
        },
        
        createPasteToast() {
            // Create a special toast for link paste detection
            const toast = document.createElement('div');
            toast.id = 'link-paste-toast';
            toast.innerHTML = `
                <div class="link-paste-content">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;flex-shrink:0;">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                    </svg>
                    <span class="link-paste-text">Link detected</span>
                    <button class="link-paste-add">Add to Map</button>
                    <button class="link-paste-dismiss">✕</button>
                </div>
            `;
            document.body.appendChild(toast);
            this.pasteToast = toast;
            
            // Add styles
            const style = document.createElement('style');
            style.textContent = `
                #link-paste-toast {
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%) translateY(100px);
                    background: var(--bg-primary);
                    border-radius: 12px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                    border: 1px solid var(--bg-tertiary);
                    z-index: 10001;
                    opacity: 0;
                    pointer-events: none;
                    transition: all 0.3s ease;
                }
                
                #link-paste-toast.visible {
                    transform: translateX(-50%) translateY(0);
                    opacity: 1;
                    pointer-events: auto;
                }
                
                .link-paste-content {
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 12px 16px;
                    color: var(--text-primary);
                }
                
                .link-paste-text {
                    font-size: 14px;
                    font-weight: 500;
                    max-width: 200px;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                
                .link-paste-add {
                    background: var(--accent);
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 8px;
                    font-size: 13px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                
                .link-paste-add:hover {
                    filter: brightness(1.1);
                }
                
                .link-paste-dismiss {
                    background: none;
                    border: none;
                    color: var(--text-tertiary);
                    font-size: 16px;
                    cursor: pointer;
                    padding: 4px;
                    line-height: 1;
                }
                
                .link-paste-dismiss:hover {
                    color: var(--text-primary);
                }
                
                @media (max-width: 768px) {
                    #link-paste-toast {
                        bottom: 140px;
                        left: 16px;
                        right: 16px;
                        transform: translateX(0) translateY(100px);
                    }
                    
                    #link-paste-toast.visible {
                        transform: translateX(0) translateY(0);
                    }
                }
            `;
            document.head.appendChild(style);
        },
        
        bindEvents() {
            // Open modal
            document.getElementById('quick-link')?.addEventListener('click', () => {
                this.open();
            });
            
            // Close modal
            document.getElementById('link-modal-close')?.addEventListener('click', () => {
                this.close();
            });
            
            document.getElementById('link-cancel')?.addEventListener('click', () => {
                this.close();
            });
            
            // Close on overlay click
            this.modal?.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.close();
                }
            });
            
            // Close on Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.modal?.classList.contains('active')) {
                    this.close();
                }
            });
            
            // Fetch button
            document.getElementById('link-fetch')?.addEventListener('click', () => {
                this.fetchLink();
            });
            
            // Enter in URL input
            document.getElementById('link-url')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    this.fetchLink();
                }
            });
            
            // Auto-detect URL paste in modal
            document.getElementById('link-url')?.addEventListener('paste', (e) => {
                setTimeout(() => this.fetchLink(), 100);
            });
            
            // Add to map
            document.getElementById('link-add')?.addEventListener('click', () => {
                this.addToMap();
            });
            
            // SMART PASTE DETECTION - Global paste listener
            document.addEventListener('paste', (e) => {
                this.handleGlobalPaste(e);
            });
            
            // Paste toast buttons
            this.pasteToast?.querySelector('.link-paste-add')?.addEventListener('click', () => {
                this.addPastedLink();
            });
            
            this.pasteToast?.querySelector('.link-paste-dismiss')?.addEventListener('click', () => {
                this.hidePasteToast();
            });
        },
        
        // Check if text is a valid URL
        isURL(text) {
            if (!text || typeof text !== 'string') return false;
            text = text.trim();
            
            // Quick pattern check
            if (!text.match(/^https?:\/\//i) && !text.match(/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}/i)) {
                return false;
            }
            
            // Add protocol if missing
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            
            try {
                new URL(text);
                return true;
            } catch {
                return false;
            }
        },
        
        // Normalize URL (add protocol if missing)
        normalizeURL(text) {
            text = text.trim();
            if (!text.match(/^https?:\/\//i)) {
                text = 'https://' + text;
            }
            return text;
        },
        
        // Handle paste anywhere in the document
        handleGlobalPaste(e) {
            // Ignore if we're in an input field (let normal paste work)
            const activeEl = document.activeElement;
            const isInput = activeEl && (
                activeEl.tagName === 'INPUT' || 
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.isContentEditable
            );
            
            // Allow paste in link-url input (handled separately)
            if (activeEl?.id === 'link-url') return;
            
            // If in another input, only intercept if it's clearly a URL being pasted into quick-input
            if (isInput && activeEl?.id !== 'quick-input') return;
            
            // Get clipboard text
            const text = e.clipboardData?.getData('text')?.trim();
            if (!text || !this.isURL(text)) return;
            
            // Don't show if modal is already open
            if (this.modal?.classList.contains('active')) return;
            
            // If pasting into quick-input, intercept it
            if (activeEl?.id === 'quick-input') {
                e.preventDefault();
            }
            
            // Store the URL and show toast
            this.pendingURL = this.normalizeURL(text);
            this.showPasteToast(this.pendingURL);
        },
        
        showPasteToast(url) {
            // Get domain for display
            let domain = 'Link detected';
            try {
                domain = new URL(url).hostname.replace('www.', '');
            } catch {}
            
            // Show where link will be added
            const textEl = this.pasteToast.querySelector('.link-paste-text');
            if (selectedNode) {
                const nodeData = store.findNode(selectedNode.userData.id);
                const nodeName = nodeData?.label || 'node';
                textEl.textContent = `${domain} → "${nodeName}"`;
            } else {
                textEl.textContent = domain;
            }
            
            this.pasteToast.classList.add('visible');
            
            // Auto-hide after 5 seconds
            clearTimeout(this.pasteToastTimeout);
            this.pasteToastTimeout = setTimeout(() => {
                this.hidePasteToast();
            }, 5000);
        },
        
        hidePasteToast() {
            this.pasteToast.classList.remove('visible');
            clearTimeout(this.pasteToastTimeout);
        },
        
        addPastedLink() {
            if (!this.pendingURL) return;
            
            this.hidePasteToast();
            
            // If a node is selected, add directly as a child
            if (selectedNode) {
                this.addLinkAsChild(this.pendingURL, selectedNode.userData.id);
            } else {
                // No node selected - open modal for categorization
                this.openWithURL(this.pendingURL);
            }
            
            this.pendingURL = null;
        },
        
        // Quick add link as child of a node
        async addLinkAsChild(url, parentId) {
            const parentNode = store.findNode(parentId);
            if (!parentNode) {
                showToast('Parent node not found', 'error');
                return;
            }
            
            // Get domain for initial display
            let domain = 'Link';
            try {
                domain = new URL(url).hostname.replace('www.', '');
            } catch {}
            
            // Create node immediately with domain as placeholder
            const linkData = {
                url: url,
                domain: domain,
                type: 'link',
                addedAt: new Date().toISOString()
            };
            
            const newNode = store.addNode(parentId, {
                label: domain,
                description: url,
                color: parentNode.color,
                link: linkData
            });
            
            buildScene();
            
            // Expand parent to show new node
            const parentMesh = nodes.get(parentId);
            if (parentMesh && !parentMesh.userData.isExpanded) {
                expandNode(parentMesh);
            }
            
            // Focus on new node
            setTimeout(() => {
                const newMesh = nodes.get(newNode.id);
                if (newMesh) {
                    selectNode(newMesh);
                    focusOnNode(newMesh);
                }
            }, 100);
            
            showToast(`Added link from ${domain}`, 'success');
            audio.add();
            
            // Fetch metadata in background and update the node
            this.fetchAndUpdateNode(url, newNode.id);
        },
        
        // Fetch metadata and update an existing node
        async fetchAndUpdateNode(url, nodeId) {
            try {
                const metadata = await this.extractMetadata(url);
                
                if (metadata.title) {
                    const node = store.findNode(nodeId);
                    if (node) {
                        // Update node with fetched metadata
                        node.label = metadata.title;
                        if (metadata.description && !node.description.startsWith('http')) {
                            node.description = metadata.description;
                        }
                        
                        // Update link data
                        if (node.link) {
                            node.link.type = metadata.type || 'link';
                            node.link.favicon = metadata.favicon;
                            node.link.image = metadata.image;
                            node.link.author = metadata.author;
                        }
                        
                        store.save();
                        
                        // Update the node mesh label
                        const mesh = nodes.get(nodeId);
                        if (mesh) {
                            // Update label
                            const oldLabel = mesh.children.find(c => c.userData?.isLabel);
                            if (oldLabel) {
                                mesh.remove(oldLabel);
                                oldLabel.geometry?.dispose();
                                oldLabel.material?.dispose();
                            }
                            const newLabel = createTextSprite(metadata.title, mesh.userData.depth || 0);
                            newLabel.position.set(0, CONFIG.VISUAL.labelOffsetY, 0);
                            newLabel.userData.isLabel = true;
                            mesh.add(newLabel);
                        }
                        
                        // Update info panel if this node is selected
                        if (selectedNode && selectedNode.userData.id === nodeId) {
                            document.getElementById('info-title').value = metadata.title;
                            if (metadata.description) {
                                document.getElementById('info-desc').value = metadata.description;
                            }
                        }
                        
                        console.log(`✓ Updated node "${nodeId}" with metadata: ${metadata.title}`);
                    }
                }
            } catch (error) {
                console.warn('Failed to fetch link metadata:', error);
            }
        },
        
        openWithURL(url) {
            this.open();
            document.getElementById('link-url').value = url;
            // Auto-fetch
            setTimeout(() => this.fetchLink(), 100);
        },
        
        open() {
            this.modal.classList.add('active');
            this.reset();
            document.getElementById('link-url').focus();
        },
        
        close() {
            this.modal.classList.remove('active');
            this.reset();
        },
        
        reset() {
            document.getElementById('link-url').value = '';
            document.getElementById('link-preview').style.display = 'none';
            document.getElementById('link-category').style.display = 'none';
            document.getElementById('link-add').disabled = true;
            this.currentLink = null;
            this.selectedCategory = null;
        },
        
        async fetchLink() {
            const url = document.getElementById('link-url').value.trim();
            
            if (!url) {
                showToast('Please enter a URL', 'error');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch {
                showToast('Invalid URL format', 'error');
                return;
            }
            
            // Show loading
            document.getElementById('link-preview').style.display = 'block';
            document.getElementById('link-preview-loading').style.display = 'flex';
            document.getElementById('link-preview-content').style.display = 'none';
            
            try {
                // Extract metadata
                const metadata = await this.extractMetadata(url);
                this.currentLink = metadata;
                
                // Show preview
                this.showPreview(metadata);
                
                // Get AI categorization
                await this.categorizeLink(metadata);
                
                // Enable add button
                document.getElementById('link-add').disabled = false;
                
                // For video content, try to fetch transcript in background
                if (metadata.type === 'video') {
                    this.fetchAndProcessTranscript(url, metadata);
                }
                
            } catch (error) {
                console.error('Failed to fetch link:', error);
                showToast('Failed to fetch link info', 'error');
                document.getElementById('link-preview').style.display = 'none';
            }
        },
        
        async fetchAndProcessTranscript(url, metadata) {
            // Show transcript loading indicator
            const transcriptStatus = document.getElementById('link-transcript-status');
            if (transcriptStatus) {
                transcriptStatus.style.display = 'flex';
                transcriptStatus.innerHTML = `
                    <svg class="spinner" viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10" opacity="0.25"/>
                        <path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/>
                    </svg>
                    <span>Fetching transcript...</span>
                `;
            }
            
            try {
                const transcriptData = await this.fetchTranscript(url, metadata);
                
                if (transcriptData && transcriptData.text) {
                    // Store transcript with current link
                    this.currentLink.transcript = transcriptData.text;
                    this.currentLink.transcriptSource = transcriptData.source;
                    
                    // Update status
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span style="color: #22c55e;">Transcript found (${Math.round(transcriptData.text.length / 100) / 10}k chars)</span>
                        `;
                    }
                    
                    // Generate AI summary if we have API key and no description yet
                    const currentDescription = document.getElementById('link-preview-description').value.trim();
                    if (!currentDescription || currentDescription.startsWith('Video by')) {
                        const summary = await this.generateAISummary(transcriptData.text, metadata);
                        if (summary) {
                            document.getElementById('link-preview-description').value = summary;
                            this.currentLink.description = summary;
                            this.currentLink.aiSummary = summary;
                            
                            // Update status
                            if (transcriptStatus) {
                                transcriptStatus.innerHTML = `
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="#22c55e" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span style="color: #22c55e;">AI summary generated</span>
                                `;
                            }
                        }
                    }
                } else {
                    // No transcript available
                    if (transcriptStatus) {
                        transcriptStatus.innerHTML = `
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                            <span>No transcript available</span>
                        `;
                    }
                }
            } catch (error) {
                console.warn('Transcript fetch failed:', error);
                if (transcriptStatus) {
                    transcriptStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="var(--text-muted)" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <circle cx="12" cy="16" r="1" fill="currentColor"/>
                        </svg>
                        <span>Transcript fetch failed</span>
                    `;
                }
            }
        },
        
        async extractMetadata(url) {
            const urlObj = new URL(url);
            const domain = urlObj.hostname.replace('www.', '');
            
            // Basic metadata from URL
            const metadata = {
                url: url,
                domain: domain,
                title: '',
                description: '',
                image: '',
                favicon: `https://www.google.com/s2/favicons?domain=${domain}&sz=32`,
                type: this.detectContentType(url, domain),
                source: 'url' // Track where we got the data
            };
            
            // Method 1: YouTube oEmbed (free, no API key needed)
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                try {
                    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
                    const response = await fetch(oembedUrl);
                    if (response.ok) {
                        const data = await response.json();
                        metadata.title = data.title || '';
                        metadata.description = `Video by ${data.author_name}`;
                        metadata.image = data.thumbnail_url || '';
                        metadata.author = data.author_name;
                        metadata.source = 'youtube';
                        console.log('✓ Got YouTube metadata via oEmbed');
                        return metadata;
                    }
                } catch (e) {
                    console.warn('YouTube oEmbed failed:', e);
                }
            }
            
            // Method 2: Free metadata API (jsonlink.io)
            // Works for TikTok, Twitter, Instagram, articles, etc.
            try {
                const metaApiUrl = `https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`;
                const response = await fetch(metaApiUrl);
                if (response.ok) {
                    const data = await response.json();
                    if (data.title || data.description) {
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.images?.[0] || '';
                        metadata.author = data.author || data.site_name || '';
                        metadata.source = 'jsonlink';
                        console.log('✓ Got metadata via jsonlink.io');
                        
                        // For TikTok, the description often IS the video caption
                        if (domain.includes('tiktok.com') && metadata.description) {
                            // Move caption to title if title is generic
                            if (!metadata.title || metadata.title.includes('TikTok')) {
                                metadata.title = metadata.description.slice(0, 100) + (metadata.description.length > 100 ? '...' : '');
                                metadata.description = metadata.author ? `Video by ${metadata.author}` : '';
                            }
                        }
                        
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('jsonlink.io failed:', e);
            }
            
            // Method 3: Try microlink.io as backup
            try {
                const microlinkUrl = `https://api.microlink.io?url=${encodeURIComponent(url)}`;
                const response = await fetch(microlinkUrl);
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'success' && result.data) {
                        const data = result.data;
                        metadata.title = data.title || '';
                        metadata.description = data.description || '';
                        metadata.image = data.image?.url || '';
                        metadata.author = data.author || data.publisher || '';
                        metadata.source = 'microlink';
                        console.log('✓ Got metadata via microlink.io');
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('microlink.io failed:', e);
            }
            
            // Method 4: Use Claude AI to guess from URL (if we have API key)
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (apiKey && !metadata.title) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 300,
                            messages: [{
                                role: 'user',
                                content: `Extract information about this URL: ${url}

Based on the URL pattern and domain, provide your best guess for:
1. A short, descriptive title (what the content is likely about)
2. A brief description (1-2 sentences max)
3. The type of content (video, article, product, social post, etc.)

Return ONLY JSON:
{"title": "...", "description": "...", "type": "..."}`
                            }]
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const text = data.content[0].text;
                        const jsonMatch = text.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            const info = JSON.parse(jsonMatch[0]);
                            metadata.title = info.title || metadata.title;
                            metadata.description = info.description || metadata.description;
                            metadata.type = info.type || metadata.type;
                            metadata.source = 'ai';
                            console.log('✓ Got metadata via Claude AI');
                        }
                    }
                } catch (e) {
                    console.warn('Could not get AI metadata:', e);
                }
            }
            
            // Fallback: Parse title from URL
            if (!metadata.title) {
                const path = urlObj.pathname.split('/').filter(Boolean).pop() || '';
                metadata.title = path
                    .replace(/[-_]/g, ' ')
                    .replace(/\.(html|php|aspx?)$/i, '')
                    .replace(/\b\w/g, l => l.toUpperCase()) || domain;
                metadata.source = 'fallback';
            }
            
            return metadata;
        },
        
        detectContentType(url, domain) {
            const lowerUrl = url.toLowerCase();
            const lowerDomain = domain.toLowerCase();
            
            // Video platforms
            if (['youtube.com', 'youtu.be', 'vimeo.com', 'tiktok.com', 'twitch.tv'].some(d => lowerDomain.includes(d))) {
                return 'video';
            }
            
            // Social media
            if (['twitter.com', 'x.com', 'facebook.com', 'instagram.com', 'linkedin.com', 'reddit.com', 'threads.net'].some(d => lowerDomain.includes(d))) {
                return 'social';
            }
            
            // Shopping
            if (['amazon.com', 'ebay.com', 'etsy.com', 'shopify.com', 'shop'].some(d => lowerDomain.includes(d)) || lowerUrl.includes('/product')) {
                return 'product';
            }
            
            // News/Articles
            if (['medium.com', 'substack.com', 'news', 'blog', 'article'].some(d => lowerUrl.includes(d))) {
                return 'article';
            }
            
            // Code
            if (['github.com', 'gitlab.com', 'stackoverflow.com', 'codepen.io'].some(d => lowerDomain.includes(d))) {
                return 'code';
            }
            
            return 'link';
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // VIDEO TRANSCRIPT EXTRACTION
        // ═══════════════════════════════════════════════════════════════════
        
        async fetchTranscript(url, metadata) {
            const domain = metadata.domain;
            console.log('📝 Attempting transcript fetch for:', domain);
            
            let transcript = null;
            let transcriptSource = null;
            
            // YouTube transcripts
            if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                transcript = await this.fetchYouTubeTranscript(url);
                if (transcript) transcriptSource = 'youtube-captions';
            }
            
            // TikTok transcripts
            else if (domain.includes('tiktok.com')) {
                transcript = await this.fetchTikTokTranscript(url);
                if (transcript) transcriptSource = 'tiktok-captions';
            }
            
            // Instagram Reels
            else if (domain.includes('instagram.com') && url.includes('/reel')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'instagram-captions';
            }
            
            // Twitter/X videos
            else if ((domain.includes('twitter.com') || domain.includes('x.com')) && url.includes('/video')) {
                transcript = await this.fetchGenericTranscript(url);
                if (transcript) transcriptSource = 'twitter-captions';
            }
            
            if (transcript) {
                console.log(`✓ Got transcript (${transcript.length} chars) from ${transcriptSource}`);
                return { text: transcript, source: transcriptSource };
            }
            
            console.log('✗ No transcript available');
            return null;
        },
        
        extractYouTubeVideoId(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([^&\n?#]+)/,
                /youtube\.com\/shorts\/([^&\n?#]+)/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        },
        
        async fetchYouTubeTranscript(url) {
            const videoId = this.extractYouTubeVideoId(url);
            if (!videoId) {
                console.warn('Could not extract YouTube video ID');
                return null;
            }
            
            console.log('📺 Fetching YouTube transcript for:', videoId);
            
            // Method 1: Try youtubetranscript.com API (free, no key needed)
            try {
                const response = await fetch(`https://youtubetranscript.com/?server_vid2=${videoId}`);
                if (response.ok) {
                    const text = await response.text();
                    // Parse the XML response
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/xml');
                    const textElements = doc.querySelectorAll('text');
                    
                    if (textElements.length > 0) {
                        const transcript = Array.from(textElements)
                            .map(el => el.textContent)
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (transcript.length > 50) {
                            console.log('✓ Got YouTube transcript via youtubetranscript.com');
                            return transcript;
                        }
                    }
                }
            } catch (e) {
                console.warn('youtubetranscript.com failed:', e);
            }
            
            // Method 2: Try kome.ai transcript API
            try {
                const response = await fetch(`https://kome.ai/api/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript) {
                        console.log('✓ Got YouTube transcript via kome.ai');
                        return data.transcript;
                    }
                }
            } catch (e) {
                console.warn('kome.ai failed:', e);
            }
            
            // Method 3: Try tactiq.io API
            try {
                const response = await fetch(`https://tactiq-apps-prod.tactiq.io/transcript?videoId=${videoId}&langCode=en`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.captions && data.captions.length > 0) {
                        const transcript = data.captions.map(c => c.text).join(' ');
                        console.log('✓ Got YouTube transcript via tactiq.io');
                        return transcript;
                    }
                }
            } catch (e) {
                console.warn('tactiq.io failed:', e);
            }
            
            return null;
        },
        
        extractTikTokVideoId(url) {
            // TikTok URLs: tiktok.com/@user/video/1234567890
            const match = url.match(/\/video\/(\d+)/);
            return match ? match[1] : null;
        },
        
        async fetchTikTokTranscript(url) {
            console.log('📱 Fetching TikTok transcript...');
            
            // Method 1: Try supdata.ai (has free tier for transcripts)
            try {
                const response = await fetch(`https://api.supdata.ai/v1/tiktok/transcript?url=${encodeURIComponent(url)}`, {
                    headers: { 'Accept': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.transcript || data.text) {
                        console.log('✓ Got TikTok transcript via supdata.ai');
                        return data.transcript || data.text;
                    }
                }
            } catch (e) {
                console.warn('supdata.ai failed:', e);
            }
            
            // Note: tikwm.com only returns captions/descriptions, not actual spoken transcripts
            // So we don't use it as a transcript source
            
            return null;
        },
        
        async fetchGenericTranscript(url) {
            // Try generic video transcript services
            console.log('🎬 Trying generic transcript fetch...');
            
            // Could add more services here as they become available
            // For now, return null - user can add description manually
            return null;
        },
        
        async generateAISummary(transcript, metadata) {
            const apiKey = localStorage.getItem(CONFIG.API_KEY);
            if (!apiKey || !transcript) return null;
            
            console.log('🤖 Generating AI summary from transcript...');
            
            // Truncate transcript if too long (keep first 4000 chars)
            const truncatedTranscript = transcript.length > 4000 
                ? transcript.substring(0, 4000) + '...' 
                : transcript;
            
            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: `Summarize this ${metadata.type || 'video'} transcript in 2-3 sentences. Focus on the key points and takeaways. Be concise.

Title: ${metadata.title || 'Unknown'}
Author: ${metadata.author || 'Unknown'}

Transcript:
${truncatedTranscript}

Summary:`
                        }]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const summary = data.content[0].text.trim();
                    console.log('✓ Generated AI summary');
                    return summary;
                }
            } catch (e) {
                console.warn('AI summary generation failed:', e);
            }
            
            return null;
        },
        
        showPreview(metadata) {
            document.getElementById('link-preview-loading').style.display = 'none';
            document.getElementById('link-preview-content').style.display = 'flex';
            
            // Set preview content
            const img = document.getElementById('link-preview-image');
            if (metadata.image) {
                img.src = metadata.image;
                img.style.display = 'block';
                img.style.objectFit = 'cover';
                img.style.padding = '0';
                img.style.background = 'var(--bg-tertiary)';
            } else {
                // Use a placeholder with the favicon
                img.src = metadata.favicon;
                img.style.objectFit = 'contain';
                img.style.padding = '20px';
                img.style.background = 'var(--bg-tertiary)';
            }
            
            document.getElementById('link-preview-title').value = metadata.title;
            document.getElementById('link-preview-description').value = metadata.description;
            
            // Source indicator
            const sourceLabels = {
                'youtube': '✓ YouTube',
                'jsonlink': '✓ Real data',
                'microlink': '✓ Real data',
                'ai': 'AI guess',
                'fallback': 'From URL'
            };
            const sourceLabel = sourceLabels[metadata.source] || '';
            
            document.getElementById('link-preview-source').innerHTML = `
                <img src="${metadata.favicon}" alt="">
                ${metadata.domain} • ${metadata.type}
                ${sourceLabel ? `<span style="margin-left: 8px; opacity: 0.7;">${sourceLabel}</span>` : ''}
            `;
        },
        
        async categorizeLink(metadata) {
            const categories = neuralNet.categories;
            
            if (categories.length === 0) {
                // No trained categories, use default placement
                this.selectedCategory = null;
                document.getElementById('link-category').style.display = 'none';
                return;
            }
            
            document.getElementById('link-category').style.display = 'block';
            document.getElementById('link-category-name').textContent = 'Analyzing...';
            document.getElementById('link-category-confidence').textContent = '';
            document.getElementById('link-category-alt').innerHTML = '';
            
            // Use neural network + Claude to categorize
            const contentText = `${metadata.title}. ${metadata.description}. ${metadata.type} from ${metadata.domain}`;
            
            try {
                // Get neural network predictions
                const predictions = await neuralNet.predictCategory(contentText);
                
                if (predictions && predictions.length > 0) {
                    // Show top prediction
                    const top = predictions[0];
                    this.selectedCategory = top.category;
                    
                    document.getElementById('link-category-name').textContent = top.category;
                    document.getElementById('link-category-confidence').textContent = `${Math.round(top.probability * 100)}%`;
                    
                    // Show alternatives
                    const alts = predictions.slice(1, 4);
                    document.getElementById('link-category-alt').innerHTML = alts.map(p => `
                        <div class="link-category-alt-item" data-category="${p.category}">
                            ${p.category} (${Math.round(p.probability * 100)}%)
                        </div>
                    `).join('');
                    
                    // Handle alt selection
                    document.querySelectorAll('.link-category-alt-item').forEach(el => {
                        el.addEventListener('click', () => {
                            this.selectedCategory = el.dataset.category;
                            document.querySelectorAll('.link-category-alt-item').forEach(e => e.classList.remove('selected'));
                            el.classList.add('selected');
                            document.getElementById('link-category-name').textContent = el.dataset.category;
                        });
                    });
                } else {
                    // No predictions available
                    document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                    this.selectedCategory = categories[0] || null;
                }
                
            } catch (error) {
                console.error('Categorization error:', error);
                document.getElementById('link-category-name').textContent = categories[0] || 'Uncategorized';
                this.selectedCategory = categories[0] || null;
            }
        },
        
        // ═══════════════════════════════════════════════════════════════════
        // SMART ORGANIZATION - Creates sub-folders when patterns detected
        // ═══════════════════════════════════════════════════════════════════
        
        async smartOrganize(parentId, newItemDomain, newItemType) {
            const parentNode = store.findNode(parentId);
            if (!parentNode || !parentNode.children) {
                console.log('📁 SmartOrganize: No parent or no children');
                return { parentId, organized: false };
            }
            
            // Analyze siblings for patterns
            const siblings = parentNode.children;
            const domainGroups = {};
            
            console.log(`📁 SmartOrganize: Analyzing ${siblings.length} siblings in "${parentNode.label}"`);
            
            // Group existing children by domain (check both link.domain and URL)
            siblings.forEach(child => {
                let domain = null;
                
                // Try to get domain from link.domain
                if (child.link?.domain) {
                    domain = this.normalizeDomain(child.link.domain);
                }
                // Also try to extract from URL if domain is missing
                else if (child.link?.url) {
                    try {
                        const urlObj = new URL(child.link.url);
                        domain = this.normalizeDomain(urlObj.hostname);
                    } catch (e) {}
                }
                
                if (domain) {
                    if (!domainGroups[domain]) domainGroups[domain] = [];
                    domainGroups[domain].push(child);
                }
            });
            
            console.log('📁 SmartOrganize: Domain groups:', Object.keys(domainGroups).map(k => `${k}: ${domainGroups[k].length}`).join(', '));
            
            const normalizedNewDomain = this.normalizeDomain(newItemDomain);
            console.log(`📁 SmartOrganize: New item domain: "${newItemDomain}" → normalized: "${normalizedNewDomain}"`);
            
            // Check if we should create a domain-based sub-folder
            // Trigger: 1+ existing items from same domain (so 2+ total after adding new one)
            if (normalizedNewDomain && domainGroups[normalizedNewDomain]?.length >= 1) {
                const existingSameDomain = domainGroups[normalizedNewDomain];
                const folderName = this.getDomainFolderName(normalizedNewDomain);
                
                console.log(`📁 SmartOrganize: Found ${existingSameDomain.length} existing items from ${normalizedNewDomain}`);
                
                // Check if folder already exists
                const existingFolder = siblings.find(s => 
                    s.label.toLowerCase() === folderName.toLowerCase() && 
                    !s.link // It's a folder, not a link
                );
                
                if (existingFolder) {
                    // Folder exists, just use it as parent
                    console.log(`📁 SmartOrganize: "${folderName}" folder already exists, using it`);
                    return { parentId: existingFolder.id, organized: false };
                }
                
                // Create new sub-folder
                console.log(`📁 SmartOrganize: Creating "${folderName}" folder and moving ${existingSameDomain.length} existing items`);
                
                const folderNode = store.addNode(parentId, {
                    label: folderName,
                    description: `Collection of ${folderName} content`,
                    color: parentNode.color,
                    source: 'smart-organize'
                });
                
                // Move existing same-domain items into the folder
                let movedCount = 0;
                for (const item of existingSameDomain) {
                    const moved = store.moveNode(item.id, folderNode.id);
                    if (moved) movedCount++;
                    console.log(`📁 SmartOrganize: Moving "${item.label}" → ${moved ? 'success' : 'failed'}`);
                }
                
                showToast(`📁 Created "${folderName}" folder and organized ${movedCount} existing items`, 'success');
                
                return { parentId: folderNode.id, organized: true, folderName };
            }
            
            // Check if parent has too many children (> 7) and we should suggest AI organization
            if (siblings.length > 7 && localStorage.getItem(CONFIG.API_KEY)) {
                console.log('⚠️ Parent has many children, consider reorganizing');
            }
            
            return { parentId, organized: false };
        },
        
        normalizeDomain(domain) {
            if (!domain) return null;
            // Remove www. and common subdomains, then lowercase
            return domain
                .replace(/^(www\.|m\.|mobile\.|vm\.|vt\.|v\.)/i, '')
                .toLowerCase();
        },
        
        getDomainFolderName(domain) {
            // Map common domains to friendly folder names
            const domainNames = {
                'tiktok.com': 'TikToks',
                'youtube.com': 'YouTube Videos',
                'youtu.be': 'YouTube Videos',
                'instagram.com': 'Instagram',
                'twitter.com': 'Twitter/X',
                'x.com': 'Twitter/X',
                'reddit.com': 'Reddit Posts',
                'github.com': 'GitHub Repos',
                'medium.com': 'Medium Articles',
                'substack.com': 'Substack',
                'linkedin.com': 'LinkedIn',
                'facebook.com': 'Facebook',
                'pinterest.com': 'Pinterest',
                'spotify.com': 'Spotify',
                'soundcloud.com': 'SoundCloud',
                'twitch.tv': 'Twitch',
                'vimeo.com': 'Vimeo'
            };
            
            return domainNames[domain] || `${domain.split('.')[0].charAt(0).toUpperCase() + domain.split('.')[0].slice(1)} Links`;
        },
        
        async addToMap() {
            if (!this.currentLink) return;
            
            // Get user-edited values
            const title = document.getElementById('link-preview-title').value.trim() || this.currentLink.title;
            const description = document.getElementById('link-preview-description').value.trim();
            
            // Find parent node (selected category or selected node or root)
            let parentId = store.data.id;
            
            if (this.selectedCategory) {
                // Find the category node
                const findCategory = (node) => {
                    if (node.label === this.selectedCategory) return node;
                    for (const child of (node.children || [])) {
                        const found = findCategory(child);
                        if (found) return found;
                    }
                    return null;
                };
                const categoryNode = findCategory(store.data);
                if (categoryNode) {
                    parentId = categoryNode.id;
                }
            } else if (selectedNode && selectedNode.userData.id !== 'mynd') {
                parentId = selectedNode.userData.id;
            }
            
            // Smart organization - check if we should create a sub-folder
            const organizeResult = await this.smartOrganize(
                parentId, 
                this.currentLink.domain, 
                this.currentLink.type
            );
            parentId = organizeResult.parentId;
            
            const parentNode = store.findNode(parentId);
            
            // Build link data with transcript if available
            const linkData = {
                url: this.currentLink.url,
                domain: this.currentLink.domain,
                type: this.currentLink.type,
                favicon: this.currentLink.favicon,
                image: this.currentLink.image || null,
                author: this.currentLink.author || null,
                source: this.currentLink.source || 'unknown',
                addedAt: new Date().toISOString()
            };
            
            // Include transcript if available
            if (this.currentLink.transcript) {
                linkData.transcript = this.currentLink.transcript;
                linkData.transcriptSource = this.currentLink.transcriptSource;
            }
            
            // Include AI summary if generated
            if (this.currentLink.aiSummary) {
                linkData.aiSummary = this.currentLink.aiSummary;
            }
            
            // Add the link node
            const newNode = store.addNode(parentId, {
                label: title,
                description: description,
                color: parentNode?.color,
                link: linkData
            });
            
            // Rebuild scene
            buildScene();
            
            // Focus on the new node
            setTimeout(() => {
                const newMesh = nodes.get(newNode.id);
                if (newMesh) {
                    selectNode(newMesh);
                    focusOnNode(newMesh);
                    
                    // Expand parent if collapsed
                    const parentMesh = nodes.get(parentId);
                    if (parentMesh && !parentMesh.userData.isExpanded) {
                        expandNode(parentMesh);
                    }
                }
            }, 100);
            
            this.close();
            showToast(`Added "${title}" to ${this.selectedCategory || 'map'}`, 'success');
            audio.add();
        }
    };
    
    // Initialize Link Manager
    setTimeout(() => {
        LinkManager.init();
    }, 50);
    
    // Initialize Neural Network UI after app init
    setTimeout(() => {
        NeuralUI.init();
    }, 100);

    // Mobile: Start with toolbar collapsed
    if (window.innerWidth <= 768) {
        document.getElementById('side-panel').classList.add('collapsed');
    }

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('SW registered'))
                .catch(err => console.log('SW failed:', err));
        }

    // Handle incoming shared content (PWA Share Target)
    function handleShareTarget() {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedUrl = urlParams.get('url');
        const sharedText = urlParams.get('text');
        const sharedTitle = urlParams.get('title');
        
        // Check if this is a share action
        if (!sharedUrl && !sharedText) return;
        
        console.log('Share Target received:', { url: sharedUrl, text: sharedText, title: sharedTitle });
        
        // Extract URL from text if no direct URL provided
        let urlToAdd = sharedUrl;
        if (!urlToAdd && sharedText) {
            // Try to extract URL from shared text
            const urlMatch = sharedText.match(/https?:\/\/[^\s]+/);
            if (urlMatch) {
                urlToAdd = urlMatch[0];
            }
        }
        
        if (urlToAdd) {
            // Clean the URL from query params so share doesn't trigger again
            window.history.replaceState({}, document.title, window.location.pathname);
            
            // Wait a moment for app to fully load, then trigger link capture
            setTimeout(() => {
                // If a node is selected, add as child
                if (selectedNode) {
                    LinkCapture.addLinkAsChild(urlToAdd, selectedNode.userData.id);
                } else {
                    // Otherwise open the link modal
                    LinkCapture.openWithURL(urlToAdd);
                }
                
                showToast('Link received from share', 'success');
            }, 500);
        } else if (sharedText || sharedTitle) {
            // Just text/title shared - open quick capture
            window.history.replaceState({}, document.title, window.location.pathname);
            
            setTimeout(() => {
                const quickInput = document.getElementById('quick-input');
                if (quickInput) {
                    quickInput.value = sharedTitle || sharedText;
                    quickInput.focus();
                }
                showToast('Content received from share', 'success');
            }, 500);
        }
    }
    
    // Run share handler after a short delay to ensure app is ready
    setTimeout(handleShareTarget, 100);

    </script>
</body>
</html>
